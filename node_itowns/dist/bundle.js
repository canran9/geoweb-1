/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./public/javascripts/map.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/createClass.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/get.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/get.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var superPropBase = __webpack_require__(/*! ./superPropBase */ \"./node_modules/@babel/runtime/helpers/superPropBase.js\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/get.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/inherits.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _typeof = __webpack_require__(/*! ../helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nmodule.exports = _interopRequireWildcard;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/interopRequireWildcard.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/iterableToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/nonIterableRest.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/nonIterableSpread.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _typeof = __webpack_require__(/*! ../helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\n\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\n\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/slicedToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/superPropBase.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/superPropBase.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/superPropBase.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ \"./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js\");\n\nvar iterableToArray = __webpack_require__(/*! ./iterableToArray */ \"./node_modules/@babel/runtime/helpers/iterableToArray.js\");\n\nvar nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ \"./node_modules/@babel/runtime/helpers/nonIterableSpread.js\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/toConsumableArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/typeof.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js ***!
  \********************************************************************/
/*! exports provided: Color, ParsingError, ValidationError, composite, convertFilter, derefLayers, diff, expression, featureFilter, format, function, latest, migrate, v8, validate, validateMapboxApiSupported, visit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return Color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsingError\", function() { return ParsingError$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationError\", function() { return ValidationError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"composite\", function() { return composite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertFilter\", function() { return convertFilter$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"derefLayers\", function() { return derefLayers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diff\", function() { return diffStyles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expression\", function() { return expression$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"featureFilter\", function() { return createFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"format\", function() { return format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"function\", function() { return styleFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"latest\", function() { return v8; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"migrate\", function() { return migrate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v8\", function() { return v8; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validate\", function() { return validateStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateMapboxApiSupported\", function() { return validateMapboxApiSupported; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"visit\", function() { return visit; });\nvar $version = 8;\nvar $root = {\n\tversion: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: [\n\t\t\t8\n\t\t],\n\t\tdoc: \"Style specification version number. Must be 8.\",\n\t\texample: 8\n\t},\n\tname: {\n\t\ttype: \"string\",\n\t\tdoc: \"A human-readable name for the style.\",\n\t\texample: \"Bright\"\n\t},\n\tmetadata: {\n\t\ttype: \"*\",\n\t\tdoc: \"Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'.\"\n\t},\n\tcenter: {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tdoc: \"Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).\",\n\t\texample: [\n\t\t\t-73.9749,\n\t\t\t40.7736\n\t\t]\n\t},\n\tzoom: {\n\t\ttype: \"number\",\n\t\tdoc: \"Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).\",\n\t\texample: 12.5\n\t},\n\tbearing: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tperiod: 360,\n\t\tunits: \"degrees\",\n\t\tdoc: \"Default bearing, in degrees. The bearing is the compass direction that is \\\"up\\\"; for example, a bearing of 90° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).\",\n\t\texample: 29\n\t},\n\tpitch: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tunits: \"degrees\",\n\t\tdoc: \"Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).\",\n\t\texample: 50\n\t},\n\tlight: {\n\t\ttype: \"light\",\n\t\tdoc: \"The global light source.\",\n\t\texample: {\n\t\t\tanchor: \"viewport\",\n\t\t\tcolor: \"white\",\n\t\t\tintensity: 0.4\n\t\t}\n\t},\n\tsources: {\n\t\trequired: true,\n\t\ttype: \"sources\",\n\t\tdoc: \"Data source specifications.\",\n\t\texample: {\n\t\t\t\"mapbox-streets\": {\n\t\t\t\ttype: \"vector\",\n\t\t\t\turl: \"mapbox://mapbox.mapbox-streets-v6\"\n\t\t\t}\n\t\t}\n\t},\n\tsprite: {\n\t\ttype: \"string\",\n\t\tdoc: \"A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).\",\n\t\texample: \"mapbox://sprites/mapbox/bright-v8\"\n\t},\n\tglyphs: {\n\t\ttype: \"string\",\n\t\tdoc: \"A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).\",\n\t\texample: \"mapbox://fonts/mapbox/{fontstack}/{range}.pbf\"\n\t},\n\ttransition: {\n\t\ttype: \"transition\",\n\t\tdoc: \"A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.\",\n\t\texample: {\n\t\t\tduration: 300,\n\t\t\tdelay: 0\n\t\t}\n\t},\n\tlayers: {\n\t\trequired: true,\n\t\ttype: \"array\",\n\t\tvalue: \"layer\",\n\t\tdoc: \"Layers will be drawn in the order of this array.\",\n\t\texample: [\n\t\t\t{\n\t\t\t\tid: \"water\",\n\t\t\t\tsource: \"mapbox-streets\",\n\t\t\t\t\"source-layer\": \"water\",\n\t\t\t\ttype: \"fill\",\n\t\t\t\tpaint: {\n\t\t\t\t\t\"fill-color\": \"#00ffff\"\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n};\nvar sources = {\n\t\"*\": {\n\t\ttype: \"source\",\n\t\tdoc: \"Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided.\"\n\t}\n};\nvar source = [\n\t\"source_vector\",\n\t\"source_raster\",\n\t\"source_raster_dem\",\n\t\"source_geojson\",\n\t\"source_video\",\n\t\"source_image\"\n];\nvar source_vector = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvector: {\n\t\t\t\tdoc: \"A vector tile source.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"The type of the source.\"\n\t},\n\turl: {\n\t\ttype: \"string\",\n\t\tdoc: \"A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`.\"\n\t},\n\ttiles: {\n\t\ttype: \"array\",\n\t\tvalue: \"string\",\n\t\tdoc: \"An array of one or more tile source URLs, as in the TileJSON spec.\"\n\t},\n\tbounds: {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 4,\n\t\t\"default\": [\n\t\t\t-180,\n\t\t\t-85.051129,\n\t\t\t180,\n\t\t\t85.051129\n\t\t],\n\t\tdoc: \"An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL.\"\n\t},\n\tscheme: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\txyz: {\n\t\t\t\tdoc: \"Slippy map tilenames scheme.\"\n\t\t\t},\n\t\t\ttms: {\n\t\t\t\tdoc: \"OSGeo spec scheme.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"xyz\",\n\t\tdoc: \"Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed.\"\n\t},\n\tminzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tdoc: \"Minimum zoom level for which tiles are available, as in the TileJSON spec.\"\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 22,\n\t\tdoc: \"Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.\"\n\t},\n\tattribution: {\n\t\ttype: \"string\",\n\t\tdoc: \"Contains an attribution to be displayed when the map is shown to a user.\"\n\t},\n\tpromoteId: {\n\t\ttype: \"promoteId\",\n\t\tdoc: \"A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers.\"\n\t},\n\t\"*\": {\n\t\ttype: \"*\",\n\t\tdoc: \"Other keys to configure the data source.\"\n\t}\n};\nvar source_raster = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\traster: {\n\t\t\t\tdoc: \"A raster tile source.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"The type of the source.\"\n\t},\n\turl: {\n\t\ttype: \"string\",\n\t\tdoc: \"A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`.\"\n\t},\n\ttiles: {\n\t\ttype: \"array\",\n\t\tvalue: \"string\",\n\t\tdoc: \"An array of one or more tile source URLs, as in the TileJSON spec.\"\n\t},\n\tbounds: {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 4,\n\t\t\"default\": [\n\t\t\t-180,\n\t\t\t-85.051129,\n\t\t\t180,\n\t\t\t85.051129\n\t\t],\n\t\tdoc: \"An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL.\"\n\t},\n\tminzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tdoc: \"Minimum zoom level for which tiles are available, as in the TileJSON spec.\"\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 22,\n\t\tdoc: \"Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.\"\n\t},\n\ttileSize: {\n\t\ttype: \"number\",\n\t\t\"default\": 512,\n\t\tunits: \"pixels\",\n\t\tdoc: \"The minimum visual size to display tiles for this layer. Only configurable for raster layers.\"\n\t},\n\tscheme: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\txyz: {\n\t\t\t\tdoc: \"Slippy map tilenames scheme.\"\n\t\t\t},\n\t\t\ttms: {\n\t\t\t\tdoc: \"OSGeo spec scheme.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"xyz\",\n\t\tdoc: \"Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed.\"\n\t},\n\tattribution: {\n\t\ttype: \"string\",\n\t\tdoc: \"Contains an attribution to be displayed when the map is shown to a user.\"\n\t},\n\t\"*\": {\n\t\ttype: \"*\",\n\t\tdoc: \"Other keys to configure the data source.\"\n\t}\n};\nvar source_raster_dem = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\t\"raster-dem\": {\n\t\t\t\tdoc: \"A RGB-encoded raster DEM source\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"The type of the source.\"\n\t},\n\turl: {\n\t\ttype: \"string\",\n\t\tdoc: \"A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`.\"\n\t},\n\ttiles: {\n\t\ttype: \"array\",\n\t\tvalue: \"string\",\n\t\tdoc: \"An array of one or more tile source URLs, as in the TileJSON spec.\"\n\t},\n\tbounds: {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 4,\n\t\t\"default\": [\n\t\t\t-180,\n\t\t\t-85.051129,\n\t\t\t180,\n\t\t\t85.051129\n\t\t],\n\t\tdoc: \"An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL.\"\n\t},\n\tminzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tdoc: \"Minimum zoom level for which tiles are available, as in the TileJSON spec.\"\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 22,\n\t\tdoc: \"Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.\"\n\t},\n\ttileSize: {\n\t\ttype: \"number\",\n\t\t\"default\": 512,\n\t\tunits: \"pixels\",\n\t\tdoc: \"The minimum visual size to display tiles for this layer. Only configurable for raster layers.\"\n\t},\n\tattribution: {\n\t\ttype: \"string\",\n\t\tdoc: \"Contains an attribution to be displayed when the map is shown to a user.\"\n\t},\n\tencoding: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tterrarium: {\n\t\t\t\tdoc: \"Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info.\"\n\t\t\t},\n\t\t\tmapbox: {\n\t\t\t\tdoc: \"Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"mapbox\",\n\t\tdoc: \"The encoding used by this source. Mapbox Terrain RGB is used by default\"\n\t},\n\t\"*\": {\n\t\ttype: \"*\",\n\t\tdoc: \"Other keys to configure the data source.\"\n\t}\n};\nvar source_geojson = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tgeojson: {\n\t\t\t\tdoc: \"A GeoJSON data source.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"The data type of the GeoJSON source.\"\n\t},\n\tdata: {\n\t\ttype: \"*\",\n\t\tdoc: \"A URL to a GeoJSON file, or inline GeoJSON.\"\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\t\"default\": 18,\n\t\tdoc: \"Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels).\"\n\t},\n\tattribution: {\n\t\ttype: \"string\",\n\t\tdoc: \"Contains an attribution to be displayed when the map is shown to a user.\"\n\t},\n\tbuffer: {\n\t\ttype: \"number\",\n\t\t\"default\": 128,\n\t\tmaximum: 512,\n\t\tminimum: 0,\n\t\tdoc: \"Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance.\"\n\t},\n\ttolerance: {\n\t\ttype: \"number\",\n\t\t\"default\": 0.375,\n\t\tdoc: \"Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance).\"\n\t},\n\tcluster: {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\\n * `cluster` Is `true` if the point is a cluster \\n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\\n * `point_count` Number of original points grouped into this cluster\\n * `point_count_abbreviated` An abbreviated point count\"\n\t},\n\tclusterRadius: {\n\t\ttype: \"number\",\n\t\t\"default\": 50,\n\t\tminimum: 0,\n\t\tdoc: \"Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile.\"\n\t},\n\tclusterMaxZoom: {\n\t\ttype: \"number\",\n\t\tdoc: \"Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered).\"\n\t},\n\tclusterProperties: {\n\t\ttype: \"*\",\n\t\tdoc: \"An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\\\"property_name\\\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\\\"+\\\"` or `\\\"max\\\"`) — it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\\n\\nExample: `{\\\"sum\\\": [\\\"+\\\", [\\\"get\\\", \\\"scalerank\\\"]]}`.\\n\\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\\\"accumulated\\\"]` value, e.g.:\\n`{\\\"sum\\\": [[\\\"+\\\", [\\\"accumulated\\\"], [\\\"get\\\", \\\"sum\\\"]], [\\\"get\\\", \\\"scalerank\\\"]]}`\"\n\t},\n\tlineMetrics: {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values.\"\n\t},\n\tgenerateId: {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values.\"\n\t},\n\tpromoteId: {\n\t\ttype: \"promoteId\",\n\t\tdoc: \"A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`.\"\n\t}\n};\nvar source_video = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvideo: {\n\t\t\t\tdoc: \"A video data source.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"The data type of the video source.\"\n\t},\n\turls: {\n\t\trequired: true,\n\t\ttype: \"array\",\n\t\tvalue: \"string\",\n\t\tdoc: \"URLs to video content in order of preferred format.\"\n\t},\n\tcoordinates: {\n\t\trequired: true,\n\t\tdoc: \"Corners of video specified in longitude, latitude pairs.\",\n\t\ttype: \"array\",\n\t\tlength: 4,\n\t\tvalue: {\n\t\t\ttype: \"array\",\n\t\t\tlength: 2,\n\t\t\tvalue: \"number\",\n\t\t\tdoc: \"A single longitude, latitude pair.\"\n\t\t}\n\t}\n};\nvar source_image = {\n\ttype: {\n\t\trequired: true,\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\timage: {\n\t\t\t\tdoc: \"An image data source.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"The data type of the image source.\"\n\t},\n\turl: {\n\t\trequired: true,\n\t\ttype: \"string\",\n\t\tdoc: \"URL that points to an image.\"\n\t},\n\tcoordinates: {\n\t\trequired: true,\n\t\tdoc: \"Corners of image specified in longitude, latitude pairs.\",\n\t\ttype: \"array\",\n\t\tlength: 4,\n\t\tvalue: {\n\t\t\ttype: \"array\",\n\t\t\tlength: 2,\n\t\t\tvalue: \"number\",\n\t\t\tdoc: \"A single longitude, latitude pair.\"\n\t\t}\n\t}\n};\nvar layer = {\n\tid: {\n\t\ttype: \"string\",\n\t\tdoc: \"Unique layer name.\",\n\t\trequired: true\n\t},\n\ttype: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tfill: {\n\t\t\t\tdoc: \"A filled polygon with an optional stroked border.\",\n\t\t\t\t\"sdk-support\": {\n\t\t\t\t\t\"basic functionality\": {\n\t\t\t\t\t\tjs: \"0.10.0\",\n\t\t\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\t\t\tios: \"2.0.0\",\n\t\t\t\t\t\tmacos: \"0.1.0\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tline: {\n\t\t\t\tdoc: \"A stroked line.\",\n\t\t\t\t\"sdk-support\": {\n\t\t\t\t\t\"basic functionality\": {\n\t\t\t\t\t\tjs: \"0.10.0\",\n\t\t\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\t\t\tios: \"2.0.0\",\n\t\t\t\t\t\tmacos: \"0.1.0\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tsymbol: {\n\t\t\t\tdoc: \"An icon or a text label.\",\n\t\t\t\t\"sdk-support\": {\n\t\t\t\t\t\"basic functionality\": {\n\t\t\t\t\t\tjs: \"0.10.0\",\n\t\t\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\t\t\tios: \"2.0.0\",\n\t\t\t\t\t\tmacos: \"0.1.0\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tcircle: {\n\t\t\t\tdoc: \"A filled circle.\",\n\t\t\t\t\"sdk-support\": {\n\t\t\t\t\t\"basic functionality\": {\n\t\t\t\t\t\tjs: \"0.10.0\",\n\t\t\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\t\t\tios: \"2.0.0\",\n\t\t\t\t\t\tmacos: \"0.1.0\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\theatmap: {\n\t\t\t\tdoc: \"A heatmap.\",\n\t\t\t\t\"sdk-support\": {\n\t\t\t\t\t\"basic functionality\": {\n\t\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"fill-extrusion\": {\n\t\t\t\tdoc: \"An extruded (3D) polygon.\",\n\t\t\t\t\"sdk-support\": {\n\t\t\t\t\t\"basic functionality\": {\n\t\t\t\t\t\tjs: \"0.27.0\",\n\t\t\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\t\t\tios: \"3.6.0\",\n\t\t\t\t\t\tmacos: \"0.5.0\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\traster: {\n\t\t\t\tdoc: \"Raster map textures such as satellite imagery.\",\n\t\t\t\t\"sdk-support\": {\n\t\t\t\t\t\"basic functionality\": {\n\t\t\t\t\t\tjs: \"0.10.0\",\n\t\t\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\t\t\tios: \"2.0.0\",\n\t\t\t\t\t\tmacos: \"0.1.0\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\thillshade: {\n\t\t\t\tdoc: \"Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.\",\n\t\t\t\t\"sdk-support\": {\n\t\t\t\t\t\"basic functionality\": {\n\t\t\t\t\t\tjs: \"0.43.0\",\n\t\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbackground: {\n\t\t\t\tdoc: \"The background color or pattern of the map.\",\n\t\t\t\t\"sdk-support\": {\n\t\t\t\t\t\"basic functionality\": {\n\t\t\t\t\t\tjs: \"0.10.0\",\n\t\t\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\t\t\tios: \"2.0.0\",\n\t\t\t\t\t\tmacos: \"0.1.0\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdoc: \"Rendering type of this layer.\",\n\t\trequired: true\n\t},\n\tmetadata: {\n\t\ttype: \"*\",\n\t\tdoc: \"Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'.\"\n\t},\n\tsource: {\n\t\ttype: \"string\",\n\t\tdoc: \"Name of a source description to be used for this layer. Required for all layer types except `background`.\"\n\t},\n\t\"source-layer\": {\n\t\ttype: \"string\",\n\t\tdoc: \"Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources.\"\n\t},\n\tminzoom: {\n\t\ttype: \"number\",\n\t\tminimum: 0,\n\t\tmaximum: 24,\n\t\tdoc: \"The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden.\"\n\t},\n\tmaxzoom: {\n\t\ttype: \"number\",\n\t\tminimum: 0,\n\t\tmaximum: 24,\n\t\tdoc: \"The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden.\"\n\t},\n\tfilter: {\n\t\ttype: \"filter\",\n\t\tdoc: \"A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions.\"\n\t},\n\tlayout: {\n\t\ttype: \"layout\",\n\t\tdoc: \"Layout properties for the layer.\"\n\t},\n\tpaint: {\n\t\ttype: \"paint\",\n\t\tdoc: \"Default paint properties for this layer.\"\n\t}\n};\nvar layout = [\n\t\"layout_fill\",\n\t\"layout_line\",\n\t\"layout_circle\",\n\t\"layout_heatmap\",\n\t\"layout_fill-extrusion\",\n\t\"layout_symbol\",\n\t\"layout_raster\",\n\t\"layout_hillshade\",\n\t\"layout_background\"\n];\nvar layout_background = {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t\tdoc: \"The layer is shown.\"\n\t\t\t},\n\t\t\tnone: {\n\t\t\t\tdoc: \"The layer is not shown.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\tdoc: \"Whether this layer is displayed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_fill = {\n\t\"fill-sort-key\": {\n\t\ttype: \"number\",\n\t\tdoc: \"Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"1.2.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"1.2.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t\tdoc: \"The layer is shown.\"\n\t\t\t},\n\t\t\tnone: {\n\t\t\t\tdoc: \"The layer is not shown.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\tdoc: \"Whether this layer is displayed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_circle = {\n\t\"circle-sort-key\": {\n\t\ttype: \"number\",\n\t\tdoc: \"Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"1.2.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"1.2.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t\tdoc: \"The layer is shown.\"\n\t\t\t},\n\t\t\tnone: {\n\t\t\t\tdoc: \"The layer is not shown.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\tdoc: \"Whether this layer is displayed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_heatmap = {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t\tdoc: \"The layer is shown.\"\n\t\t\t},\n\t\t\tnone: {\n\t\t\t\tdoc: \"The layer is not shown.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\tdoc: \"Whether this layer is displayed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.41.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_line = {\n\t\"line-cap\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tbutt: {\n\t\t\t\tdoc: \"A cap with a squared-off end which is drawn to the exact endpoint of the line.\"\n\t\t\t},\n\t\t\tround: {\n\t\t\t\tdoc: \"A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\"\n\t\t\t},\n\t\t\tsquare: {\n\t\t\t\tdoc: \"A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"butt\",\n\t\tdoc: \"The display of line endings.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-join\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tbevel: {\n\t\t\t\tdoc: \"A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\"\n\t\t\t},\n\t\t\tround: {\n\t\t\t\tdoc: \"A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\"\n\t\t\t},\n\t\t\tmiter: {\n\t\t\t\tdoc: \"A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"miter\",\n\t\tdoc: \"The display of lines when joining.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.40.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-miter-limit\": {\n\t\ttype: \"number\",\n\t\t\"default\": 2,\n\t\tdoc: \"Used to automatically convert miter joins to bevel joins for sharp angles.\",\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"line-join\": \"miter\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-round-limit\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1.05,\n\t\tdoc: \"Used to automatically convert round joins to miter joins for shallow angles.\",\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"line-join\": \"round\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-sort-key\": {\n\t\ttype: \"number\",\n\t\tdoc: \"Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"1.2.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"1.2.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t\tdoc: \"The layer is shown.\"\n\t\t\t},\n\t\t\tnone: {\n\t\t\t\tdoc: \"The layer is not shown.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\tdoc: \"Whether this layer is displayed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_symbol = {\n\t\"symbol-placement\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tpoint: {\n\t\t\t\tdoc: \"The label is placed at the point where the geometry is located.\"\n\t\t\t},\n\t\t\tline: {\n\t\t\t\tdoc: \"The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries.\"\n\t\t\t},\n\t\t\t\"line-center\": {\n\t\t\t\tdoc: \"The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"point\",\n\t\tdoc: \"Label placement relative to its geometry.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"`line-center` value\": {\n\t\t\t\tjs: \"0.47.0\",\n\t\t\t\tandroid: \"6.4.0\",\n\t\t\t\tios: \"4.3.0\",\n\t\t\t\tmacos: \"0.10.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"symbol-spacing\": {\n\t\ttype: \"number\",\n\t\t\"default\": 250,\n\t\tminimum: 1,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Distance between two symbol anchors.\",\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"symbol-placement\": \"line\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"symbol-avoid-edges\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"symbol-sort-key\": {\n\t\ttype: \"number\",\n\t\tdoc: \"Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key when they overlap. Features with a lower sort key will have priority over other features when doing placement.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.53.0\",\n\t\t\t\tandroid: \"7.4.0\",\n\t\t\t\tios: \"4.11.0\",\n\t\t\t\tmacos: \"0.14.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.53.0\",\n\t\t\t\tandroid: \"7.4.0\",\n\t\t\t\tios: \"4.11.0\",\n\t\t\t\tmacos: \"0.14.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"symbol-z-order\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tauto: {\n\t\t\t\tdoc: \"If `symbol-sort-key` is set, sort based on that. Otherwise sort symbols by their y-position relative to the viewport.\"\n\t\t\t},\n\t\t\t\"viewport-y\": {\n\t\t\t\tdoc: \"Symbols will be sorted by their y-position relative to the viewport.\"\n\t\t\t},\n\t\t\tsource: {\n\t\t\t\tdoc: \"Symbols will be rendered in the same order as the source data with no sorting applied.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\tdoc: \"Controls the order in which overlapping symbols in the same layer are rendered\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.49.0\",\n\t\t\t\tandroid: \"6.6.0\",\n\t\t\t\tios: \"4.5.0\",\n\t\t\t\tmacos: \"0.12.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-allow-overlap\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"If true, the icon will be visible even if it collides with other previously drawn symbols.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-ignore-placement\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"If true, other symbols can be visible even if they collide with the icon.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-optional\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.\",\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-rotation-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.\"\n\t\t\t},\n\t\t\tauto: {\n\t\t\t\tdoc: \"When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\tdoc: \"In combination with `symbol-placement`, determines the rotation behavior of icons.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"`auto` value\": {\n\t\t\t\tjs: \"0.25.0\",\n\t\t\t\tandroid: \"4.2.0\",\n\t\t\t\tios: \"3.4.0\",\n\t\t\t\tmacos: \"0.3.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-size\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tunits: \"factor of the original icon size\",\n\t\tdoc: \"Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.35.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-text-fit\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tnone: {\n\t\t\t\tdoc: \"The icon is displayed at its intrinsic aspect ratio.\"\n\t\t\t},\n\t\t\twidth: {\n\t\t\t\tdoc: \"The icon is scaled in the x-dimension to fit the width of the text.\"\n\t\t\t},\n\t\t\theight: {\n\t\t\t\tdoc: \"The icon is scaled in the y-dimension to fit the height of the text.\"\n\t\t\t},\n\t\t\tboth: {\n\t\t\t\tdoc: \"The icon is scaled in both x- and y-dimensions.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"none\",\n\t\tdoc: \"Scales the icon to fit around the associated text.\",\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.21.0\",\n\t\t\t\tandroid: \"4.2.0\",\n\t\t\t\tios: \"3.4.0\",\n\t\t\t\tmacos: \"0.2.1\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-text-fit-padding\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 4,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\tunits: \"pixels\",\n\t\tdoc: \"Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.\",\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"icon-text-fit\": [\n\t\t\t\t\t\"both\",\n\t\t\t\t\t\"width\",\n\t\t\t\t\t\"height\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.21.0\",\n\t\t\t\tandroid: \"4.2.0\",\n\t\t\t\tios: \"3.4.0\",\n\t\t\t\tmacos: \"0.2.1\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-image\": {\n\t\ttype: \"resolvedImage\",\n\t\tdoc: \"Name of image in sprite to use for drawing an image background.\",\n\t\ttokens: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.35.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-rotate\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tperiod: 360,\n\t\tunits: \"degrees\",\n\t\tdoc: \"Rotates the icon clockwise.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.21.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-padding\": {\n\t\ttype: \"number\",\n\t\t\"default\": 2,\n\t\tminimum: 0,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Size of the additional area around the icon bounding box used for detecting symbol collisions.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-keep-upright\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"If true, the icon may be flipped to prevent it from being rendered upside-down.\",\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t{\n\t\t\t\t\"icon-rotation-alignment\": \"map\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"line\",\n\t\t\t\t\t\"line-center\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-offset\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\tdoc: \"Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tcenter: {\n\t\t\t\tdoc: \"The center of the icon is placed closest to the anchor.\"\n\t\t\t},\n\t\t\tleft: {\n\t\t\t\tdoc: \"The left side of the icon is placed closest to the anchor.\"\n\t\t\t},\n\t\t\tright: {\n\t\t\t\tdoc: \"The right side of the icon is placed closest to the anchor.\"\n\t\t\t},\n\t\t\ttop: {\n\t\t\t\tdoc: \"The top of the icon is placed closest to the anchor.\"\n\t\t\t},\n\t\t\tbottom: {\n\t\t\t\tdoc: \"The bottom of the icon is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"top-left\": {\n\t\t\t\tdoc: \"The top left corner of the icon is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"top-right\": {\n\t\t\t\tdoc: \"The top right corner of the icon is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"bottom-left\": {\n\t\t\t\tdoc: \"The bottom left corner of the icon is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"bottom-right\": {\n\t\t\t\tdoc: \"The bottom right corner of the icon is placed closest to the anchor.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"center\",\n\t\tdoc: \"Part of the icon placed closest to the anchor.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.40.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.40.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-pitch-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The icon is aligned to the plane of the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The icon is aligned to the plane of the viewport.\"\n\t\t\t},\n\t\t\tauto: {\n\t\t\t\tdoc: \"Automatically matches the value of `icon-rotation-alignment`.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\tdoc: \"Orientation of icon when map is pitched.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.39.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-pitch-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The text is aligned to the plane of the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The text is aligned to the plane of the viewport.\"\n\t\t\t},\n\t\t\tauto: {\n\t\t\t\tdoc: \"Automatically matches the value of `text-rotation-alignment`.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\tdoc: \"Orientation of text when map is pitched.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.21.0\",\n\t\t\t\tandroid: \"4.2.0\",\n\t\t\t\tios: \"3.4.0\",\n\t\t\t\tmacos: \"0.2.1\"\n\t\t\t},\n\t\t\t\"`auto` value\": {\n\t\t\t\tjs: \"0.25.0\",\n\t\t\t\tandroid: \"4.2.0\",\n\t\t\t\tios: \"3.4.0\",\n\t\t\t\tmacos: \"0.3.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-rotation-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.\"\n\t\t\t},\n\t\t\tauto: {\n\t\t\t\tdoc: \"When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"auto\",\n\t\tdoc: \"In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"`auto` value\": {\n\t\t\t\tjs: \"0.25.0\",\n\t\t\t\tandroid: \"4.2.0\",\n\t\t\t\tios: \"3.4.0\",\n\t\t\t\tmacos: \"0.3.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-field\": {\n\t\ttype: \"formatted\",\n\t\t\"default\": \"\",\n\t\ttokens: true,\n\t\tdoc: \"Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-font\": {\n\t\ttype: \"array\",\n\t\tvalue: \"string\",\n\t\t\"default\": [\n\t\t\t\"Open Sans Regular\",\n\t\t\t\"Arial Unicode MS Regular\"\n\t\t],\n\t\tdoc: \"Font stack to use for displaying text.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.43.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-size\": {\n\t\ttype: \"number\",\n\t\t\"default\": 16,\n\t\tminimum: 0,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Font size.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.35.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-max-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 10,\n\t\tminimum: 0,\n\t\tunits: \"ems\",\n\t\tdoc: \"The maximum line width for text wrapping.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.40.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-line-height\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1.2,\n\t\tunits: \"ems\",\n\t\tdoc: \"Text leading value for multi-line text.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-letter-spacing\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tunits: \"ems\",\n\t\tdoc: \"Text tracking amount.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.40.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-justify\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tauto: {\n\t\t\t\tdoc: \"The text is aligned towards the anchor position.\"\n\t\t\t},\n\t\t\tleft: {\n\t\t\t\tdoc: \"The text is aligned to the left.\"\n\t\t\t},\n\t\t\tcenter: {\n\t\t\t\tdoc: \"The text is centered.\"\n\t\t\t},\n\t\t\tright: {\n\t\t\t\tdoc: \"The text is aligned to the right.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"center\",\n\t\tdoc: \"Text justification options.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.39.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t},\n\t\t\tauto: {\n\t\t\t\tjs: \"0.54.0\",\n\t\t\t\tandroid: \"7.4.0\",\n\t\t\t\tios: \"4.10.0\",\n\t\t\t\tmacos: \"0.14.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-radial-offset\": {\n\t\ttype: \"number\",\n\t\tunits: \"ems\",\n\t\t\"default\": 0,\n\t\tdoc: \"Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.54.0\",\n\t\t\t\tandroid: \"7.4.0\",\n\t\t\t\tios: \"4.10.0\",\n\t\t\t\tmacos: \"0.14.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.54.0\",\n\t\t\t\tandroid: \"7.4.0\",\n\t\t\t\tios: \"4.10.0\",\n\t\t\t\tmacos: \"0.14.0\"\n\t\t\t}\n\t\t},\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"property-type\": \"data-driven\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t}\n\t},\n\t\"text-variable-anchor\": {\n\t\ttype: \"array\",\n\t\tvalue: \"enum\",\n\t\tvalues: {\n\t\t\tcenter: {\n\t\t\t\tdoc: \"The center of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\tleft: {\n\t\t\t\tdoc: \"The left side of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\tright: {\n\t\t\t\tdoc: \"The right side of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\ttop: {\n\t\t\t\tdoc: \"The top of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\tbottom: {\n\t\t\t\tdoc: \"The bottom of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"top-left\": {\n\t\t\t\tdoc: \"The top left corner of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"top-right\": {\n\t\t\t\tdoc: \"The top right corner of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"bottom-left\": {\n\t\t\t\tdoc: \"The bottom left corner of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"bottom-right\": {\n\t\t\t\tdoc: \"The bottom right corner of the text is placed closest to the anchor.\"\n\t\t\t}\n\t\t},\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"point\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\tdoc: \"To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.54.0\",\n\t\t\t\tandroid: \"7.4.0\",\n\t\t\t\tios: \"4.10.0\",\n\t\t\t\tmacos: \"0.14.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tcenter: {\n\t\t\t\tdoc: \"The center of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\tleft: {\n\t\t\t\tdoc: \"The left side of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\tright: {\n\t\t\t\tdoc: \"The right side of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\ttop: {\n\t\t\t\tdoc: \"The top of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\tbottom: {\n\t\t\t\tdoc: \"The bottom of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"top-left\": {\n\t\t\t\tdoc: \"The top left corner of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"top-right\": {\n\t\t\t\tdoc: \"The top right corner of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"bottom-left\": {\n\t\t\t\tdoc: \"The bottom left corner of the text is placed closest to the anchor.\"\n\t\t\t},\n\t\t\t\"bottom-right\": {\n\t\t\t\tdoc: \"The bottom right corner of the text is placed closest to the anchor.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"center\",\n\t\tdoc: \"Part of the text placed closest to the anchor.\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"!\": \"text-variable-anchor\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.39.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-max-angle\": {\n\t\ttype: \"number\",\n\t\t\"default\": 45,\n\t\tunits: \"degrees\",\n\t\tdoc: \"Maximum angle change between adjacent characters.\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"line\",\n\t\t\t\t\t\"line-center\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-writing-mode\": {\n\t\ttype: \"array\",\n\t\tvalue: \"enum\",\n\t\tvalues: {\n\t\t\thorizontal: {\n\t\t\t\tdoc: \"If a text's language supports horizontal writing mode, symbols with point placement would be laid out horizontally.\"\n\t\t\t},\n\t\t\tvertical: {\n\t\t\t\tdoc: \"If a text's language supports vertical writing mode, symbols with point placement would be laid out vertically.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesn’t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. The order of elements in an array define priority order for the placement of an orientation variant.\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"point\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"1.3.0\",\n\t\t\t\tandroid: \"8.3.0\",\n\t\t\t\tios: \"5.3.0\",\n\t\t\t\tmacos: \"0.14.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-rotate\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tperiod: 360,\n\t\tunits: \"degrees\",\n\t\tdoc: \"Rotates the text clockwise.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.35.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-padding\": {\n\t\ttype: \"number\",\n\t\t\"default\": 2,\n\t\tminimum: 0,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Size of the additional area around the text bounding box used for detecting symbol collisions.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-keep-upright\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": true,\n\t\tdoc: \"If true, the text may be flipped vertically to prevent it from being rendered upside-down.\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"text-rotation-alignment\": \"map\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"symbol-placement\": [\n\t\t\t\t\t\"line\",\n\t\t\t\t\t\"line-center\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-transform\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tnone: {\n\t\t\t\tdoc: \"The text is not altered.\"\n\t\t\t},\n\t\t\tuppercase: {\n\t\t\t\tdoc: \"Forces all letters to be displayed in uppercase.\"\n\t\t\t},\n\t\t\tlowercase: {\n\t\t\t\tdoc: \"Forces all letters to be displayed in lowercase.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"none\",\n\t\tdoc: \"Specifies how to capitalize text, similar to the CSS `text-transform` property.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-offset\": {\n\t\ttype: \"array\",\n\t\tdoc: \"Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.\",\n\t\tvalue: \"number\",\n\t\tunits: \"ems\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t{\n\t\t\t\t\"!\": \"text-radial-offset\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.35.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-allow-overlap\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"If true, the text will be visible even if it collides with other previously drawn symbols.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-ignore-placement\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"If true, other symbols can be visible even if they collide with the text.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-optional\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": false,\n\t\tdoc: \"If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t\tdoc: \"The layer is shown.\"\n\t\t\t},\n\t\t\tnone: {\n\t\t\t\tdoc: \"The layer is not shown.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\tdoc: \"Whether this layer is displayed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_raster = {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t\tdoc: \"The layer is shown.\"\n\t\t\t},\n\t\t\tnone: {\n\t\t\t\tdoc: \"The layer is not shown.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\tdoc: \"Whether this layer is displayed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar layout_hillshade = {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t\tdoc: \"The layer is shown.\"\n\t\t\t},\n\t\t\tnone: {\n\t\t\t\tdoc: \"The layer is not shown.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\tdoc: \"Whether this layer is displayed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.43.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"constant\"\n\t}\n};\nvar filter = {\n\ttype: \"array\",\n\tvalue: \"*\",\n\tdoc: \"A filter selects specific features from a layer.\"\n};\nvar filter_operator = {\n\ttype: \"enum\",\n\tvalues: {\n\t\t\"==\": {\n\t\t\tdoc: \"`[\\\"==\\\", key, value]` equality: `feature[key] = value`\"\n\t\t},\n\t\t\"!=\": {\n\t\t\tdoc: \"`[\\\"!=\\\", key, value]` inequality: `feature[key] ≠ value`\"\n\t\t},\n\t\t\">\": {\n\t\t\tdoc: \"`[\\\">\\\", key, value]` greater than: `feature[key] > value`\"\n\t\t},\n\t\t\">=\": {\n\t\t\tdoc: \"`[\\\">=\\\", key, value]` greater than or equal: `feature[key] ≥ value`\"\n\t\t},\n\t\t\"<\": {\n\t\t\tdoc: \"`[\\\"<\\\", key, value]` less than: `feature[key] < value`\"\n\t\t},\n\t\t\"<=\": {\n\t\t\tdoc: \"`[\\\"<=\\\", key, value]` less than or equal: `feature[key] ≤ value`\"\n\t\t},\n\t\t\"in\": {\n\t\t\tdoc: \"`[\\\"in\\\", key, v0, ..., vn]` set inclusion: `feature[key] ∈ {v0, ..., vn}`\"\n\t\t},\n\t\t\"!in\": {\n\t\t\tdoc: \"`[\\\"!in\\\", key, v0, ..., vn]` set exclusion: `feature[key] ∉ {v0, ..., vn}`\"\n\t\t},\n\t\tall: {\n\t\t\tdoc: \"`[\\\"all\\\", f0, ..., fn]` logical `AND`: `f0 ∧ ... ∧ fn`\"\n\t\t},\n\t\tany: {\n\t\t\tdoc: \"`[\\\"any\\\", f0, ..., fn]` logical `OR`: `f0 ∨ ... ∨ fn`\"\n\t\t},\n\t\tnone: {\n\t\t\tdoc: \"`[\\\"none\\\", f0, ..., fn]` logical `NOR`: `¬f0 ∧ ... ∧ ¬fn`\"\n\t\t},\n\t\thas: {\n\t\t\tdoc: \"`[\\\"has\\\", key]` `feature[key]` exists\"\n\t\t},\n\t\t\"!has\": {\n\t\t\tdoc: \"`[\\\"!has\\\", key]` `feature[key]` does not exist\"\n\t\t}\n\t},\n\tdoc: \"The filter operator.\"\n};\nvar geometry_type = {\n\ttype: \"enum\",\n\tvalues: {\n\t\tPoint: {\n\t\t\tdoc: \"Filter to point geometries.\"\n\t\t},\n\t\tLineString: {\n\t\t\tdoc: \"Filter to line geometries.\"\n\t\t},\n\t\tPolygon: {\n\t\t\tdoc: \"Filter to polygon geometries.\"\n\t\t}\n\t},\n\tdoc: \"The geometry type for the filter to select.\"\n};\nvar function_stop = {\n\ttype: \"array\",\n\tminimum: 0,\n\tmaximum: 24,\n\tvalue: [\n\t\t\"number\",\n\t\t\"color\"\n\t],\n\tlength: 2,\n\tdoc: \"Zoom level and value pair.\"\n};\nvar expression = {\n\ttype: \"array\",\n\tvalue: \"*\",\n\tminimum: 1,\n\tdoc: \"An expression defines a function that can be used for data-driven style properties or feature filters.\"\n};\nvar expression_name = {\n\tdoc: \"\",\n\ttype: \"enum\",\n\tvalues: {\n\t\t\"let\": {\n\t\t\tdoc: \"Binds expressions to named variables, which can then be referenced in the result expression using [\\\"var\\\", \\\"variable_name\\\"].\",\n\t\t\tgroup: \"Variable binding\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"var\": {\n\t\t\tdoc: \"References variable bound using \\\"let\\\".\",\n\t\t\tgroup: \"Variable binding\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tliteral: {\n\t\t\tdoc: \"Provides a literal array or object value.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tarray: {\n\t\t\tdoc: \"Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tat: {\n\t\t\tdoc: \"Retrieves an item from an array.\",\n\t\t\tgroup: \"Lookup\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"in\": {\n\t\t\tdoc: \"Determines whether an item exists in an array or a substring exists in a string.\",\n\t\t\tgroup: \"Lookup\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"1.6.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"case\": {\n\t\t\tdoc: \"Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tmatch: {\n\t\t\tdoc: \"Selects the output whose label value matches the input value, or the fallback value if no match is found. The input can be any expression (e.g. `[\\\"get\\\", \\\"building_type\\\"]`). Each label must be either:\\n * a single literal value; or\\n * an array of literal values, whose values must be all strings or all numbers (e.g. `[100, 101]` or `[\\\"c\\\", \\\"b\\\"]`). The input matches if any of the values in the array matches, similar to the `\\\"in\\\"` operator.\\n\\nEach label must be unique. If the input type does not match the type of the labels, the result will be the fallback value.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcoalesce: {\n\t\t\tdoc: \"Evaluates each expression in turn until the first non-null value is obtained, and returns that value.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstep: {\n\t\t\tdoc: \"Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\\\"stops\\\"). The `input` may be any numeric expression (e.g., `[\\\"get\\\", \\\"population\\\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.\",\n\t\t\tgroup: \"Ramps, scales, curves\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.42.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tinterpolate: {\n\t\t\tdoc: \"Produces continuous, smooth results by interpolating between pairs of input and output values (\\\"stops\\\"). The `input` may be any numeric expression (e.g., `[\\\"get\\\", \\\"population\\\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\\n\\nInterpolation types:\\n- `[\\\"linear\\\"]`: interpolates linearly between the pair of stops just less than and just greater than the input.\\n- `[\\\"exponential\\\", base]`: interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\\n- `[\\\"cubic-bezier\\\", x1, y1, x2, y2]`: interpolates using the cubic bezier curve defined by the given control points.\",\n\t\t\tgroup: \"Ramps, scales, curves\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.42.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"interpolate-hcl\": {\n\t\t\tdoc: \"Produces continuous, smooth results by interpolating between pairs of input and output values (\\\"stops\\\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.\",\n\t\t\tgroup: \"Ramps, scales, curves\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.49.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"interpolate-lab\": {\n\t\t\tdoc: \"Produces continuous, smooth results by interpolating between pairs of input and output values (\\\"stops\\\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.\",\n\t\t\tgroup: \"Ramps, scales, curves\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.49.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tln2: {\n\t\t\tdoc: \"Returns mathematical constant ln(2).\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tpi: {\n\t\t\tdoc: \"Returns the mathematical constant pi.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\te: {\n\t\t\tdoc: \"Returns the mathematical constant e.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"typeof\": {\n\t\t\tdoc: \"Returns a string describing the type of the given value.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstring: {\n\t\t\tdoc: \"Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tnumber: {\n\t\t\tdoc: \"Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tboolean: {\n\t\t\tdoc: \"Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tobject: {\n\t\t\tdoc: \"Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcollator: {\n\t\t\tdoc: \"Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\t\tios: \"4.2.0\",\n\t\t\t\t\tmacos: \"0.9.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tdoc: \"Returns `formatted` text containing annotations for use in mixed-format `text-field` entries. For a `text-field` entries of a string type, following option object's properties are supported: If set, the `text-font` value overrides the font specified by the root layout properties. If set, the `font-scale` value specifies a scaling factor relative to the `text-size` specified in the root layout properties. If set, the `text-color` value overrides the color specified by the root paint properties for this layer.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.48.0\",\n\t\t\t\t\tandroid: \"6.7.0\",\n\t\t\t\t\tios: \"4.6.0\",\n\t\t\t\t\tmacos: \"0.12.0\"\n\t\t\t\t},\n\t\t\t\t\"text-font\": {\n\t\t\t\t\tjs: \"0.48.0\",\n\t\t\t\t\tandroid: \"6.7.0\",\n\t\t\t\t\tios: \"4.6.0\",\n\t\t\t\t\tmacos: \"0.12.0\"\n\t\t\t\t},\n\t\t\t\t\"font-scale\": {\n\t\t\t\t\tjs: \"0.48.0\",\n\t\t\t\t\tandroid: \"6.7.0\",\n\t\t\t\t\tios: \"4.6.0\",\n\t\t\t\t\tmacos: \"0.12.0\"\n\t\t\t\t},\n\t\t\t\t\"text-color\": {\n\t\t\t\t\tjs: \"1.3.0\",\n\t\t\t\t\tandroid: \"7.3.0\",\n\t\t\t\t\tios: \"4.10.0\",\n\t\t\t\t\tmacos: \"0.14.0\"\n\t\t\t\t},\n\t\t\t\timage: {\n\t\t\t\t\tjs: \"1.6.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\timage: {\n\t\t\tdoc: \"Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"1.4.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"number-format\": {\n\t\t\tdoc: \"Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.54.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"to-string\": {\n\t\t\tdoc: \"Converts the input value to a string. If the input is `null`, the result is `\\\"\\\"`. If the input is a boolean, the result is `\\\"true\\\"` or `\\\"false\\\"`. If the input is a number, it is converted to a string as specified by the [\\\"NumberToString\\\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `\\\"rgba(r,g,b,a)\\\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"to-number\": {\n\t\t\tdoc: \"Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\\\"ToNumber Applied to the String Type\\\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"to-boolean\": {\n\t\t\tdoc: \"Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"to-rgba\": {\n\t\t\tdoc: \"Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.\",\n\t\t\tgroup: \"Color\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"to-color\": {\n\t\t\tdoc: \"Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.\",\n\t\t\tgroup: \"Types\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\trgb: {\n\t\t\tdoc: \"Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.\",\n\t\t\tgroup: \"Color\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\trgba: {\n\t\t\tdoc: \"Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.\",\n\t\t\tgroup: \"Color\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tget: {\n\t\t\tdoc: \"Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns null if the requested property is missing.\",\n\t\t\tgroup: \"Lookup\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thas: {\n\t\t\tdoc: \"Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.\",\n\t\t\tgroup: \"Lookup\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tlength: {\n\t\t\tdoc: \"Gets the length of an array or string.\",\n\t\t\tgroup: \"Lookup\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tproperties: {\n\t\t\tdoc: \"Gets the feature properties object.  Note that in some cases, it may be more efficient to use [\\\"get\\\", \\\"property_name\\\"] directly.\",\n\t\t\tgroup: \"Feature data\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"feature-state\": {\n\t\t\tdoc: \"Retrieves a property value from the current feature's state. Returns null if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\\\"feature-state\\\"] can only be used with paint properties that support data-driven styling.\",\n\t\t\tgroup: \"Feature data\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.46.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"geometry-type\": {\n\t\t\tdoc: \"Gets the feature's geometry type: Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon.\",\n\t\t\tgroup: \"Feature data\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tid: {\n\t\t\tdoc: \"Gets the feature's id, if it has one.\",\n\t\t\tgroup: \"Feature data\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tzoom: {\n\t\t\tdoc: \"Gets the current zoom level.  Note that in style layout and paint properties, [\\\"zoom\\\"] may only appear as the input to a top-level \\\"step\\\" or \\\"interpolate\\\" expression.\",\n\t\t\tgroup: \"Zoom\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"heatmap-density\": {\n\t\t\tdoc: \"Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.\",\n\t\t\tgroup: \"Heatmap\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"line-progress\": {\n\t\t\tdoc: \"Gets the progress along a gradient line. Can only be used in the `line-gradient` property.\",\n\t\t\tgroup: \"Feature data\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\t\tios: \"4.6.0\",\n\t\t\t\t\tmacos: \"0.12.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\taccumulated: {\n\t\t\tdoc: \"Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.\",\n\t\t\tgroup: \"Feature data\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.53.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"+\": {\n\t\t\tdoc: \"Returns the sum of the inputs.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"*\": {\n\t\t\tdoc: \"Returns the product of the inputs.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"-\": {\n\t\t\tdoc: \"For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"/\": {\n\t\t\tdoc: \"Returns the result of floating point division of the first input by the second.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"%\": {\n\t\t\tdoc: \"Returns the remainder after integer division of the first input by the second.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"^\": {\n\t\t\tdoc: \"Returns the result of raising the first input to the power specified by the second.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsqrt: {\n\t\t\tdoc: \"Returns the square root of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.42.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tlog10: {\n\t\t\tdoc: \"Returns the base-ten logarithm of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tln: {\n\t\t\tdoc: \"Returns the natural logarithm of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tlog2: {\n\t\t\tdoc: \"Returns the base-two logarithm of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsin: {\n\t\t\tdoc: \"Returns the sine of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcos: {\n\t\t\tdoc: \"Returns the cosine of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttan: {\n\t\t\tdoc: \"Returns the tangent of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tasin: {\n\t\t\tdoc: \"Returns the arcsine of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tacos: {\n\t\t\tdoc: \"Returns the arccosine of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tatan: {\n\t\t\tdoc: \"Returns the arctangent of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tmin: {\n\t\t\tdoc: \"Returns the minimum value of the inputs.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tmax: {\n\t\t\tdoc: \"Returns the maximum value of the inputs.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tround: {\n\t\t\tdoc: \"Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\\\"round\\\", -1.5]` evaluates to -2.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tabs: {\n\t\t\tdoc: \"Returns the absolute value of the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tceil: {\n\t\t\tdoc: \"Returns the smallest integer that is greater than or equal to the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfloor: {\n\t\t\tdoc: \"Returns the largest integer that is less than or equal to the input.\",\n\t\t\tgroup: \"Math\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"==\": {\n\t\t\tdoc: \"Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t},\n\t\t\t\tcollator: {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\t\tios: \"4.2.0\",\n\t\t\t\t\tmacos: \"0.9.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"!=\": {\n\t\t\tdoc: \"Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t},\n\t\t\t\tcollator: {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\t\tios: \"4.2.0\",\n\t\t\t\t\tmacos: \"0.9.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\">\": {\n\t\t\tdoc: \"Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t},\n\t\t\t\tcollator: {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\t\tios: \"4.2.0\",\n\t\t\t\t\tmacos: \"0.9.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"<\": {\n\t\t\tdoc: \"Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t},\n\t\t\t\tcollator: {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\t\tios: \"4.2.0\",\n\t\t\t\t\tmacos: \"0.9.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\">=\": {\n\t\t\tdoc: \"Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t},\n\t\t\t\tcollator: {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\t\tios: \"4.2.0\",\n\t\t\t\t\tmacos: \"0.9.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"<=\": {\n\t\t\tdoc: \"Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t},\n\t\t\t\tcollator: {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\t\tios: \"4.2.0\",\n\t\t\t\t\tmacos: \"0.9.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tall: {\n\t\t\tdoc: \"Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tany: {\n\t\t\tdoc: \"Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"!\": {\n\t\t\tdoc: \"Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.\",\n\t\t\tgroup: \"Decision\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"is-supported-script\": {\n\t\t\tdoc: \"Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).\",\n\t\t\tgroup: \"String\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.6.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tupcase: {\n\t\t\tdoc: \"Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.\",\n\t\t\tgroup: \"String\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdowncase: {\n\t\t\tdoc: \"Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.\",\n\t\t\tgroup: \"String\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tconcat: {\n\t\t\tdoc: \"Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.\",\n\t\t\tgroup: \"String\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.41.0\",\n\t\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\t\tios: \"4.0.0\",\n\t\t\t\t\tmacos: \"0.7.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"resolved-locale\": {\n\t\t\tdoc: \"Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.\",\n\t\t\tgroup: \"String\",\n\t\t\t\"sdk-support\": {\n\t\t\t\t\"basic functionality\": {\n\t\t\t\t\tjs: \"0.45.0\",\n\t\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\t\tios: \"4.2.0\",\n\t\t\t\t\tmacos: \"0.9.0\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nvar light = {\n\tanchor: {\n\t\ttype: \"enum\",\n\t\t\"default\": \"viewport\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The position of the light source is aligned to the rotation of the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The position of the light source is aligned to the rotation of the viewport.\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"data-constant\",\n\t\ttransition: false,\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\tdoc: \"Whether extruded geometries are lit relative to the map or viewport.\",\n\t\texample: \"map\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t}\n\t},\n\tposition: {\n\t\ttype: \"array\",\n\t\t\"default\": [\n\t\t\t1.15,\n\t\t\t210,\n\t\t\t30\n\t\t],\n\t\tlength: 3,\n\t\tvalue: \"number\",\n\t\t\"property-type\": \"data-constant\",\n\t\ttransition: true,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\tdoc: \"Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0° (0° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0°, directly above, to 180°, directly below).\",\n\t\texample: [\n\t\t\t1.5,\n\t\t\t90,\n\t\t\t80\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t}\n\t},\n\tcolor: {\n\t\ttype: \"color\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": \"#ffffff\",\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true,\n\t\tdoc: \"Color tint for lighting extruded geometries.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t}\n\t},\n\tintensity: {\n\t\ttype: \"number\",\n\t\t\"property-type\": \"data-constant\",\n\t\t\"default\": 0.5,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\ttransition: true,\n\t\tdoc: \"Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t}\n\t}\n};\nvar paint = [\n\t\"paint_fill\",\n\t\"paint_line\",\n\t\"paint_circle\",\n\t\"paint_heatmap\",\n\t\"paint_fill-extrusion\",\n\t\"paint_symbol\",\n\t\"paint_raster\",\n\t\"paint_hillshade\",\n\t\"paint_background\"\n];\nvar paint_fill = {\n\t\"fill-antialias\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": true,\n\t\tdoc: \"Whether or not the fill should be antialiased.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\tdoc: \"The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.21.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\tdoc: \"The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"fill-pattern\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.19.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-outline-color\": {\n\t\ttype: \"color\",\n\t\tdoc: \"The outline color of the fill. Matches the value of `fill-color` if unspecified.\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"fill-pattern\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"fill-antialias\": true\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.19.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The fill is translated relative to the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The fill is translated relative to the viewport.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"Controls the frame of reference for `fill-translate`.\",\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"fill-translate\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-pattern\": {\n\t\ttype: \"resolvedImage\",\n\t\ttransition: true,\n\t\tdoc: \"Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.49.0\",\n\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\tmacos: \"0.11.0\",\n\t\t\t\tios: \"4.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded-data-driven\"\n\t}\n};\nvar paint_line = {\n\t\"line-opacity\": {\n\t\ttype: \"number\",\n\t\tdoc: \"The opacity at which the line will be drawn.\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-color\": {\n\t\ttype: \"color\",\n\t\tdoc: \"The color with which the line will be drawn.\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"line-pattern\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.23.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The line is translated relative to the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The line is translated relative to the viewport.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"Controls the frame of reference for `line-translate`.\",\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"line-translate\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"line-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Stroke thickness.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.39.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-gap-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\tdoc: \"Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.\",\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-offset\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tdoc: \"The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.\",\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.12.1\",\n\t\t\t\tandroid: \"3.0.0\",\n\t\t\t\tios: \"3.1.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-blur\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Blur applied to the line, in pixels.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"line-dasharray\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tdoc: \"Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.\",\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"line widths\",\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"line-pattern\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded\"\n\t},\n\t\"line-pattern\": {\n\t\ttype: \"resolvedImage\",\n\t\ttransition: true,\n\t\tdoc: \"Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.49.0\",\n\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\tmacos: \"0.11.0\",\n\t\t\t\tios: \"4.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded-data-driven\"\n\t},\n\t\"line-gradient\": {\n\t\ttype: \"color\",\n\t\tdoc: \"Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\\\"lineMetrics\\\": true`.\",\n\t\ttransition: false,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"line-dasharray\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"!\": \"line-pattern\"\n\t\t\t},\n\t\t\t{\n\t\t\t\tsource: \"geojson\",\n\t\t\t\thas: {\n\t\t\t\t\tlineMetrics: true\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.45.0\",\n\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\tios: \"4.4.0\",\n\t\t\t\tmacos: \"0.11.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"line-progress\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"color-ramp\"\n\t}\n};\nvar paint_circle = {\n\t\"circle-radius\": {\n\t\ttype: \"number\",\n\t\t\"default\": 5,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Circle radius.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.18.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\tdoc: \"The fill color of the circle.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.18.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-blur\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tdoc: \"Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.20.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-opacity\": {\n\t\ttype: \"number\",\n\t\tdoc: \"The opacity at which the circle will be drawn.\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.20.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"circle-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The circle is translated relative to the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The circle is translated relative to the viewport.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"Controls the frame of reference for `circle-translate`.\",\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"circle-translate\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"circle-pitch-scale\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"Circles are scaled according to their apparent distance to the camera.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"Circles are not scaled.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"map\",\n\t\tdoc: \"Controls the scaling behavior of the circle when the map is pitched.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.21.0\",\n\t\t\t\tandroid: \"4.2.0\",\n\t\t\t\tios: \"3.4.0\",\n\t\t\t\tmacos: \"0.2.1\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"circle-pitch-alignment\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The circle is aligned to the plane of the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The circle is aligned to the plane of the viewport.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"viewport\",\n\t\tdoc: \"Orientation of circle when map is pitched.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.39.0\",\n\t\t\t\tandroid: \"5.2.0\",\n\t\t\t\tios: \"3.7.0\",\n\t\t\t\tmacos: \"0.6.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"circle-stroke-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-stroke-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\tdoc: \"The stroke color of the circle.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"circle-stroke-opacity\": {\n\t\ttype: \"number\",\n\t\tdoc: \"The opacity of the circle's stroke.\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.29.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t}\n};\nvar paint_heatmap = {\n\t\"heatmap-radius\": {\n\t\ttype: \"number\",\n\t\t\"default\": 30,\n\t\tminimum: 1,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.41.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.43.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"heatmap-weight\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\ttransition: false,\n\t\tdoc: \"A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.41.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.41.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"heatmap-intensity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tdoc: \"Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.41.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"heatmap-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": [\n\t\t\t\"interpolate\",\n\t\t\t[\n\t\t\t\t\"linear\"\n\t\t\t],\n\t\t\t[\n\t\t\t\t\"heatmap-density\"\n\t\t\t],\n\t\t\t0,\n\t\t\t\"rgba(0, 0, 255, 0)\",\n\t\t\t0.1,\n\t\t\t\"royalblue\",\n\t\t\t0.3,\n\t\t\t\"cyan\",\n\t\t\t0.5,\n\t\t\t\"lime\",\n\t\t\t0.7,\n\t\t\t\"yellow\",\n\t\t\t1,\n\t\t\t\"red\"\n\t\t],\n\t\tdoc: \"Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\\\"heatmap-density\\\"]` as input.\",\n\t\ttransition: false,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.41.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"heatmap-density\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"color-ramp\"\n\t},\n\t\"heatmap-opacity\": {\n\t\ttype: \"number\",\n\t\tdoc: \"The global opacity at which the heatmap layer will be drawn.\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.41.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar paint_symbol = {\n\t\"icon-opacity\": {\n\t\tdoc: \"The opacity at which the icon will be drawn.\",\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\tdoc: \"The color of the icon. This can only be used with sdf icons.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-halo-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"rgba(0, 0, 0, 0)\",\n\t\ttransition: true,\n\t\tdoc: \"The color of the icon's halo. Icon halos can only be used with SDF icons.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-halo-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Distance of halo to the icon outline.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-halo-blur\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Fade out the halo towards the outside.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"icon-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.\",\n\t\trequires: [\n\t\t\t\"icon-image\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"icon-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"Icons are translated relative to the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"Icons are translated relative to the viewport.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"Controls the frame of reference for `icon-translate`.\",\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"icon-image\",\n\t\t\t\"icon-translate\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-opacity\": {\n\t\ttype: \"number\",\n\t\tdoc: \"The opacity at which the text will be drawn.\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-color\": {\n\t\ttype: \"color\",\n\t\tdoc: \"The color with which the text will be drawn.\",\n\t\t\"default\": \"#000000\",\n\t\ttransition: true,\n\t\toverridable: true,\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-halo-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"rgba(0, 0, 0, 0)\",\n\t\ttransition: true,\n\t\tdoc: \"The color of the text's halo, which helps it stand out from backgrounds.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-halo-width\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-halo-blur\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"The halo's fadeout distance towards the outside.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.33.0\",\n\t\t\t\tandroid: \"5.0.0\",\n\t\t\t\tios: \"3.5.0\",\n\t\t\t\tmacos: \"0.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"text-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.\",\n\t\trequires: [\n\t\t\t\"text-field\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"text-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The text is translated relative to the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The text is translated relative to the viewport.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"Controls the frame of reference for `text-translate`.\",\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"text-field\",\n\t\t\t\"text-translate\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar paint_raster = {\n\t\"raster-opacity\": {\n\t\ttype: \"number\",\n\t\tdoc: \"The opacity at which the image will be drawn.\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-hue-rotate\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tperiod: 360,\n\t\ttransition: true,\n\t\tunits: \"degrees\",\n\t\tdoc: \"Rotates hues around the color wheel.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-brightness-min\": {\n\t\ttype: \"number\",\n\t\tdoc: \"Increase or reduce the brightness of the image. The value is the minimum brightness.\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-brightness-max\": {\n\t\ttype: \"number\",\n\t\tdoc: \"Increase or reduce the brightness of the image. The value is the maximum brightness.\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-saturation\": {\n\t\ttype: \"number\",\n\t\tdoc: \"Increase or reduce the saturation of the image.\",\n\t\t\"default\": 0,\n\t\tminimum: -1,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-contrast\": {\n\t\ttype: \"number\",\n\t\tdoc: \"Increase or reduce the contrast of the image.\",\n\t\t\"default\": 0,\n\t\tminimum: -1,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-resampling\": {\n\t\ttype: \"enum\",\n\t\tdoc: \"The resampling/interpolation method to use for overscaling, also known as texture magnification filter\",\n\t\tvalues: {\n\t\t\tlinear: {\n\t\t\t\tdoc: \"(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled\"\n\t\t\t},\n\t\t\tnearest: {\n\t\t\t\tdoc: \"Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"linear\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.47.0\",\n\t\t\t\tandroid: \"6.3.0\",\n\t\t\t\tios: \"4.2.0\",\n\t\t\t\tmacos: \"0.9.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"raster-fade-duration\": {\n\t\ttype: \"number\",\n\t\t\"default\": 300,\n\t\tminimum: 0,\n\t\ttransition: false,\n\t\tunits: \"milliseconds\",\n\t\tdoc: \"Fade duration when a new tile is added.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar paint_hillshade = {\n\t\"hillshade-illumination-direction\": {\n\t\ttype: \"number\",\n\t\t\"default\": 335,\n\t\tminimum: 0,\n\t\tmaximum: 359,\n\t\tdoc: \"The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.\",\n\t\ttransition: false,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.43.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-illumination-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The hillshade illumination is relative to the north direction.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The hillshade illumination is relative to the top of the viewport.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"viewport\",\n\t\tdoc: \"Direction of light source when map is rotated.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.43.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-exaggeration\": {\n\t\ttype: \"number\",\n\t\tdoc: \"Intensity of the hillshade\",\n\t\t\"default\": 0.5,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.43.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-shadow-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\tdoc: \"The shading color of areas that face away from the light source.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.43.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-highlight-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#FFFFFF\",\n\t\tdoc: \"The shading color of areas that faces towards the light source.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.43.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"hillshade-accent-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\tdoc: \"The shading color used to accentuate rugged terrain like sharp cliffs and gorges.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.43.0\",\n\t\t\t\tandroid: \"6.0.0\",\n\t\t\t\tios: \"4.0.0\",\n\t\t\t\tmacos: \"0.7.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar paint_background = {\n\t\"background-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\tdoc: \"The color with which the background will be drawn.\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"background-pattern\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"background-pattern\": {\n\t\ttype: \"resolvedImage\",\n\t\ttransition: true,\n\t\tdoc: \"Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded\"\n\t},\n\t\"background-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\tdoc: \"The opacity at which the background will be drawn.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.10.0\",\n\t\t\t\tandroid: \"2.0.1\",\n\t\t\t\tios: \"2.0.0\",\n\t\t\t\tmacos: \"0.1.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n};\nvar transition = {\n\tduration: {\n\t\ttype: \"number\",\n\t\t\"default\": 300,\n\t\tminimum: 0,\n\t\tunits: \"milliseconds\",\n\t\tdoc: \"Time allotted for transitions to complete.\"\n\t},\n\tdelay: {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\tunits: \"milliseconds\",\n\t\tdoc: \"Length of time before a transition begins.\"\n\t}\n};\nvar promoteId = {\n\t\"*\": {\n\t\ttype: \"string\",\n\t\tdoc: \"A name of a feature property to use as ID for feature state.\"\n\t}\n};\nvar v8 = {\n\t$version: $version,\n\t$root: $root,\n\tsources: sources,\n\tsource: source,\n\tsource_vector: source_vector,\n\tsource_raster: source_raster,\n\tsource_raster_dem: source_raster_dem,\n\tsource_geojson: source_geojson,\n\tsource_video: source_video,\n\tsource_image: source_image,\n\tlayer: layer,\n\tlayout: layout,\n\tlayout_background: layout_background,\n\tlayout_fill: layout_fill,\n\tlayout_circle: layout_circle,\n\tlayout_heatmap: layout_heatmap,\n\t\"layout_fill-extrusion\": {\n\tvisibility: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tvisible: {\n\t\t\t\tdoc: \"The layer is shown.\"\n\t\t\t},\n\t\t\tnone: {\n\t\t\t\tdoc: \"The layer is not shown.\"\n\t\t\t}\n\t\t},\n\t\t\"default\": \"visible\",\n\t\tdoc: \"Whether this layer is displayed.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\t\"property-type\": \"constant\"\n\t}\n},\n\tlayout_line: layout_line,\n\tlayout_symbol: layout_symbol,\n\tlayout_raster: layout_raster,\n\tlayout_hillshade: layout_hillshade,\n\tfilter: filter,\n\tfilter_operator: filter_operator,\n\tgeometry_type: geometry_type,\n\t\"function\": {\n\texpression: {\n\t\ttype: \"expression\",\n\t\tdoc: \"An expression.\"\n\t},\n\tstops: {\n\t\ttype: \"array\",\n\t\tdoc: \"An array of stops.\",\n\t\tvalue: \"function_stop\"\n\t},\n\tbase: {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tdoc: \"The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly.\"\n\t},\n\tproperty: {\n\t\ttype: \"string\",\n\t\tdoc: \"The name of a feature property to use as the function input.\",\n\t\t\"default\": \"$zoom\"\n\t},\n\ttype: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tidentity: {\n\t\t\t\tdoc: \"Return the input value as the output value.\"\n\t\t\t},\n\t\t\texponential: {\n\t\t\t\tdoc: \"Generate an output by interpolating between stops just less than and just greater than the function input.\"\n\t\t\t},\n\t\t\tinterval: {\n\t\t\t\tdoc: \"Return the output value of the stop just less than the function input.\"\n\t\t\t},\n\t\t\tcategorical: {\n\t\t\t\tdoc: \"Return the output value of the stop equal to the function input.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"The interpolation strategy to use in function evaluation.\",\n\t\t\"default\": \"exponential\"\n\t},\n\tcolorSpace: {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\trgb: {\n\t\t\t\tdoc: \"Use the RGB color space to interpolate color values\"\n\t\t\t},\n\t\t\tlab: {\n\t\t\t\tdoc: \"Use the LAB color space to interpolate color values.\"\n\t\t\t},\n\t\t\thcl: {\n\t\t\t\tdoc: \"Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.\",\n\t\t\"default\": \"rgb\"\n\t},\n\t\"default\": {\n\t\ttype: \"*\",\n\t\trequired: false,\n\t\tdoc: \"A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\\n* In categorical functions, when the feature value does not match any of the stop domain values.\\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\\nIf no default is provided, the style property's default is used in these circumstances.\"\n\t}\n},\n\tfunction_stop: function_stop,\n\texpression: expression,\n\texpression_name: expression_name,\n\tlight: light,\n\tpaint: paint,\n\tpaint_fill: paint_fill,\n\t\"paint_fill-extrusion\": {\n\t\"fill-extrusion-opacity\": {\n\t\ttype: \"number\",\n\t\t\"default\": 1,\n\t\tminimum: 0,\n\t\tmaximum: 1,\n\t\tdoc: \"The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-extrusion-color\": {\n\t\ttype: \"color\",\n\t\t\"default\": \"#000000\",\n\t\tdoc: \"The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t{\n\t\t\t\t\"!\": \"fill-extrusion-pattern\"\n\t\t\t}\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-extrusion-translate\": {\n\t\ttype: \"array\",\n\t\tvalue: \"number\",\n\t\tlength: 2,\n\t\t\"default\": [\n\t\t\t0,\n\t\t\t0\n\t\t],\n\t\ttransition: true,\n\t\tunits: \"pixels\",\n\t\tdoc: \"The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-extrusion-translate-anchor\": {\n\t\ttype: \"enum\",\n\t\tvalues: {\n\t\t\tmap: {\n\t\t\t\tdoc: \"The fill extrusion is translated relative to the map.\"\n\t\t\t},\n\t\t\tviewport: {\n\t\t\t\tdoc: \"The fill extrusion is translated relative to the viewport.\"\n\t\t\t}\n\t\t},\n\t\tdoc: \"Controls the frame of reference for `fill-extrusion-translate`.\",\n\t\t\"default\": \"map\",\n\t\trequires: [\n\t\t\t\"fill-extrusion-translate\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t},\n\t\"fill-extrusion-pattern\": {\n\t\ttype: \"resolvedImage\",\n\t\ttransition: true,\n\t\tdoc: \"Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.\",\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.49.0\",\n\t\t\t\tandroid: \"6.5.0\",\n\t\t\t\tmacos: \"0.11.0\",\n\t\t\t\tios: \"4.4.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"cross-faded-data-driven\"\n\t},\n\t\"fill-extrusion-height\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\tunits: \"meters\",\n\t\tdoc: \"The height with which to extrude this layer.\",\n\t\ttransition: true,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-extrusion-base\": {\n\t\ttype: \"number\",\n\t\t\"default\": 0,\n\t\tminimum: 0,\n\t\tunits: \"meters\",\n\t\tdoc: \"The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.\",\n\t\ttransition: true,\n\t\trequires: [\n\t\t\t\"fill-extrusion-height\"\n\t\t],\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t},\n\t\t\t\"data-driven styling\": {\n\t\t\t\tjs: \"0.27.0\",\n\t\t\t\tandroid: \"5.1.0\",\n\t\t\t\tios: \"3.6.0\",\n\t\t\t\tmacos: \"0.5.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: true,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\",\n\t\t\t\t\"feature\",\n\t\t\t\t\"feature-state\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-driven\"\n\t},\n\t\"fill-extrusion-vertical-gradient\": {\n\t\ttype: \"boolean\",\n\t\t\"default\": true,\n\t\tdoc: \"Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.\",\n\t\ttransition: false,\n\t\t\"sdk-support\": {\n\t\t\t\"basic functionality\": {\n\t\t\t\tjs: \"0.50.0\",\n\t\t\t\tios: \"4.7.0\",\n\t\t\t\tmacos: \"0.13.0\"\n\t\t\t}\n\t\t},\n\t\texpression: {\n\t\t\tinterpolated: false,\n\t\t\tparameters: [\n\t\t\t\t\"zoom\"\n\t\t\t]\n\t\t},\n\t\t\"property-type\": \"data-constant\"\n\t}\n},\n\tpaint_line: paint_line,\n\tpaint_circle: paint_circle,\n\tpaint_heatmap: paint_heatmap,\n\tpaint_symbol: paint_symbol,\n\tpaint_raster: paint_raster,\n\tpaint_hillshade: paint_hillshade,\n\tpaint_background: paint_background,\n\ttransition: transition,\n\t\"property-type\": {\n\t\"data-driven\": {\n\t\ttype: \"property-type\",\n\t\tdoc: \"Property is interpolable and can be represented using a property expression.\"\n\t},\n\t\"cross-faded\": {\n\t\ttype: \"property-type\",\n\t\tdoc: \"Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms.\"\n\t},\n\t\"cross-faded-data-driven\": {\n\t\ttype: \"property-type\",\n\t\tdoc: \"Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression.\"\n\t},\n\t\"color-ramp\": {\n\t\ttype: \"property-type\",\n\t\tdoc: \"Property should be specified using a color ramp from which the output color can be sampled based on a property calculation.\"\n\t},\n\t\"data-constant\": {\n\t\ttype: \"property-type\",\n\t\tdoc: \"Property is interpolable but cannot be represented using a property expression.\"\n\t},\n\tconstant: {\n\t\ttype: \"property-type\",\n\t\tdoc: \"Property is constant across all zoom levels and property values.\"\n\t}\n},\n\tpromoteId: promoteId\n};\n\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,]/g;\nvar jsonStringifyPrettyCompact = function stringify(passedObj, options) {\n    var indent, maxLength, replacer;\n    options = options || {};\n    indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);\n    maxLength = indent === '' ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;\n    replacer = options.replacer;\n    return function _stringify(obj, currentIndent, reserved) {\n        var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;\n        if (obj && typeof obj.toJSON === 'function') {\n            obj = obj.toJSON();\n        }\n        string = JSON.stringify(obj, replacer);\n        if (string === undefined) {\n            return string;\n        }\n        length = maxLength - currentIndent.length - reserved;\n        if (string.length <= length) {\n            prettified = string.replace(stringOrChar, function (match, stringLiteral) {\n                return stringLiteral || match + ' ';\n            });\n            if (prettified.length <= length) {\n                return prettified;\n            }\n        }\n        if (replacer != null) {\n            obj = JSON.parse(string);\n            replacer = undefined;\n        }\n        if (typeof obj === 'object' && obj !== null) {\n            nextIndent = currentIndent + indent;\n            items = [];\n            index = 0;\n            if (Array.isArray(obj)) {\n                start = '[';\n                end = ']';\n                length = obj.length;\n                for (; index < length; index++) {\n                    items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || 'null');\n                }\n            } else {\n                start = '{';\n                end = '}';\n                keys = Object.keys(obj);\n                length = keys.length;\n                for (; index < length; index++) {\n                    key = keys[index];\n                    keyPart = JSON.stringify(key) + ': ';\n                    value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));\n                    if (value !== undefined) {\n                        items.push(keyPart + value);\n                    }\n                }\n            }\n            if (items.length > 0) {\n                return [\n                    start,\n                    indent + items.join(',\\n' + nextIndent),\n                    end\n                ].join('\\n' + currentIndent);\n            }\n        }\n        return string;\n    }(passedObj, '', 0);\n};\n\nfunction sortKeysBy(obj, reference) {\n    var result = {};\n    for (var key in reference) {\n        if (obj[key] !== undefined) {\n            result[key] = obj[key];\n        }\n    }\n    for (var key$1 in obj) {\n        if (result[key$1] === undefined) {\n            result[key$1] = obj[key$1];\n        }\n    }\n    return result;\n}\nfunction format(style, space) {\n    if (space === void 0)\n        space = 2;\n    style = sortKeysBy(style, v8.$root);\n    if (style.layers) {\n        style.layers = style.layers.map(function (layer) {\n            return sortKeysBy(layer, v8.layer);\n        });\n    }\n    return jsonStringifyPrettyCompact(style, { indent: space });\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar punycode = createCommonjsModule(function (module, exports) {\n(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(commonjsGlobal));\n});\n\nvar util = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n// Copyright Joyent, Inc. and other Node contributors.\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar decode = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\n// Copyright Joyent, Inc. and other Node contributors.\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nvar encode = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) { return ''; }\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar querystring = createCommonjsModule(function (module, exports) {\n\nexports.decode = exports.parse = decode;\nexports.encode = exports.stringify = encode;\n});\nvar querystring_1 = querystring.decode;\nvar querystring_2 = querystring.parse;\nvar querystring_3 = querystring.encode;\nvar querystring_4 = querystring.stringify;\n\nvar parse = urlParse;\nvar resolve = urlResolve;\nvar resolveObject = urlResolveObject;\nvar format$1 = urlFormat;\n\nvar Url_1 = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    };\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) { return url; }\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        { hostEnd = hec; }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        { hostEnd = hec; }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      { hostEnd = rest.length; }\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        { continue; }\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) { obj = urlParse(obj); }\n  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }\n  if (search && search.charAt(0) !== '?') { search = '?' + search; }\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) { return relative; }\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        { result[rkey] = relative[rkey]; }\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift())){ }\n      if (!relative.host) { relative.host = ''; }\n      if (!relative.hostname) { relative.hostname = ''; }\n      if (relPath[0] !== '') { relPath.unshift(''); }\n      if (relPath.length < 2) { relPath.unshift(''); }\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') { srcPath[0] = result.host; }\n      else { srcPath.unshift(result.host); }\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') { relPath[0] = relative.host; }\n        else { relPath.unshift(relative.host); }\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) { srcPath = []; }\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nvar url = {\n\tparse: parse,\n\tresolve: resolve,\n\tresolveObject: resolveObject,\n\tformat: format$1,\n\tUrl: Url_1\n};\n\nfunction getPropertyReference(propertyName) {\n    for (var i = 0; i < v8.layout.length; i++) {\n        for (var key in v8[v8.layout[i]]) {\n            if (key === propertyName) {\n                return v8[v8.layout[i]][key];\n            }\n        }\n    }\n    for (var i$1 = 0; i$1 < v8.paint.length; i$1++) {\n        for (var key$1 in v8[v8.paint[i$1]]) {\n            if (key$1 === propertyName) {\n                return v8[v8.paint[i$1]][key$1];\n            }\n        }\n    }\n    return null;\n}\nfunction eachSource(style, callback) {\n    for (var k in style.sources) {\n        callback(style.sources[k]);\n    }\n}\nfunction eachLayer(style, callback) {\n    for (var i = 0, list = style.layers; i < list.length; i += 1) {\n        var layer = list[i];\n        callback(layer);\n    }\n}\nfunction eachProperty(style, options, callback) {\n    function inner(layer, propertyType) {\n        var properties = layer[propertyType];\n        if (!properties) {\n            return;\n        }\n        Object.keys(properties).forEach(function (key) {\n            callback({\n                path: [\n                    layer.id,\n                    propertyType,\n                    key\n                ],\n                key: key,\n                value: properties[key],\n                reference: getPropertyReference(key),\n                set: function set(x) {\n                    properties[key] = x;\n                }\n            });\n        });\n    }\n    eachLayer(style, function (layer) {\n        if (options.paint) {\n            inner(layer, 'paint');\n        }\n        if (options.layout) {\n            inner(layer, 'layout');\n        }\n    });\n}\n\nfunction eachLayout(layer, callback) {\n    for (var k in layer) {\n        if (k.indexOf('layout') === 0) {\n            callback(layer[k], k);\n        }\n    }\n}\nfunction eachPaint(layer, callback) {\n    for (var k in layer) {\n        if (k.indexOf('paint') === 0) {\n            callback(layer[k], k);\n        }\n    }\n}\nfunction resolveConstant(style, value) {\n    if (typeof value === 'string' && value[0] === '@') {\n        return resolveConstant(style, style.constants[value]);\n    } else {\n        return value;\n    }\n}\nfunction isFunction(value) {\n    return Array.isArray(value.stops);\n}\nfunction renameProperty(obj, from, to) {\n    obj[to] = obj[from];\n    delete obj[from];\n}\nfunction migrateToV8 (style) {\n    style.version = 8;\n    eachSource(style, function (source) {\n        if (source.type === 'video' && source.url !== undefined) {\n            renameProperty(source, 'url', 'urls');\n        }\n        if (source.type === 'video') {\n            source.coordinates.forEach(function (coord) {\n                return coord.reverse();\n            });\n        }\n    });\n    eachLayer(style, function (layer) {\n        eachLayout(layer, function (layout) {\n            if (layout['symbol-min-distance'] !== undefined) {\n                renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');\n            }\n        });\n        eachPaint(layer, function (paint) {\n            if (paint['background-image'] !== undefined) {\n                renameProperty(paint, 'background-image', 'background-pattern');\n            }\n            if (paint['line-image'] !== undefined) {\n                renameProperty(paint, 'line-image', 'line-pattern');\n            }\n            if (paint['fill-image'] !== undefined) {\n                renameProperty(paint, 'fill-image', 'fill-pattern');\n            }\n        });\n    });\n    eachProperty(style, {\n        paint: true,\n        layout: true\n    }, function (property) {\n        var value = resolveConstant(style, property.value);\n        if (isFunction(value)) {\n            value.stops.forEach(function (stop) {\n                stop[1] = resolveConstant(style, stop[1]);\n            });\n        }\n        property.set(value);\n    });\n    delete style.constants;\n    eachLayer(style, function (layer) {\n        eachLayout(layer, function (layout) {\n            delete layout['text-max-size'];\n            delete layout['icon-max-size'];\n        });\n        eachPaint(layer, function (paint) {\n            if (paint['text-size']) {\n                if (!layer.layout) {\n                    layer.layout = {};\n                }\n                layer.layout['text-size'] = paint['text-size'];\n                delete paint['text-size'];\n            }\n            if (paint['icon-size']) {\n                if (!layer.layout) {\n                    layer.layout = {};\n                }\n                layer.layout['icon-size'] = paint['icon-size'];\n                delete paint['icon-size'];\n            }\n        });\n    });\n    function migrateFontstackURL(input) {\n        var inputParsed = url.parse(input);\n        var inputPathnameParts = inputParsed.pathname.split('/');\n        if (inputParsed.protocol !== 'mapbox:') {\n            return input;\n        } else if (inputParsed.hostname === 'fontstack') {\n            return 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf';\n        } else if (inputParsed.hostname === 'fonts') {\n            return 'mapbox://fonts/' + inputPathnameParts[2] + '/{fontstack}/{range}.pbf';\n        }\n    }\n    if (style.glyphs) {\n        style.glyphs = migrateFontstackURL(style.glyphs);\n    }\n    function migrateFontStack(font) {\n        function splitAndTrim(string) {\n            return string.split(',').map(function (s) {\n                return s.trim();\n            });\n        }\n        if (Array.isArray(font)) {\n            return font;\n        } else if (typeof font === 'string') {\n            return splitAndTrim(font);\n        } else if (typeof font === 'object') {\n            font.stops.forEach(function (stop) {\n                stop[1] = splitAndTrim(stop[1]);\n            });\n            return font;\n        } else {\n            throw new Error('unexpected font value');\n        }\n    }\n    eachLayer(style, function (layer) {\n        eachLayout(layer, function (layout) {\n            if (layout['text-font']) {\n                layout['text-font'] = migrateFontStack(layout['text-font']);\n            }\n        });\n    });\n    var firstSymbolLayer = 0;\n    for (var i = style.layers.length - 1; i >= 0; i--) {\n        var layer = style.layers[i];\n        if (layer.type !== 'symbol') {\n            firstSymbolLayer = i + 1;\n            break;\n        }\n    }\n    var symbolLayers = style.layers.splice(firstSymbolLayer);\n    symbolLayers.reverse();\n    style.layers = style.layers.concat(symbolLayers);\n    return style;\n}\n\nfunction extend (output) {\n    var inputs = [], len = arguments.length - 1;\n    while (len-- > 0)\n        inputs[len] = arguments[len + 1];\n    for (var i = 0, list = inputs; i < list.length; i += 1) {\n        var input = list[i];\n        for (var k in input) {\n            output[k] = input[k];\n        }\n    }\n    return output;\n}\n\nvar ParsingError = function (Error) {\n    function ParsingError(key, message) {\n        Error.call(this, message);\n        this.message = message;\n        this.key = key;\n    }\n    if (Error)\n        ParsingError.__proto__ = Error;\n    ParsingError.prototype = Object.create(Error && Error.prototype);\n    ParsingError.prototype.constructor = ParsingError;\n    return ParsingError;\n}(Error);\n\nvar Scope = function Scope(parent, bindings) {\n    if (bindings === void 0)\n        bindings = [];\n    this.parent = parent;\n    this.bindings = {};\n    for (var i = 0, list = bindings; i < list.length; i += 1) {\n        var ref = list[i];\n        var name = ref[0];\n        var expression = ref[1];\n        this.bindings[name] = expression;\n    }\n};\nScope.prototype.concat = function concat(bindings) {\n    return new Scope(this, bindings);\n};\nScope.prototype.get = function get(name) {\n    if (this.bindings[name]) {\n        return this.bindings[name];\n    }\n    if (this.parent) {\n        return this.parent.get(name);\n    }\n    throw new Error(name + ' not found in scope.');\n};\nScope.prototype.has = function has(name) {\n    if (this.bindings[name]) {\n        return true;\n    }\n    return this.parent ? this.parent.has(name) : false;\n};\n\nvar NullType = { kind: 'null' };\nvar NumberType = { kind: 'number' };\nvar StringType = { kind: 'string' };\nvar BooleanType = { kind: 'boolean' };\nvar ColorType = { kind: 'color' };\nvar ObjectType = { kind: 'object' };\nvar ValueType = { kind: 'value' };\nvar ErrorType = { kind: 'error' };\nvar CollatorType = { kind: 'collator' };\nvar FormattedType = { kind: 'formatted' };\nvar ResolvedImageType = { kind: 'resolvedImage' };\nfunction array(itemType, N) {\n    return {\n        kind: 'array',\n        itemType: itemType,\n        N: N\n    };\n}\nfunction toString(type) {\n    if (type.kind === 'array') {\n        var itemType = toString(type.itemType);\n        return typeof type.N === 'number' ? 'array<' + itemType + ', ' + type.N + '>' : type.itemType.kind === 'value' ? 'array' : 'array<' + itemType + '>';\n    } else {\n        return type.kind;\n    }\n}\nvar valueMemberTypes = [\n    NullType,\n    NumberType,\n    StringType,\n    BooleanType,\n    ColorType,\n    FormattedType,\n    ObjectType,\n    array(ValueType),\n    ResolvedImageType\n];\nfunction checkSubtype(expected, t) {\n    if (t.kind === 'error') {\n        return null;\n    } else if (expected.kind === 'array') {\n        if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {\n            return null;\n        }\n    } else if (expected.kind === t.kind) {\n        return null;\n    } else if (expected.kind === 'value') {\n        for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {\n            var memberType = list[i];\n            if (!checkSubtype(memberType, t)) {\n                return null;\n            }\n        }\n    }\n    return 'Expected ' + toString(expected) + ' but found ' + toString(t) + ' instead.';\n}\n\nvar csscolorparser = createCommonjsModule(function (module, exports) {\nvar kCSSColorTable = {\n    'transparent': [\n        0,\n        0,\n        0,\n        0\n    ],\n    'aliceblue': [\n        240,\n        248,\n        255,\n        1\n    ],\n    'antiquewhite': [\n        250,\n        235,\n        215,\n        1\n    ],\n    'aqua': [\n        0,\n        255,\n        255,\n        1\n    ],\n    'aquamarine': [\n        127,\n        255,\n        212,\n        1\n    ],\n    'azure': [\n        240,\n        255,\n        255,\n        1\n    ],\n    'beige': [\n        245,\n        245,\n        220,\n        1\n    ],\n    'bisque': [\n        255,\n        228,\n        196,\n        1\n    ],\n    'black': [\n        0,\n        0,\n        0,\n        1\n    ],\n    'blanchedalmond': [\n        255,\n        235,\n        205,\n        1\n    ],\n    'blue': [\n        0,\n        0,\n        255,\n        1\n    ],\n    'blueviolet': [\n        138,\n        43,\n        226,\n        1\n    ],\n    'brown': [\n        165,\n        42,\n        42,\n        1\n    ],\n    'burlywood': [\n        222,\n        184,\n        135,\n        1\n    ],\n    'cadetblue': [\n        95,\n        158,\n        160,\n        1\n    ],\n    'chartreuse': [\n        127,\n        255,\n        0,\n        1\n    ],\n    'chocolate': [\n        210,\n        105,\n        30,\n        1\n    ],\n    'coral': [\n        255,\n        127,\n        80,\n        1\n    ],\n    'cornflowerblue': [\n        100,\n        149,\n        237,\n        1\n    ],\n    'cornsilk': [\n        255,\n        248,\n        220,\n        1\n    ],\n    'crimson': [\n        220,\n        20,\n        60,\n        1\n    ],\n    'cyan': [\n        0,\n        255,\n        255,\n        1\n    ],\n    'darkblue': [\n        0,\n        0,\n        139,\n        1\n    ],\n    'darkcyan': [\n        0,\n        139,\n        139,\n        1\n    ],\n    'darkgoldenrod': [\n        184,\n        134,\n        11,\n        1\n    ],\n    'darkgray': [\n        169,\n        169,\n        169,\n        1\n    ],\n    'darkgreen': [\n        0,\n        100,\n        0,\n        1\n    ],\n    'darkgrey': [\n        169,\n        169,\n        169,\n        1\n    ],\n    'darkkhaki': [\n        189,\n        183,\n        107,\n        1\n    ],\n    'darkmagenta': [\n        139,\n        0,\n        139,\n        1\n    ],\n    'darkolivegreen': [\n        85,\n        107,\n        47,\n        1\n    ],\n    'darkorange': [\n        255,\n        140,\n        0,\n        1\n    ],\n    'darkorchid': [\n        153,\n        50,\n        204,\n        1\n    ],\n    'darkred': [\n        139,\n        0,\n        0,\n        1\n    ],\n    'darksalmon': [\n        233,\n        150,\n        122,\n        1\n    ],\n    'darkseagreen': [\n        143,\n        188,\n        143,\n        1\n    ],\n    'darkslateblue': [\n        72,\n        61,\n        139,\n        1\n    ],\n    'darkslategray': [\n        47,\n        79,\n        79,\n        1\n    ],\n    'darkslategrey': [\n        47,\n        79,\n        79,\n        1\n    ],\n    'darkturquoise': [\n        0,\n        206,\n        209,\n        1\n    ],\n    'darkviolet': [\n        148,\n        0,\n        211,\n        1\n    ],\n    'deeppink': [\n        255,\n        20,\n        147,\n        1\n    ],\n    'deepskyblue': [\n        0,\n        191,\n        255,\n        1\n    ],\n    'dimgray': [\n        105,\n        105,\n        105,\n        1\n    ],\n    'dimgrey': [\n        105,\n        105,\n        105,\n        1\n    ],\n    'dodgerblue': [\n        30,\n        144,\n        255,\n        1\n    ],\n    'firebrick': [\n        178,\n        34,\n        34,\n        1\n    ],\n    'floralwhite': [\n        255,\n        250,\n        240,\n        1\n    ],\n    'forestgreen': [\n        34,\n        139,\n        34,\n        1\n    ],\n    'fuchsia': [\n        255,\n        0,\n        255,\n        1\n    ],\n    'gainsboro': [\n        220,\n        220,\n        220,\n        1\n    ],\n    'ghostwhite': [\n        248,\n        248,\n        255,\n        1\n    ],\n    'gold': [\n        255,\n        215,\n        0,\n        1\n    ],\n    'goldenrod': [\n        218,\n        165,\n        32,\n        1\n    ],\n    'gray': [\n        128,\n        128,\n        128,\n        1\n    ],\n    'green': [\n        0,\n        128,\n        0,\n        1\n    ],\n    'greenyellow': [\n        173,\n        255,\n        47,\n        1\n    ],\n    'grey': [\n        128,\n        128,\n        128,\n        1\n    ],\n    'honeydew': [\n        240,\n        255,\n        240,\n        1\n    ],\n    'hotpink': [\n        255,\n        105,\n        180,\n        1\n    ],\n    'indianred': [\n        205,\n        92,\n        92,\n        1\n    ],\n    'indigo': [\n        75,\n        0,\n        130,\n        1\n    ],\n    'ivory': [\n        255,\n        255,\n        240,\n        1\n    ],\n    'khaki': [\n        240,\n        230,\n        140,\n        1\n    ],\n    'lavender': [\n        230,\n        230,\n        250,\n        1\n    ],\n    'lavenderblush': [\n        255,\n        240,\n        245,\n        1\n    ],\n    'lawngreen': [\n        124,\n        252,\n        0,\n        1\n    ],\n    'lemonchiffon': [\n        255,\n        250,\n        205,\n        1\n    ],\n    'lightblue': [\n        173,\n        216,\n        230,\n        1\n    ],\n    'lightcoral': [\n        240,\n        128,\n        128,\n        1\n    ],\n    'lightcyan': [\n        224,\n        255,\n        255,\n        1\n    ],\n    'lightgoldenrodyellow': [\n        250,\n        250,\n        210,\n        1\n    ],\n    'lightgray': [\n        211,\n        211,\n        211,\n        1\n    ],\n    'lightgreen': [\n        144,\n        238,\n        144,\n        1\n    ],\n    'lightgrey': [\n        211,\n        211,\n        211,\n        1\n    ],\n    'lightpink': [\n        255,\n        182,\n        193,\n        1\n    ],\n    'lightsalmon': [\n        255,\n        160,\n        122,\n        1\n    ],\n    'lightseagreen': [\n        32,\n        178,\n        170,\n        1\n    ],\n    'lightskyblue': [\n        135,\n        206,\n        250,\n        1\n    ],\n    'lightslategray': [\n        119,\n        136,\n        153,\n        1\n    ],\n    'lightslategrey': [\n        119,\n        136,\n        153,\n        1\n    ],\n    'lightsteelblue': [\n        176,\n        196,\n        222,\n        1\n    ],\n    'lightyellow': [\n        255,\n        255,\n        224,\n        1\n    ],\n    'lime': [\n        0,\n        255,\n        0,\n        1\n    ],\n    'limegreen': [\n        50,\n        205,\n        50,\n        1\n    ],\n    'linen': [\n        250,\n        240,\n        230,\n        1\n    ],\n    'magenta': [\n        255,\n        0,\n        255,\n        1\n    ],\n    'maroon': [\n        128,\n        0,\n        0,\n        1\n    ],\n    'mediumaquamarine': [\n        102,\n        205,\n        170,\n        1\n    ],\n    'mediumblue': [\n        0,\n        0,\n        205,\n        1\n    ],\n    'mediumorchid': [\n        186,\n        85,\n        211,\n        1\n    ],\n    'mediumpurple': [\n        147,\n        112,\n        219,\n        1\n    ],\n    'mediumseagreen': [\n        60,\n        179,\n        113,\n        1\n    ],\n    'mediumslateblue': [\n        123,\n        104,\n        238,\n        1\n    ],\n    'mediumspringgreen': [\n        0,\n        250,\n        154,\n        1\n    ],\n    'mediumturquoise': [\n        72,\n        209,\n        204,\n        1\n    ],\n    'mediumvioletred': [\n        199,\n        21,\n        133,\n        1\n    ],\n    'midnightblue': [\n        25,\n        25,\n        112,\n        1\n    ],\n    'mintcream': [\n        245,\n        255,\n        250,\n        1\n    ],\n    'mistyrose': [\n        255,\n        228,\n        225,\n        1\n    ],\n    'moccasin': [\n        255,\n        228,\n        181,\n        1\n    ],\n    'navajowhite': [\n        255,\n        222,\n        173,\n        1\n    ],\n    'navy': [\n        0,\n        0,\n        128,\n        1\n    ],\n    'oldlace': [\n        253,\n        245,\n        230,\n        1\n    ],\n    'olive': [\n        128,\n        128,\n        0,\n        1\n    ],\n    'olivedrab': [\n        107,\n        142,\n        35,\n        1\n    ],\n    'orange': [\n        255,\n        165,\n        0,\n        1\n    ],\n    'orangered': [\n        255,\n        69,\n        0,\n        1\n    ],\n    'orchid': [\n        218,\n        112,\n        214,\n        1\n    ],\n    'palegoldenrod': [\n        238,\n        232,\n        170,\n        1\n    ],\n    'palegreen': [\n        152,\n        251,\n        152,\n        1\n    ],\n    'paleturquoise': [\n        175,\n        238,\n        238,\n        1\n    ],\n    'palevioletred': [\n        219,\n        112,\n        147,\n        1\n    ],\n    'papayawhip': [\n        255,\n        239,\n        213,\n        1\n    ],\n    'peachpuff': [\n        255,\n        218,\n        185,\n        1\n    ],\n    'peru': [\n        205,\n        133,\n        63,\n        1\n    ],\n    'pink': [\n        255,\n        192,\n        203,\n        1\n    ],\n    'plum': [\n        221,\n        160,\n        221,\n        1\n    ],\n    'powderblue': [\n        176,\n        224,\n        230,\n        1\n    ],\n    'purple': [\n        128,\n        0,\n        128,\n        1\n    ],\n    'rebeccapurple': [\n        102,\n        51,\n        153,\n        1\n    ],\n    'red': [\n        255,\n        0,\n        0,\n        1\n    ],\n    'rosybrown': [\n        188,\n        143,\n        143,\n        1\n    ],\n    'royalblue': [\n        65,\n        105,\n        225,\n        1\n    ],\n    'saddlebrown': [\n        139,\n        69,\n        19,\n        1\n    ],\n    'salmon': [\n        250,\n        128,\n        114,\n        1\n    ],\n    'sandybrown': [\n        244,\n        164,\n        96,\n        1\n    ],\n    'seagreen': [\n        46,\n        139,\n        87,\n        1\n    ],\n    'seashell': [\n        255,\n        245,\n        238,\n        1\n    ],\n    'sienna': [\n        160,\n        82,\n        45,\n        1\n    ],\n    'silver': [\n        192,\n        192,\n        192,\n        1\n    ],\n    'skyblue': [\n        135,\n        206,\n        235,\n        1\n    ],\n    'slateblue': [\n        106,\n        90,\n        205,\n        1\n    ],\n    'slategray': [\n        112,\n        128,\n        144,\n        1\n    ],\n    'slategrey': [\n        112,\n        128,\n        144,\n        1\n    ],\n    'snow': [\n        255,\n        250,\n        250,\n        1\n    ],\n    'springgreen': [\n        0,\n        255,\n        127,\n        1\n    ],\n    'steelblue': [\n        70,\n        130,\n        180,\n        1\n    ],\n    'tan': [\n        210,\n        180,\n        140,\n        1\n    ],\n    'teal': [\n        0,\n        128,\n        128,\n        1\n    ],\n    'thistle': [\n        216,\n        191,\n        216,\n        1\n    ],\n    'tomato': [\n        255,\n        99,\n        71,\n        1\n    ],\n    'turquoise': [\n        64,\n        224,\n        208,\n        1\n    ],\n    'violet': [\n        238,\n        130,\n        238,\n        1\n    ],\n    'wheat': [\n        245,\n        222,\n        179,\n        1\n    ],\n    'white': [\n        255,\n        255,\n        255,\n        1\n    ],\n    'whitesmoke': [\n        245,\n        245,\n        245,\n        1\n    ],\n    'yellow': [\n        255,\n        255,\n        0,\n        1\n    ],\n    'yellowgreen': [\n        154,\n        205,\n        50,\n        1\n    ]\n};\nfunction clamp_css_byte(i) {\n    i = Math.round(i);\n    return i < 0 ? 0 : i > 255 ? 255 : i;\n}\nfunction clamp_css_float(f) {\n    return f < 0 ? 0 : f > 1 ? 1 : f;\n}\nfunction parse_css_int(str) {\n    if (str[str.length - 1] === '%') {\n        return clamp_css_byte(parseFloat(str) / 100 * 255);\n    }\n    return clamp_css_byte(parseInt(str));\n}\nfunction parse_css_float(str) {\n    if (str[str.length - 1] === '%') {\n        return clamp_css_float(parseFloat(str) / 100);\n    }\n    return clamp_css_float(parseFloat(str));\n}\nfunction css_hue_to_rgb(m1, m2, h) {\n    if (h < 0) {\n        h += 1;\n    } else if (h > 1) {\n        h -= 1;\n    }\n    if (h * 6 < 1) {\n        return m1 + (m2 - m1) * h * 6;\n    }\n    if (h * 2 < 1) {\n        return m2;\n    }\n    if (h * 3 < 2) {\n        return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n    }\n    return m1;\n}\nfunction parseCSSColor(css_str) {\n    var str = css_str.replace(/ /g, '').toLowerCase();\n    if (str in kCSSColorTable) {\n        return kCSSColorTable[str].slice();\n    }\n    if (str[0] === '#') {\n        if (str.length === 4) {\n            var iv = parseInt(str.substr(1), 16);\n            if (!(iv >= 0 && iv <= 4095)) {\n                return null;\n            }\n            return [\n                (iv & 3840) >> 4 | (iv & 3840) >> 8,\n                iv & 240 | (iv & 240) >> 4,\n                iv & 15 | (iv & 15) << 4,\n                1\n            ];\n        } else if (str.length === 7) {\n            var iv = parseInt(str.substr(1), 16);\n            if (!(iv >= 0 && iv <= 16777215)) {\n                return null;\n            }\n            return [\n                (iv & 16711680) >> 16,\n                (iv & 65280) >> 8,\n                iv & 255,\n                1\n            ];\n        }\n        return null;\n    }\n    var op = str.indexOf('('), ep = str.indexOf(')');\n    if (op !== -1 && ep + 1 === str.length) {\n        var fname = str.substr(0, op);\n        var params = str.substr(op + 1, ep - (op + 1)).split(',');\n        var alpha = 1;\n        switch (fname) {\n        case 'rgba':\n            if (params.length !== 4) {\n                return null;\n            }\n            alpha = parse_css_float(params.pop());\n        case 'rgb':\n            if (params.length !== 3) {\n                return null;\n            }\n            return [\n                parse_css_int(params[0]),\n                parse_css_int(params[1]),\n                parse_css_int(params[2]),\n                alpha\n            ];\n        case 'hsla':\n            if (params.length !== 4) {\n                return null;\n            }\n            alpha = parse_css_float(params.pop());\n        case 'hsl':\n            if (params.length !== 3) {\n                return null;\n            }\n            var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360;\n            var s = parse_css_float(params[1]);\n            var l = parse_css_float(params[2]);\n            var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n            var m1 = l * 2 - m2;\n            return [\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),\n                alpha\n            ];\n        default:\n            return null;\n        }\n    }\n    return null;\n}\ntry {\n    exports.parseCSSColor = parseCSSColor;\n} catch (e) {\n}\n});\nvar csscolorparser_1 = csscolorparser.parseCSSColor;\n\nvar Color = function Color(r, g, b, a) {\n    if (a === void 0)\n        a = 1;\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n};\nColor.parse = function parse(input) {\n    if (!input) {\n        return undefined;\n    }\n    if (input instanceof Color) {\n        return input;\n    }\n    if (typeof input !== 'string') {\n        return undefined;\n    }\n    var rgba = csscolorparser_1(input);\n    if (!rgba) {\n        return undefined;\n    }\n    return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);\n};\nColor.prototype.toString = function toString() {\n    var ref = this.toArray();\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var a = ref[3];\n    return 'rgba(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(b) + ',' + a + ')';\n};\nColor.prototype.toArray = function toArray() {\n    var ref = this;\n    var r = ref.r;\n    var g = ref.g;\n    var b = ref.b;\n    var a = ref.a;\n    return a === 0 ? [\n        0,\n        0,\n        0,\n        0\n    ] : [\n        r * 255 / a,\n        g * 255 / a,\n        b * 255 / a,\n        a\n    ];\n};\nColor.black = new Color(0, 0, 0, 1);\nColor.white = new Color(1, 1, 1, 1);\nColor.transparent = new Color(0, 0, 0, 0);\nColor.red = new Color(1, 0, 0, 1);\n\nvar Collator = function Collator(caseSensitive, diacriticSensitive, locale) {\n    if (caseSensitive) {\n        this.sensitivity = diacriticSensitive ? 'variant' : 'case';\n    } else {\n        this.sensitivity = diacriticSensitive ? 'accent' : 'base';\n    }\n    this.locale = locale;\n    this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n        sensitivity: this.sensitivity,\n        usage: 'search'\n    });\n};\nCollator.prototype.compare = function compare(lhs, rhs) {\n    return this.collator.compare(lhs, rhs);\n};\nCollator.prototype.resolvedLocale = function resolvedLocale() {\n    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n};\n\nvar FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {\n    this.text = text;\n    this.image = image;\n    this.scale = scale;\n    this.fontStack = fontStack;\n    this.textColor = textColor;\n};\nvar Formatted = function Formatted(sections) {\n    this.sections = sections;\n};\nFormatted.fromString = function fromString(unformatted) {\n    return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);\n};\nFormatted.prototype.isEmpty = function isEmpty() {\n    if (this.sections.length === 0) {\n        return true;\n    }\n    return !this.sections.some(function (section) {\n        return section.text.length !== 0 || section.image && section.image.name.length !== 0;\n    });\n};\nFormatted.factory = function factory(text) {\n    if (text instanceof Formatted) {\n        return text;\n    } else {\n        return Formatted.fromString(text);\n    }\n};\nFormatted.prototype.toString = function toString() {\n    if (this.sections.length === 0) {\n        return '';\n    }\n    return this.sections.map(function (section) {\n        return section.text;\n    }).join('');\n};\nFormatted.prototype.serialize = function serialize() {\n    var serialized = ['format'];\n    for (var i = 0, list = this.sections; i < list.length; i += 1) {\n        var section = list[i];\n        if (section.image) {\n            serialized.push([\n                'image',\n                section.image.name\n            ]);\n            continue;\n        }\n        serialized.push(section.text);\n        var options = {};\n        if (section.fontStack) {\n            options['text-font'] = [\n                'literal',\n                section.fontStack.split(',')\n            ];\n        }\n        if (section.scale) {\n            options['font-scale'] = section.scale;\n        }\n        if (section.textColor) {\n            options['text-color'] = ['rgba'].concat(section.textColor.toArray());\n        }\n        serialized.push(options);\n    }\n    return serialized;\n};\n\nvar ResolvedImage = function ResolvedImage(options) {\n    this.name = options.name;\n    this.available = options.available;\n};\nResolvedImage.prototype.toString = function toString() {\n    return this.name;\n};\nResolvedImage.fromString = function fromString(name) {\n    return new ResolvedImage({\n        name: name,\n        available: false\n    });\n};\nResolvedImage.prototype.serialize = function serialize() {\n    return [\n        'image',\n        this.name\n    ];\n};\n\nfunction validateRGBA(r, g, b, a) {\n    if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {\n        var value = typeof a === 'number' ? [\n            r,\n            g,\n            b,\n            a\n        ] : [\n            r,\n            g,\n            b\n        ];\n        return 'Invalid rgba value [' + value.join(', ') + ']: \\'r\\', \\'g\\', and \\'b\\' must be between 0 and 255.';\n    }\n    if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {\n        return 'Invalid rgba value [' + [\n            r,\n            g,\n            b,\n            a\n        ].join(', ') + ']: \\'a\\' must be between 0 and 1.';\n    }\n    return null;\n}\nfunction isValue(mixed) {\n    if (mixed === null) {\n        return true;\n    } else if (typeof mixed === 'string') {\n        return true;\n    } else if (typeof mixed === 'boolean') {\n        return true;\n    } else if (typeof mixed === 'number') {\n        return true;\n    } else if (mixed instanceof Color) {\n        return true;\n    } else if (mixed instanceof Collator) {\n        return true;\n    } else if (mixed instanceof Formatted) {\n        return true;\n    } else if (mixed instanceof ResolvedImage) {\n        return true;\n    } else if (Array.isArray(mixed)) {\n        for (var i = 0, list = mixed; i < list.length; i += 1) {\n            var item = list[i];\n            if (!isValue(item)) {\n                return false;\n            }\n        }\n        return true;\n    } else if (typeof mixed === 'object') {\n        for (var key in mixed) {\n            if (!isValue(mixed[key])) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction typeOf(value) {\n    if (value === null) {\n        return NullType;\n    } else if (typeof value === 'string') {\n        return StringType;\n    } else if (typeof value === 'boolean') {\n        return BooleanType;\n    } else if (typeof value === 'number') {\n        return NumberType;\n    } else if (value instanceof Color) {\n        return ColorType;\n    } else if (value instanceof Collator) {\n        return CollatorType;\n    } else if (value instanceof Formatted) {\n        return FormattedType;\n    } else if (value instanceof ResolvedImage) {\n        return ResolvedImageType;\n    } else if (Array.isArray(value)) {\n        var length = value.length;\n        var itemType;\n        for (var i = 0, list = value; i < list.length; i += 1) {\n            var item = list[i];\n            var t = typeOf(item);\n            if (!itemType) {\n                itemType = t;\n            } else if (itemType === t) {\n                continue;\n            } else {\n                itemType = ValueType;\n                break;\n            }\n        }\n        return array(itemType || ValueType, length);\n    } else {\n        return ObjectType;\n    }\n}\nfunction toString$1(value) {\n    var type = typeof value;\n    if (value === null) {\n        return '';\n    } else if (type === 'string' || type === 'number' || type === 'boolean') {\n        return String(value);\n    } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {\n        return value.toString();\n    } else {\n        return JSON.stringify(value);\n    }\n}\n\nvar Literal = function Literal(type, value) {\n    this.type = type;\n    this.value = value;\n};\nLiteral.parse = function parse(args, context) {\n    if (args.length !== 2) {\n        return context.error('\\'literal\\' expression requires exactly one argument, but found ' + (args.length - 1) + ' instead.');\n    }\n    if (!isValue(args[1])) {\n        return context.error('invalid value');\n    }\n    var value = args[1];\n    var type = typeOf(value);\n    var expected = context.expectedType;\n    if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {\n        type = expected;\n    }\n    return new Literal(type, value);\n};\nLiteral.prototype.evaluate = function evaluate() {\n    return this.value;\n};\nLiteral.prototype.eachChild = function eachChild() {\n};\nLiteral.prototype.possibleOutputs = function possibleOutputs() {\n    return [this.value];\n};\nLiteral.prototype.serialize = function serialize() {\n    if (this.type.kind === 'array' || this.type.kind === 'object') {\n        return [\n            'literal',\n            this.value\n        ];\n    } else if (this.value instanceof Color) {\n        return ['rgba'].concat(this.value.toArray());\n    } else if (this.value instanceof Formatted) {\n        return this.value.serialize();\n    } else {\n        return this.value;\n    }\n};\n\nvar RuntimeError = function RuntimeError(message) {\n    this.name = 'ExpressionEvaluationError';\n    this.message = message;\n};\nRuntimeError.prototype.toJSON = function toJSON() {\n    return this.message;\n};\n\nvar types = {\n    string: StringType,\n    number: NumberType,\n    boolean: BooleanType,\n    object: ObjectType\n};\nvar Assertion = function Assertion(type, args) {\n    this.type = type;\n    this.args = args;\n};\nAssertion.parse = function parse(args, context) {\n    if (args.length < 2) {\n        return context.error('Expected at least one argument.');\n    }\n    var i = 1;\n    var type;\n    var name = args[0];\n    if (name === 'array') {\n        var itemType;\n        if (args.length > 2) {\n            var type$1 = args[1];\n            if (typeof type$1 !== 'string' || !(type$1 in types) || type$1 === 'object') {\n                return context.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n            }\n            itemType = types[type$1];\n            i++;\n        } else {\n            itemType = ValueType;\n        }\n        var N;\n        if (args.length > 3) {\n            if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {\n                return context.error('The length argument to \"array\" must be a positive integer literal', 2);\n            }\n            N = args[2];\n            i++;\n        }\n        type = array(itemType, N);\n    } else {\n        type = types[name];\n    }\n    var parsed = [];\n    for (; i < args.length; i++) {\n        var input = context.parse(args[i], i, ValueType);\n        if (!input) {\n            return null;\n        }\n        parsed.push(input);\n    }\n    return new Assertion(type, parsed);\n};\nAssertion.prototype.evaluate = function evaluate(ctx) {\n    for (var i = 0; i < this.args.length; i++) {\n        var value = this.args[i].evaluate(ctx);\n        var error = checkSubtype(this.type, typeOf(value));\n        if (!error) {\n            return value;\n        } else if (i === this.args.length - 1) {\n            throw new RuntimeError('Expected value to be of type ' + toString(this.type) + ', but found ' + toString(typeOf(value)) + ' instead.');\n        }\n    }\n    return null;\n};\nAssertion.prototype.eachChild = function eachChild(fn) {\n    this.args.forEach(fn);\n};\nAssertion.prototype.possibleOutputs = function possibleOutputs() {\n    var ref;\n    return (ref = []).concat.apply(ref, this.args.map(function (arg) {\n        return arg.possibleOutputs();\n    }));\n};\nAssertion.prototype.serialize = function serialize() {\n    var type = this.type;\n    var serialized = [type.kind];\n    if (type.kind === 'array') {\n        var itemType = type.itemType;\n        if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {\n            serialized.push(itemType.kind);\n            var N = type.N;\n            if (typeof N === 'number' || this.args.length > 1) {\n                serialized.push(N);\n            }\n        }\n    }\n    return serialized.concat(this.args.map(function (arg) {\n        return arg.serialize();\n    }));\n};\n\nvar FormatExpression = function FormatExpression(sections) {\n    this.type = FormattedType;\n    this.sections = sections;\n};\nFormatExpression.parse = function parse(args, context) {\n    if (args.length < 2) {\n        return context.error('Expected at least one argument.');\n    }\n    var firstArg = args[1];\n    if (!Array.isArray(firstArg) && typeof firstArg === 'object') {\n        return context.error('First argument must be an image or text section.');\n    }\n    var sections = [];\n    var nextTokenMayBeObject = false;\n    for (var i = 1; i <= args.length - 1; ++i) {\n        var arg = args[i];\n        if (nextTokenMayBeObject && typeof arg === 'object' && !Array.isArray(arg)) {\n            nextTokenMayBeObject = false;\n            var scale = null;\n            if (arg['font-scale']) {\n                scale = context.parse(arg['font-scale'], 1, NumberType);\n                if (!scale) {\n                    return null;\n                }\n            }\n            var font = null;\n            if (arg['text-font']) {\n                font = context.parse(arg['text-font'], 1, array(StringType));\n                if (!font) {\n                    return null;\n                }\n            }\n            var textColor = null;\n            if (arg['text-color']) {\n                textColor = context.parse(arg['text-color'], 1, ColorType);\n                if (!textColor) {\n                    return null;\n                }\n            }\n            var lastExpression = sections[sections.length - 1];\n            lastExpression.scale = scale;\n            lastExpression.font = font;\n            lastExpression.textColor = textColor;\n        } else {\n            var content = context.parse(args[i], 1, ValueType);\n            if (!content) {\n                return null;\n            }\n            var kind = content.type.kind;\n            if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') {\n                return context.error('Formatted text type must be \\'string\\', \\'value\\', \\'image\\' or \\'null\\'.');\n            }\n            nextTokenMayBeObject = true;\n            sections.push({\n                content: content,\n                scale: null,\n                font: null,\n                textColor: null\n            });\n        }\n    }\n    return new FormatExpression(sections);\n};\nFormatExpression.prototype.evaluate = function evaluate(ctx) {\n    var evaluateSection = function (section) {\n        var evaluatedContent = section.content.evaluate(ctx);\n        if (typeOf(evaluatedContent) === ResolvedImageType) {\n            return new FormattedSection('', evaluatedContent, null, null, null);\n        }\n        return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);\n    };\n    return new Formatted(this.sections.map(evaluateSection));\n};\nFormatExpression.prototype.eachChild = function eachChild(fn) {\n    for (var i = 0, list = this.sections; i < list.length; i += 1) {\n        var section = list[i];\n        fn(section.content);\n        if (section.scale) {\n            fn(section.scale);\n        }\n        if (section.font) {\n            fn(section.font);\n        }\n        if (section.textColor) {\n            fn(section.textColor);\n        }\n    }\n};\nFormatExpression.prototype.possibleOutputs = function possibleOutputs() {\n    return [undefined];\n};\nFormatExpression.prototype.serialize = function serialize() {\n    var serialized = ['format'];\n    for (var i = 0, list = this.sections; i < list.length; i += 1) {\n        var section = list[i];\n        serialized.push(section.content.serialize());\n        var options = {};\n        if (section.scale) {\n            options['font-scale'] = section.scale.serialize();\n        }\n        if (section.font) {\n            options['text-font'] = section.font.serialize();\n        }\n        if (section.textColor) {\n            options['text-color'] = section.textColor.serialize();\n        }\n        serialized.push(options);\n    }\n    return serialized;\n};\n\nvar ImageExpression = function ImageExpression(input) {\n    this.type = ResolvedImageType;\n    this.input = input;\n};\nImageExpression.parse = function parse(args, context) {\n    if (args.length !== 2) {\n        return context.error('Expected two arguments.');\n    }\n    var name = context.parse(args[1], 1, StringType);\n    if (!name) {\n        return context.error('No image name provided.');\n    }\n    return new ImageExpression(name);\n};\nImageExpression.prototype.evaluate = function evaluate(ctx) {\n    var evaluatedImageName = this.input.evaluate(ctx);\n    var available = false;\n    if (ctx.availableImages && ctx.availableImages.indexOf(evaluatedImageName) > -1) {\n        available = true;\n    }\n    return new ResolvedImage({\n        name: evaluatedImageName,\n        available: available\n    });\n};\nImageExpression.prototype.eachChild = function eachChild(fn) {\n    fn(this.input);\n};\nImageExpression.prototype.possibleOutputs = function possibleOutputs() {\n    return [undefined];\n};\nImageExpression.prototype.serialize = function serialize() {\n    return [\n        'image',\n        this.input.serialize()\n    ];\n};\n\nvar types$1 = {\n    'to-boolean': BooleanType,\n    'to-color': ColorType,\n    'to-number': NumberType,\n    'to-string': StringType\n};\nvar Coercion = function Coercion(type, args) {\n    this.type = type;\n    this.args = args;\n};\nCoercion.parse = function parse(args, context) {\n    if (args.length < 2) {\n        return context.error('Expected at least one argument.');\n    }\n    var name = args[0];\n    if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) {\n        return context.error('Expected one argument.');\n    }\n    var type = types$1[name];\n    var parsed = [];\n    for (var i = 1; i < args.length; i++) {\n        var input = context.parse(args[i], i, ValueType);\n        if (!input) {\n            return null;\n        }\n        parsed.push(input);\n    }\n    return new Coercion(type, parsed);\n};\nCoercion.prototype.evaluate = function evaluate(ctx) {\n    if (this.type.kind === 'boolean') {\n        return Boolean(this.args[0].evaluate(ctx));\n    } else if (this.type.kind === 'color') {\n        var input;\n        var error;\n        for (var i = 0, list = this.args; i < list.length; i += 1) {\n            var arg = list[i];\n            input = arg.evaluate(ctx);\n            error = null;\n            if (input instanceof Color) {\n                return input;\n            } else if (typeof input === 'string') {\n                var c = ctx.parseColor(input);\n                if (c) {\n                    return c;\n                }\n            } else if (Array.isArray(input)) {\n                if (input.length < 3 || input.length > 4) {\n                    error = 'Invalid rbga value ' + JSON.stringify(input) + ': expected an array containing either three or four numeric values.';\n                } else {\n                    error = validateRGBA(input[0], input[1], input[2], input[3]);\n                }\n                if (!error) {\n                    return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);\n                }\n            }\n        }\n        throw new RuntimeError(error || 'Could not parse color from value \\'' + (typeof input === 'string' ? input : String(JSON.stringify(input))) + '\\'');\n    } else if (this.type.kind === 'number') {\n        var value = null;\n        for (var i$1 = 0, list$1 = this.args; i$1 < list$1.length; i$1 += 1) {\n            var arg$1 = list$1[i$1];\n            value = arg$1.evaluate(ctx);\n            if (value === null) {\n                return 0;\n            }\n            var num = Number(value);\n            if (isNaN(num)) {\n                continue;\n            }\n            return num;\n        }\n        throw new RuntimeError('Could not convert ' + JSON.stringify(value) + ' to number.');\n    } else if (this.type.kind === 'formatted') {\n        return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));\n    } else if (this.type.kind === 'resolvedImage') {\n        return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));\n    } else {\n        return toString$1(this.args[0].evaluate(ctx));\n    }\n};\nCoercion.prototype.eachChild = function eachChild(fn) {\n    this.args.forEach(fn);\n};\nCoercion.prototype.possibleOutputs = function possibleOutputs() {\n    var ref;\n    return (ref = []).concat.apply(ref, this.args.map(function (arg) {\n        return arg.possibleOutputs();\n    }));\n};\nCoercion.prototype.serialize = function serialize() {\n    if (this.type.kind === 'formatted') {\n        return new FormatExpression([{\n                content: this.args[0],\n                scale: null,\n                font: null,\n                textColor: null\n            }]).serialize();\n    }\n    if (this.type.kind === 'resolvedImage') {\n        return new ImageExpression(this.args[0]).serialize();\n    }\n    var serialized = ['to-' + this.type.kind];\n    this.eachChild(function (child) {\n        serialized.push(child.serialize());\n    });\n    return serialized;\n};\n\nvar geometryTypes = [\n    'Unknown',\n    'Point',\n    'LineString',\n    'Polygon'\n];\nvar EvaluationContext = function EvaluationContext() {\n    this.globals = null;\n    this.feature = null;\n    this.featureState = null;\n    this.formattedSection = null;\n    this._parseColorCache = {};\n    this.availableImages = null;\n};\nEvaluationContext.prototype.id = function id() {\n    return this.feature && 'id' in this.feature ? this.feature.id : null;\n};\nEvaluationContext.prototype.geometryType = function geometryType() {\n    return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;\n};\nEvaluationContext.prototype.properties = function properties() {\n    return this.feature && this.feature.properties || {};\n};\nEvaluationContext.prototype.parseColor = function parseColor(input) {\n    var cached = this._parseColorCache[input];\n    if (!cached) {\n        cached = this._parseColorCache[input] = Color.parse(input);\n    }\n    return cached;\n};\n\nvar CompoundExpression = function CompoundExpression(name, type, evaluate, args) {\n    this.name = name;\n    this.type = type;\n    this._evaluate = evaluate;\n    this.args = args;\n};\nCompoundExpression.prototype.evaluate = function evaluate(ctx) {\n    return this._evaluate(ctx, this.args);\n};\nCompoundExpression.prototype.eachChild = function eachChild(fn) {\n    this.args.forEach(fn);\n};\nCompoundExpression.prototype.possibleOutputs = function possibleOutputs() {\n    return [undefined];\n};\nCompoundExpression.prototype.serialize = function serialize() {\n    return [this.name].concat(this.args.map(function (arg) {\n        return arg.serialize();\n    }));\n};\nCompoundExpression.parse = function parse(args, context) {\n    var ref$1;\n    var op = args[0];\n    var definition = CompoundExpression.definitions[op];\n    if (!definition) {\n        return context.error('Unknown expression \"' + op + '\". If you wanted a literal array, use [\"literal\", [...]].', 0);\n    }\n    var type = Array.isArray(definition) ? definition[0] : definition.type;\n    var availableOverloads = Array.isArray(definition) ? [[\n            definition[1],\n            definition[2]\n        ]] : definition.overloads;\n    var overloads = availableOverloads.filter(function (ref) {\n        var signature = ref[0];\n        return !Array.isArray(signature) || signature.length === args.length - 1;\n    });\n    var signatureContext = null;\n    for (var i$3 = 0, list = overloads; i$3 < list.length; i$3 += 1) {\n        var ref = list[i$3];\n        var params = ref[0];\n        var evaluate = ref[1];\n        signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);\n        var parsedArgs = [];\n        var argParseFailed = false;\n        for (var i = 1; i < args.length; i++) {\n            var arg = args[i];\n            var expectedType = Array.isArray(params) ? params[i - 1] : params.type;\n            var parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);\n            if (!parsed) {\n                argParseFailed = true;\n                break;\n            }\n            parsedArgs.push(parsed);\n        }\n        if (argParseFailed) {\n            continue;\n        }\n        if (Array.isArray(params)) {\n            if (params.length !== parsedArgs.length) {\n                signatureContext.error('Expected ' + params.length + ' arguments, but found ' + parsedArgs.length + ' instead.');\n                continue;\n            }\n        }\n        for (var i$1 = 0; i$1 < parsedArgs.length; i$1++) {\n            var expected = Array.isArray(params) ? params[i$1] : params.type;\n            var arg$1 = parsedArgs[i$1];\n            signatureContext.concat(i$1 + 1).checkSubtype(expected, arg$1.type);\n        }\n        if (signatureContext.errors.length === 0) {\n            return new CompoundExpression(op, type, evaluate, parsedArgs);\n        }\n    }\n    if (overloads.length === 1) {\n        (ref$1 = context.errors).push.apply(ref$1, signatureContext.errors);\n    } else {\n        var expected$1 = overloads.length ? overloads : availableOverloads;\n        var signatures = expected$1.map(function (ref) {\n            var params = ref[0];\n            return stringifySignature(params);\n        }).join(' | ');\n        var actualTypes = [];\n        for (var i$2 = 1; i$2 < args.length; i$2++) {\n            var parsed$1 = context.parse(args[i$2], 1 + actualTypes.length);\n            if (!parsed$1) {\n                return null;\n            }\n            actualTypes.push(toString(parsed$1.type));\n        }\n        context.error('Expected arguments of type ' + signatures + ', but found (' + actualTypes.join(', ') + ') instead.');\n    }\n    return null;\n};\nCompoundExpression.register = function register(registry, definitions) {\n    CompoundExpression.definitions = definitions;\n    for (var name in definitions) {\n        registry[name] = CompoundExpression;\n    }\n};\nfunction stringifySignature(signature) {\n    if (Array.isArray(signature)) {\n        return '(' + signature.map(toString).join(', ') + ')';\n    } else {\n        return '(' + toString(signature.type) + '...)';\n    }\n}\n\nvar CollatorExpression = function CollatorExpression(caseSensitive, diacriticSensitive, locale) {\n    this.type = CollatorType;\n    this.locale = locale;\n    this.caseSensitive = caseSensitive;\n    this.diacriticSensitive = diacriticSensitive;\n};\nCollatorExpression.parse = function parse(args, context) {\n    if (args.length !== 2) {\n        return context.error('Expected one argument.');\n    }\n    var options = args[1];\n    if (typeof options !== 'object' || Array.isArray(options)) {\n        return context.error('Collator options argument must be an object.');\n    }\n    var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);\n    if (!caseSensitive) {\n        return null;\n    }\n    var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);\n    if (!diacriticSensitive) {\n        return null;\n    }\n    var locale = null;\n    if (options['locale']) {\n        locale = context.parse(options['locale'], 1, StringType);\n        if (!locale) {\n            return null;\n        }\n    }\n    return new CollatorExpression(caseSensitive, diacriticSensitive, locale);\n};\nCollatorExpression.prototype.evaluate = function evaluate(ctx) {\n    return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);\n};\nCollatorExpression.prototype.eachChild = function eachChild(fn) {\n    fn(this.caseSensitive);\n    fn(this.diacriticSensitive);\n    if (this.locale) {\n        fn(this.locale);\n    }\n};\nCollatorExpression.prototype.possibleOutputs = function possibleOutputs() {\n    return [undefined];\n};\nCollatorExpression.prototype.serialize = function serialize() {\n    var options = {};\n    options['case-sensitive'] = this.caseSensitive.serialize();\n    options['diacritic-sensitive'] = this.diacriticSensitive.serialize();\n    if (this.locale) {\n        options['locale'] = this.locale.serialize();\n    }\n    return [\n        'collator',\n        options\n    ];\n};\n\nfunction isFeatureConstant(e) {\n    if (e instanceof CompoundExpression) {\n        if (e.name === 'get' && e.args.length === 1) {\n            return false;\n        } else if (e.name === 'feature-state') {\n            return false;\n        } else if (e.name === 'has' && e.args.length === 1) {\n            return false;\n        } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {\n            return false;\n        } else if (/^filter-/.test(e.name)) {\n            return false;\n        }\n    }\n    var result = true;\n    e.eachChild(function (arg) {\n        if (result && !isFeatureConstant(arg)) {\n            result = false;\n        }\n    });\n    return result;\n}\nfunction isStateConstant(e) {\n    if (e instanceof CompoundExpression) {\n        if (e.name === 'feature-state') {\n            return false;\n        }\n    }\n    var result = true;\n    e.eachChild(function (arg) {\n        if (result && !isStateConstant(arg)) {\n            result = false;\n        }\n    });\n    return result;\n}\nfunction isGlobalPropertyConstant(e, properties) {\n    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {\n        return false;\n    }\n    var result = true;\n    e.eachChild(function (arg) {\n        if (result && !isGlobalPropertyConstant(arg, properties)) {\n            result = false;\n        }\n    });\n    return result;\n}\n\nvar Var = function Var(name, boundExpression) {\n    this.type = boundExpression.type;\n    this.name = name;\n    this.boundExpression = boundExpression;\n};\nVar.parse = function parse(args, context) {\n    if (args.length !== 2 || typeof args[1] !== 'string') {\n        return context.error('\\'var\\' expression requires exactly one string literal argument.');\n    }\n    var name = args[1];\n    if (!context.scope.has(name)) {\n        return context.error('Unknown variable \"' + name + '\". Make sure \"' + name + '\" has been bound in an enclosing \"let\" expression before using it.', 1);\n    }\n    return new Var(name, context.scope.get(name));\n};\nVar.prototype.evaluate = function evaluate(ctx) {\n    return this.boundExpression.evaluate(ctx);\n};\nVar.prototype.eachChild = function eachChild() {\n};\nVar.prototype.possibleOutputs = function possibleOutputs() {\n    return [undefined];\n};\nVar.prototype.serialize = function serialize() {\n    return [\n        'var',\n        this.name\n    ];\n};\n\nvar ParsingContext = function ParsingContext(registry, path, expectedType, scope, errors) {\n    if (path === void 0)\n        path = [];\n    if (scope === void 0)\n        scope = new Scope();\n    if (errors === void 0)\n        errors = [];\n    this.registry = registry;\n    this.path = path;\n    this.key = path.map(function (part) {\n        return '[' + part + ']';\n    }).join('');\n    this.scope = scope;\n    this.errors = errors;\n    this.expectedType = expectedType;\n};\nParsingContext.prototype.parse = function parse(expr, index, expectedType, bindings, options) {\n    if (options === void 0)\n        options = {};\n    if (index) {\n        return this.concat(index, expectedType, bindings)._parse(expr, options);\n    }\n    return this._parse(expr, options);\n};\nParsingContext.prototype._parse = function _parse(expr, options) {\n    if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {\n        expr = [\n            'literal',\n            expr\n        ];\n    }\n    function annotate(parsed, type, typeAnnotation) {\n        if (typeAnnotation === 'assert') {\n            return new Assertion(type, [parsed]);\n        } else if (typeAnnotation === 'coerce') {\n            return new Coercion(type, [parsed]);\n        } else {\n            return parsed;\n        }\n    }\n    if (Array.isArray(expr)) {\n        if (expr.length === 0) {\n            return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n        }\n        var op = expr[0];\n        if (typeof op !== 'string') {\n            this.error('Expression name must be a string, but found ' + typeof op + ' instead. If you wanted a literal array, use [\"literal\", [...]].', 0);\n            return null;\n        }\n        var Expr = this.registry[op];\n        if (Expr) {\n            var parsed = Expr.parse(expr, this);\n            if (!parsed) {\n                return null;\n            }\n            if (this.expectedType) {\n                var expected = this.expectedType;\n                var actual = parsed.type;\n                if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {\n                    parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');\n                } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {\n                    parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');\n                } else if (this.checkSubtype(expected, actual)) {\n                    return null;\n                }\n            }\n            if (!(parsed instanceof Literal) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {\n                var ec = new EvaluationContext();\n                try {\n                    parsed = new Literal(parsed.type, parsed.evaluate(ec));\n                } catch (e) {\n                    this.error(e.message);\n                    return null;\n                }\n            }\n            return parsed;\n        }\n        return this.error('Unknown expression \"' + op + '\". If you wanted a literal array, use [\"literal\", [...]].', 0);\n    } else if (typeof expr === 'undefined') {\n        return this.error('\\'undefined\\' value invalid. Use null instead.');\n    } else if (typeof expr === 'object') {\n        return this.error('Bare objects invalid. Use [\"literal\", {...}] instead.');\n    } else {\n        return this.error('Expected an array, but found ' + typeof expr + ' instead.');\n    }\n};\nParsingContext.prototype.concat = function concat(index, expectedType, bindings) {\n    var path = typeof index === 'number' ? this.path.concat(index) : this.path;\n    var scope = bindings ? this.scope.concat(bindings) : this.scope;\n    return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);\n};\nParsingContext.prototype.error = function error(error$1) {\n    var keys = [], len = arguments.length - 1;\n    while (len-- > 0)\n        keys[len] = arguments[len + 1];\n    var key = '' + this.key + keys.map(function (k) {\n        return '[' + k + ']';\n    }).join('');\n    this.errors.push(new ParsingError(key, error$1));\n};\nParsingContext.prototype.checkSubtype = function checkSubtype$1(expected, t) {\n    var error = checkSubtype(expected, t);\n    if (error) {\n        this.error(error);\n    }\n    return error;\n};\nfunction isConstant(expression) {\n    if (expression instanceof Var) {\n        return isConstant(expression.boundExpression);\n    } else if (expression instanceof CompoundExpression && expression.name === 'error') {\n        return false;\n    } else if (expression instanceof CollatorExpression) {\n        return false;\n    }\n    var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;\n    var childrenConstant = true;\n    expression.eachChild(function (child) {\n        if (isTypeAnnotation) {\n            childrenConstant = childrenConstant && isConstant(child);\n        } else {\n            childrenConstant = childrenConstant && child instanceof Literal;\n        }\n    });\n    if (!childrenConstant) {\n        return false;\n    }\n    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, [\n        'zoom',\n        'heatmap-density',\n        'line-progress',\n        'accumulated',\n        'is-supported-script'\n    ]);\n}\n\nfunction findStopLessThanOrEqualTo(stops, input) {\n    var lastIndex = stops.length - 1;\n    var lowerIndex = 0;\n    var upperIndex = lastIndex;\n    var currentIndex = 0;\n    var currentValue, nextValue;\n    while (lowerIndex <= upperIndex) {\n        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);\n        currentValue = stops[currentIndex];\n        nextValue = stops[currentIndex + 1];\n        if (currentValue <= input) {\n            if (currentIndex === lastIndex || input < nextValue) {\n                return currentIndex;\n            }\n            lowerIndex = currentIndex + 1;\n        } else if (currentValue > input) {\n            upperIndex = currentIndex - 1;\n        } else {\n            throw new RuntimeError('Input is not a number.');\n        }\n    }\n    return 0;\n}\n\nvar Step = function Step(type, input, stops) {\n    this.type = type;\n    this.input = input;\n    this.labels = [];\n    this.outputs = [];\n    for (var i = 0, list = stops; i < list.length; i += 1) {\n        var ref = list[i];\n        var label = ref[0];\n        var expression = ref[1];\n        this.labels.push(label);\n        this.outputs.push(expression);\n    }\n};\nStep.parse = function parse(args, context) {\n    if (args.length - 1 < 4) {\n        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');\n    }\n    if ((args.length - 1) % 2 !== 0) {\n        return context.error('Expected an even number of arguments.');\n    }\n    var input = context.parse(args[1], 1, NumberType);\n    if (!input) {\n        return null;\n    }\n    var stops = [];\n    var outputType = null;\n    if (context.expectedType && context.expectedType.kind !== 'value') {\n        outputType = context.expectedType;\n    }\n    for (var i = 1; i < args.length; i += 2) {\n        var label = i === 1 ? -Infinity : args[i];\n        var value = args[i + 1];\n        var labelKey = i;\n        var valueKey = i + 1;\n        if (typeof label !== 'number') {\n            return context.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);\n        }\n        if (stops.length && stops[stops.length - 1][0] >= label) {\n            return context.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', labelKey);\n        }\n        var parsed = context.parse(value, valueKey, outputType);\n        if (!parsed) {\n            return null;\n        }\n        outputType = outputType || parsed.type;\n        stops.push([\n            label,\n            parsed\n        ]);\n    }\n    return new Step(outputType, input, stops);\n};\nStep.prototype.evaluate = function evaluate(ctx) {\n    var labels = this.labels;\n    var outputs = this.outputs;\n    if (labels.length === 1) {\n        return outputs[0].evaluate(ctx);\n    }\n    var value = this.input.evaluate(ctx);\n    if (value <= labels[0]) {\n        return outputs[0].evaluate(ctx);\n    }\n    var stopCount = labels.length;\n    if (value >= labels[stopCount - 1]) {\n        return outputs[stopCount - 1].evaluate(ctx);\n    }\n    var index = findStopLessThanOrEqualTo(labels, value);\n    return outputs[index].evaluate(ctx);\n};\nStep.prototype.eachChild = function eachChild(fn) {\n    fn(this.input);\n    for (var i = 0, list = this.outputs; i < list.length; i += 1) {\n        var expression = list[i];\n        fn(expression);\n    }\n};\nStep.prototype.possibleOutputs = function possibleOutputs() {\n    var ref;\n    return (ref = []).concat.apply(ref, this.outputs.map(function (output) {\n        return output.possibleOutputs();\n    }));\n};\nStep.prototype.serialize = function serialize() {\n    var serialized = [\n        'step',\n        this.input.serialize()\n    ];\n    for (var i = 0; i < this.labels.length; i++) {\n        if (i > 0) {\n            serialized.push(this.labels[i]);\n        }\n        serialized.push(this.outputs[i].serialize());\n    }\n    return serialized;\n};\n\nvar unitbezier = UnitBezier;\nfunction UnitBezier(p1x, p1y, p2x, p2y) {\n    this.cx = 3 * p1x;\n    this.bx = 3 * (p2x - p1x) - this.cx;\n    this.ax = 1 - this.cx - this.bx;\n    this.cy = 3 * p1y;\n    this.by = 3 * (p2y - p1y) - this.cy;\n    this.ay = 1 - this.cy - this.by;\n    this.p1x = p1x;\n    this.p1y = p2y;\n    this.p2x = p2x;\n    this.p2y = p2y;\n}\nUnitBezier.prototype.sampleCurveX = function (t) {\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n};\nUnitBezier.prototype.sampleCurveY = function (t) {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n};\nUnitBezier.prototype.sampleCurveDerivativeX = function (t) {\n    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n};\nUnitBezier.prototype.solveCurveX = function (x, epsilon) {\n    if (typeof epsilon === 'undefined') {\n        epsilon = 0.000001;\n    }\n    var t0, t1, t2, x2, i;\n    for (t2 = x, i = 0; i < 8; i++) {\n        x2 = this.sampleCurveX(t2) - x;\n        if (Math.abs(x2) < epsilon) {\n            return t2;\n        }\n        var d2 = this.sampleCurveDerivativeX(t2);\n        if (Math.abs(d2) < 0.000001) {\n            break;\n        }\n        t2 = t2 - x2 / d2;\n    }\n    t0 = 0;\n    t1 = 1;\n    t2 = x;\n    if (t2 < t0) {\n        return t0;\n    }\n    if (t2 > t1) {\n        return t1;\n    }\n    while (t0 < t1) {\n        x2 = this.sampleCurveX(t2);\n        if (Math.abs(x2 - x) < epsilon) {\n            return t2;\n        }\n        if (x > x2) {\n            t0 = t2;\n        } else {\n            t1 = t2;\n        }\n        t2 = (t1 - t0) * 0.5 + t0;\n    }\n    return t2;\n};\nUnitBezier.prototype.solve = function (x, epsilon) {\n    return this.sampleCurveY(this.solveCurveX(x, epsilon));\n};\n\nfunction number(a, b, t) {\n    return a * (1 - t) + b * t;\n}\nfunction color(from, to, t) {\n    return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));\n}\nfunction array$1(from, to, t) {\n    return from.map(function (d, i) {\n        return number(d, to[i], t);\n    });\n}\n\nvar interpolate = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  number: number,\n  color: color,\n  array: array$1\n});\n\nvar Xn = 0.95047, Yn = 1, Zn = 1.08883, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1, deg2rad = Math.PI / 180, rad2deg = 180 / Math.PI;\nfunction xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\nfunction lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n}\nfunction xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\nfunction rgb2xyz(x) {\n    x /= 255;\n    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\nfunction rgbToLab(rgbColor) {\n    var b = rgb2xyz(rgbColor.r), a = rgb2xyz(rgbColor.g), l = rgb2xyz(rgbColor.b), x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn), y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn), z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);\n    return {\n        l: 116 * y - 16,\n        a: 500 * (x - y),\n        b: 200 * (y - z),\n        alpha: rgbColor.a\n    };\n}\nfunction labToRgb(labColor) {\n    var y = (labColor.l + 16) / 116, x = isNaN(labColor.a) ? y : y + labColor.a / 500, z = isNaN(labColor.b) ? y : y - labColor.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);\n}\nfunction interpolateLab(from, to, t) {\n    return {\n        l: number(from.l, to.l, t),\n        a: number(from.a, to.a, t),\n        b: number(from.b, to.b, t),\n        alpha: number(from.alpha, to.alpha, t)\n    };\n}\nfunction rgbToHcl(rgbColor) {\n    var ref = rgbToLab(rgbColor);\n    var l = ref.l;\n    var a = ref.a;\n    var b = ref.b;\n    var h = Math.atan2(b, a) * rad2deg;\n    return {\n        h: h < 0 ? h + 360 : h,\n        c: Math.sqrt(a * a + b * b),\n        l: l,\n        alpha: rgbColor.a\n    };\n}\nfunction hclToRgb(hclColor) {\n    var h = hclColor.h * deg2rad, c = hclColor.c, l = hclColor.l;\n    return labToRgb({\n        l: l,\n        a: Math.cos(h) * c,\n        b: Math.sin(h) * c,\n        alpha: hclColor.alpha\n    });\n}\nfunction interpolateHue(a, b, t) {\n    var d = b - a;\n    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);\n}\nfunction interpolateHcl(from, to, t) {\n    return {\n        h: interpolateHue(from.h, to.h, t),\n        c: number(from.c, to.c, t),\n        l: number(from.l, to.l, t),\n        alpha: number(from.alpha, to.alpha, t)\n    };\n}\nvar lab = {\n    forward: rgbToLab,\n    reverse: labToRgb,\n    interpolate: interpolateLab\n};\nvar hcl = {\n    forward: rgbToHcl,\n    reverse: hclToRgb,\n    interpolate: interpolateHcl\n};\n\nvar colorSpaces = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lab: lab,\n  hcl: hcl\n});\n\nvar Interpolate = function Interpolate(type, operator, interpolation, input, stops) {\n    this.type = type;\n    this.operator = operator;\n    this.interpolation = interpolation;\n    this.input = input;\n    this.labels = [];\n    this.outputs = [];\n    for (var i = 0, list = stops; i < list.length; i += 1) {\n        var ref = list[i];\n        var label = ref[0];\n        var expression = ref[1];\n        this.labels.push(label);\n        this.outputs.push(expression);\n    }\n};\nInterpolate.interpolationFactor = function interpolationFactor(interpolation, input, lower, upper) {\n    var t = 0;\n    if (interpolation.name === 'exponential') {\n        t = exponentialInterpolation(input, interpolation.base, lower, upper);\n    } else if (interpolation.name === 'linear') {\n        t = exponentialInterpolation(input, 1, lower, upper);\n    } else if (interpolation.name === 'cubic-bezier') {\n        var c = interpolation.controlPoints;\n        var ub = new unitbezier(c[0], c[1], c[2], c[3]);\n        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));\n    }\n    return t;\n};\nInterpolate.parse = function parse(args, context) {\n    var operator = args[0];\n    var interpolation = args[1];\n    var input = args[2];\n    var rest = args.slice(3);\n    if (!Array.isArray(interpolation) || interpolation.length === 0) {\n        return context.error('Expected an interpolation type expression.', 1);\n    }\n    if (interpolation[0] === 'linear') {\n        interpolation = { name: 'linear' };\n    } else if (interpolation[0] === 'exponential') {\n        var base = interpolation[1];\n        if (typeof base !== 'number') {\n            return context.error('Exponential interpolation requires a numeric base.', 1, 1);\n        }\n        interpolation = {\n            name: 'exponential',\n            base: base\n        };\n    } else if (interpolation[0] === 'cubic-bezier') {\n        var controlPoints = interpolation.slice(1);\n        if (controlPoints.length !== 4 || controlPoints.some(function (t) {\n                return typeof t !== 'number' || t < 0 || t > 1;\n            })) {\n            return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);\n        }\n        interpolation = {\n            name: 'cubic-bezier',\n            controlPoints: controlPoints\n        };\n    } else {\n        return context.error('Unknown interpolation type ' + String(interpolation[0]), 1, 0);\n    }\n    if (args.length - 1 < 4) {\n        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');\n    }\n    if ((args.length - 1) % 2 !== 0) {\n        return context.error('Expected an even number of arguments.');\n    }\n    input = context.parse(input, 2, NumberType);\n    if (!input) {\n        return null;\n    }\n    var stops = [];\n    var outputType = null;\n    if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {\n        outputType = ColorType;\n    } else if (context.expectedType && context.expectedType.kind !== 'value') {\n        outputType = context.expectedType;\n    }\n    for (var i = 0; i < rest.length; i += 2) {\n        var label = rest[i];\n        var value = rest[i + 1];\n        var labelKey = i + 3;\n        var valueKey = i + 4;\n        if (typeof label !== 'number') {\n            return context.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);\n        }\n        if (stops.length && stops[stops.length - 1][0] >= label) {\n            return context.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', labelKey);\n        }\n        var parsed = context.parse(value, valueKey, outputType);\n        if (!parsed) {\n            return null;\n        }\n        outputType = outputType || parsed.type;\n        stops.push([\n            label,\n            parsed\n        ]);\n    }\n    if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {\n        return context.error('Type ' + toString(outputType) + ' is not interpolatable.');\n    }\n    return new Interpolate(outputType, operator, interpolation, input, stops);\n};\nInterpolate.prototype.evaluate = function evaluate(ctx) {\n    var labels = this.labels;\n    var outputs = this.outputs;\n    if (labels.length === 1) {\n        return outputs[0].evaluate(ctx);\n    }\n    var value = this.input.evaluate(ctx);\n    if (value <= labels[0]) {\n        return outputs[0].evaluate(ctx);\n    }\n    var stopCount = labels.length;\n    if (value >= labels[stopCount - 1]) {\n        return outputs[stopCount - 1].evaluate(ctx);\n    }\n    var index = findStopLessThanOrEqualTo(labels, value);\n    var lower = labels[index];\n    var upper = labels[index + 1];\n    var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);\n    var outputLower = outputs[index].evaluate(ctx);\n    var outputUpper = outputs[index + 1].evaluate(ctx);\n    if (this.operator === 'interpolate') {\n        return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);\n    } else if (this.operator === 'interpolate-hcl') {\n        return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));\n    } else {\n        return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));\n    }\n};\nInterpolate.prototype.eachChild = function eachChild(fn) {\n    fn(this.input);\n    for (var i = 0, list = this.outputs; i < list.length; i += 1) {\n        var expression = list[i];\n        fn(expression);\n    }\n};\nInterpolate.prototype.possibleOutputs = function possibleOutputs() {\n    var ref;\n    return (ref = []).concat.apply(ref, this.outputs.map(function (output) {\n        return output.possibleOutputs();\n    }));\n};\nInterpolate.prototype.serialize = function serialize() {\n    var interpolation;\n    if (this.interpolation.name === 'linear') {\n        interpolation = ['linear'];\n    } else if (this.interpolation.name === 'exponential') {\n        if (this.interpolation.base === 1) {\n            interpolation = ['linear'];\n        } else {\n            interpolation = [\n                'exponential',\n                this.interpolation.base\n            ];\n        }\n    } else {\n        interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);\n    }\n    var serialized = [\n        this.operator,\n        interpolation,\n        this.input.serialize()\n    ];\n    for (var i = 0; i < this.labels.length; i++) {\n        serialized.push(this.labels[i], this.outputs[i].serialize());\n    }\n    return serialized;\n};\nfunction exponentialInterpolation(input, base, lowerValue, upperValue) {\n    var difference = upperValue - lowerValue;\n    var progress = input - lowerValue;\n    if (difference === 0) {\n        return 0;\n    } else if (base === 1) {\n        return progress / difference;\n    } else {\n        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n    }\n}\n\nvar Coalesce = function Coalesce(type, args) {\n    this.type = type;\n    this.args = args;\n};\nCoalesce.parse = function parse(args, context) {\n    if (args.length < 2) {\n        return context.error('Expectected at least one argument.');\n    }\n    var outputType = null;\n    var expectedType = context.expectedType;\n    if (expectedType && expectedType.kind !== 'value') {\n        outputType = expectedType;\n    }\n    var parsedArgs = [];\n    for (var i = 0, list = args.slice(1); i < list.length; i += 1) {\n        var arg = list[i];\n        var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });\n        if (!parsed) {\n            return null;\n        }\n        outputType = outputType || parsed.type;\n        parsedArgs.push(parsed);\n    }\n    var needsAnnotation = expectedType && parsedArgs.some(function (arg) {\n        return checkSubtype(expectedType, arg.type);\n    });\n    return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);\n};\nCoalesce.prototype.evaluate = function evaluate(ctx) {\n    var result = null;\n    var argCount = 0;\n    var requestedImageName;\n    for (var i = 0, list = this.args; i < list.length; i += 1) {\n        var arg = list[i];\n        argCount++;\n        result = arg.evaluate(ctx);\n        if (result && result instanceof ResolvedImage && !result.available) {\n            if (!requestedImageName) {\n                requestedImageName = result.name;\n            }\n            result = null;\n            if (argCount === this.args.length) {\n                result = requestedImageName;\n            }\n        }\n        if (result !== null) {\n            break;\n        }\n    }\n    return result;\n};\nCoalesce.prototype.eachChild = function eachChild(fn) {\n    this.args.forEach(fn);\n};\nCoalesce.prototype.possibleOutputs = function possibleOutputs() {\n    var ref;\n    return (ref = []).concat.apply(ref, this.args.map(function (arg) {\n        return arg.possibleOutputs();\n    }));\n};\nCoalesce.prototype.serialize = function serialize() {\n    var serialized = ['coalesce'];\n    this.eachChild(function (child) {\n        serialized.push(child.serialize());\n    });\n    return serialized;\n};\n\nvar Let = function Let(bindings, result) {\n    this.type = result.type;\n    this.bindings = [].concat(bindings);\n    this.result = result;\n};\nLet.prototype.evaluate = function evaluate(ctx) {\n    return this.result.evaluate(ctx);\n};\nLet.prototype.eachChild = function eachChild(fn) {\n    for (var i = 0, list = this.bindings; i < list.length; i += 1) {\n        var binding = list[i];\n        fn(binding[1]);\n    }\n    fn(this.result);\n};\nLet.parse = function parse(args, context) {\n    if (args.length < 4) {\n        return context.error('Expected at least 3 arguments, but found ' + (args.length - 1) + ' instead.');\n    }\n    var bindings = [];\n    for (var i = 1; i < args.length - 1; i += 2) {\n        var name = args[i];\n        if (typeof name !== 'string') {\n            return context.error('Expected string, but found ' + typeof name + ' instead.', i);\n        }\n        if (/[^a-zA-Z0-9_]/.test(name)) {\n            return context.error('Variable names must contain only alphanumeric characters or \\'_\\'.', i);\n        }\n        var value = context.parse(args[i + 1], i + 1);\n        if (!value) {\n            return null;\n        }\n        bindings.push([\n            name,\n            value\n        ]);\n    }\n    var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);\n    if (!result) {\n        return null;\n    }\n    return new Let(bindings, result);\n};\nLet.prototype.possibleOutputs = function possibleOutputs() {\n    return this.result.possibleOutputs();\n};\nLet.prototype.serialize = function serialize() {\n    var serialized = ['let'];\n    for (var i = 0, list = this.bindings; i < list.length; i += 1) {\n        var ref = list[i];\n        var name = ref[0];\n        var expr = ref[1];\n        serialized.push(name, expr.serialize());\n    }\n    serialized.push(this.result.serialize());\n    return serialized;\n};\n\nvar At = function At(type, index, input) {\n    this.type = type;\n    this.index = index;\n    this.input = input;\n};\nAt.parse = function parse(args, context) {\n    if (args.length !== 3) {\n        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');\n    }\n    var index = context.parse(args[1], 1, NumberType);\n    var input = context.parse(args[2], 2, array(context.expectedType || ValueType));\n    if (!index || !input) {\n        return null;\n    }\n    var t = input.type;\n    return new At(t.itemType, index, input);\n};\nAt.prototype.evaluate = function evaluate(ctx) {\n    var index = this.index.evaluate(ctx);\n    var array = this.input.evaluate(ctx);\n    if (index < 0) {\n        throw new RuntimeError('Array index out of bounds: ' + index + ' < 0.');\n    }\n    if (index >= array.length) {\n        throw new RuntimeError('Array index out of bounds: ' + index + ' > ' + (array.length - 1) + '.');\n    }\n    if (index !== Math.floor(index)) {\n        throw new RuntimeError('Array index must be an integer, but found ' + index + ' instead.');\n    }\n    return array[index];\n};\nAt.prototype.eachChild = function eachChild(fn) {\n    fn(this.index);\n    fn(this.input);\n};\nAt.prototype.possibleOutputs = function possibleOutputs() {\n    return [undefined];\n};\nAt.prototype.serialize = function serialize() {\n    return [\n        'at',\n        this.index.serialize(),\n        this.input.serialize()\n    ];\n};\n\nfunction isComparableType(type) {\n    return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';\n}\nfunction isComparableRuntimeValue(needle) {\n    return typeof needle === 'boolean' || typeof needle === 'string' || typeof needle === 'number';\n}\nfunction isSearchableRuntimeValue(haystack) {\n    return Array.isArray(haystack) || typeof haystack === 'string';\n}\nvar In = function In(needle, haystack) {\n    this.type = BooleanType;\n    this.needle = needle;\n    this.haystack = haystack;\n};\nIn.parse = function parse(args, context) {\n    if (args.length !== 3) {\n        return context.error('Expected 2 arguments, but found ' + (args.length - 1) + ' instead.');\n    }\n    var needle = context.parse(args[1], 1, ValueType);\n    var haystack = context.parse(args[2], 2, ValueType);\n    if (!needle || !haystack) {\n        return null;\n    }\n    if (!isComparableType(needle.type)) {\n        return context.error('Expected first argument to be of type boolean, string, number or null, but found ' + toString(needle.type) + ' instead');\n    }\n    return new In(needle, haystack);\n};\nIn.prototype.evaluate = function evaluate(ctx) {\n    var needle = this.needle.evaluate(ctx);\n    var haystack = this.haystack.evaluate(ctx);\n    if (!needle || !haystack) {\n        return false;\n    }\n    if (!isComparableRuntimeValue(needle)) {\n        throw new RuntimeError('Expected first argument to be of type boolean, string or number, but found ' + toString(typeOf(needle)) + ' instead.');\n    }\n    if (!isSearchableRuntimeValue(haystack)) {\n        throw new RuntimeError('Expected second argument to be of type array or string, but found ' + toString(typeOf(haystack)) + ' instead.');\n    }\n    return haystack.indexOf(needle) >= 0;\n};\nIn.prototype.eachChild = function eachChild(fn) {\n    fn(this.needle);\n    fn(this.haystack);\n};\nIn.prototype.possibleOutputs = function possibleOutputs() {\n    return [\n        true,\n        false\n    ];\n};\nIn.prototype.serialize = function serialize() {\n    return [\n        'in',\n        this.needle.serialize(),\n        this.haystack.serialize()\n    ];\n};\n\nvar Match = function Match(inputType, outputType, input, cases, outputs, otherwise) {\n    this.inputType = inputType;\n    this.type = outputType;\n    this.input = input;\n    this.cases = cases;\n    this.outputs = outputs;\n    this.otherwise = otherwise;\n};\nMatch.parse = function parse(args, context) {\n    if (args.length < 5) {\n        return context.error('Expected at least 4 arguments, but found only ' + (args.length - 1) + '.');\n    }\n    if (args.length % 2 !== 1) {\n        return context.error('Expected an even number of arguments.');\n    }\n    var inputType;\n    var outputType;\n    if (context.expectedType && context.expectedType.kind !== 'value') {\n        outputType = context.expectedType;\n    }\n    var cases = {};\n    var outputs = [];\n    for (var i = 2; i < args.length - 1; i += 2) {\n        var labels = args[i];\n        var value = args[i + 1];\n        if (!Array.isArray(labels)) {\n            labels = [labels];\n        }\n        var labelContext = context.concat(i);\n        if (labels.length === 0) {\n            return labelContext.error('Expected at least one branch label.');\n        }\n        for (var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1) {\n            var label = list[i$1];\n            if (typeof label !== 'number' && typeof label !== 'string') {\n                return labelContext.error('Branch labels must be numbers or strings.');\n            } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {\n                return labelContext.error('Branch labels must be integers no larger than ' + Number.MAX_SAFE_INTEGER + '.');\n            } else if (typeof label === 'number' && Math.floor(label) !== label) {\n                return labelContext.error('Numeric branch labels must be integer values.');\n            } else if (!inputType) {\n                inputType = typeOf(label);\n            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {\n                return null;\n            }\n            if (typeof cases[String(label)] !== 'undefined') {\n                return labelContext.error('Branch labels must be unique.');\n            }\n            cases[String(label)] = outputs.length;\n        }\n        var result = context.parse(value, i, outputType);\n        if (!result) {\n            return null;\n        }\n        outputType = outputType || result.type;\n        outputs.push(result);\n    }\n    var input = context.parse(args[1], 1, ValueType);\n    if (!input) {\n        return null;\n    }\n    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n    if (!otherwise) {\n        return null;\n    }\n    if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {\n        return null;\n    }\n    return new Match(inputType, outputType, input, cases, outputs, otherwise);\n};\nMatch.prototype.evaluate = function evaluate(ctx) {\n    var input = this.input.evaluate(ctx);\n    var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;\n    return output.evaluate(ctx);\n};\nMatch.prototype.eachChild = function eachChild(fn) {\n    fn(this.input);\n    this.outputs.forEach(fn);\n    fn(this.otherwise);\n};\nMatch.prototype.possibleOutputs = function possibleOutputs() {\n    var ref;\n    return (ref = []).concat.apply(ref, this.outputs.map(function (out) {\n        return out.possibleOutputs();\n    })).concat(this.otherwise.possibleOutputs());\n};\nMatch.prototype.serialize = function serialize() {\n    var this$1 = this;\n    var serialized = [\n        'match',\n        this.input.serialize()\n    ];\n    var sortedLabels = Object.keys(this.cases).sort();\n    var groupedByOutput = [];\n    var outputLookup = {};\n    for (var i = 0, list = sortedLabels; i < list.length; i += 1) {\n        var label = list[i];\n        var outputIndex = outputLookup[this.cases[label]];\n        if (outputIndex === undefined) {\n            outputLookup[this.cases[label]] = groupedByOutput.length;\n            groupedByOutput.push([\n                this.cases[label],\n                [label]\n            ]);\n        } else {\n            groupedByOutput[outputIndex][1].push(label);\n        }\n    }\n    var coerceLabel = function (label) {\n        return this$1.inputType.kind === 'number' ? Number(label) : label;\n    };\n    for (var i$1 = 0, list$1 = groupedByOutput; i$1 < list$1.length; i$1 += 1) {\n        var ref = list$1[i$1];\n        var outputIndex = ref[0];\n        var labels = ref[1];\n        if (labels.length === 1) {\n            serialized.push(coerceLabel(labels[0]));\n        } else {\n            serialized.push(labels.map(coerceLabel));\n        }\n        serialized.push(this.outputs[outputIndex$1].serialize());\n    }\n    serialized.push(this.otherwise.serialize());\n    return serialized;\n};\n\nvar Case = function Case(type, branches, otherwise) {\n    this.type = type;\n    this.branches = branches;\n    this.otherwise = otherwise;\n};\nCase.parse = function parse(args, context) {\n    if (args.length < 4) {\n        return context.error('Expected at least 3 arguments, but found only ' + (args.length - 1) + '.');\n    }\n    if (args.length % 2 !== 0) {\n        return context.error('Expected an odd number of arguments.');\n    }\n    var outputType;\n    if (context.expectedType && context.expectedType.kind !== 'value') {\n        outputType = context.expectedType;\n    }\n    var branches = [];\n    for (var i = 1; i < args.length - 1; i += 2) {\n        var test = context.parse(args[i], i, BooleanType);\n        if (!test) {\n            return null;\n        }\n        var result = context.parse(args[i + 1], i + 1, outputType);\n        if (!result) {\n            return null;\n        }\n        branches.push([\n            test,\n            result\n        ]);\n        outputType = outputType || result.type;\n    }\n    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n    if (!otherwise) {\n        return null;\n    }\n    return new Case(outputType, branches, otherwise);\n};\nCase.prototype.evaluate = function evaluate(ctx) {\n    for (var i = 0, list = this.branches; i < list.length; i += 1) {\n        var ref = list[i];\n        var test = ref[0];\n        var expression = ref[1];\n        if (test.evaluate(ctx)) {\n            return expression.evaluate(ctx);\n        }\n    }\n    return this.otherwise.evaluate(ctx);\n};\nCase.prototype.eachChild = function eachChild(fn) {\n    for (var i = 0, list = this.branches; i < list.length; i += 1) {\n        var ref = list[i];\n        var test = ref[0];\n        var expression = ref[1];\n        fn(test);\n        fn(expression);\n    }\n    fn(this.otherwise);\n};\nCase.prototype.possibleOutputs = function possibleOutputs() {\n    var ref;\n    return (ref = []).concat.apply(ref, this.branches.map(function (ref) {\n        var _ = ref[0];\n        var out = ref[1];\n        return out.possibleOutputs();\n    })).concat(this.otherwise.possibleOutputs());\n};\nCase.prototype.serialize = function serialize() {\n    var serialized = ['case'];\n    this.eachChild(function (child) {\n        serialized.push(child.serialize());\n    });\n    return serialized;\n};\n\nfunction isComparableType$1(op, type) {\n    if (op === '==' || op === '!=') {\n        return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';\n    } else {\n        return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';\n    }\n}\nfunction eq(ctx, a, b) {\n    return a === b;\n}\nfunction neq(ctx, a, b) {\n    return a !== b;\n}\nfunction lt(ctx, a, b) {\n    return a < b;\n}\nfunction gt(ctx, a, b) {\n    return a > b;\n}\nfunction lteq(ctx, a, b) {\n    return a <= b;\n}\nfunction gteq(ctx, a, b) {\n    return a >= b;\n}\nfunction eqCollate(ctx, a, b, c) {\n    return c.compare(a, b) === 0;\n}\nfunction neqCollate(ctx, a, b, c) {\n    return !eqCollate(ctx, a, b, c);\n}\nfunction ltCollate(ctx, a, b, c) {\n    return c.compare(a, b) < 0;\n}\nfunction gtCollate(ctx, a, b, c) {\n    return c.compare(a, b) > 0;\n}\nfunction lteqCollate(ctx, a, b, c) {\n    return c.compare(a, b) <= 0;\n}\nfunction gteqCollate(ctx, a, b, c) {\n    return c.compare(a, b) >= 0;\n}\nfunction makeComparison(op, compareBasic, compareWithCollator) {\n    var isOrderComparison = op !== '==' && op !== '!=';\n    return function () {\n        function Comparison(lhs, rhs, collator) {\n            this.type = BooleanType;\n            this.lhs = lhs;\n            this.rhs = rhs;\n            this.collator = collator;\n            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';\n        }\n        Comparison.parse = function parse(args, context) {\n            if (args.length !== 3 && args.length !== 4) {\n                return context.error('Expected two or three arguments.');\n            }\n            var op = args[0];\n            var lhs = context.parse(args[1], 1, ValueType);\n            if (!lhs) {\n                return null;\n            }\n            if (!isComparableType$1(op, lhs.type)) {\n                return context.concat(1).error('\"' + op + '\" comparisons are not supported for type \\'' + toString(lhs.type) + '\\'.');\n            }\n            var rhs = context.parse(args[2], 2, ValueType);\n            if (!rhs) {\n                return null;\n            }\n            if (!isComparableType$1(op, rhs.type)) {\n                return context.concat(2).error('\"' + op + '\" comparisons are not supported for type \\'' + toString(rhs.type) + '\\'.');\n            }\n            if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {\n                return context.error('Cannot compare types \\'' + toString(lhs.type) + '\\' and \\'' + toString(rhs.type) + '\\'.');\n            }\n            if (isOrderComparison) {\n                if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {\n                    lhs = new Assertion(rhs.type, [lhs]);\n                } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {\n                    rhs = new Assertion(lhs.type, [rhs]);\n                }\n            }\n            var collator = null;\n            if (args.length === 4) {\n                if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {\n                    return context.error('Cannot use collator to compare non-string types.');\n                }\n                collator = context.parse(args[3], 3, CollatorType);\n                if (!collator) {\n                    return null;\n                }\n            }\n            return new Comparison(lhs, rhs, collator);\n        };\n        Comparison.prototype.evaluate = function evaluate(ctx) {\n            var lhs = this.lhs.evaluate(ctx);\n            var rhs = this.rhs.evaluate(ctx);\n            if (isOrderComparison && this.hasUntypedArgument) {\n                var lt = typeOf(lhs);\n                var rt = typeOf(rhs);\n                if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {\n                    throw new RuntimeError('Expected arguments for \"' + op + '\" to be (string, string) or (number, number), but found (' + lt.kind + ', ' + rt.kind + ') instead.');\n                }\n            }\n            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {\n                var lt$1 = typeOf(lhs);\n                var rt$1 = typeOf(rhs);\n                if (lt$1.kind !== 'string' || rt$1.kind !== 'string') {\n                    return compareBasic(ctx, lhs, rhs);\n                }\n            }\n            return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);\n        };\n        Comparison.prototype.eachChild = function eachChild(fn) {\n            fn(this.lhs);\n            fn(this.rhs);\n            if (this.collator) {\n                fn(this.collator);\n            }\n        };\n        Comparison.prototype.possibleOutputs = function possibleOutputs() {\n            return [\n                true,\n                false\n            ];\n        };\n        Comparison.prototype.serialize = function serialize() {\n            var serialized = [op];\n            this.eachChild(function (child) {\n                serialized.push(child.serialize());\n            });\n            return serialized;\n        };\n        return Comparison;\n    }();\n}\nvar Equals = makeComparison('==', eq, eqCollate);\nvar NotEquals = makeComparison('!=', neq, neqCollate);\nvar LessThan = makeComparison('<', lt, ltCollate);\nvar GreaterThan = makeComparison('>', gt, gtCollate);\nvar LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);\nvar GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);\n\nvar NumberFormat = function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {\n    this.type = StringType;\n    this.number = number;\n    this.locale = locale;\n    this.currency = currency;\n    this.minFractionDigits = minFractionDigits;\n    this.maxFractionDigits = maxFractionDigits;\n};\nNumberFormat.parse = function parse(args, context) {\n    if (args.length !== 3) {\n        return context.error('Expected two arguments.');\n    }\n    var number = context.parse(args[1], 1, NumberType);\n    if (!number) {\n        return null;\n    }\n    var options = args[2];\n    if (typeof options !== 'object' || Array.isArray(options)) {\n        return context.error('NumberFormat options argument must be an object.');\n    }\n    var locale = null;\n    if (options['locale']) {\n        locale = context.parse(options['locale'], 1, StringType);\n        if (!locale) {\n            return null;\n        }\n    }\n    var currency = null;\n    if (options['currency']) {\n        currency = context.parse(options['currency'], 1, StringType);\n        if (!currency) {\n            return null;\n        }\n    }\n    var minFractionDigits = null;\n    if (options['min-fraction-digits']) {\n        minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);\n        if (!minFractionDigits) {\n            return null;\n        }\n    }\n    var maxFractionDigits = null;\n    if (options['max-fraction-digits']) {\n        maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);\n        if (!maxFractionDigits) {\n            return null;\n        }\n    }\n    return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);\n};\nNumberFormat.prototype.evaluate = function evaluate(ctx) {\n    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {\n        style: this.currency ? 'currency' : 'decimal',\n        currency: this.currency ? this.currency.evaluate(ctx) : undefined,\n        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,\n        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined\n    }).format(this.number.evaluate(ctx));\n};\nNumberFormat.prototype.eachChild = function eachChild(fn) {\n    fn(this.number);\n    if (this.locale) {\n        fn(this.locale);\n    }\n    if (this.currency) {\n        fn(this.currency);\n    }\n    if (this.minFractionDigits) {\n        fn(this.minFractionDigits);\n    }\n    if (this.maxFractionDigits) {\n        fn(this.maxFractionDigits);\n    }\n};\nNumberFormat.prototype.possibleOutputs = function possibleOutputs() {\n    return [undefined];\n};\nNumberFormat.prototype.serialize = function serialize() {\n    var options = {};\n    if (this.locale) {\n        options['locale'] = this.locale.serialize();\n    }\n    if (this.currency) {\n        options['currency'] = this.currency.serialize();\n    }\n    if (this.minFractionDigits) {\n        options['min-fraction-digits'] = this.minFractionDigits.serialize();\n    }\n    if (this.maxFractionDigits) {\n        options['max-fraction-digits'] = this.maxFractionDigits.serialize();\n    }\n    return [\n        'number-format',\n        this.number.serialize(),\n        options\n    ];\n};\n\nvar Length = function Length(input) {\n    this.type = NumberType;\n    this.input = input;\n};\nLength.parse = function parse(args, context) {\n    if (args.length !== 2) {\n        return context.error('Expected 1 argument, but found ' + (args.length - 1) + ' instead.');\n    }\n    var input = context.parse(args[1], 1);\n    if (!input) {\n        return null;\n    }\n    if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') {\n        return context.error('Expected argument of type string or array, but found ' + toString(input.type) + ' instead.');\n    }\n    return new Length(input);\n};\nLength.prototype.evaluate = function evaluate(ctx) {\n    var input = this.input.evaluate(ctx);\n    if (typeof input === 'string') {\n        return input.length;\n    } else if (Array.isArray(input)) {\n        return input.length;\n    } else {\n        throw new RuntimeError('Expected value to be of type string or array, but found ' + toString(typeOf(input)) + ' instead.');\n    }\n};\nLength.prototype.eachChild = function eachChild(fn) {\n    fn(this.input);\n};\nLength.prototype.possibleOutputs = function possibleOutputs() {\n    return [undefined];\n};\nLength.prototype.serialize = function serialize() {\n    var serialized = ['length'];\n    this.eachChild(function (child) {\n        serialized.push(child.serialize());\n    });\n    return serialized;\n};\n\nvar expressions = {\n    '==': Equals,\n    '!=': NotEquals,\n    '>': GreaterThan,\n    '<': LessThan,\n    '>=': GreaterThanOrEqual,\n    '<=': LessThanOrEqual,\n    'array': Assertion,\n    'at': At,\n    'boolean': Assertion,\n    'case': Case,\n    'coalesce': Coalesce,\n    'collator': CollatorExpression,\n    'format': FormatExpression,\n    'image': ImageExpression,\n    'in': In,\n    'interpolate': Interpolate,\n    'interpolate-hcl': Interpolate,\n    'interpolate-lab': Interpolate,\n    'length': Length,\n    'let': Let,\n    'literal': Literal,\n    'match': Match,\n    'number': Assertion,\n    'number-format': NumberFormat,\n    'object': Assertion,\n    'step': Step,\n    'string': Assertion,\n    'to-boolean': Coercion,\n    'to-color': Coercion,\n    'to-number': Coercion,\n    'to-string': Coercion,\n    'var': Var\n};\nfunction rgba(ctx, ref) {\n    var r = ref[0];\n    var g = ref[1];\n    var b = ref[2];\n    var a = ref[3];\n    r = r.evaluate(ctx);\n    g = g.evaluate(ctx);\n    b = b.evaluate(ctx);\n    var alpha = a ? a.evaluate(ctx) : 1;\n    var error = validateRGBA(r, g, b, alpha);\n    if (error) {\n        throw new RuntimeError(error);\n    }\n    return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);\n}\nfunction has(key, obj) {\n    return key in obj;\n}\nfunction get(key, obj) {\n    var v = obj[key];\n    return typeof v === 'undefined' ? null : v;\n}\nfunction binarySearch(v, a, i, j) {\n    while (i <= j) {\n        var m = i + j >> 1;\n        if (a[m] === v) {\n            return true;\n        }\n        if (a[m] > v) {\n            j = m - 1;\n        } else {\n            i = m + 1;\n        }\n    }\n    return false;\n}\nfunction varargs(type) {\n    return { type: type };\n}\nCompoundExpression.register(expressions, {\n    'error': [\n        ErrorType,\n        [StringType],\n        function (ctx, ref) {\n            var v = ref[0];\n            throw new RuntimeError(v.evaluate(ctx));\n        }\n    ],\n    'typeof': [\n        StringType,\n        [ValueType],\n        function (ctx, ref) {\n            var v = ref[0];\n            return toString(typeOf(v.evaluate(ctx)));\n        }\n    ],\n    'to-rgba': [\n        array(NumberType, 4),\n        [ColorType],\n        function (ctx, ref) {\n            var v = ref[0];\n            return v.evaluate(ctx).toArray();\n        }\n    ],\n    'rgb': [\n        ColorType,\n        [\n            NumberType,\n            NumberType,\n            NumberType\n        ],\n        rgba\n    ],\n    'rgba': [\n        ColorType,\n        [\n            NumberType,\n            NumberType,\n            NumberType,\n            NumberType\n        ],\n        rgba\n    ],\n    'has': {\n        type: BooleanType,\n        overloads: [\n            [\n                [StringType],\n                function (ctx, ref) {\n                    var key = ref[0];\n                    return has(key.evaluate(ctx), ctx.properties());\n                }\n            ],\n            [\n                [\n                    StringType,\n                    ObjectType\n                ],\n                function (ctx, ref) {\n                    var key = ref[0];\n                    var obj = ref[1];\n                    return has(key.evaluate(ctx), obj.evaluate(ctx));\n                }\n            ]\n        ]\n    },\n    'get': {\n        type: ValueType,\n        overloads: [\n            [\n                [StringType],\n                function (ctx, ref) {\n                    var key = ref[0];\n                    return get(key.evaluate(ctx), ctx.properties());\n                }\n            ],\n            [\n                [\n                    StringType,\n                    ObjectType\n                ],\n                function (ctx, ref) {\n                    var key = ref[0];\n                    var obj = ref[1];\n                    return get(key.evaluate(ctx), obj.evaluate(ctx));\n                }\n            ]\n        ]\n    },\n    'feature-state': [\n        ValueType,\n        [StringType],\n        function (ctx, ref) {\n            var key = ref[0];\n            return get(key.evaluate(ctx), ctx.featureState || {});\n        }\n    ],\n    'properties': [\n        ObjectType,\n        [],\n        function (ctx) {\n            return ctx.properties();\n        }\n    ],\n    'geometry-type': [\n        StringType,\n        [],\n        function (ctx) {\n            return ctx.geometryType();\n        }\n    ],\n    'id': [\n        ValueType,\n        [],\n        function (ctx) {\n            return ctx.id();\n        }\n    ],\n    'zoom': [\n        NumberType,\n        [],\n        function (ctx) {\n            return ctx.globals.zoom;\n        }\n    ],\n    'heatmap-density': [\n        NumberType,\n        [],\n        function (ctx) {\n            return ctx.globals.heatmapDensity || 0;\n        }\n    ],\n    'line-progress': [\n        NumberType,\n        [],\n        function (ctx) {\n            return ctx.globals.lineProgress || 0;\n        }\n    ],\n    'accumulated': [\n        ValueType,\n        [],\n        function (ctx) {\n            return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;\n        }\n    ],\n    '+': [\n        NumberType,\n        varargs(NumberType),\n        function (ctx, args) {\n            var result = 0;\n            for (var i = 0, list = args; i < list.length; i += 1) {\n                var arg = list[i];\n                result += arg.evaluate(ctx);\n            }\n            return result;\n        }\n    ],\n    '*': [\n        NumberType,\n        varargs(NumberType),\n        function (ctx, args) {\n            var result = 1;\n            for (var i = 0, list = args; i < list.length; i += 1) {\n                var arg = list[i];\n                result *= arg.evaluate(ctx);\n            }\n            return result;\n        }\n    ],\n    '-': {\n        type: NumberType,\n        overloads: [\n            [\n                [\n                    NumberType,\n                    NumberType\n                ],\n                function (ctx, ref) {\n                    var a = ref[0];\n                    var b = ref[1];\n                    return a.evaluate(ctx) - b.evaluate(ctx);\n                }\n            ],\n            [\n                [NumberType],\n                function (ctx, ref) {\n                    var a = ref[0];\n                    return -a.evaluate(ctx);\n                }\n            ]\n        ]\n    },\n    '/': [\n        NumberType,\n        [\n            NumberType,\n            NumberType\n        ],\n        function (ctx, ref) {\n            var a = ref[0];\n            var b = ref[1];\n            return a.evaluate(ctx) / b.evaluate(ctx);\n        }\n    ],\n    '%': [\n        NumberType,\n        [\n            NumberType,\n            NumberType\n        ],\n        function (ctx, ref) {\n            var a = ref[0];\n            var b = ref[1];\n            return a.evaluate(ctx) % b.evaluate(ctx);\n        }\n    ],\n    'ln2': [\n        NumberType,\n        [],\n        function () {\n            return Math.LN2;\n        }\n    ],\n    'pi': [\n        NumberType,\n        [],\n        function () {\n            return Math.PI;\n        }\n    ],\n    'e': [\n        NumberType,\n        [],\n        function () {\n            return Math.E;\n        }\n    ],\n    '^': [\n        NumberType,\n        [\n            NumberType,\n            NumberType\n        ],\n        function (ctx, ref) {\n            var b = ref[0];\n            var e = ref[1];\n            return Math.pow(b.evaluate(ctx), e.evaluate(ctx));\n        }\n    ],\n    'sqrt': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var x = ref[0];\n            return Math.sqrt(x.evaluate(ctx));\n        }\n    ],\n    'log10': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.log(n.evaluate(ctx)) / Math.LN10;\n        }\n    ],\n    'ln': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.log(n.evaluate(ctx));\n        }\n    ],\n    'log2': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.log(n.evaluate(ctx)) / Math.LN2;\n        }\n    ],\n    'sin': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.sin(n.evaluate(ctx));\n        }\n    ],\n    'cos': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.cos(n.evaluate(ctx));\n        }\n    ],\n    'tan': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.tan(n.evaluate(ctx));\n        }\n    ],\n    'asin': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.asin(n.evaluate(ctx));\n        }\n    ],\n    'acos': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.acos(n.evaluate(ctx));\n        }\n    ],\n    'atan': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.atan(n.evaluate(ctx));\n        }\n    ],\n    'min': [\n        NumberType,\n        varargs(NumberType),\n        function (ctx, args) {\n            return Math.min.apply(Math, args.map(function (arg) {\n                return arg.evaluate(ctx);\n            }));\n        }\n    ],\n    'max': [\n        NumberType,\n        varargs(NumberType),\n        function (ctx, args) {\n            return Math.max.apply(Math, args.map(function (arg) {\n                return arg.evaluate(ctx);\n            }));\n        }\n    ],\n    'abs': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.abs(n.evaluate(ctx));\n        }\n    ],\n    'round': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            var v = n.evaluate(ctx);\n            return v < 0 ? -Math.round(-v) : Math.round(v);\n        }\n    ],\n    'floor': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.floor(n.evaluate(ctx));\n        }\n    ],\n    'ceil': [\n        NumberType,\n        [NumberType],\n        function (ctx, ref) {\n            var n = ref[0];\n            return Math.ceil(n.evaluate(ctx));\n        }\n    ],\n    'filter-==': [\n        BooleanType,\n        [\n            StringType,\n            ValueType\n        ],\n        function (ctx, ref) {\n            var k = ref[0];\n            var v = ref[1];\n            return ctx.properties()[k.value] === v.value;\n        }\n    ],\n    'filter-id-==': [\n        BooleanType,\n        [ValueType],\n        function (ctx, ref) {\n            var v = ref[0];\n            return ctx.id() === v.value;\n        }\n    ],\n    'filter-type-==': [\n        BooleanType,\n        [StringType],\n        function (ctx, ref) {\n            var v = ref[0];\n            return ctx.geometryType() === v.value;\n        }\n    ],\n    'filter-<': [\n        BooleanType,\n        [\n            StringType,\n            ValueType\n        ],\n        function (ctx, ref) {\n            var k = ref[0];\n            var v = ref[1];\n            var a = ctx.properties()[k.value];\n            var b = v.value;\n            return typeof a === typeof b && a < b;\n        }\n    ],\n    'filter-id-<': [\n        BooleanType,\n        [ValueType],\n        function (ctx, ref) {\n            var v = ref[0];\n            var a = ctx.id();\n            var b = v.value;\n            return typeof a === typeof b && a < b;\n        }\n    ],\n    'filter->': [\n        BooleanType,\n        [\n            StringType,\n            ValueType\n        ],\n        function (ctx, ref) {\n            var k = ref[0];\n            var v = ref[1];\n            var a = ctx.properties()[k.value];\n            var b = v.value;\n            return typeof a === typeof b && a > b;\n        }\n    ],\n    'filter-id->': [\n        BooleanType,\n        [ValueType],\n        function (ctx, ref) {\n            var v = ref[0];\n            var a = ctx.id();\n            var b = v.value;\n            return typeof a === typeof b && a > b;\n        }\n    ],\n    'filter-<=': [\n        BooleanType,\n        [\n            StringType,\n            ValueType\n        ],\n        function (ctx, ref) {\n            var k = ref[0];\n            var v = ref[1];\n            var a = ctx.properties()[k.value];\n            var b = v.value;\n            return typeof a === typeof b && a <= b;\n        }\n    ],\n    'filter-id-<=': [\n        BooleanType,\n        [ValueType],\n        function (ctx, ref) {\n            var v = ref[0];\n            var a = ctx.id();\n            var b = v.value;\n            return typeof a === typeof b && a <= b;\n        }\n    ],\n    'filter->=': [\n        BooleanType,\n        [\n            StringType,\n            ValueType\n        ],\n        function (ctx, ref) {\n            var k = ref[0];\n            var v = ref[1];\n            var a = ctx.properties()[k.value];\n            var b = v.value;\n            return typeof a === typeof b && a >= b;\n        }\n    ],\n    'filter-id->=': [\n        BooleanType,\n        [ValueType],\n        function (ctx, ref) {\n            var v = ref[0];\n            var a = ctx.id();\n            var b = v.value;\n            return typeof a === typeof b && a >= b;\n        }\n    ],\n    'filter-has': [\n        BooleanType,\n        [ValueType],\n        function (ctx, ref) {\n            var k = ref[0];\n            return k.value in ctx.properties();\n        }\n    ],\n    'filter-has-id': [\n        BooleanType,\n        [],\n        function (ctx) {\n            return ctx.id() !== null;\n        }\n    ],\n    'filter-type-in': [\n        BooleanType,\n        [array(StringType)],\n        function (ctx, ref) {\n            var v = ref[0];\n            return v.value.indexOf(ctx.geometryType()) >= 0;\n        }\n    ],\n    'filter-id-in': [\n        BooleanType,\n        [array(ValueType)],\n        function (ctx, ref) {\n            var v = ref[0];\n            return v.value.indexOf(ctx.id()) >= 0;\n        }\n    ],\n    'filter-in-small': [\n        BooleanType,\n        [\n            StringType,\n            array(ValueType)\n        ],\n        function (ctx, ref) {\n            var k = ref[0];\n            var v = ref[1];\n            return v.value.indexOf(ctx.properties()[k.value]) >= 0;\n        }\n    ],\n    'filter-in-large': [\n        BooleanType,\n        [\n            StringType,\n            array(ValueType)\n        ],\n        function (ctx, ref) {\n            var k = ref[0];\n            var v = ref[1];\n            return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);\n        }\n    ],\n    'all': {\n        type: BooleanType,\n        overloads: [\n            [\n                [\n                    BooleanType,\n                    BooleanType\n                ],\n                function (ctx, ref) {\n                    var a = ref[0];\n                    var b = ref[1];\n                    return a.evaluate(ctx) && b.evaluate(ctx);\n                }\n            ],\n            [\n                varargs(BooleanType),\n                function (ctx, args) {\n                    for (var i = 0, list = args; i < list.length; i += 1) {\n                        var arg = list[i];\n                        if (!arg.evaluate(ctx)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            ]\n        ]\n    },\n    'any': {\n        type: BooleanType,\n        overloads: [\n            [\n                [\n                    BooleanType,\n                    BooleanType\n                ],\n                function (ctx, ref) {\n                    var a = ref[0];\n                    var b = ref[1];\n                    return a.evaluate(ctx) || b.evaluate(ctx);\n                }\n            ],\n            [\n                varargs(BooleanType),\n                function (ctx, args) {\n                    for (var i = 0, list = args; i < list.length; i += 1) {\n                        var arg = list[i];\n                        if (arg.evaluate(ctx)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            ]\n        ]\n    },\n    '!': [\n        BooleanType,\n        [BooleanType],\n        function (ctx, ref) {\n            var b = ref[0];\n            return !b.evaluate(ctx);\n        }\n    ],\n    'is-supported-script': [\n        BooleanType,\n        [StringType],\n        function (ctx, ref) {\n            var s = ref[0];\n            var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;\n            if (isSupportedScript) {\n                return isSupportedScript(s.evaluate(ctx));\n            }\n            return true;\n        }\n    ],\n    'upcase': [\n        StringType,\n        [StringType],\n        function (ctx, ref) {\n            var s = ref[0];\n            return s.evaluate(ctx).toUpperCase();\n        }\n    ],\n    'downcase': [\n        StringType,\n        [StringType],\n        function (ctx, ref) {\n            var s = ref[0];\n            return s.evaluate(ctx).toLowerCase();\n        }\n    ],\n    'concat': [\n        StringType,\n        varargs(ValueType),\n        function (ctx, args) {\n            return args.map(function (arg) {\n                return toString$1(arg.evaluate(ctx));\n            }).join('');\n        }\n    ],\n    'resolved-locale': [\n        StringType,\n        [CollatorType],\n        function (ctx, ref) {\n            var collator = ref[0];\n            return collator.evaluate(ctx).resolvedLocale();\n        }\n    ]\n});\n\nfunction success(value) {\n    return {\n        result: 'success',\n        value: value\n    };\n}\nfunction error(value) {\n    return {\n        result: 'error',\n        value: value\n    };\n}\n\nfunction supportsPropertyExpression(spec) {\n    return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';\n}\nfunction supportsZoomExpression(spec) {\n    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;\n}\nfunction supportsInterpolation(spec) {\n    return !!spec.expression && spec.expression.interpolated;\n}\n\nfunction getType(val) {\n    if (val instanceof Number) {\n        return 'number';\n    } else if (val instanceof String) {\n        return 'string';\n    } else if (val instanceof Boolean) {\n        return 'boolean';\n    } else if (Array.isArray(val)) {\n        return 'array';\n    } else if (val === null) {\n        return 'null';\n    } else {\n        return typeof val;\n    }\n}\n\nfunction isFunction$1(value) {\n    return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\nfunction identityFunction(x) {\n    return x;\n}\nfunction createFunction(parameters, propertySpec) {\n    var isColor = propertySpec.type === 'color';\n    var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';\n    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n    var zoomDependent = zoomAndFeatureDependent || !featureDependent;\n    var type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');\n    if (isColor) {\n        parameters = extend({}, parameters);\n        if (parameters.stops) {\n            parameters.stops = parameters.stops.map(function (stop) {\n                return [\n                    stop[0],\n                    Color.parse(stop[1])\n                ];\n            });\n        }\n        if (parameters.default) {\n            parameters.default = Color.parse(parameters.default);\n        } else {\n            parameters.default = Color.parse(propertySpec.default);\n        }\n    }\n    if (parameters.colorSpace && parameters.colorSpace !== 'rgb' && !colorSpaces[parameters.colorSpace]) {\n        throw new Error('Unknown color space: ' + parameters.colorSpace);\n    }\n    var innerFun;\n    var hashedStops;\n    var categoricalKeyType;\n    if (type === 'exponential') {\n        innerFun = evaluateExponentialFunction;\n    } else if (type === 'interval') {\n        innerFun = evaluateIntervalFunction;\n    } else if (type === 'categorical') {\n        innerFun = evaluateCategoricalFunction;\n        hashedStops = Object.create(null);\n        for (var i = 0, list = parameters.stops; i < list.length; i += 1) {\n            var stop = list[i];\n            hashedStops[stop[0]] = stop[1];\n        }\n        categoricalKeyType = typeof parameters.stops[0][0];\n    } else if (type === 'identity') {\n        innerFun = evaluateIdentityFunction;\n    } else {\n        throw new Error('Unknown function type \"' + type + '\"');\n    }\n    if (zoomAndFeatureDependent) {\n        var featureFunctions = {};\n        var zoomStops = [];\n        for (var s = 0; s < parameters.stops.length; s++) {\n            var stop$1 = parameters.stops[s];\n            var zoom = stop$1[0].zoom;\n            if (featureFunctions[zoom] === undefined) {\n                featureFunctions[zoom] = {\n                    zoom: zoom,\n                    type: parameters.type,\n                    property: parameters.property,\n                    default: parameters.default,\n                    stops: []\n                };\n                zoomStops.push(zoom);\n            }\n            featureFunctions[zoom].stops.push([\n                stop$1[0].value,\n                stop$1[1]\n            ]);\n        }\n        var featureFunctionStops = [];\n        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {\n            var z = list$1[i$1];\n            featureFunctionStops.push([\n                featureFunctions[z].zoom,\n                createFunction(featureFunctions[z], propertySpec)\n            ]);\n        }\n        var interpolationType = { name: 'linear' };\n        return {\n            kind: 'composite',\n            interpolationType: interpolationType,\n            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),\n            zoomStops: featureFunctionStops.map(function (s) {\n                return s[0];\n            }),\n            evaluate: function evaluate(ref, properties) {\n                var zoom = ref.zoom;\n                return evaluateExponentialFunction({\n                    stops: featureFunctionStops,\n                    base: parameters.base\n                }, propertySpec, zoom).evaluate(zoom, properties);\n            }\n        };\n    } else if (zoomDependent) {\n        var interpolationType$1 = type === 'exponential' ? {\n            name: 'exponential',\n            base: parameters.base !== undefined ? parameters.base : 1\n        } : null;\n        return {\n            kind: 'camera',\n            interpolationType: interpolationType$1,\n            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType$1),\n            zoomStops: parameters.stops.map(function (s) {\n                return s[0];\n            }),\n            evaluate: function (ref) {\n                var zoom = ref.zoom;\n                return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);\n            }\n        };\n    } else {\n        return {\n            kind: 'source',\n            evaluate: function evaluate(_, feature) {\n                var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;\n                if (value === undefined) {\n                    return coalesce(parameters.default, propertySpec.default);\n                }\n                return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);\n            }\n        };\n    }\n}\nfunction coalesce(a, b, c) {\n    if (a !== undefined) {\n        return a;\n    }\n    if (b !== undefined) {\n        return b;\n    }\n    if (c !== undefined) {\n        return c;\n    }\n}\nfunction evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {\n    var evaluated = typeof input === keyType ? hashedStops[input] : undefined;\n    return coalesce(evaluated, parameters.default, propertySpec.default);\n}\nfunction evaluateIntervalFunction(parameters, propertySpec, input) {\n    if (getType(input) !== 'number') {\n        return coalesce(parameters.default, propertySpec.default);\n    }\n    var n = parameters.stops.length;\n    if (n === 1) {\n        return parameters.stops[0][1];\n    }\n    if (input <= parameters.stops[0][0]) {\n        return parameters.stops[0][1];\n    }\n    if (input >= parameters.stops[n - 1][0]) {\n        return parameters.stops[n - 1][1];\n    }\n    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {\n        return stop[0];\n    }), input);\n    return parameters.stops[index][1];\n}\nfunction evaluateExponentialFunction(parameters, propertySpec, input) {\n    var base = parameters.base !== undefined ? parameters.base : 1;\n    if (getType(input) !== 'number') {\n        return coalesce(parameters.default, propertySpec.default);\n    }\n    var n = parameters.stops.length;\n    if (n === 1) {\n        return parameters.stops[0][1];\n    }\n    if (input <= parameters.stops[0][0]) {\n        return parameters.stops[0][1];\n    }\n    if (input >= parameters.stops[n - 1][0]) {\n        return parameters.stops[n - 1][1];\n    }\n    var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {\n        return stop[0];\n    }), input);\n    var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);\n    var outputLower = parameters.stops[index][1];\n    var outputUpper = parameters.stops[index + 1][1];\n    var interp = interpolate[propertySpec.type] || identityFunction;\n    if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {\n        var colorspace = colorSpaces[parameters.colorSpace];\n        interp = function (a, b) {\n            return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));\n        };\n    }\n    if (typeof outputLower.evaluate === 'function') {\n        return {\n            evaluate: function evaluate() {\n                var args = [], len = arguments.length;\n                while (len--)\n                    args[len] = arguments[len];\n                var evaluatedLower = outputLower.evaluate.apply(undefined, args);\n                var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);\n                if (evaluatedLower === undefined || evaluatedUpper === undefined) {\n                    return undefined;\n                }\n                return interp(evaluatedLower, evaluatedUpper, t);\n            }\n        };\n    }\n    return interp(outputLower, outputUpper, t);\n}\nfunction evaluateIdentityFunction(parameters, propertySpec, input) {\n    if (propertySpec.type === 'color') {\n        input = Color.parse(input);\n    } else if (propertySpec.type === 'formatted') {\n        input = Formatted.fromString(input.toString());\n    } else if (propertySpec.type === 'resolvedImage') {\n        input = ResolvedImage.fromString(input.toString());\n    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {\n        input = undefined;\n    }\n    return coalesce(input, parameters.default, propertySpec.default);\n}\nfunction interpolationFactor(input, base, lowerValue, upperValue) {\n    var difference = upperValue - lowerValue;\n    var progress = input - lowerValue;\n    if (difference === 0) {\n        return 0;\n    } else if (base === 1) {\n        return progress / difference;\n    } else {\n        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n    }\n}\n\nvar StyleExpression = function StyleExpression(expression, propertySpec) {\n    this.expression = expression;\n    this._warningHistory = {};\n    this._evaluator = new EvaluationContext();\n    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;\n    this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;\n};\nStyleExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, availableImages, formattedSection) {\n    this._evaluator.globals = globals;\n    this._evaluator.feature = feature;\n    this._evaluator.featureState = featureState;\n    this._evaluator.availableImages = availableImages || null;\n    this._evaluator.formattedSection = formattedSection;\n    return this.expression.evaluate(this._evaluator);\n};\nStyleExpression.prototype.evaluate = function evaluate(globals, feature, featureState, availableImages, formattedSection) {\n    this._evaluator.globals = globals;\n    this._evaluator.feature = feature || null;\n    this._evaluator.featureState = featureState || null;\n    this._evaluator.availableImages = availableImages || null;\n    this._evaluator.formattedSection = formattedSection || null;\n    try {\n        var val = this.expression.evaluate(this._evaluator);\n        if (val === null || val === undefined || typeof val === 'number' && val !== val) {\n            return this._defaultValue;\n        }\n        if (this._enumValues && !(val in this._enumValues)) {\n            throw new RuntimeError('Expected value to be one of ' + Object.keys(this._enumValues).map(function (v) {\n                return JSON.stringify(v);\n            }).join(', ') + ', but found ' + JSON.stringify(val) + ' instead.');\n        }\n        return val;\n    } catch (e) {\n        if (!this._warningHistory[e.message]) {\n            this._warningHistory[e.message] = true;\n            if (typeof console !== 'undefined') {\n                console.warn(e.message);\n            }\n        }\n        return this._defaultValue;\n    }\n};\nfunction isExpression(expression) {\n    return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in expressions;\n}\nfunction createExpression(expression, propertySpec) {\n    var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);\n    var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? { typeAnnotation: 'coerce' } : undefined);\n    if (!parsed) {\n        return error(parser.errors);\n    }\n    return success(new StyleExpression(parsed, propertySpec));\n}\nvar ZoomConstantExpression = function ZoomConstantExpression(kind, expression) {\n    this.kind = kind;\n    this._styleExpression = expression;\n    this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);\n};\nZoomConstantExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, availableImages, formattedSection) {\n    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, availableImages, formattedSection);\n};\nZoomConstantExpression.prototype.evaluate = function evaluate(globals, feature, featureState, availableImages, formattedSection) {\n    return this._styleExpression.evaluate(globals, feature, featureState, availableImages, formattedSection);\n};\nvar ZoomDependentExpression = function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {\n    this.kind = kind;\n    this.zoomStops = zoomStops;\n    this._styleExpression = expression;\n    this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);\n    this.interpolationType = interpolationType;\n};\nZoomDependentExpression.prototype.evaluateWithoutErrorHandling = function evaluateWithoutErrorHandling(globals, feature, featureState, availableImages, formattedSection) {\n    return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, availableImages, formattedSection);\n};\nZoomDependentExpression.prototype.evaluate = function evaluate(globals, feature, featureState, availableImages, formattedSection) {\n    return this._styleExpression.evaluate(globals, feature, featureState, availableImages, formattedSection);\n};\nZoomDependentExpression.prototype.interpolationFactor = function interpolationFactor(input, lower, upper) {\n    if (this.interpolationType) {\n        return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);\n    } else {\n        return 0;\n    }\n};\nfunction createPropertyExpression(expression, propertySpec) {\n    expression = createExpression(expression, propertySpec);\n    if (expression.result === 'error') {\n        return expression;\n    }\n    var parsed = expression.value.expression;\n    var isFeatureConstant$1 = isFeatureConstant(parsed);\n    if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {\n        return error([new ParsingError('', 'data expressions not supported')]);\n    }\n    var isZoomConstant = isGlobalPropertyConstant(parsed, ['zoom']);\n    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {\n        return error([new ParsingError('', 'zoom expressions not supported')]);\n    }\n    var zoomCurve = findZoomCurve(parsed);\n    if (!zoomCurve && !isZoomConstant) {\n        return error([new ParsingError('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n    } else if (zoomCurve instanceof ParsingError) {\n        return error([zoomCurve]);\n    } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {\n        return error([new ParsingError('', '\"interpolate\" expressions cannot be used with this property')]);\n    }\n    if (!zoomCurve) {\n        return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));\n    }\n    var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;\n    return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));\n}\nvar StylePropertyFunction = function StylePropertyFunction(parameters, specification) {\n    this._parameters = parameters;\n    this._specification = specification;\n    extend(this, createFunction(this._parameters, this._specification));\n};\nStylePropertyFunction.deserialize = function deserialize(serialized) {\n    return new StylePropertyFunction(serialized._parameters, serialized._specification);\n};\nStylePropertyFunction.serialize = function serialize(input) {\n    return {\n        _parameters: input._parameters,\n        _specification: input._specification\n    };\n};\nfunction normalizePropertyExpression(value, specification) {\n    if (isFunction$1(value)) {\n        return new StylePropertyFunction(value, specification);\n    } else if (isExpression(value)) {\n        var expression = createPropertyExpression(value, specification);\n        if (expression.result === 'error') {\n            throw new Error(expression.value.map(function (err) {\n                return err.key + ': ' + err.message;\n            }).join(', '));\n        }\n        return expression.value;\n    } else {\n        var constant = value;\n        if (typeof value === 'string' && specification.type === 'color') {\n            constant = Color.parse(value);\n        }\n        return {\n            kind: 'constant',\n            evaluate: function () {\n                return constant;\n            }\n        };\n    }\n}\nfunction findZoomCurve(expression) {\n    var result = null;\n    if (expression instanceof Let) {\n        result = findZoomCurve(expression.result);\n    } else if (expression instanceof Coalesce) {\n        for (var i = 0, list = expression.args; i < list.length; i += 1) {\n            var arg = list[i];\n            result = findZoomCurve(arg);\n            if (result) {\n                break;\n            }\n        }\n    } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === 'zoom') {\n        result = expression;\n    }\n    if (result instanceof ParsingError) {\n        return result;\n    }\n    expression.eachChild(function (child) {\n        var childResult = findZoomCurve(child);\n        if (childResult instanceof ParsingError) {\n            result = childResult;\n        } else if (!result && childResult) {\n            result = new ParsingError('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.');\n        } else if (result && childResult && result !== childResult) {\n            result = new ParsingError('', 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.');\n        }\n    });\n    return result;\n}\nfunction getExpectedType(spec) {\n    var types = {\n        color: ColorType,\n        string: StringType,\n        number: NumberType,\n        enum: StringType,\n        boolean: BooleanType,\n        formatted: FormattedType,\n        resolvedImage: ResolvedImageType\n    };\n    if (spec.type === 'array') {\n        return array(types[spec.value] || ValueType, spec.length);\n    }\n    return types[spec.type];\n}\nfunction getDefaultValue(spec) {\n    if (spec.type === 'color' && isFunction$1(spec.default)) {\n        return new Color(0, 0, 0, 0);\n    } else if (spec.type === 'color') {\n        return Color.parse(spec.default) || null;\n    } else if (spec.default === undefined) {\n        return null;\n    } else {\n        return spec.default;\n    }\n}\n\nfunction convertLiteral(value) {\n    return typeof value === 'object' ? [\n        'literal',\n        value\n    ] : value;\n}\nfunction convertFunction(parameters, propertySpec) {\n    var stops = parameters.stops;\n    if (!stops) {\n        return convertIdentityFunction(parameters, propertySpec);\n    }\n    var zoomAndFeatureDependent = stops && typeof stops[0][0] === 'object';\n    var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n    var zoomDependent = zoomAndFeatureDependent || !featureDependent;\n    stops = stops.map(function (stop) {\n        if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {\n            return [\n                stop[0],\n                convertTokenString(stop[1])\n            ];\n        }\n        return [\n            stop[0],\n            convertLiteral(stop[1])\n        ];\n    });\n    if (zoomAndFeatureDependent) {\n        return convertZoomAndPropertyFunction(parameters, propertySpec, stops);\n    } else if (zoomDependent) {\n        return convertZoomFunction(parameters, propertySpec, stops);\n    } else {\n        return convertPropertyFunction(parameters, propertySpec, stops);\n    }\n}\nfunction convertIdentityFunction(parameters, propertySpec) {\n    var get = [\n        'get',\n        parameters.property\n    ];\n    if (parameters.default === undefined) {\n        return propertySpec.type === 'string' ? [\n            'string',\n            get\n        ] : get;\n    } else if (propertySpec.type === 'enum') {\n        return [\n            'match',\n            get,\n            Object.keys(propertySpec.values),\n            get,\n            parameters.default\n        ];\n    } else {\n        var expression = [\n            propertySpec.type === 'color' ? 'to-color' : propertySpec.type,\n            get,\n            convertLiteral(parameters.default)\n        ];\n        if (propertySpec.type === 'array') {\n            expression.splice(1, 0, propertySpec.value, propertySpec.length || null);\n        }\n        return expression;\n    }\n}\nfunction getInterpolateOperator(parameters) {\n    switch (parameters.colorSpace) {\n    case 'hcl':\n        return 'interpolate-hcl';\n    case 'lab':\n        return 'interpolate-lab';\n    default:\n        return 'interpolate';\n    }\n}\nfunction convertZoomAndPropertyFunction(parameters, propertySpec, stops) {\n    var featureFunctionParameters = {};\n    var featureFunctionStops = {};\n    var zoomStops = [];\n    for (var s = 0; s < stops.length; s++) {\n        var stop = stops[s];\n        var zoom = stop[0].zoom;\n        if (featureFunctionParameters[zoom] === undefined) {\n            featureFunctionParameters[zoom] = {\n                zoom: zoom,\n                type: parameters.type,\n                property: parameters.property,\n                default: parameters.default\n            };\n            featureFunctionStops[zoom] = [];\n            zoomStops.push(zoom);\n        }\n        featureFunctionStops[zoom].push([\n            stop[0].value,\n            stop[1]\n        ]);\n    }\n    var functionType = getFunctionType({}, propertySpec);\n    if (functionType === 'exponential') {\n        var expression = [\n            getInterpolateOperator(parameters),\n            ['linear'],\n            ['zoom']\n        ];\n        for (var i = 0, list = zoomStops; i < list.length; i += 1) {\n            var z = list[i];\n            var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);\n            appendStopPair(expression, z, output, false);\n        }\n        return expression;\n    } else {\n        var expression$1 = [\n            'step',\n            ['zoom']\n        ];\n        for (var i$1 = 0, list$1 = zoomStops; i$1 < list$1.length; i$1 += 1) {\n            var z$1 = list$1[i$1];\n            var output$1 = convertPropertyFunction(featureFunctionParameters[z$1], propertySpec, featureFunctionStops[z$1]);\n            appendStopPair(expression$1, z$1, output$1, true);\n        }\n        fixupDegenerateStepCurve(expression$1);\n        return expression$1;\n    }\n}\nfunction coalesce$1(a, b) {\n    if (a !== undefined) {\n        return a;\n    }\n    if (b !== undefined) {\n        return b;\n    }\n}\nfunction convertPropertyFunction(parameters, propertySpec, stops) {\n    var type = getFunctionType(parameters, propertySpec);\n    var get = [\n        'get',\n        parameters.property\n    ];\n    if (type === 'categorical' && typeof stops[0][0] === 'boolean') {\n        var expression = ['case'];\n        for (var i = 0, list = stops; i < list.length; i += 1) {\n            var stop = list[i];\n            expression.push([\n                '==',\n                get,\n                stop[0]\n            ], stop[1]);\n        }\n        expression.push(convertLiteral(coalesce$1(parameters.default, propertySpec.default)));\n        return expression;\n    } else if (type === 'categorical') {\n        var expression$1 = [\n            'match',\n            get\n        ];\n        for (var i$1 = 0, list$1 = stops; i$1 < list$1.length; i$1 += 1) {\n            var stop$1 = list$1[i$1];\n            appendStopPair(expression$1, stop$1[0], stop$1[1], false);\n        }\n        expression$1.push(convertLiteral(coalesce$1(parameters.default, propertySpec.default)));\n        return expression$1;\n    } else if (type === 'interval') {\n        var expression$2 = [\n            'step',\n            [\n                'number',\n                get\n            ]\n        ];\n        for (var i$2 = 0, list$2 = stops; i$2 < list$2.length; i$2 += 1) {\n            var stop$2 = list$2[i$2];\n            appendStopPair(expression$2, stop$2[0], stop$2[1], true);\n        }\n        fixupDegenerateStepCurve(expression$2);\n        return parameters.default === undefined ? expression$2 : [\n            'case',\n            [\n                '==',\n                [\n                    'typeof',\n                    get\n                ],\n                'number'\n            ],\n            expression$2,\n            convertLiteral(parameters.default)\n        ];\n    } else if (type === 'exponential') {\n        var base = parameters.base !== undefined ? parameters.base : 1;\n        var expression$3 = [\n            getInterpolateOperator(parameters),\n            base === 1 ? ['linear'] : [\n                'exponential',\n                base\n            ],\n            [\n                'number',\n                get\n            ]\n        ];\n        for (var i$3 = 0, list$3 = stops; i$3 < list$3.length; i$3 += 1) {\n            var stop$3 = list$3[i$3];\n            appendStopPair(expression$3, stop$3[0], stop$3[1], false);\n        }\n        return parameters.default === undefined ? expression$3 : [\n            'case',\n            [\n                '==',\n                [\n                    'typeof',\n                    get\n                ],\n                'number'\n            ],\n            expression$3,\n            convertLiteral(parameters.default)\n        ];\n    } else {\n        throw new Error('Unknown property function type ' + type);\n    }\n}\nfunction convertZoomFunction(parameters, propertySpec, stops, input) {\n    if (input === void 0)\n        input = ['zoom'];\n    var type = getFunctionType(parameters, propertySpec);\n    var expression;\n    var isStep = false;\n    if (type === 'interval') {\n        expression = [\n            'step',\n            input\n        ];\n        isStep = true;\n    } else if (type === 'exponential') {\n        var base = parameters.base !== undefined ? parameters.base : 1;\n        expression = [\n            getInterpolateOperator(parameters),\n            base === 1 ? ['linear'] : [\n                'exponential',\n                base\n            ],\n            input\n        ];\n    } else {\n        throw new Error('Unknown zoom function type \"' + type + '\"');\n    }\n    for (var i = 0, list = stops; i < list.length; i += 1) {\n        var stop = list[i];\n        appendStopPair(expression, stop[0], stop[1], isStep);\n    }\n    fixupDegenerateStepCurve(expression);\n    return expression;\n}\nfunction fixupDegenerateStepCurve(expression) {\n    if (expression[0] === 'step' && expression.length === 3) {\n        expression.push(0);\n        expression.push(expression[3]);\n    }\n}\nfunction appendStopPair(curve, input, output, isStep) {\n    if (curve.length > 3 && input === curve[curve.length - 2]) {\n        return;\n    }\n    if (!(isStep && curve.length === 2)) {\n        curve.push(input);\n    }\n    curve.push(output);\n}\nfunction getFunctionType(parameters, propertySpec) {\n    if (parameters.type) {\n        return parameters.type;\n    } else {\n        return propertySpec.expression.interpolated ? 'exponential' : 'interval';\n    }\n}\nfunction convertTokenString(s) {\n    var result = ['concat'];\n    var re = /{([^{}]+)}/g;\n    var pos = 0;\n    for (var match = re.exec(s); match !== null; match = re.exec(s)) {\n        var literal = s.slice(pos, re.lastIndex - match[0].length);\n        pos = re.lastIndex;\n        if (literal.length > 0) {\n            result.push(literal);\n        }\n        result.push([\n            'get',\n            match[1]\n        ]);\n    }\n    if (result.length === 1) {\n        return s;\n    }\n    if (pos < s.length) {\n        result.push(s.slice(pos));\n    } else if (result.length === 2) {\n        return [\n            'to-string',\n            result[1]\n        ];\n    }\n    return result;\n}\n\nfunction isExpressionFilter(filter) {\n    if (filter === true || filter === false) {\n        return true;\n    }\n    if (!Array.isArray(filter) || filter.length === 0) {\n        return false;\n    }\n    switch (filter[0]) {\n    case 'has':\n        return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';\n    case 'in':\n        return filter.length >= 3 && Array.isArray(filter[2]);\n    case '!in':\n    case '!has':\n    case 'none':\n        return false;\n    case '==':\n    case '!=':\n    case '>':\n    case '>=':\n    case '<':\n    case '<=':\n        return filter.length !== 3 || (Array.isArray(filter[1]) || Array.isArray(filter[2]));\n    case 'any':\n    case 'all':\n        for (var i = 0, list = filter.slice(1); i < list.length; i += 1) {\n            var f = list[i];\n            if (!isExpressionFilter(f) && typeof f !== 'boolean') {\n                return false;\n            }\n        }\n        return true;\n    default:\n        return true;\n    }\n}\nvar filterSpec = {\n    'type': 'boolean',\n    'default': false,\n    'transition': false,\n    'property-type': 'data-driven',\n    'expression': {\n        'interpolated': false,\n        'parameters': [\n            'zoom',\n            'feature'\n        ]\n    }\n};\nfunction createFilter(filter) {\n    if (filter === null || filter === undefined) {\n        return function () {\n            return true;\n        };\n    }\n    if (!isExpressionFilter(filter)) {\n        filter = convertFilter(filter);\n    }\n    var compiled = createExpression(filter, filterSpec);\n    if (compiled.result === 'error') {\n        throw new Error(compiled.value.map(function (err) {\n            return err.key + ': ' + err.message;\n        }).join(', '));\n    } else {\n        return function (globalProperties, feature) {\n            return compiled.value.evaluate(globalProperties, feature);\n        };\n    }\n}\nfunction compare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\nfunction convertFilter(filter) {\n    if (!filter) {\n        return true;\n    }\n    var op = filter[0];\n    if (filter.length <= 1) {\n        return op !== 'any';\n    }\n    var converted = op === '==' ? convertComparisonOp(filter[1], filter[2], '==') : op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) : op === '<' || op === '>' || op === '<=' || op === '>=' ? convertComparisonOp(filter[1], filter[2], op) : op === 'any' ? convertDisjunctionOp(filter.slice(1)) : op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) : op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === 'in' ? convertInOp(filter[1], filter.slice(2)) : op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === 'has' ? convertHasOp(filter[1]) : op === '!has' ? convertNegation(convertHasOp(filter[1])) : true;\n    return converted;\n}\nfunction convertComparisonOp(property, value, op) {\n    switch (property) {\n    case '$type':\n        return [\n            'filter-type-' + op,\n            value\n        ];\n    case '$id':\n        return [\n            'filter-id-' + op,\n            value\n        ];\n    default:\n        return [\n            'filter-' + op,\n            property,\n            value\n        ];\n    }\n}\nfunction convertDisjunctionOp(filters) {\n    return ['any'].concat(filters.map(convertFilter));\n}\nfunction convertInOp(property, values) {\n    if (values.length === 0) {\n        return false;\n    }\n    switch (property) {\n    case '$type':\n        return [\n            'filter-type-in',\n            [\n                'literal',\n                values\n            ]\n        ];\n    case '$id':\n        return [\n            'filter-id-in',\n            [\n                'literal',\n                values\n            ]\n        ];\n    default:\n        if (values.length > 200 && !values.some(function (v) {\n                return typeof v !== typeof values[0];\n            })) {\n            return [\n                'filter-in-large',\n                property,\n                [\n                    'literal',\n                    values.sort(compare)\n                ]\n            ];\n        } else {\n            return [\n                'filter-in-small',\n                property,\n                [\n                    'literal',\n                    values\n                ]\n            ];\n        }\n    }\n}\nfunction convertHasOp(property) {\n    switch (property) {\n    case '$type':\n        return true;\n    case '$id':\n        return ['filter-has-id'];\n    default:\n        return [\n            'filter-has',\n            property\n        ];\n    }\n}\nfunction convertNegation(filter) {\n    return [\n        '!',\n        filter\n    ];\n}\n\nfunction convertFilter$1(filter) {\n    return _convertFilter(filter, {});\n}\nfunction _convertFilter(filter, expectedTypes) {\n    var ref$1;\n    if (isExpressionFilter(filter)) {\n        return filter;\n    }\n    if (!filter) {\n        return true;\n    }\n    var op = filter[0];\n    if (filter.length <= 1) {\n        return op !== 'any';\n    }\n    var converted;\n    if (op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=') {\n        var ref = filter;\n        var property = ref[1];\n        var value = ref[2];\n        converted = convertComparisonOp$1(property, value, op, expectedTypes);\n    } else if (op === 'any') {\n        var children = filter.slice(1).map(function (f) {\n            var types = {};\n            var child = _convertFilter(f, types);\n            var typechecks = runtimeTypeChecks(types);\n            return typechecks === true ? child : [\n                'case',\n                typechecks,\n                child,\n                false\n            ];\n        });\n        return ['any'].concat(children);\n    } else if (op === 'all') {\n        var children$1 = filter.slice(1).map(function (f) {\n            return _convertFilter(f, expectedTypes);\n        });\n        return children$1.length > 1 ? ['all'].concat(children$1) : (ref$1 = []).concat.apply(ref$1, children$1);\n    } else if (op === 'none') {\n        return [\n            '!',\n            _convertFilter(['any'].concat(filter.slice(1)), {})\n        ];\n    } else if (op === 'in') {\n        converted = convertInOp$1(filter[1], filter.slice(2));\n    } else if (op === '!in') {\n        converted = convertInOp$1(filter[1], filter.slice(2), true);\n    } else if (op === 'has') {\n        converted = convertHasOp$1(filter[1]);\n    } else if (op === '!has') {\n        converted = [\n            '!',\n            convertHasOp$1(filter[1])\n        ];\n    } else {\n        converted = true;\n    }\n    return converted;\n}\nfunction runtimeTypeChecks(expectedTypes) {\n    var conditions = [];\n    for (var property in expectedTypes) {\n        var get = property === '$id' ? ['id'] : [\n            'get',\n            property\n        ];\n        conditions.push([\n            '==',\n            [\n                'typeof',\n                get\n            ],\n            expectedTypes[property]\n        ]);\n    }\n    if (conditions.length === 0) {\n        return true;\n    }\n    if (conditions.length === 1) {\n        return conditions[0];\n    }\n    return ['all'].concat(conditions);\n}\nfunction convertComparisonOp$1(property, value, op, expectedTypes) {\n    var get;\n    if (property === '$type') {\n        return [\n            op,\n            ['geometry-type'],\n            value\n        ];\n    } else if (property === '$id') {\n        get = ['id'];\n    } else {\n        get = [\n            'get',\n            property\n        ];\n    }\n    if (expectedTypes && value !== null) {\n        var type = typeof value;\n        expectedTypes[property] = type;\n    }\n    if (op === '==' && property !== '$id' && value === null) {\n        return [\n            'all',\n            [\n                'has',\n                property\n            ],\n            [\n                '==',\n                get,\n                null\n            ]\n        ];\n    } else if (op === '!=' && property !== '$id' && value === null) {\n        return [\n            'any',\n            [\n                '!',\n                [\n                    'has',\n                    property\n                ]\n            ],\n            [\n                '!=',\n                get,\n                null\n            ]\n        ];\n    }\n    return [\n        op,\n        get,\n        value\n    ];\n}\nfunction convertInOp$1(property, values, negate) {\n    if (negate === void 0)\n        negate = false;\n    if (values.length === 0) {\n        return negate;\n    }\n    var get;\n    if (property === '$type') {\n        get = ['geometry-type'];\n    } else if (property === '$id') {\n        get = ['id'];\n    } else {\n        get = [\n            'get',\n            property\n        ];\n    }\n    var uniformTypes = true;\n    var type = typeof values[0];\n    for (var i = 0, list = values; i < list.length; i += 1) {\n        var value = list[i];\n        if (typeof value !== type) {\n            uniformTypes = false;\n            break;\n        }\n    }\n    if (uniformTypes && (type === 'string' || type === 'number')) {\n        var uniqueValues = values.sort().filter(function (v, i) {\n            return i === 0 || values[i - 1] !== v;\n        });\n        return [\n            'match',\n            get,\n            uniqueValues,\n            !negate,\n            negate\n        ];\n    }\n    return [negate ? 'all' : 'any'].concat(values.map(function (v) {\n        return [\n            negate ? '!=' : '==',\n            get,\n            v\n        ];\n    }));\n}\nfunction convertHasOp$1(property) {\n    if (property === '$type') {\n        return true;\n    } else if (property === '$id') {\n        return [\n            '!=',\n            ['id'],\n            null\n        ];\n    } else {\n        return [\n            'has',\n            property\n        ];\n    }\n}\n\nfunction migrateToExpressions (style) {\n    var converted = [];\n    eachLayer(style, function (layer) {\n        if (layer.filter) {\n            layer.filter = convertFilter$1(layer.filter);\n        }\n    });\n    eachProperty(style, {\n        paint: true,\n        layout: true\n    }, function (ref) {\n        var path = ref.path;\n        var value = ref.value;\n        var reference = ref.reference;\n        var set = ref.set;\n        if (isExpression(value)) {\n            return;\n        }\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            set(convertFunction(value, reference));\n            converted.push(path.join('.'));\n        } else if (reference.tokens && typeof value === 'string') {\n            set(convertTokenString(value));\n        }\n    });\n    return style;\n}\n\nfunction migrate (style) {\n    var migrated = false;\n    if (style.version === 7) {\n        style = migrateToV8(style);\n        migrated = true;\n    }\n    if (style.version === 8) {\n        migrated = migrateToExpressions(style);\n        migrated = true;\n    }\n    if (!migrated) {\n        throw new Error('cannot migrate from', style.version);\n    }\n    return style;\n}\n\nfunction composite (style) {\n    var styleIDs = [];\n    var sourceIDs = [];\n    var compositedSourceLayers = [];\n    for (var id in style.sources) {\n        var source = style.sources[id];\n        if (source.type !== 'vector') {\n            continue;\n        }\n        var match = /^mapbox:\\/\\/(.*)/.exec(source.url);\n        if (!match) {\n            continue;\n        }\n        styleIDs.push(id);\n        sourceIDs.push(match[1]);\n    }\n    if (styleIDs.length < 2) {\n        return style;\n    }\n    styleIDs.forEach(function (id) {\n        delete style.sources[id];\n    });\n    var compositeID = sourceIDs.join(',');\n    style.sources[compositeID] = {\n        'type': 'vector',\n        'url': 'mapbox://' + compositeID\n    };\n    style.layers.forEach(function (layer) {\n        if (styleIDs.indexOf(layer.source) >= 0) {\n            layer.source = compositeID;\n            if ('source-layer' in layer) {\n                if (compositedSourceLayers.indexOf(layer['source-layer']) >= 0) {\n                    throw new Error('Conflicting source layer names');\n                } else {\n                    compositedSourceLayers.push(layer['source-layer']);\n                }\n            }\n        }\n    });\n    return style;\n}\n\nvar refProperties = [\n    'type',\n    'source',\n    'source-layer',\n    'minzoom',\n    'maxzoom',\n    'filter',\n    'layout'\n];\n\nfunction deref(layer, parent) {\n    var result = {};\n    for (var k in layer) {\n        if (k !== 'ref') {\n            result[k] = layer[k];\n        }\n    }\n    refProperties.forEach(function (k) {\n        if (k in parent) {\n            result[k] = parent[k];\n        }\n    });\n    return result;\n}\nfunction derefLayers(layers) {\n    layers = layers.slice();\n    var map = Object.create(null);\n    for (var i = 0; i < layers.length; i++) {\n        map[layers[i].id] = layers[i];\n    }\n    for (var i$1 = 0; i$1 < layers.length; i$1++) {\n        if ('ref' in layers[i$1]) {\n            layers[i$1] = deref(layers[i$1], map[layers[i$1].ref]);\n        }\n    }\n    return layers;\n}\n\nfunction deepEqual(a, b) {\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b) || a.length !== b.length) {\n            return false;\n        }\n        for (var i = 0; i < a.length; i++) {\n            if (!deepEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeof a === 'object' && a !== null && b !== null) {\n        if (!(typeof b === 'object')) {\n            return false;\n        }\n        var keys = Object.keys(a);\n        if (keys.length !== Object.keys(b).length) {\n            return false;\n        }\n        for (var key in a) {\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b;\n}\n\nvar operations = {\n    setStyle: 'setStyle',\n    addLayer: 'addLayer',\n    removeLayer: 'removeLayer',\n    setPaintProperty: 'setPaintProperty',\n    setLayoutProperty: 'setLayoutProperty',\n    setFilter: 'setFilter',\n    addSource: 'addSource',\n    removeSource: 'removeSource',\n    setGeoJSONSourceData: 'setGeoJSONSourceData',\n    setLayerZoomRange: 'setLayerZoomRange',\n    setLayerProperty: 'setLayerProperty',\n    setCenter: 'setCenter',\n    setZoom: 'setZoom',\n    setBearing: 'setBearing',\n    setPitch: 'setPitch',\n    setSprite: 'setSprite',\n    setGlyphs: 'setGlyphs',\n    setTransition: 'setTransition',\n    setLight: 'setLight'\n};\nfunction addSource(sourceId, after, commands) {\n    commands.push({\n        command: operations.addSource,\n        args: [\n            sourceId,\n            after[sourceId]\n        ]\n    });\n}\nfunction removeSource(sourceId, commands, sourcesRemoved) {\n    commands.push({\n        command: operations.removeSource,\n        args: [sourceId]\n    });\n    sourcesRemoved[sourceId] = true;\n}\nfunction updateSource(sourceId, after, commands, sourcesRemoved) {\n    removeSource(sourceId, commands, sourcesRemoved);\n    addSource(sourceId, after, commands);\n}\nfunction canUpdateGeoJSON(before, after, sourceId) {\n    var prop;\n    for (prop in before[sourceId]) {\n        if (!before[sourceId].hasOwnProperty(prop)) {\n            continue;\n        }\n        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {\n            return false;\n        }\n    }\n    for (prop in after[sourceId]) {\n        if (!after[sourceId].hasOwnProperty(prop)) {\n            continue;\n        }\n        if (prop !== 'data' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction diffSources(before, after, commands, sourcesRemoved) {\n    before = before || {};\n    after = after || {};\n    var sourceId;\n    for (sourceId in before) {\n        if (!before.hasOwnProperty(sourceId)) {\n            continue;\n        }\n        if (!after.hasOwnProperty(sourceId)) {\n            removeSource(sourceId, commands, sourcesRemoved);\n        }\n    }\n    for (sourceId in after) {\n        if (!after.hasOwnProperty(sourceId)) {\n            continue;\n        }\n        if (!before.hasOwnProperty(sourceId)) {\n            addSource(sourceId, after, commands);\n        } else if (!deepEqual(before[sourceId], after[sourceId])) {\n            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {\n                commands.push({\n                    command: operations.setGeoJSONSourceData,\n                    args: [\n                        sourceId,\n                        after[sourceId].data\n                    ]\n                });\n            } else {\n                updateSource(sourceId, after, commands, sourcesRemoved);\n            }\n        }\n    }\n}\nfunction diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {\n    before = before || {};\n    after = after || {};\n    var prop;\n    for (prop in before) {\n        if (!before.hasOwnProperty(prop)) {\n            continue;\n        }\n        if (!deepEqual(before[prop], after[prop])) {\n            commands.push({\n                command: command,\n                args: [\n                    layerId,\n                    prop,\n                    after[prop],\n                    klass\n                ]\n            });\n        }\n    }\n    for (prop in after) {\n        if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) {\n            continue;\n        }\n        if (!deepEqual(before[prop], after[prop])) {\n            commands.push({\n                command: command,\n                args: [\n                    layerId,\n                    prop,\n                    after[prop],\n                    klass\n                ]\n            });\n        }\n    }\n}\nfunction pluckId(layer) {\n    return layer.id;\n}\nfunction indexById(group, layer) {\n    group[layer.id] = layer;\n    return group;\n}\nfunction diffLayers(before, after, commands) {\n    before = before || [];\n    after = after || [];\n    var beforeOrder = before.map(pluckId);\n    var afterOrder = after.map(pluckId);\n    var beforeIndex = before.reduce(indexById, {});\n    var afterIndex = after.reduce(indexById, {});\n    var tracker = beforeOrder.slice();\n    var clean = Object.create(null);\n    var i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;\n    for (i = 0, d = 0; i < beforeOrder.length; i++) {\n        layerId = beforeOrder[i];\n        if (!afterIndex.hasOwnProperty(layerId)) {\n            commands.push({\n                command: operations.removeLayer,\n                args: [layerId]\n            });\n            tracker.splice(tracker.indexOf(layerId, d), 1);\n        } else {\n            d++;\n        }\n    }\n    for (i = 0, d = 0; i < afterOrder.length; i++) {\n        layerId = afterOrder[afterOrder.length - 1 - i];\n        if (tracker[tracker.length - 1 - i] === layerId) {\n            continue;\n        }\n        if (beforeIndex.hasOwnProperty(layerId)) {\n            commands.push({\n                command: operations.removeLayer,\n                args: [layerId]\n            });\n            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);\n        } else {\n            d++;\n        }\n        insertBeforeLayerId = tracker[tracker.length - i];\n        commands.push({\n            command: operations.addLayer,\n            args: [\n                afterIndex[layerId],\n                insertBeforeLayerId\n            ]\n        });\n        tracker.splice(tracker.length - i, 0, layerId);\n        clean[layerId] = true;\n    }\n    for (i = 0; i < afterOrder.length; i++) {\n        layerId = afterOrder[i];\n        beforeLayer = beforeIndex[layerId];\n        afterLayer = afterIndex[layerId];\n        if (clean[layerId] || deepEqual(beforeLayer, afterLayer)) {\n            continue;\n        }\n        if (!deepEqual(beforeLayer.source, afterLayer.source) || !deepEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !deepEqual(beforeLayer.type, afterLayer.type)) {\n            commands.push({\n                command: operations.removeLayer,\n                args: [layerId]\n            });\n            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];\n            commands.push({\n                command: operations.addLayer,\n                args: [\n                    afterLayer,\n                    insertBeforeLayerId\n                ]\n            });\n            continue;\n        }\n        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);\n        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);\n        if (!deepEqual(beforeLayer.filter, afterLayer.filter)) {\n            commands.push({\n                command: operations.setFilter,\n                args: [\n                    layerId,\n                    afterLayer.filter\n                ]\n            });\n        }\n        if (!deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {\n            commands.push({\n                command: operations.setLayerZoomRange,\n                args: [\n                    layerId,\n                    afterLayer.minzoom,\n                    afterLayer.maxzoom\n                ]\n            });\n        }\n        for (prop in beforeLayer) {\n            if (!beforeLayer.hasOwnProperty(prop)) {\n                continue;\n            }\n            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {\n                continue;\n            }\n            if (prop.indexOf('paint.') === 0) {\n                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {\n                commands.push({\n                    command: operations.setLayerProperty,\n                    args: [\n                        layerId,\n                        prop,\n                        afterLayer[prop]\n                    ]\n                });\n            }\n        }\n        for (prop in afterLayer) {\n            if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) {\n                continue;\n            }\n            if (prop === 'layout' || prop === 'paint' || prop === 'filter' || prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') {\n                continue;\n            }\n            if (prop.indexOf('paint.') === 0) {\n                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n            } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {\n                commands.push({\n                    command: operations.setLayerProperty,\n                    args: [\n                        layerId,\n                        prop,\n                        afterLayer[prop]\n                    ]\n                });\n            }\n        }\n    }\n}\nfunction diffStyles(before, after) {\n    if (!before) {\n        return [{\n                command: operations.setStyle,\n                args: [after]\n            }];\n    }\n    var commands = [];\n    try {\n        if (!deepEqual(before.version, after.version)) {\n            return [{\n                    command: operations.setStyle,\n                    args: [after]\n                }];\n        }\n        if (!deepEqual(before.center, after.center)) {\n            commands.push({\n                command: operations.setCenter,\n                args: [after.center]\n            });\n        }\n        if (!deepEqual(before.zoom, after.zoom)) {\n            commands.push({\n                command: operations.setZoom,\n                args: [after.zoom]\n            });\n        }\n        if (!deepEqual(before.bearing, after.bearing)) {\n            commands.push({\n                command: operations.setBearing,\n                args: [after.bearing]\n            });\n        }\n        if (!deepEqual(before.pitch, after.pitch)) {\n            commands.push({\n                command: operations.setPitch,\n                args: [after.pitch]\n            });\n        }\n        if (!deepEqual(before.sprite, after.sprite)) {\n            commands.push({\n                command: operations.setSprite,\n                args: [after.sprite]\n            });\n        }\n        if (!deepEqual(before.glyphs, after.glyphs)) {\n            commands.push({\n                command: operations.setGlyphs,\n                args: [after.glyphs]\n            });\n        }\n        if (!deepEqual(before.transition, after.transition)) {\n            commands.push({\n                command: operations.setTransition,\n                args: [after.transition]\n            });\n        }\n        if (!deepEqual(before.light, after.light)) {\n            commands.push({\n                command: operations.setLight,\n                args: [after.light]\n            });\n        }\n        var sourcesRemoved = {};\n        var removeOrAddSourceCommands = [];\n        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);\n        var beforeLayers = [];\n        if (before.layers) {\n            before.layers.forEach(function (layer) {\n                if (sourcesRemoved[layer.source]) {\n                    commands.push({\n                        command: operations.removeLayer,\n                        args: [layer.id]\n                    });\n                } else {\n                    beforeLayers.push(layer);\n                }\n            });\n        }\n        commands = commands.concat(removeOrAddSourceCommands);\n        diffLayers(beforeLayers, after.layers, commands);\n    } catch (e) {\n        console.warn('Unable to compute style diff:', e);\n        commands = [{\n                command: operations.setStyle,\n                args: [after]\n            }];\n    }\n    return commands;\n}\n\nvar ValidationError = function ValidationError(key, value, message, identifier) {\n    this.message = (key ? key + ': ' : '') + message;\n    if (identifier) {\n        this.identifier = identifier;\n    }\n    if (value !== null && value !== undefined && value.__line__) {\n        this.line = value.__line__;\n    }\n};\n\nvar ParsingError$1 = function ParsingError(error) {\n    this.error = error;\n    this.message = error.message;\n    var match = error.message.match(/line (\\d+)/);\n    this.line = match ? parseInt(match[1], 10) : 0;\n};\n\nfunction validateConstants(options) {\n    var key = options.key;\n    var constants = options.value;\n    if (constants) {\n        return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];\n    } else {\n        return [];\n    }\n}\n\nfunction unbundle(value) {\n    if (value instanceof Number || value instanceof String || value instanceof Boolean) {\n        return value.valueOf();\n    } else {\n        return value;\n    }\n}\nfunction deepUnbundle(value) {\n    if (Array.isArray(value)) {\n        return value.map(deepUnbundle);\n    } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {\n        var unbundledValue = {};\n        for (var key in value) {\n            unbundledValue[key] = deepUnbundle(value[key]);\n        }\n        return unbundledValue;\n    }\n    return unbundle(value);\n}\n\nfunction validateObject(options) {\n    var key = options.key;\n    var object = options.value;\n    var elementSpecs = options.valueSpec || {};\n    var elementValidators = options.objectElementValidators || {};\n    var style = options.style;\n    var styleSpec = options.styleSpec;\n    var errors = [];\n    var type = getType(object);\n    if (type !== 'object') {\n        return [new ValidationError(key, object, 'object expected, ' + type + ' found')];\n    }\n    for (var objectKey in object) {\n        var elementSpecKey = objectKey.split('.')[0];\n        var elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];\n        var validateElement = void 0;\n        if (elementValidators[elementSpecKey]) {\n            validateElement = elementValidators[elementSpecKey];\n        } else if (elementSpecs[elementSpecKey]) {\n            validateElement = validate;\n        } else if (elementValidators['*']) {\n            validateElement = elementValidators['*'];\n        } else if (elementSpecs['*']) {\n            validateElement = validate;\n        } else {\n            errors.push(new ValidationError(key, object[objectKey], 'unknown property \"' + objectKey + '\"'));\n            continue;\n        }\n        errors = errors.concat(validateElement({\n            key: (key ? key + '.' : key) + objectKey,\n            value: object[objectKey],\n            valueSpec: elementSpec,\n            style: style,\n            styleSpec: styleSpec,\n            object: object,\n            objectKey: objectKey\n        }, object));\n    }\n    for (var elementSpecKey$1 in elementSpecs) {\n        if (elementValidators[elementSpecKey$1]) {\n            continue;\n        }\n        if (elementSpecs[elementSpecKey$1].required && elementSpecs[elementSpecKey$1]['default'] === undefined && object[elementSpecKey$1] === undefined) {\n            errors.push(new ValidationError(key, object, 'missing required property \"' + elementSpecKey$1 + '\"'));\n        }\n    }\n    return errors;\n}\n\nfunction validateArray(options) {\n    var array = options.value;\n    var arraySpec = options.valueSpec;\n    var style = options.style;\n    var styleSpec = options.styleSpec;\n    var key = options.key;\n    var validateArrayElement = options.arrayElementValidator || validate;\n    if (getType(array) !== 'array') {\n        return [new ValidationError(key, array, 'array expected, ' + getType(array) + ' found')];\n    }\n    if (arraySpec.length && array.length !== arraySpec.length) {\n        return [new ValidationError(key, array, 'array length ' + arraySpec.length + ' expected, length ' + array.length + ' found')];\n    }\n    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {\n        return [new ValidationError(key, array, 'array length at least ' + arraySpec['min-length'] + ' expected, length ' + array.length + ' found')];\n    }\n    var arrayElementSpec = {\n        'type': arraySpec.value,\n        'values': arraySpec.values\n    };\n    if (styleSpec.$version < 7) {\n        arrayElementSpec.function = arraySpec.function;\n    }\n    if (getType(arraySpec.value) === 'object') {\n        arrayElementSpec = arraySpec.value;\n    }\n    var errors = [];\n    for (var i = 0; i < array.length; i++) {\n        errors = errors.concat(validateArrayElement({\n            array: array,\n            arrayIndex: i,\n            value: array[i],\n            valueSpec: arrayElementSpec,\n            style: style,\n            styleSpec: styleSpec,\n            key: key + '[' + i + ']'\n        }));\n    }\n    return errors;\n}\n\nfunction validateNumber(options) {\n    var key = options.key;\n    var value = options.value;\n    var valueSpec = options.valueSpec;\n    var type = getType(value);\n    if (type === 'number' && value !== value) {\n        type = 'NaN';\n    }\n    if (type !== 'number') {\n        return [new ValidationError(key, value, 'number expected, ' + type + ' found')];\n    }\n    if ('minimum' in valueSpec && value < valueSpec.minimum) {\n        return [new ValidationError(key, value, value + ' is less than the minimum value ' + valueSpec.minimum)];\n    }\n    if ('maximum' in valueSpec && value > valueSpec.maximum) {\n        return [new ValidationError(key, value, value + ' is greater than the maximum value ' + valueSpec.maximum)];\n    }\n    return [];\n}\n\nfunction validateFunction(options) {\n    var functionValueSpec = options.valueSpec;\n    var functionType = unbundle(options.value.type);\n    var stopKeyType;\n    var stopDomainValues = {};\n    var previousStopDomainValue;\n    var previousStopDomainZoom;\n    var isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;\n    var isPropertyFunction = !isZoomFunction;\n    var isZoomAndPropertyFunction = getType(options.value.stops) === 'array' && getType(options.value.stops[0]) === 'array' && getType(options.value.stops[0][0]) === 'object';\n    var errors = validateObject({\n        key: options.key,\n        value: options.value,\n        valueSpec: options.styleSpec.function,\n        style: options.style,\n        styleSpec: options.styleSpec,\n        objectElementValidators: {\n            stops: validateFunctionStops,\n            default: validateFunctionDefault\n        }\n    });\n    if (functionType === 'identity' && isZoomFunction) {\n        errors.push(new ValidationError(options.key, options.value, 'missing required property \"property\"'));\n    }\n    if (functionType !== 'identity' && !options.value.stops) {\n        errors.push(new ValidationError(options.key, options.value, 'missing required property \"stops\"'));\n    }\n    if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {\n        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));\n    }\n    if (options.styleSpec.$version >= 8) {\n        if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {\n            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));\n        } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {\n            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));\n        }\n    }\n    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {\n        errors.push(new ValidationError(options.key, options.value, '\"property\" property is required'));\n    }\n    return errors;\n    function validateFunctionStops(options) {\n        if (functionType === 'identity') {\n            return [new ValidationError(options.key, options.value, 'identity function may not have a \"stops\" property')];\n        }\n        var errors = [];\n        var value = options.value;\n        errors = errors.concat(validateArray({\n            key: options.key,\n            value: value,\n            valueSpec: options.valueSpec,\n            style: options.style,\n            styleSpec: options.styleSpec,\n            arrayElementValidator: validateFunctionStop\n        }));\n        if (getType(value) === 'array' && value.length === 0) {\n            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));\n        }\n        return errors;\n    }\n    function validateFunctionStop(options) {\n        var errors = [];\n        var value = options.value;\n        var key = options.key;\n        if (getType(value) !== 'array') {\n            return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];\n        }\n        if (value.length !== 2) {\n            return [new ValidationError(key, value, 'array length 2 expected, length ' + value.length + ' found')];\n        }\n        if (isZoomAndPropertyFunction) {\n            if (getType(value[0]) !== 'object') {\n                return [new ValidationError(key, value, 'object expected, ' + getType(value[0]) + ' found')];\n            }\n            if (value[0].zoom === undefined) {\n                return [new ValidationError(key, value, 'object stop key must have zoom')];\n            }\n            if (value[0].value === undefined) {\n                return [new ValidationError(key, value, 'object stop key must have value')];\n            }\n            if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {\n                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];\n            }\n            if (unbundle(value[0].zoom) !== previousStopDomainZoom) {\n                previousStopDomainZoom = unbundle(value[0].zoom);\n                previousStopDomainValue = undefined;\n                stopDomainValues = {};\n            }\n            errors = errors.concat(validateObject({\n                key: key + '[0]',\n                value: value[0],\n                valueSpec: { zoom: {} },\n                style: options.style,\n                styleSpec: options.styleSpec,\n                objectElementValidators: {\n                    zoom: validateNumber,\n                    value: validateStopDomainValue\n                }\n            }));\n        } else {\n            errors = errors.concat(validateStopDomainValue({\n                key: key + '[0]',\n                value: value[0],\n                valueSpec: {},\n                style: options.style,\n                styleSpec: options.styleSpec\n            }, value));\n        }\n        if (isExpression(deepUnbundle(value[1]))) {\n            return errors.concat([new ValidationError(key + '[1]', value[1], 'expressions are not allowed in function stops.')]);\n        }\n        return errors.concat(validate({\n            key: key + '[1]',\n            value: value[1],\n            valueSpec: functionValueSpec,\n            style: options.style,\n            styleSpec: options.styleSpec\n        }));\n    }\n    function validateStopDomainValue(options, stop) {\n        var type = getType(options.value);\n        var value = unbundle(options.value);\n        var reportValue = options.value !== null ? options.value : stop;\n        if (!stopKeyType) {\n            stopKeyType = type;\n        } else if (type !== stopKeyType) {\n            return [new ValidationError(options.key, reportValue, type + ' stop domain type must match previous stop domain type ' + stopKeyType)];\n        }\n        if (type !== 'number' && type !== 'string' && type !== 'boolean') {\n            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];\n        }\n        if (type !== 'number' && functionType !== 'categorical') {\n            var message = 'number expected, ' + type + ' found';\n            if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {\n                message += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.';\n            }\n            return [new ValidationError(options.key, reportValue, message)];\n        }\n        if (functionType === 'categorical' && type === 'number' && (!isFinite(value) || Math.floor(value) !== value)) {\n            return [new ValidationError(options.key, reportValue, 'integer expected, found ' + value)];\n        }\n        if (functionType !== 'categorical' && type === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {\n            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];\n        } else {\n            previousStopDomainValue = value;\n        }\n        if (functionType === 'categorical' && value in stopDomainValues) {\n            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];\n        } else {\n            stopDomainValues[value] = true;\n        }\n        return [];\n    }\n    function validateFunctionDefault(options) {\n        return validate({\n            key: options.key,\n            value: options.value,\n            valueSpec: functionValueSpec,\n            style: options.style,\n            styleSpec: options.styleSpec\n        });\n    }\n}\n\nfunction validateExpression(options) {\n    var expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);\n    if (expression.result === 'error') {\n        return expression.value.map(function (error) {\n            return new ValidationError('' + options.key + error.key, options.value, error.message);\n        });\n    }\n    var expressionObj = expression.value.expression || expression.value._styleExpression.expression;\n    if (options.expressionContext === 'property' && options.propertyKey === 'text-font' && expressionObj.possibleOutputs().indexOf(undefined) !== -1) {\n        return [new ValidationError(options.key, options.value, 'Invalid data expression for \"' + options.propertyKey + '\". Output values must be contained as literals within the expression.')];\n    }\n    if (options.expressionContext === 'property' && options.propertyType === 'layout' && !isStateConstant(expressionObj)) {\n        return [new ValidationError(options.key, options.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n    }\n    if (options.expressionContext === 'filter' && !isStateConstant(expressionObj)) {\n        return [new ValidationError(options.key, options.value, '\"feature-state\" data expressions are not supported with filters.')];\n    }\n    if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {\n        if (!isGlobalPropertyConstant(expressionObj, [\n                'zoom',\n                'feature-state'\n            ])) {\n            return [new ValidationError(options.key, options.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n        }\n        if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {\n            return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];\n        }\n    }\n    return [];\n}\n\nfunction validateBoolean(options) {\n    var value = options.value;\n    var key = options.key;\n    var type = getType(value);\n    if (type !== 'boolean') {\n        return [new ValidationError(key, value, 'boolean expected, ' + type + ' found')];\n    }\n    return [];\n}\n\nfunction validateColor(options) {\n    var key = options.key;\n    var value = options.value;\n    var type = getType(value);\n    if (type !== 'string') {\n        return [new ValidationError(key, value, 'color expected, ' + type + ' found')];\n    }\n    if (csscolorparser_1(value) === null) {\n        return [new ValidationError(key, value, 'color expected, \"' + value + '\" found')];\n    }\n    return [];\n}\n\nfunction validateEnum(options) {\n    var key = options.key;\n    var value = options.value;\n    var valueSpec = options.valueSpec;\n    var errors = [];\n    if (Array.isArray(valueSpec.values)) {\n        if (valueSpec.values.indexOf(unbundle(value)) === -1) {\n            errors.push(new ValidationError(key, value, 'expected one of [' + valueSpec.values.join(', ') + '], ' + JSON.stringify(value) + ' found'));\n        }\n    } else {\n        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {\n            errors.push(new ValidationError(key, value, 'expected one of [' + Object.keys(valueSpec.values).join(', ') + '], ' + JSON.stringify(value) + ' found'));\n        }\n    }\n    return errors;\n}\n\nfunction validateFilter(options) {\n    if (isExpressionFilter(deepUnbundle(options.value))) {\n        return validateExpression(extend({}, options, {\n            expressionContext: 'filter',\n            valueSpec: { value: 'boolean' }\n        }));\n    } else {\n        return validateNonExpressionFilter(options);\n    }\n}\nfunction validateNonExpressionFilter(options) {\n    var value = options.value;\n    var key = options.key;\n    if (getType(value) !== 'array') {\n        return [new ValidationError(key, value, 'array expected, ' + getType(value) + ' found')];\n    }\n    var styleSpec = options.styleSpec;\n    var type;\n    var errors = [];\n    if (value.length < 1) {\n        return [new ValidationError(key, value, 'filter array must have at least 1 element')];\n    }\n    errors = errors.concat(validateEnum({\n        key: key + '[0]',\n        value: value[0],\n        valueSpec: styleSpec.filter_operator,\n        style: options.style,\n        styleSpec: options.styleSpec\n    }));\n    switch (unbundle(value[0])) {\n    case '<':\n    case '<=':\n    case '>':\n    case '>=':\n        if (value.length >= 2 && unbundle(value[1]) === '$type') {\n            errors.push(new ValidationError(key, value, '\"$type\" cannot be use with operator \"' + value[0] + '\"'));\n        }\n    case '==':\n    case '!=':\n        if (value.length !== 3) {\n            errors.push(new ValidationError(key, value, 'filter array for operator \"' + value[0] + '\" must have 3 elements'));\n        }\n    case 'in':\n    case '!in':\n        if (value.length >= 2) {\n            type = getType(value[1]);\n            if (type !== 'string') {\n                errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));\n            }\n        }\n        for (var i = 2; i < value.length; i++) {\n            type = getType(value[i]);\n            if (unbundle(value[1]) === '$type') {\n                errors = errors.concat(validateEnum({\n                    key: key + '[' + i + ']',\n                    value: value[i],\n                    valueSpec: styleSpec.geometry_type,\n                    style: options.style,\n                    styleSpec: options.styleSpec\n                }));\n            } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {\n                errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, ' + type + ' found'));\n            }\n        }\n        break;\n    case 'any':\n    case 'all':\n    case 'none':\n        for (var i$1 = 1; i$1 < value.length; i$1++) {\n            errors = errors.concat(validateNonExpressionFilter({\n                key: key + '[' + i$1 + ']',\n                value: value[i$1],\n                style: options.style,\n                styleSpec: options.styleSpec\n            }));\n        }\n        break;\n    case 'has':\n    case '!has':\n        type = getType(value[1]);\n        if (value.length !== 2) {\n            errors.push(new ValidationError(key, value, 'filter array for \"' + value[0] + '\" operator must have 2 elements'));\n        } else if (type !== 'string') {\n            errors.push(new ValidationError(key + '[1]', value[1], 'string expected, ' + type + ' found'));\n        }\n        break;\n    }\n    return errors;\n}\n\nfunction validateProperty(options, propertyType) {\n    var key = options.key;\n    var style = options.style;\n    var styleSpec = options.styleSpec;\n    var value = options.value;\n    var propertyKey = options.objectKey;\n    var layerSpec = styleSpec[propertyType + '_' + options.layerType];\n    if (!layerSpec) {\n        return [];\n    }\n    var transitionMatch = propertyKey.match(/^(.*)-transition$/);\n    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {\n        return validate({\n            key: key,\n            value: value,\n            valueSpec: styleSpec.transition,\n            style: style,\n            styleSpec: styleSpec\n        });\n    }\n    var valueSpec = options.valueSpec || layerSpec[propertyKey];\n    if (!valueSpec) {\n        return [new ValidationError(key, value, 'unknown property \"' + propertyKey + '\"')];\n    }\n    var tokenMatch;\n    if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {\n        return [new ValidationError(key, value, '\"' + propertyKey + '\" does not support interpolation syntax\\n' + 'Use an identity property function instead: `{ \"type\": \"identity\", \"property\": ' + JSON.stringify(tokenMatch[1]) + ' }`.')];\n    }\n    var errors = [];\n    if (options.layerType === 'symbol') {\n        if (propertyKey === 'text-field' && style && !style.glyphs) {\n            errors.push(new ValidationError(key, value, 'use of \"text-field\" requires a style \"glyphs\" property'));\n        }\n        if (propertyKey === 'text-font' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === 'identity') {\n            errors.push(new ValidationError(key, value, '\"text-font\" does not support identity functions'));\n        }\n    }\n    return errors.concat(validate({\n        key: options.key,\n        value: value,\n        valueSpec: valueSpec,\n        style: style,\n        styleSpec: styleSpec,\n        expressionContext: 'property',\n        propertyType: propertyType,\n        propertyKey: propertyKey\n    }));\n}\n\nfunction validatePaintProperty(options) {\n    return validateProperty(options, 'paint');\n}\n\nfunction validateLayoutProperty(options) {\n    return validateProperty(options, 'layout');\n}\n\nfunction validateLayer(options) {\n    var errors = [];\n    var layer = options.value;\n    var key = options.key;\n    var style = options.style;\n    var styleSpec = options.styleSpec;\n    if (!layer.type && !layer.ref) {\n        errors.push(new ValidationError(key, layer, 'either \"type\" or \"ref\" is required'));\n    }\n    var type = unbundle(layer.type);\n    var ref = unbundle(layer.ref);\n    if (layer.id) {\n        var layerId = unbundle(layer.id);\n        for (var i = 0; i < options.arrayIndex; i++) {\n            var otherLayer = style.layers[i];\n            if (unbundle(otherLayer.id) === layerId) {\n                errors.push(new ValidationError(key, layer.id, 'duplicate layer id \"' + layer.id + '\", previously used at line ' + otherLayer.id.__line__));\n            }\n        }\n    }\n    if ('ref' in layer) {\n        [\n            'type',\n            'source',\n            'source-layer',\n            'filter',\n            'layout'\n        ].forEach(function (p) {\n            if (p in layer) {\n                errors.push(new ValidationError(key, layer[p], '\"' + p + '\" is prohibited for ref layers'));\n            }\n        });\n        var parent;\n        style.layers.forEach(function (layer) {\n            if (unbundle(layer.id) === ref) {\n                parent = layer;\n            }\n        });\n        if (!parent) {\n            errors.push(new ValidationError(key, layer.ref, 'ref layer \"' + ref + '\" not found'));\n        } else if (parent.ref) {\n            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));\n        } else {\n            type = unbundle(parent.type);\n        }\n    } else if (type !== 'background') {\n        if (!layer.source) {\n            errors.push(new ValidationError(key, layer, 'missing required property \"source\"'));\n        } else {\n            var source = style.sources && style.sources[layer.source];\n            var sourceType = source && unbundle(source.type);\n            if (!source) {\n                errors.push(new ValidationError(key, layer.source, 'source \"' + layer.source + '\" not found'));\n            } else if (sourceType === 'vector' && type === 'raster') {\n                errors.push(new ValidationError(key, layer.source, 'layer \"' + layer.id + '\" requires a raster source'));\n            } else if (sourceType === 'raster' && type !== 'raster') {\n                errors.push(new ValidationError(key, layer.source, 'layer \"' + layer.id + '\" requires a vector source'));\n            } else if (sourceType === 'vector' && !layer['source-layer']) {\n                errors.push(new ValidationError(key, layer, 'layer \"' + layer.id + '\" must specify a \"source-layer\"'));\n            } else if (sourceType === 'raster-dem' && type !== 'hillshade') {\n                errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \\'hillshade\\'.'));\n            } else if (type === 'line' && layer.paint && layer.paint['line-gradient'] && (sourceType !== 'geojson' || !source.lineMetrics)) {\n                errors.push(new ValidationError(key, layer, 'layer \"' + layer.id + '\" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'));\n            }\n        }\n    }\n    errors = errors.concat(validateObject({\n        key: key,\n        value: layer,\n        valueSpec: styleSpec.layer,\n        style: options.style,\n        styleSpec: options.styleSpec,\n        objectElementValidators: {\n            '*': function _() {\n                return [];\n            },\n            type: function type() {\n                return validate({\n                    key: key + '.type',\n                    value: layer.type,\n                    valueSpec: styleSpec.layer.type,\n                    style: options.style,\n                    styleSpec: options.styleSpec,\n                    object: layer,\n                    objectKey: 'type'\n                });\n            },\n            filter: validateFilter,\n            layout: function layout(options) {\n                return validateObject({\n                    layer: layer,\n                    key: options.key,\n                    value: options.value,\n                    style: options.style,\n                    styleSpec: options.styleSpec,\n                    objectElementValidators: {\n                        '*': function _(options) {\n                            return validateLayoutProperty(extend({ layerType: type }, options));\n                        }\n                    }\n                });\n            },\n            paint: function paint(options) {\n                return validateObject({\n                    layer: layer,\n                    key: options.key,\n                    value: options.value,\n                    style: options.style,\n                    styleSpec: options.styleSpec,\n                    objectElementValidators: {\n                        '*': function _(options) {\n                            return validatePaintProperty(extend({ layerType: type }, options));\n                        }\n                    }\n                });\n            }\n        }\n    }));\n    return errors;\n}\n\nfunction validateString(options) {\n    var value = options.value;\n    var key = options.key;\n    var type = getType(value);\n    if (type !== 'string') {\n        return [new ValidationError(key, value, 'string expected, ' + type + ' found')];\n    }\n    return [];\n}\n\nvar objectElementValidators = { promoteId: validatePromoteId };\nfunction validateSource(options) {\n    var value = options.value;\n    var key = options.key;\n    var styleSpec = options.styleSpec;\n    var style = options.style;\n    if (!value.type) {\n        return [new ValidationError(key, value, '\"type\" is required')];\n    }\n    var type = unbundle(value.type);\n    var errors;\n    switch (type) {\n    case 'vector':\n    case 'raster':\n    case 'raster-dem':\n        errors = validateObject({\n            key: key,\n            value: value,\n            valueSpec: styleSpec['source_' + type.replace('-', '_')],\n            style: options.style,\n            styleSpec: styleSpec,\n            objectElementValidators: objectElementValidators\n        });\n        return errors;\n    case 'geojson':\n        errors = validateObject({\n            key: key,\n            value: value,\n            valueSpec: styleSpec.source_geojson,\n            style: style,\n            styleSpec: styleSpec,\n            objectElementValidators: objectElementValidators\n        });\n        if (value.cluster) {\n            for (var prop in value.clusterProperties) {\n                var ref = value.clusterProperties[prop];\n                var operator = ref[0];\n                var mapExpr = ref[1];\n                var reduceExpr = typeof operator === 'string' ? [\n                    operator,\n                    ['accumulated'],\n                    [\n                        'get',\n                        prop\n                    ]\n                ] : operator;\n                errors.push.apply(errors, validateExpression({\n                    key: key + '.' + prop + '.map',\n                    value: mapExpr,\n                    expressionContext: 'cluster-map'\n                }));\n                errors.push.apply(errors, validateExpression({\n                    key: key + '.' + prop + '.reduce',\n                    value: reduceExpr,\n                    expressionContext: 'cluster-reduce'\n                }));\n            }\n        }\n        return errors;\n    case 'video':\n        return validateObject({\n            key: key,\n            value: value,\n            valueSpec: styleSpec.source_video,\n            style: style,\n            styleSpec: styleSpec\n        });\n    case 'image':\n        return validateObject({\n            key: key,\n            value: value,\n            valueSpec: styleSpec.source_image,\n            style: style,\n            styleSpec: styleSpec\n        });\n    case 'canvas':\n        return [new ValidationError(key, null, 'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.', 'source.canvas')];\n    default:\n        return validateEnum({\n            key: key + '.type',\n            value: value.type,\n            valueSpec: {\n                values: [\n                    'vector',\n                    'raster',\n                    'raster-dem',\n                    'geojson',\n                    'video',\n                    'image'\n                ]\n            },\n            style: style,\n            styleSpec: styleSpec\n        });\n    }\n}\nfunction validatePromoteId(ref) {\n    var key = ref.key;\n    var value = ref.value;\n    if (getType(value) === 'string') {\n        return validateString({\n            key: key,\n            value: value\n        });\n    } else {\n        var errors = [];\n        for (var prop in value) {\n            errors.push.apply(errors, validateString({\n                key: key + '.' + prop,\n                value: value[prop]\n            }));\n        }\n        return errors;\n    }\n}\n\nfunction validateLight(options) {\n    var light = options.value;\n    var styleSpec = options.styleSpec;\n    var lightSpec = styleSpec.light;\n    var style = options.style;\n    var errors = [];\n    var rootType = getType(light);\n    if (light === undefined) {\n        return errors;\n    } else if (rootType !== 'object') {\n        errors = errors.concat([new ValidationError('light', light, 'object expected, ' + rootType + ' found')]);\n        return errors;\n    }\n    for (var key in light) {\n        var transitionMatch = key.match(/^(.*)-transition$/);\n        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {\n            errors = errors.concat(validate({\n                key: key,\n                value: light[key],\n                valueSpec: styleSpec.transition,\n                style: style,\n                styleSpec: styleSpec\n            }));\n        } else if (lightSpec[key]) {\n            errors = errors.concat(validate({\n                key: key,\n                value: light[key],\n                valueSpec: lightSpec[key],\n                style: style,\n                styleSpec: styleSpec\n            }));\n        } else {\n            errors = errors.concat([new ValidationError(key, light[key], 'unknown property \"' + key + '\"')]);\n        }\n    }\n    return errors;\n}\n\nfunction validateFormatted(options) {\n    if (validateString(options).length === 0) {\n        return [];\n    }\n    return validateExpression(options);\n}\n\nfunction validateImage(options) {\n    if (validateString(options).length === 0) {\n        return [];\n    }\n    return validateExpression(options);\n}\n\nvar VALIDATORS = {\n    '*': function _() {\n        return [];\n    },\n    'array': validateArray,\n    'boolean': validateBoolean,\n    'number': validateNumber,\n    'color': validateColor,\n    'constants': validateConstants,\n    'enum': validateEnum,\n    'filter': validateFilter,\n    'function': validateFunction,\n    'layer': validateLayer,\n    'object': validateObject,\n    'source': validateSource,\n    'light': validateLight,\n    'string': validateString,\n    'formatted': validateFormatted,\n    'resolvedImage': validateImage\n};\nfunction validate(options) {\n    var value = options.value;\n    var valueSpec = options.valueSpec;\n    var styleSpec = options.styleSpec;\n    if (valueSpec.expression && isFunction$1(unbundle(value))) {\n        return validateFunction(options);\n    } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {\n        return validateExpression(options);\n    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {\n        return VALIDATORS[valueSpec.type](options);\n    } else {\n        var valid = validateObject(extend({}, options, { valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec }));\n        return valid;\n    }\n}\n\nfunction validateGlyphsURL (options) {\n    var value = options.value;\n    var key = options.key;\n    var errors = validateString(options);\n    if (errors.length) {\n        return errors;\n    }\n    if (value.indexOf('{fontstack}') === -1) {\n        errors.push(new ValidationError(key, value, '\"glyphs\" url must include a \"{fontstack}\" token'));\n    }\n    if (value.indexOf('{range}') === -1) {\n        errors.push(new ValidationError(key, value, '\"glyphs\" url must include a \"{range}\" token'));\n    }\n    return errors;\n}\n\nfunction validateStyleMin(style, styleSpec) {\n    if (styleSpec === void 0)\n        styleSpec = v8;\n    var errors = [];\n    errors = errors.concat(validate({\n        key: '',\n        value: style,\n        valueSpec: styleSpec.$root,\n        styleSpec: styleSpec,\n        style: style,\n        objectElementValidators: {\n            glyphs: validateGlyphsURL,\n            '*': function _() {\n                return [];\n            }\n        }\n    }));\n    if (style.constants) {\n        errors = errors.concat(validateConstants({\n            key: 'constants',\n            value: style.constants,\n            style: style,\n            styleSpec: styleSpec\n        }));\n    }\n    return sortErrors(errors);\n}\nvalidateStyleMin.source = wrapCleanErrors(validateSource);\nvalidateStyleMin.light = wrapCleanErrors(validateLight);\nvalidateStyleMin.layer = wrapCleanErrors(validateLayer);\nvalidateStyleMin.filter = wrapCleanErrors(validateFilter);\nvalidateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);\nvalidateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);\nfunction sortErrors(errors) {\n    return [].concat(errors).sort(function (a, b) {\n        return a.line - b.line;\n    });\n}\nfunction wrapCleanErrors(inner) {\n    return function () {\n        var args = [], len = arguments.length;\n        while (len--)\n            args[len] = arguments[len];\n        return sortErrors(inner.apply(this, args));\n    };\n}\n\nvar jsonlint = createCommonjsModule(function (module, exports) {\nvar parser = function () {\n    var o = function (k, v, o, l) {\n            for (o = o || {}, l = k.length; l--; o[k[l]] = v) {\n            }\n            return o;\n        }, $V0 = [\n            1,\n            12\n        ], $V1 = [\n            1,\n            13\n        ], $V2 = [\n            1,\n            9\n        ], $V3 = [\n            1,\n            10\n        ], $V4 = [\n            1,\n            11\n        ], $V5 = [\n            1,\n            14\n        ], $V6 = [\n            1,\n            15\n        ], $V7 = [\n            14,\n            18,\n            22,\n            24\n        ], $V8 = [\n            18,\n            22\n        ], $V9 = [\n            22,\n            24\n        ];\n    var parser = {\n        trace: function trace() {\n        },\n        yy: {},\n        symbols_: {\n            'error': 2,\n            'JSONString': 3,\n            'STRING': 4,\n            'JSONNumber': 5,\n            'NUMBER': 6,\n            'JSONNullLiteral': 7,\n            'NULL': 8,\n            'JSONBooleanLiteral': 9,\n            'TRUE': 10,\n            'FALSE': 11,\n            'JSONText': 12,\n            'JSONValue': 13,\n            'EOF': 14,\n            'JSONObject': 15,\n            'JSONArray': 16,\n            '{': 17,\n            '}': 18,\n            'JSONMemberList': 19,\n            'JSONMember': 20,\n            ':': 21,\n            ',': 22,\n            '[': 23,\n            ']': 24,\n            'JSONElementList': 25,\n            '$accept': 0,\n            '$end': 1\n        },\n        terminals_: {\n            2: 'error',\n            4: 'STRING',\n            6: 'NUMBER',\n            8: 'NULL',\n            10: 'TRUE',\n            11: 'FALSE',\n            14: 'EOF',\n            17: '{',\n            18: '}',\n            21: ':',\n            22: ',',\n            23: '[',\n            24: ']'\n        },\n        productions_: [\n            0,\n            [\n                3,\n                1\n            ],\n            [\n                5,\n                1\n            ],\n            [\n                7,\n                1\n            ],\n            [\n                9,\n                1\n            ],\n            [\n                9,\n                1\n            ],\n            [\n                12,\n                2\n            ],\n            [\n                13,\n                1\n            ],\n            [\n                13,\n                1\n            ],\n            [\n                13,\n                1\n            ],\n            [\n                13,\n                1\n            ],\n            [\n                13,\n                1\n            ],\n            [\n                13,\n                1\n            ],\n            [\n                15,\n                2\n            ],\n            [\n                15,\n                3\n            ],\n            [\n                20,\n                3\n            ],\n            [\n                19,\n                1\n            ],\n            [\n                19,\n                3\n            ],\n            [\n                16,\n                2\n            ],\n            [\n                16,\n                3\n            ],\n            [\n                25,\n                1\n            ],\n            [\n                25,\n                3\n            ]\n        ],\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n            var $0 = $$.length - 1;\n            switch (yystate) {\n            case 1:\n                this.$ = new String(yytext.replace(/\\\\(\\\\|\")/g, '$' + '1').replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r').replace(/\\\\t/g, '\\t').replace(/\\\\v/g, '\\x0B').replace(/\\\\f/g, '\\f').replace(/\\\\b/g, '\\b'));\n                this.$.__line__ = this._$.first_line;\n                break;\n            case 2:\n                this.$ = new Number(yytext);\n                this.$.__line__ = this._$.first_line;\n                break;\n            case 3:\n                this.$ = null;\n                break;\n            case 4:\n                this.$ = new Boolean(true);\n                this.$.__line__ = this._$.first_line;\n                break;\n            case 5:\n                this.$ = new Boolean(false);\n                this.$.__line__ = this._$.first_line;\n                break;\n            case 6:\n                return this.$ = $$[$0 - 1];\n            case 13:\n                this.$ = {};\n                Object.defineProperty(this.$, '__line__', {\n                    value: this._$.first_line,\n                    enumerable: false\n                });\n                break;\n            case 14:\n            case 19:\n                this.$ = $$[$0 - 1];\n                Object.defineProperty(this.$, '__line__', {\n                    value: this._$.first_line,\n                    enumerable: false\n                });\n                break;\n            case 15:\n                this.$ = [\n                    $$[$0 - 2],\n                    $$[$0]\n                ];\n                break;\n            case 16:\n                this.$ = {};\n                this.$[$$[$0][0]] = $$[$0][1];\n                break;\n            case 17:\n                this.$ = $$[$0 - 2];\n                $$[$0 - 2][$$[$0][0]] = $$[$0][1];\n                break;\n            case 18:\n                this.$ = [];\n                Object.defineProperty(this.$, '__line__', {\n                    value: this._$.first_line,\n                    enumerable: false\n                });\n                break;\n            case 20:\n                this.$ = [$$[$0]];\n                break;\n            case 21:\n                this.$ = $$[$0 - 2];\n                $$[$0 - 2].push($$[$0]);\n                break;\n            }\n        },\n        table: [\n            {\n                3: 5,\n                4: $V0,\n                5: 6,\n                6: $V1,\n                7: 3,\n                8: $V2,\n                9: 4,\n                10: $V3,\n                11: $V4,\n                12: 1,\n                13: 2,\n                15: 7,\n                16: 8,\n                17: $V5,\n                23: $V6\n            },\n            { 1: [3] },\n            {\n                14: [\n                    1,\n                    16\n                ]\n            },\n            o($V7, [\n                2,\n                7\n            ]),\n            o($V7, [\n                2,\n                8\n            ]),\n            o($V7, [\n                2,\n                9\n            ]),\n            o($V7, [\n                2,\n                10\n            ]),\n            o($V7, [\n                2,\n                11\n            ]),\n            o($V7, [\n                2,\n                12\n            ]),\n            o($V7, [\n                2,\n                3\n            ]),\n            o($V7, [\n                2,\n                4\n            ]),\n            o($V7, [\n                2,\n                5\n            ]),\n            o([\n                14,\n                18,\n                21,\n                22,\n                24\n            ], [\n                2,\n                1\n            ]),\n            o($V7, [\n                2,\n                2\n            ]),\n            {\n                3: 20,\n                4: $V0,\n                18: [\n                    1,\n                    17\n                ],\n                19: 18,\n                20: 19\n            },\n            {\n                3: 5,\n                4: $V0,\n                5: 6,\n                6: $V1,\n                7: 3,\n                8: $V2,\n                9: 4,\n                10: $V3,\n                11: $V4,\n                13: 23,\n                15: 7,\n                16: 8,\n                17: $V5,\n                23: $V6,\n                24: [\n                    1,\n                    21\n                ],\n                25: 22\n            },\n            {\n                1: [\n                    2,\n                    6\n                ]\n            },\n            o($V7, [\n                2,\n                13\n            ]),\n            {\n                18: [\n                    1,\n                    24\n                ],\n                22: [\n                    1,\n                    25\n                ]\n            },\n            o($V8, [\n                2,\n                16\n            ]),\n            {\n                21: [\n                    1,\n                    26\n                ]\n            },\n            o($V7, [\n                2,\n                18\n            ]),\n            {\n                22: [\n                    1,\n                    28\n                ],\n                24: [\n                    1,\n                    27\n                ]\n            },\n            o($V9, [\n                2,\n                20\n            ]),\n            o($V7, [\n                2,\n                14\n            ]),\n            {\n                3: 20,\n                4: $V0,\n                20: 29\n            },\n            {\n                3: 5,\n                4: $V0,\n                5: 6,\n                6: $V1,\n                7: 3,\n                8: $V2,\n                9: 4,\n                10: $V3,\n                11: $V4,\n                13: 30,\n                15: 7,\n                16: 8,\n                17: $V5,\n                23: $V6\n            },\n            o($V7, [\n                2,\n                19\n            ]),\n            {\n                3: 5,\n                4: $V0,\n                5: 6,\n                6: $V1,\n                7: 3,\n                8: $V2,\n                9: 4,\n                10: $V3,\n                11: $V4,\n                13: 31,\n                15: 7,\n                16: 8,\n                17: $V5,\n                23: $V6\n            },\n            o($V8, [\n                2,\n                17\n            ]),\n            o($V8, [\n                2,\n                15\n            ]),\n            o($V9, [\n                2,\n                21\n            ])\n        ],\n        defaultActions: {\n            16: [\n                2,\n                6\n            ]\n        },\n        parseError: function parseError(str, hash) {\n            if (hash.recoverable) {\n                this.trace(str);\n            } else {\n                throw new Error(str);\n            }\n        },\n        parse: function parse(input) {\n            var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;\n            var args = lstack.slice.call(arguments, 1);\n            var lexer = Object.create(this.lexer);\n            var sharedState = { yy: {} };\n            for (var k in this.yy) {\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n                    sharedState.yy[k] = this.yy[k];\n                }\n            }\n            lexer.setInput(input, sharedState.yy);\n            sharedState.yy.lexer = lexer;\n            sharedState.yy.parser = this;\n            if (typeof lexer.yylloc == 'undefined') {\n                lexer.yylloc = {};\n            }\n            var yyloc = lexer.yylloc;\n            lstack.push(yyloc);\n            var ranges = lexer.options && lexer.options.ranges;\n            if (typeof sharedState.yy.parseError === 'function') {\n                this.parseError = sharedState.yy.parseError;\n            } else {\n                this.parseError = Object.getPrototypeOf(this).parseError;\n            }\n            function lex() {\n                var token;\n                token = lexer.lex() || EOF;\n                if (typeof token !== 'number') {\n                    token = self.symbols_[token] || token;\n                }\n                return token;\n            }\n            var symbol, preErrorSymbol, state, action, r, yyval = {}, p, len, newState, expected;\n            while (true) {\n                state = stack[stack.length - 1];\n                if (this.defaultActions[state]) {\n                    action = this.defaultActions[state];\n                } else {\n                    if (symbol === null || typeof symbol == 'undefined') {\n                        symbol = lex();\n                    }\n                    action = table[state] && table[state][symbol];\n                }\n                if (typeof action === 'undefined' || !action.length || !action[0]) {\n                    var errStr = '';\n                    expected = [];\n                    for (p in table[state]) {\n                        if (this.terminals_[p] && p > TERROR) {\n                            expected.push('\\'' + this.terminals_[p] + '\\'');\n                        }\n                    }\n                    if (lexer.showPosition) {\n                        errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                    } else {\n                        errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                    }\n                    this.parseError(errStr, {\n                        text: lexer.match,\n                        token: this.terminals_[symbol] || symbol,\n                        line: lexer.yylineno,\n                        loc: yyloc,\n                        expected: expected\n                    });\n                }\n                if (action[0] instanceof Array && action.length > 1) {\n                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n                }\n                switch (action[0]) {\n                case 1:\n                    stack.push(symbol);\n                    vstack.push(lexer.yytext);\n                    lstack.push(lexer.yylloc);\n                    stack.push(action[1]);\n                    symbol = null;\n                    if (!preErrorSymbol) {\n                        yyleng = lexer.yyleng;\n                        yytext = lexer.yytext;\n                        yylineno = lexer.yylineno;\n                        yyloc = lexer.yylloc;\n                    } else {\n                        symbol = preErrorSymbol;\n                        preErrorSymbol = null;\n                    }\n                    break;\n                case 2:\n                    len = this.productions_[action[1]][1];\n                    yyval.$ = vstack[vstack.length - len];\n                    yyval._$ = {\n                        first_line: lstack[lstack.length - (len || 1)].first_line,\n                        last_line: lstack[lstack.length - 1].last_line,\n                        first_column: lstack[lstack.length - (len || 1)].first_column,\n                        last_column: lstack[lstack.length - 1].last_column\n                    };\n                    if (ranges) {\n                        yyval._$.range = [\n                            lstack[lstack.length - (len || 1)].range[0],\n                            lstack[lstack.length - 1].range[1]\n                        ];\n                    }\n                    r = this.performAction.apply(yyval, [\n                        yytext,\n                        yyleng,\n                        yylineno,\n                        sharedState.yy,\n                        action[1],\n                        vstack,\n                        lstack\n                    ].concat(args));\n                    if (typeof r !== 'undefined') {\n                        return r;\n                    }\n                    if (len) {\n                        stack = stack.slice(0, -1 * len * 2);\n                        vstack = vstack.slice(0, -1 * len);\n                        lstack = lstack.slice(0, -1 * len);\n                    }\n                    stack.push(this.productions_[action[1]][0]);\n                    vstack.push(yyval.$);\n                    lstack.push(yyval._$);\n                    newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n                    stack.push(newState);\n                    break;\n                case 3:\n                    return true;\n                }\n            }\n            return true;\n        }\n    };\n    var lexer = function () {\n        var lexer = {\n            EOF: 1,\n            parseError: function parseError(str, hash) {\n                if (this.yy.parser) {\n                    this.yy.parser.parseError(str, hash);\n                } else {\n                    throw new Error(str);\n                }\n            },\n            setInput: function (input, yy) {\n                this.yy = yy || this.yy || {};\n                this._input = input;\n                this._more = this._backtrack = this.done = false;\n                this.yylineno = this.yyleng = 0;\n                this.yytext = this.matched = this.match = '';\n                this.conditionStack = ['INITIAL'];\n                this.yylloc = {\n                    first_line: 1,\n                    first_column: 0,\n                    last_line: 1,\n                    last_column: 0\n                };\n                if (this.options.ranges) {\n                    this.yylloc.range = [\n                        0,\n                        0\n                    ];\n                }\n                this.offset = 0;\n                return this;\n            },\n            input: function () {\n                var ch = this._input[0];\n                this.yytext += ch;\n                this.yyleng++;\n                this.offset++;\n                this.match += ch;\n                this.matched += ch;\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n                if (lines) {\n                    this.yylineno++;\n                    this.yylloc.last_line++;\n                } else {\n                    this.yylloc.last_column++;\n                }\n                if (this.options.ranges) {\n                    this.yylloc.range[1]++;\n                }\n                this._input = this._input.slice(1);\n                return ch;\n            },\n            unput: function (ch) {\n                var len = ch.length;\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n                this._input = ch + this._input;\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\n                this.offset -= len;\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n                this.match = this.match.substr(0, this.match.length - 1);\n                this.matched = this.matched.substr(0, this.matched.length - 1);\n                if (lines.length - 1) {\n                    this.yylineno -= lines.length - 1;\n                }\n                var r = this.yylloc.range;\n                this.yylloc = {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.yylineno + 1,\n                    first_column: this.yylloc.first_column,\n                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n                };\n                if (this.options.ranges) {\n                    this.yylloc.range = [\n                        r[0],\n                        r[0] + this.yyleng - len\n                    ];\n                }\n                this.yyleng = this.yytext.length;\n                return this;\n            },\n            more: function () {\n                this._more = true;\n                return this;\n            },\n            reject: function () {\n                if (this.options.backtrack_lexer) {\n                    this._backtrack = true;\n                } else {\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                        text: '',\n                        token: null,\n                        line: this.yylineno\n                    });\n                }\n                return this;\n            },\n            less: function (n) {\n                this.unput(this.match.slice(n));\n            },\n            pastInput: function () {\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, '');\n            },\n            upcomingInput: function () {\n                var next = this.match;\n                if (next.length < 20) {\n                    next += this._input.substr(0, 20 - next.length);\n                }\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, '');\n            },\n            showPosition: function () {\n                var pre = this.pastInput();\n                var c = new Array(pre.length + 1).join('-');\n                return pre + this.upcomingInput() + '\\n' + c + '^';\n            },\n            test_match: function (match, indexed_rule) {\n                var token, lines, backup;\n                if (this.options.backtrack_lexer) {\n                    backup = {\n                        yylineno: this.yylineno,\n                        yylloc: {\n                            first_line: this.yylloc.first_line,\n                            last_line: this.last_line,\n                            first_column: this.yylloc.first_column,\n                            last_column: this.yylloc.last_column\n                        },\n                        yytext: this.yytext,\n                        match: this.match,\n                        matches: this.matches,\n                        matched: this.matched,\n                        yyleng: this.yyleng,\n                        offset: this.offset,\n                        _more: this._more,\n                        _input: this._input,\n                        yy: this.yy,\n                        conditionStack: this.conditionStack.slice(0),\n                        done: this.done\n                    };\n                    if (this.options.ranges) {\n                        backup.yylloc.range = this.yylloc.range.slice(0);\n                    }\n                }\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n                if (lines) {\n                    this.yylineno += lines.length;\n                }\n                this.yylloc = {\n                    first_line: this.yylloc.last_line,\n                    last_line: this.yylineno + 1,\n                    first_column: this.yylloc.last_column,\n                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n                };\n                this.yytext += match[0];\n                this.match += match[0];\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                if (this.options.ranges) {\n                    this.yylloc.range = [\n                        this.offset,\n                        this.offset += this.yyleng\n                    ];\n                }\n                this._more = false;\n                this._backtrack = false;\n                this._input = this._input.slice(match[0].length);\n                this.matched += match[0];\n                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n                if (this.done && this._input) {\n                    this.done = false;\n                }\n                if (token) {\n                    return token;\n                } else if (this._backtrack) {\n                    for (var k in backup) {\n                        this[k] = backup[k];\n                    }\n                    return false;\n                }\n                return false;\n            },\n            next: function () {\n                if (this.done) {\n                    return this.EOF;\n                }\n                if (!this._input) {\n                    this.done = true;\n                }\n                var token, match, tempMatch, index;\n                if (!this._more) {\n                    this.yytext = '';\n                    this.match = '';\n                }\n                var rules = this._currentRules();\n                for (var i = 0; i < rules.length; i++) {\n                    tempMatch = this._input.match(this.rules[rules[i]]);\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                        match = tempMatch;\n                        index = i;\n                        if (this.options.backtrack_lexer) {\n                            token = this.test_match(tempMatch, rules[i]);\n                            if (token !== false) {\n                                return token;\n                            } else if (this._backtrack) {\n                                match = false;\n                                continue;\n                            } else {\n                                return false;\n                            }\n                        } else if (!this.options.flex) {\n                            break;\n                        }\n                    }\n                }\n                if (match) {\n                    token = this.test_match(match, rules[index]);\n                    if (token !== false) {\n                        return token;\n                    }\n                    return false;\n                }\n                if (this._input === '') {\n                    return this.EOF;\n                } else {\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                        text: '',\n                        token: null,\n                        line: this.yylineno\n                    });\n                }\n            },\n            lex: function lex() {\n                var r = this.next();\n                if (r) {\n                    return r;\n                } else {\n                    return this.lex();\n                }\n            },\n            begin: function begin(condition) {\n                this.conditionStack.push(condition);\n            },\n            popState: function popState() {\n                var n = this.conditionStack.length - 1;\n                if (n > 0) {\n                    return this.conditionStack.pop();\n                } else {\n                    return this.conditionStack[0];\n                }\n            },\n            _currentRules: function _currentRules() {\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n                } else {\n                    return this.conditions['INITIAL'].rules;\n                }\n            },\n            topState: function topState(n) {\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\n                if (n >= 0) {\n                    return this.conditionStack[n];\n                } else {\n                    return 'INITIAL';\n                }\n            },\n            pushState: function pushState(condition) {\n                this.begin(condition);\n            },\n            stateStackSize: function stateStackSize() {\n                return this.conditionStack.length;\n            },\n            options: {},\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n                switch ($avoiding_name_collisions) {\n                case 0:\n                    break;\n                case 1:\n                    return 6;\n                case 2:\n                    yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);\n                    return 4;\n                case 3:\n                    return 17;\n                case 4:\n                    return 18;\n                case 5:\n                    return 23;\n                case 6:\n                    return 24;\n                case 7:\n                    return 22;\n                case 8:\n                    return 21;\n                case 9:\n                    return 10;\n                case 10:\n                    return 11;\n                case 11:\n                    return 8;\n                case 12:\n                    return 14;\n                case 13:\n                    return 'INVALID';\n                }\n            },\n            rules: [\n                /^(?:\\s+)/,\n                /^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/,\n                /^(?:\"(?:\\\\[\\\\\"bfnrt/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f\"])*\")/,\n                /^(?:\\{)/,\n                /^(?:\\})/,\n                /^(?:\\[)/,\n                /^(?:\\])/,\n                /^(?:,)/,\n                /^(?::)/,\n                /^(?:true\\b)/,\n                /^(?:false\\b)/,\n                /^(?:null\\b)/,\n                /^(?:$)/,\n                /^(?:.)/\n            ],\n            conditions: {\n                'INITIAL': {\n                    'rules': [\n                        0,\n                        1,\n                        2,\n                        3,\n                        4,\n                        5,\n                        6,\n                        7,\n                        8,\n                        9,\n                        10,\n                        11,\n                        12,\n                        13\n                    ],\n                    'inclusive': true\n                }\n            }\n        };\n        return lexer;\n    }();\n    parser.lexer = lexer;\n    function Parser() {\n        this.yy = {};\n    }\n    Parser.prototype = parser;\n    parser.Parser = Parser;\n    return new Parser();\n}();\nif (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {\n    exports.parser = parser;\n    exports.Parser = parser.Parser;\n    exports.parse = function () {\n        return parser.parse.apply(parser, arguments);\n    };\n}\n});\nvar jsonlint_1 = jsonlint.parser;\nvar jsonlint_2 = jsonlint.Parser;\nvar jsonlint_3 = jsonlint.parse;\n\nfunction readStyle(style) {\n    if (style instanceof String || typeof style === 'string' || style instanceof Buffer) {\n        try {\n            return jsonlint.parse(style.toString());\n        } catch (e) {\n            throw new ParsingError$1(e);\n        }\n    }\n    return style;\n}\n\nfunction validateStyle(style, styleSpec) {\n    if (styleSpec === void 0)\n        styleSpec = v8;\n    var s = style;\n    try {\n        s = readStyle(s);\n    } catch (e) {\n        return [e];\n    }\n    return validateStyleMin(s, styleSpec);\n}\n\nvar SUPPORTED_SPEC_VERSION = 8;\nvar MAX_SOURCES_IN_STYLE = 15;\nfunction isValid(value, regex) {\n    if (!value || getType(value) !== 'string') {\n        return true;\n    }\n    return !!value.match(regex);\n}\nfunction getSourceCount(source) {\n    if (source.url) {\n        return source.url.split(',').length;\n    } else {\n        return 0;\n    }\n}\nfunction getAllowedKeyErrors(obj, keys, path) {\n    var allowed = new Set(keys);\n    var errors = [];\n    Object.keys(obj).forEach(function (k) {\n        if (!allowed.has(k)) {\n            var prop = path ? path + '.' + k : null;\n            errors.push(new ValidationError(prop, obj[k], 'Unsupported property \"' + k + '\"'));\n        }\n    });\n    return errors;\n}\nfunction getSourceErrors(source, i) {\n    var errors = [];\n    var sourceKeys = [\n        'type',\n        'url',\n        'tileSize'\n    ];\n    errors.push.apply(errors, getAllowedKeyErrors(source, sourceKeys, 'source'));\n    var sourceUrlPattern = /^mapbox:\\/\\/([^/]*)$/;\n    if (!isValid(source.url, sourceUrlPattern)) {\n        errors.push(new ValidationError('sources[' + i + ']', source.url, 'Source url must be a valid Mapbox tileset url'));\n    }\n    return errors;\n}\nfunction getSourcesErrors(sources) {\n    var errors = [];\n    var count = 0;\n    Object.keys(sources).forEach(function (s, i) {\n        var sourceErrors = getSourceErrors(sources[s], i);\n        if (!sourceErrors.length) {\n            count = count + getSourceCount(sources[s]);\n        }\n        errors.push.apply(errors, sourceErrors);\n    });\n    if (count > MAX_SOURCES_IN_STYLE) {\n        errors.push(new ValidationError('sources', null, 'Styles must contain ' + MAX_SOURCES_IN_STYLE + ' or fewer sources'));\n    }\n    return errors;\n}\nfunction getRootErrors(style, specKeys) {\n    var errors = [];\n    var optionalRootProperties = [\n        'owner',\n        'id',\n        'cacheControl',\n        'draft',\n        'created',\n        'modified',\n        'visibility'\n    ];\n    var allowedKeyErrors = getAllowedKeyErrors(style, specKeys.concat(optionalRootProperties));\n    errors.push.apply(errors, allowedKeyErrors);\n    if (style.version > SUPPORTED_SPEC_VERSION || style.version < SUPPORTED_SPEC_VERSION) {\n        errors.push(new ValidationError('version', style.version, 'Style version must be ' + SUPPORTED_SPEC_VERSION));\n    }\n    var glyphUrlPattern = /^mapbox:\\/\\/fonts\\/([^/]*)\\/{fontstack}\\/{range}.pbf$/;\n    if (!isValid(style.glyphs, glyphUrlPattern)) {\n        errors.push(new ValidationError('glyphs', style.glyphs, 'Styles must reference glyphs hosted by Mapbox'));\n    }\n    var spriteUrlPattern = /^mapbox:\\/\\/sprites\\/([^/]*)\\/([^/]*)\\/?([^/]*)?$/;\n    if (!isValid(style.sprite, spriteUrlPattern)) {\n        errors.push(new ValidationError('sprite', style.sprite, 'Styles must reference sprites hosted by Mapbox'));\n    }\n    var visibilityPattern = /^(public|private)$/;\n    if (!isValid(style.visibility, visibilityPattern)) {\n        errors.push(new ValidationError('visibility', style.visibility, 'Style visibility must be public or private'));\n    }\n    return errors;\n}\nfunction validateMapboxApiSupported(style) {\n    var s = style;\n    try {\n        s = readStyle(s);\n    } catch (e) {\n        return [e];\n    }\n    var errors = validateStyleMin(s, v8).concat(getRootErrors(s, Object.keys(v8.$root)));\n    if (s.sources) {\n        errors = errors.concat(getSourcesErrors(s.sources));\n    }\n    return errors;\n}\n\nvar expression$1 = {\n    StyleExpression: StyleExpression,\n    isExpression: isExpression,\n    createExpression: createExpression,\n    createPropertyExpression: createPropertyExpression,\n    normalizePropertyExpression: normalizePropertyExpression,\n    ZoomConstantExpression: ZoomConstantExpression,\n    ZoomDependentExpression: ZoomDependentExpression,\n    StylePropertyFunction: StylePropertyFunction\n};\nvar styleFunction = {\n    convertFunction: convertFunction,\n    createFunction: createFunction,\n    isFunction: isFunction$1\n};\nvar visit = {\n    eachSource: eachSource,\n    eachLayer: eachLayer,\n    eachProperty: eachProperty\n};\nvalidateStyle.parsed = validateStyle;\nvalidateStyle.latest = validateStyle;\n\n\n//# sourceMappingURL=index.es.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@mapbox/point-geometry/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@mapbox/point-geometry/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = Point;\n\n/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class Point\n * @param {Number} x the x-coordinate. this could be longitude or screen\n * pixels, or any other sort of unit.\n * @param {Number} y the y-coordinate. this could be latitude or screen\n * pixels, or any other sort of unit.\n * @example\n * var point = new Point(-77, 38);\n */\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone: function() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add:     function(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub:     function(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint:    function(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint:     function(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    mult:    function(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    div:     function(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate:  function(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {Array<Number>} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult: function(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit:    function() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp:    function() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round:   function() { return this.clone()._round(); },\n\n    /**\n     * Return the magitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {Number} magnitude\n     */\n    mag: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals: function(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    dist: function(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    distSqr: function(p) {\n        var dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {Number} angle\n     */\n    angle: function() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleTo: function(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleWith: function(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /*\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin(θ) for θ.\n     * @param {Number} x the x-coordinate\n     * @param {Number} y the y-coordinate\n     * @return {Number} the angle in radians\n     */\n    angleWithSep: function(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    _matMult: function(m) {\n        var x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _add: function(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    _sub: function(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    _mult: function(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    _div: function(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    _multByPoint: function(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    _divByPoint: function(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit: function() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp: function() {\n        var y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    _rotate: function(angle) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _rotateAround: function(angle, p) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round: function() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    }\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, or an unknown type, return it unchanged\n * @param {Array<Number>|Point|*} a any kind of input value\n * @return {Point} constructed point, or passed-through value.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (a) {\n    if (a instanceof Point) {\n        return a;\n    }\n    if (Array.isArray(a)) {\n        return new Point(a[0], a[1]);\n    }\n    return a;\n};\n\n\n//# sourceURL=webpack:///./node_modules/@mapbox/point-geometry/index.js?");

/***/ }),

/***/ "./node_modules/@mapbox/togeojson/togeojson.js":
/*!*****************************************************!*\
  !*** ./node_modules/@mapbox/togeojson/togeojson.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var toGeoJSON = (function() {\n    'use strict';\n\n    var removeSpace = /\\s*/g,\n        trimSpace = /^\\s*|\\s*$/g,\n        splitSpace = /\\s+/;\n    // generate a short, numeric hash of a string\n    function okhash(x) {\n        if (!x || !x.length) return 0;\n        for (var i = 0, h = 0; i < x.length; i++) {\n            h = ((h << 5) - h) + x.charCodeAt(i) | 0;\n        } return h;\n    }\n    // all Y children of X\n    function get(x, y) { return x.getElementsByTagName(y); }\n    function attr(x, y) { return x.getAttribute(y); }\n    function attrf(x, y) { return parseFloat(attr(x, y)); }\n    // one Y child of X, if any, otherwise null\n    function get1(x, y) { var n = get(x, y); return n.length ? n[0] : null; }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\n    function norm(el) { if (el.normalize) { el.normalize(); } return el; }\n    // cast array x into numbers\n    function numarray(x) {\n        for (var j = 0, o = []; j < x.length; j++) { o[j] = parseFloat(x[j]); }\n        return o;\n    }\n    // get the content of a text node, if any\n    function nodeVal(x) {\n        if (x) { norm(x); }\n        return (x && x.textContent) || '';\n    }\n    // get the contents of multiple text nodes, if present\n    function getMulti(x, ys) {\n        var o = {}, n, k;\n        for (k = 0; k < ys.length; k++) {\n            n = get1(x, ys[k]);\n            if (n) o[ys[k]] = nodeVal(n);\n        }\n        return o;\n    }\n    // add properties of Y to X, overwriting if present in both\n    function extend(x, y) { for (var k in y) x[k] = y[k]; }\n    // get one coordinate from a coordinate array, if any\n    function coord1(v) { return numarray(v.replace(removeSpace, '').split(',')); }\n    // get all coordinates from a coordinate array as [[],[]]\n    function coord(v) {\n        var coords = v.replace(trimSpace, '').split(splitSpace),\n            o = [];\n        for (var i = 0; i < coords.length; i++) {\n            o.push(coord1(coords[i]));\n        }\n        return o;\n    }\n    function coordPair(x) {\n        var ll = [attrf(x, 'lon'), attrf(x, 'lat')],\n            ele = get1(x, 'ele'),\n            // handle namespaced attribute in browser\n            heartRate = get1(x, 'gpxtpx:hr') || get1(x, 'hr'),\n            time = get1(x, 'time'),\n            e;\n        if (ele) {\n            e = parseFloat(nodeVal(ele));\n            if (!isNaN(e)) {\n                ll.push(e);\n            }\n        }\n        return {\n            coordinates: ll,\n            time: time ? nodeVal(time) : null,\n            heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n        };\n    }\n\n    // create a new feature collection parent object\n    function fc() {\n        return {\n            type: 'FeatureCollection',\n            features: []\n        };\n    }\n\n    var serializer;\n    if (typeof XMLSerializer !== 'undefined') {\n        /* istanbul ignore next */\n        serializer = new XMLSerializer();\n    // only require xmldom in a node environment\n    } else if ( true && typeof process === 'object' && !process.browser) {\n        serializer = new (__webpack_require__(/*! xmldom */ 0).XMLSerializer)();\n    }\n    function xml2str(str) {\n        // IE9 will create a new XMLSerializer but it'll crash immediately.\n        // This line is ignored because we don't run coverage tests in IE9\n        /* istanbul ignore next */\n        if (str.xml !== undefined) return str.xml;\n        return serializer.serializeToString(str);\n    }\n\n    var t = {\n        kml: function(doc) {\n\n            var gj = fc(),\n                // styleindex keeps track of hashed styles in order to match features\n                styleIndex = {}, styleByHash = {},\n                // stylemapindex keeps track of style maps to expose in properties\n                styleMapIndex = {},\n                // atomic geospatial types supported by KML - MultiGeometry is\n                // handled separately\n                geotypes = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'],\n                // all root placemarks in the file\n                placemarks = get(doc, 'Placemark'),\n                styles = get(doc, 'Style'),\n                styleMaps = get(doc, 'StyleMap');\n\n            for (var k = 0; k < styles.length; k++) {\n                var hash = okhash(xml2str(styles[k])).toString(16);\n                styleIndex['#' + attr(styles[k], 'id')] = hash;\n                styleByHash[hash] = styles[k];\n            }\n            for (var l = 0; l < styleMaps.length; l++) {\n                styleIndex['#' + attr(styleMaps[l], 'id')] = okhash(xml2str(styleMaps[l])).toString(16);\n                var pairs = get(styleMaps[l], 'Pair');\n                var pairsMap = {};\n                for (var m = 0; m < pairs.length; m++) {\n                    pairsMap[nodeVal(get1(pairs[m], 'key'))] = nodeVal(get1(pairs[m], 'styleUrl'));\n                }\n                styleMapIndex['#' + attr(styleMaps[l], 'id')] = pairsMap;\n\n            }\n            for (var j = 0; j < placemarks.length; j++) {\n                gj.features = gj.features.concat(getPlacemark(placemarks[j]));\n            }\n            function kmlColor(v) {\n                var color, opacity;\n                v = v || '';\n                if (v.substr(0, 1) === '#') { v = v.substr(1); }\n                if (v.length === 6 || v.length === 3) { color = v; }\n                if (v.length === 8) {\n                    opacity = parseInt(v.substr(0, 2), 16) / 255;\n                    color = '#' + v.substr(6, 2) +\n                        v.substr(4, 2) +\n                        v.substr(2, 2);\n                }\n                return [color, isNaN(opacity) ? undefined : opacity];\n            }\n            function gxCoord(v) { return numarray(v.split(' ')); }\n            function gxCoords(root) {\n                var elems = get(root, 'coord', 'gx'), coords = [], times = [];\n                if (elems.length === 0) elems = get(root, 'gx:coord');\n                for (var i = 0; i < elems.length; i++) coords.push(gxCoord(nodeVal(elems[i])));\n                var timeElems = get(root, 'when');\n                for (var j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n                return {\n                    coords: coords,\n                    times: times\n                };\n            }\n            function getGeometry(root) {\n                var geomNode, geomNodes, i, j, k, geoms = [], coordTimes = [];\n                if (get1(root, 'MultiGeometry')) { return getGeometry(get1(root, 'MultiGeometry')); }\n                if (get1(root, 'MultiTrack')) { return getGeometry(get1(root, 'MultiTrack')); }\n                if (get1(root, 'gx:MultiTrack')) { return getGeometry(get1(root, 'gx:MultiTrack')); }\n                for (i = 0; i < geotypes.length; i++) {\n                    geomNodes = get(root, geotypes[i]);\n                    if (geomNodes) {\n                        for (j = 0; j < geomNodes.length; j++) {\n                            geomNode = geomNodes[j];\n                            if (geotypes[i] === 'Point') {\n                                geoms.push({\n                                    type: 'Point',\n                                    coordinates: coord1(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'LineString') {\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: coord(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'Polygon') {\n                                var rings = get(geomNode, 'LinearRing'),\n                                    coords = [];\n                                for (k = 0; k < rings.length; k++) {\n                                    coords.push(coord(nodeVal(get1(rings[k], 'coordinates'))));\n                                }\n                                geoms.push({\n                                    type: 'Polygon',\n                                    coordinates: coords\n                                });\n                            } else if (geotypes[i] === 'Track' ||\n                                geotypes[i] === 'gx:Track') {\n                                var track = gxCoords(geomNode);\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: track.coords\n                                });\n                                if (track.times.length) coordTimes.push(track.times);\n                            }\n                        }\n                    }\n                }\n                return {\n                    geoms: geoms,\n                    coordTimes: coordTimes\n                };\n            }\n            function getPlacemark(root) {\n                var geomsAndTimes = getGeometry(root), i, properties = {},\n                    name = nodeVal(get1(root, 'name')),\n                    address = nodeVal(get1(root, 'address')),\n                    styleUrl = nodeVal(get1(root, 'styleUrl')),\n                    description = nodeVal(get1(root, 'description')),\n                    timeSpan = get1(root, 'TimeSpan'),\n                    timeStamp = get1(root, 'TimeStamp'),\n                    extendedData = get1(root, 'ExtendedData'),\n                    lineStyle = get1(root, 'LineStyle'),\n                    polyStyle = get1(root, 'PolyStyle'),\n                    visibility = get1(root, 'visibility');\n\n                if (!geomsAndTimes.geoms.length) return [];\n                if (name) properties.name = name;\n                if (address) properties.address = address;\n                if (styleUrl) {\n                    if (styleUrl[0] !== '#') {\n                        styleUrl = '#' + styleUrl;\n                    }\n\n                    properties.styleUrl = styleUrl;\n                    if (styleIndex[styleUrl]) {\n                        properties.styleHash = styleIndex[styleUrl];\n                    }\n                    if (styleMapIndex[styleUrl]) {\n                        properties.styleMapHash = styleMapIndex[styleUrl];\n                        properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n                    }\n                    // Try to populate the lineStyle or polyStyle since we got the style hash\n                    var style = styleByHash[properties.styleHash];\n                    if (style) {\n                        if (!lineStyle) lineStyle = get1(style, 'LineStyle');\n                        if (!polyStyle) polyStyle = get1(style, 'PolyStyle');\n                    }\n                }\n                if (description) properties.description = description;\n                if (timeSpan) {\n                    var begin = nodeVal(get1(timeSpan, 'begin'));\n                    var end = nodeVal(get1(timeSpan, 'end'));\n                    properties.timespan = { begin: begin, end: end };\n                }\n                if (timeStamp) {\n                    properties.timestamp = nodeVal(get1(timeStamp, 'when'));\n                }\n                if (lineStyle) {\n                    var linestyles = kmlColor(nodeVal(get1(lineStyle, 'color'))),\n                        color = linestyles[0],\n                        opacity = linestyles[1],\n                        width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                    if (color) properties.stroke = color;\n                    if (!isNaN(opacity)) properties['stroke-opacity'] = opacity;\n                    if (!isNaN(width)) properties['stroke-width'] = width;\n                }\n                if (polyStyle) {\n                    var polystyles = kmlColor(nodeVal(get1(polyStyle, 'color'))),\n                        pcolor = polystyles[0],\n                        popacity = polystyles[1],\n                        fill = nodeVal(get1(polyStyle, 'fill')),\n                        outline = nodeVal(get1(polyStyle, 'outline'));\n                    if (pcolor) properties.fill = pcolor;\n                    if (!isNaN(popacity)) properties['fill-opacity'] = popacity;\n                    if (fill) properties['fill-opacity'] = fill === '1' ? properties['fill-opacity'] || 1 : 0;\n                    if (outline) properties['stroke-opacity'] = outline === '1' ? properties['stroke-opacity'] || 1 : 0;\n                }\n                if (extendedData) {\n                    var datas = get(extendedData, 'Data'),\n                        simpleDatas = get(extendedData, 'SimpleData');\n\n                    for (i = 0; i < datas.length; i++) {\n                        properties[datas[i].getAttribute('name')] = nodeVal(get1(datas[i], 'value'));\n                    }\n                    for (i = 0; i < simpleDatas.length; i++) {\n                        properties[simpleDatas[i].getAttribute('name')] = nodeVal(simpleDatas[i]);\n                    }\n                }\n                if (visibility) {\n                    properties.visibility = nodeVal(visibility);\n                }\n                if (geomsAndTimes.coordTimes.length) {\n                    properties.coordTimes = (geomsAndTimes.coordTimes.length === 1) ?\n                        geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n                }\n                var feature = {\n                    type: 'Feature',\n                    geometry: (geomsAndTimes.geoms.length === 1) ? geomsAndTimes.geoms[0] : {\n                        type: 'GeometryCollection',\n                        geometries: geomsAndTimes.geoms\n                    },\n                    properties: properties\n                };\n                if (attr(root, 'id')) feature.id = attr(root, 'id');\n                return [feature];\n            }\n            return gj;\n        },\n        gpx: function(doc) {\n            var i,\n                tracks = get(doc, 'trk'),\n                routes = get(doc, 'rte'),\n                waypoints = get(doc, 'wpt'),\n                // a feature collection\n                gj = fc(),\n                feature;\n            for (i = 0; i < tracks.length; i++) {\n                feature = getTrack(tracks[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < routes.length; i++) {\n                feature = getRoute(routes[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < waypoints.length; i++) {\n                gj.features.push(getPoint(waypoints[i]));\n            }\n            function getPoints(node, pointname) {\n                var pts = get(node, pointname),\n                    line = [],\n                    times = [],\n                    heartRates = [],\n                    l = pts.length;\n                if (l < 2) return {};  // Invalid line in GeoJSON\n                for (var i = 0; i < l; i++) {\n                    var c = coordPair(pts[i]);\n                    line.push(c.coordinates);\n                    if (c.time) times.push(c.time);\n                    if (c.heartRate) heartRates.push(c.heartRate);\n                }\n                return {\n                    line: line,\n                    times: times,\n                    heartRates: heartRates\n                };\n            }\n            function getTrack(node) {\n                var segments = get(node, 'trkseg'),\n                    track = [],\n                    times = [],\n                    heartRates = [],\n                    line;\n                for (var i = 0; i < segments.length; i++) {\n                    line = getPoints(segments[i], 'trkpt');\n                    if (line) {\n                        if (line.line) track.push(line.line);\n                        if (line.times && line.times.length) times.push(line.times);\n                        if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);\n                    }\n                }\n                if (track.length === 0) return;\n                var properties = getProperties(node);\n                extend(properties, getLineStyle(get1(node, 'extensions')));\n                if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;\n                if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n                return {\n                    type: 'Feature',\n                    properties: properties,\n                    geometry: {\n                        type: track.length === 1 ? 'LineString' : 'MultiLineString',\n                        coordinates: track.length === 1 ? track[0] : track\n                    }\n                };\n            }\n            function getRoute(node) {\n                var line = getPoints(node, 'rtept');\n                if (!line.line) return;\n                var prop = getProperties(node);\n                extend(prop, getLineStyle(get1(node, 'extensions')));\n                var routeObj = {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: line.line\n                    }\n                };\n                return routeObj;\n            }\n            function getPoint(node) {\n                var prop = getProperties(node);\n                extend(prop, getMulti(node, ['sym']));\n                return {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'Point',\n                        coordinates: coordPair(node).coordinates\n                    }\n                };\n            }\n            function getLineStyle(extensions) {\n                var style = {};\n                if (extensions) {\n                    var lineStyle = get1(extensions, 'line');\n                    if (lineStyle) {\n                        var color = nodeVal(get1(lineStyle, 'color')),\n                            opacity = parseFloat(nodeVal(get1(lineStyle, 'opacity'))),\n                            width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                        if (color) style.stroke = color;\n                        if (!isNaN(opacity)) style['stroke-opacity'] = opacity;\n                        // GPX width is in mm, convert to px with 96 px per inch\n                        if (!isNaN(width)) style['stroke-width'] = width * 96 / 25.4;\n                    }\n                }\n                return style;\n            }\n            function getProperties(node) {\n                var prop = getMulti(node, ['name', 'cmt', 'desc', 'type', 'time', 'keywords']),\n                    links = get(node, 'link');\n                if (links.length) prop.links = [];\n                for (var i = 0, link; i < links.length; i++) {\n                    link = { href: attr(links[i], 'href') };\n                    extend(link, getMulti(links[i], ['text', 'type']));\n                    prop.links.push(link);\n                }\n                return prop;\n            }\n            return gj;\n        }\n    };\n    return t;\n})();\n\nif (true) module.exports = toGeoJSON;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/@mapbox/togeojson/togeojson.js?");

/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports.VectorTile = __webpack_require__(/*! ./lib/vectortile.js */ \"./node_modules/@mapbox/vector-tile/lib/vectortile.js\");\nmodule.exports.VectorTileFeature = __webpack_require__(/*! ./lib/vectortilefeature.js */ \"./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js\");\nmodule.exports.VectorTileLayer = __webpack_require__(/*! ./lib/vectortilelayer.js */ \"./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js\");\n\n\n//# sourceURL=webpack:///./node_modules/@mapbox/vector-tile/index.js?");

/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/lib/vectortile.js":
/*!************************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/lib/vectortile.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar VectorTileLayer = __webpack_require__(/*! ./vectortilelayer */ \"./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js\");\n\nmodule.exports = VectorTile;\n\nfunction VectorTile(pbf, end) {\n    this.layers = pbf.readFields(readTile, {}, end);\n}\n\nfunction readTile(tag, layers, pbf) {\n    if (tag === 3) {\n        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n        if (layer.length) layers[layer.name] = layer;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/@mapbox/vector-tile/lib/vectortile.js?");

/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Point = __webpack_require__(/*! @mapbox/point-geometry */ \"./node_modules/@mapbox/point-geometry/index.js\");\n\nmodule.exports = VectorTileFeature;\n\nfunction VectorTileFeature(pbf, end, extent, keys, values) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n\n    pbf.readFields(readFeature, this, end);\n}\n\nfunction readFeature(tag, feature, pbf) {\n    if (tag == 1) feature.id = pbf.readVarint();\n    else if (tag == 2) readTag(pbf, feature);\n    else if (tag == 3) feature.type = pbf.readVarint();\n    else if (tag == 4) feature._geometry = pbf.pos;\n}\n\nfunction readTag(pbf, feature) {\n    var end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        var key = feature._keys[pbf.readVarint()],\n            value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n\nVectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\nVectorTileFeature.prototype.loadGeometry = function() {\n    var pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    var end = pbf.readVarint() + pbf.pos,\n        cmd = 1,\n        length = 0,\n        x = 0,\n        y = 0,\n        lines = [],\n        line;\n\n    while (pbf.pos < end) {\n        if (length <= 0) {\n            var cmdLen = pbf.readVarint();\n            cmd = cmdLen & 0x7;\n            length = cmdLen >> 3;\n        }\n\n        length--;\n\n        if (cmd === 1 || cmd === 2) {\n            x += pbf.readSVarint();\n            y += pbf.readSVarint();\n\n            if (cmd === 1) { // moveTo\n                if (line) lines.push(line);\n                line = [];\n            }\n\n            line.push(new Point(x, y));\n\n        } else if (cmd === 7) {\n\n            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n            if (line) {\n                line.push(line[0].clone()); // closePolygon\n            }\n\n        } else {\n            throw new Error('unknown command ' + cmd);\n        }\n    }\n\n    if (line) lines.push(line);\n\n    return lines;\n};\n\nVectorTileFeature.prototype.bbox = function() {\n    var pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    var end = pbf.readVarint() + pbf.pos,\n        cmd = 1,\n        length = 0,\n        x = 0,\n        y = 0,\n        x1 = Infinity,\n        x2 = -Infinity,\n        y1 = Infinity,\n        y2 = -Infinity;\n\n    while (pbf.pos < end) {\n        if (length <= 0) {\n            var cmdLen = pbf.readVarint();\n            cmd = cmdLen & 0x7;\n            length = cmdLen >> 3;\n        }\n\n        length--;\n\n        if (cmd === 1 || cmd === 2) {\n            x += pbf.readSVarint();\n            y += pbf.readSVarint();\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n\n        } else if (cmd !== 7) {\n            throw new Error('unknown command ' + cmd);\n        }\n    }\n\n    return [x1, y1, x2, y2];\n};\n\nVectorTileFeature.prototype.toGeoJSON = function(x, y, z) {\n    var size = this.extent * Math.pow(2, z),\n        x0 = this.extent * x,\n        y0 = this.extent * y,\n        coords = this.loadGeometry(),\n        type = VectorTileFeature.types[this.type],\n        i, j;\n\n    function project(line) {\n        for (var j = 0; j < line.length; j++) {\n            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;\n            line[j] = [\n                (p.x + x0) * 360 / size - 180,\n                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90\n            ];\n        }\n    }\n\n    switch (this.type) {\n    case 1:\n        var points = [];\n        for (i = 0; i < coords.length; i++) {\n            points[i] = coords[i][0];\n        }\n        coords = points;\n        project(coords);\n        break;\n\n    case 2:\n        for (i = 0; i < coords.length; i++) {\n            project(coords[i]);\n        }\n        break;\n\n    case 3:\n        coords = classifyRings(coords);\n        for (i = 0; i < coords.length; i++) {\n            for (j = 0; j < coords[i].length; j++) {\n                project(coords[i][j]);\n            }\n        }\n        break;\n    }\n\n    if (coords.length === 1) {\n        coords = coords[0];\n    } else {\n        type = 'Multi' + type;\n    }\n\n    var result = {\n        type: \"Feature\",\n        geometry: {\n            type: type,\n            coordinates: coords\n        },\n        properties: this.properties\n    };\n\n    if ('id' in this) {\n        result.id = this.id;\n    }\n\n    return result;\n};\n\n// classifies an array of rings into polygons with outer rings and holes\n\nfunction classifyRings(rings) {\n    var len = rings.length;\n\n    if (len <= 1) return [rings];\n\n    var polygons = [],\n        polygon,\n        ccw;\n\n    for (var i = 0; i < len; i++) {\n        var area = signedArea(rings[i]);\n        if (area === 0) continue;\n\n        if (ccw === undefined) ccw = area < 0;\n\n        if (ccw === area < 0) {\n            if (polygon) polygons.push(polygon);\n            polygon = [rings[i]];\n\n        } else {\n            polygon.push(rings[i]);\n        }\n    }\n    if (polygon) polygons.push(polygon);\n\n    return polygons;\n}\n\nfunction signedArea(ring) {\n    var sum = 0;\n    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js?");

/***/ }),

/***/ "./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar VectorTileFeature = __webpack_require__(/*! ./vectortilefeature.js */ \"./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js\");\n\nmodule.exports = VectorTileLayer;\n\nfunction VectorTileLayer(pbf, end) {\n    // Public\n    this.version = 1;\n    this.name = null;\n    this.extent = 4096;\n    this.length = 0;\n\n    // Private\n    this._pbf = pbf;\n    this._keys = [];\n    this._values = [];\n    this._features = [];\n\n    pbf.readFields(readLayer, this, end);\n\n    this.length = this._features.length;\n}\n\nfunction readLayer(tag, layer, pbf) {\n    if (tag === 15) layer.version = pbf.readVarint();\n    else if (tag === 1) layer.name = pbf.readString();\n    else if (tag === 5) layer.extent = pbf.readVarint();\n    else if (tag === 2) layer._features.push(pbf.pos);\n    else if (tag === 3) layer._keys.push(pbf.readString());\n    else if (tag === 4) layer._values.push(readValueMessage(pbf));\n}\n\nfunction readValueMessage(pbf) {\n    var value = null,\n        end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        var tag = pbf.readVarint() >> 3;\n\n        value = tag === 1 ? pbf.readString() :\n            tag === 2 ? pbf.readFloat() :\n            tag === 3 ? pbf.readDouble() :\n            tag === 4 ? pbf.readVarint64() :\n            tag === 5 ? pbf.readVarint() :\n            tag === 6 ? pbf.readSVarint() :\n            tag === 7 ? pbf.readBoolean() : null;\n    }\n\n    return value;\n}\n\n// return feature `i` from this layer as a `VectorTileFeature`\nVectorTileLayer.prototype.feature = function(i) {\n    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');\n\n    this._pbf.pos = this._features[i];\n\n    var end = this._pbf.readVarint() + this._pbf.pos;\n    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);\n};\n\n\n//# sourceURL=webpack:///./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js?");

/***/ }),

/***/ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tweenjs/tween.js/dist/tween.esm.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process) {var version = '18.5.0';\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\n\n\nvar _Group = function () {\n\tthis._tweens = {};\n\tthis._tweensAddedDuringUpdate = {};\n};\n\n_Group.prototype = {\n\tgetAll: function () {\n\n\t\treturn Object.keys(this._tweens).map(function (tweenId) {\n\t\t\treturn this._tweens[tweenId];\n\t\t}.bind(this));\n\n\t},\n\n\tremoveAll: function () {\n\n\t\tthis._tweens = {};\n\n\t},\n\n\tadd: function (tween) {\n\n\t\tthis._tweens[tween.getId()] = tween;\n\t\tthis._tweensAddedDuringUpdate[tween.getId()] = tween;\n\n\t},\n\n\tremove: function (tween) {\n\n\t\tdelete this._tweens[tween.getId()];\n\t\tdelete this._tweensAddedDuringUpdate[tween.getId()];\n\n\t},\n\n\tupdate: function (time, preserve) {\n\n\t\tvar tweenIds = Object.keys(this._tweens);\n\n\t\tif (tweenIds.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttime = time !== undefined ? time : TWEEN.now();\n\n\t\t// Tweens are updated in \"batches\". If you add a new tween during an\n\t\t// update, then the new tween will be updated in the next batch.\n\t\t// If you remove a tween during an update, it may or may not be updated.\n\t\t// However, if the removed tween was added during the current batch,\n\t\t// then it will not be updated.\n\t\twhile (tweenIds.length > 0) {\n\t\t\tthis._tweensAddedDuringUpdate = {};\n\n\t\t\tfor (var i = 0; i < tweenIds.length; i++) {\n\n\t\t\t\tvar tween = this._tweens[tweenIds[i]];\n\n\t\t\t\tif (tween && tween.update(time) === false) {\n\t\t\t\t\ttween._isPlaying = false;\n\n\t\t\t\t\tif (!preserve) {\n\t\t\t\t\t\tdelete this._tweens[tweenIds[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttweenIds = Object.keys(this._tweensAddedDuringUpdate);\n\t\t}\n\n\t\treturn true;\n\n\t}\n};\n\nvar TWEEN = new _Group();\n\nTWEEN.Group = _Group;\nTWEEN._nextId = 0;\nTWEEN.nextId = function () {\n\treturn TWEEN._nextId++;\n};\n\n\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\nif (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {\n\tTWEEN.now = function () {\n\t\tvar time = process.hrtime();\n\n\t\t// Convert [seconds, nanoseconds] to milliseconds.\n\t\treturn time[0] * 1000 + time[1] / 1000000;\n\t};\n}\n// In a browser, use self.performance.now if it is available.\nelse if (typeof (self) !== 'undefined' &&\n         self.performance !== undefined &&\n\t\t self.performance.now !== undefined) {\n\t// This must be bound, because directly assigning this function\n\t// leads to an invocation exception in Chrome.\n\tTWEEN.now = self.performance.now.bind(self.performance);\n}\n// Use Date.now if it is available.\nelse if (Date.now !== undefined) {\n\tTWEEN.now = Date.now;\n}\n// Otherwise, use 'new Date().getTime()'.\nelse {\n\tTWEEN.now = function () {\n\t\treturn new Date().getTime();\n\t};\n}\n\n\nTWEEN.Tween = function (object, group) {\n\tthis._isPaused = false;\n\tthis._pauseStart = null;\n\tthis._object = object;\n\tthis._valuesStart = {};\n\tthis._valuesEnd = {};\n\tthis._valuesStartRepeat = {};\n\tthis._duration = 1000;\n\tthis._repeat = 0;\n\tthis._repeatDelayTime = undefined;\n\tthis._yoyo = false;\n\tthis._isPlaying = false;\n\tthis._reversed = false;\n\tthis._delayTime = 0;\n\tthis._startTime = null;\n\tthis._easingFunction = TWEEN.Easing.Linear.None;\n\tthis._interpolationFunction = TWEEN.Interpolation.Linear;\n\tthis._chainedTweens = [];\n\tthis._onStartCallback = null;\n\tthis._onStartCallbackFired = false;\n\tthis._onUpdateCallback = null;\n\tthis._onRepeatCallback = null;\n\tthis._onCompleteCallback = null;\n\tthis._onStopCallback = null;\n\tthis._group = group || TWEEN;\n\tthis._id = TWEEN.nextId();\n\n};\n\nTWEEN.Tween.prototype = {\n\tgetId: function () {\n\t\treturn this._id;\n\t},\n\n\tisPlaying: function () {\n\t\treturn this._isPlaying;\n\t},\n\n\tisPaused: function () {\n\t\treturn this._isPaused;\n\t},\n\n\tto: function (properties, duration) {\n\n\t\tthis._valuesEnd = Object.create(properties);\n\n\t\tif (duration !== undefined) {\n\t\t\tthis._duration = duration;\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tduration: function duration(d) {\n\t\tthis._duration = d;\n\t\treturn this;\n\t},\n\n\tstart: function (time) {\n\n\t\tthis._group.add(this);\n\n\t\tthis._isPlaying = true;\n\n\t\tthis._isPaused = false;\n\n\t\tthis._onStartCallbackFired = false;\n\n\t\tthis._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();\n\t\tthis._startTime += this._delayTime;\n\n\t\tfor (var property in this._valuesEnd) {\n\n\t\t\t// Check if an Array was provided as property value\n\t\t\tif (this._valuesEnd[property] instanceof Array) {\n\n\t\t\t\tif (this._valuesEnd[property].length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Create a local copy of the Array with the start value at the front\n\t\t\t\tthis._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);\n\n\t\t\t}\n\n\t\t\t// If `to()` specifies a property that doesn't exist in the source object,\n\t\t\t// we should not set that property in the object\n\t\t\tif (this._object[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Save the starting value, but only once.\n\t\t\tif (typeof(this._valuesStart[property]) === 'undefined') {\n\t\t\t\tthis._valuesStart[property] = this._object[property];\n\t\t\t}\n\n\t\t\tif ((this._valuesStart[property] instanceof Array) === false) {\n\t\t\t\tthis._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n\t\t\t}\n\n\t\t\tthis._valuesStartRepeat[property] = this._valuesStart[property] || 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif (!this._isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._group.remove(this);\n\n\t\tthis._isPlaying = false;\n\n\t\tthis._isPaused = false;\n\n\t\tif (this._onStopCallback !== null) {\n\t\t\tthis._onStopCallback(this._object);\n\t\t}\n\n\t\tthis.stopChainedTweens();\n\t\treturn this;\n\n\t},\n\n\tend: function () {\n\n\t\tthis.update(Infinity);\n\t\treturn this;\n\n\t},\n\n\tpause: function(time) {\n\n\t\tif (this._isPaused || !this._isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._isPaused = true;\n\n\t\tthis._pauseStart = time === undefined ? TWEEN.now() : time;\n\n\t\tthis._group.remove(this);\n\n\t\treturn this;\n\n\t},\n\n\tresume: function(time) {\n\n\t\tif (!this._isPaused || !this._isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._isPaused = false;\n\n\t\tthis._startTime += (time === undefined ? TWEEN.now() : time)\n\t\t\t- this._pauseStart;\n\n\t\tthis._pauseStart = 0;\n\n\t\tthis._group.add(this);\n\n\t\treturn this;\n\n\t},\n\n\tstopChainedTweens: function () {\n\n\t\tfor (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\tthis._chainedTweens[i].stop();\n\t\t}\n\n\t},\n\n\tgroup: function (group) {\n\t\tthis._group = group;\n\t\treturn this;\n\t},\n\n\tdelay: function (amount) {\n\n\t\tthis._delayTime = amount;\n\t\treturn this;\n\n\t},\n\n\trepeat: function (times) {\n\n\t\tthis._repeat = times;\n\t\treturn this;\n\n\t},\n\n\trepeatDelay: function (amount) {\n\n\t\tthis._repeatDelayTime = amount;\n\t\treturn this;\n\n\t},\n\n\tyoyo: function (yoyo) {\n\n\t\tthis._yoyo = yoyo;\n\t\treturn this;\n\n\t},\n\n\teasing: function (easingFunction) {\n\n\t\tthis._easingFunction = easingFunction;\n\t\treturn this;\n\n\t},\n\n\tinterpolation: function (interpolationFunction) {\n\n\t\tthis._interpolationFunction = interpolationFunction;\n\t\treturn this;\n\n\t},\n\n\tchain: function () {\n\n\t\tthis._chainedTweens = arguments;\n\t\treturn this;\n\n\t},\n\n\tonStart: function (callback) {\n\n\t\tthis._onStartCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonUpdate: function (callback) {\n\n\t\tthis._onUpdateCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonRepeat: function onRepeat(callback) {\n\n\t\tthis._onRepeatCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonComplete: function (callback) {\n\n\t\tthis._onCompleteCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonStop: function (callback) {\n\n\t\tthis._onStopCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tupdate: function (time) {\n\n\t\tvar property;\n\t\tvar elapsed;\n\t\tvar value;\n\n\t\tif (time < this._startTime) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this._onStartCallbackFired === false) {\n\n\t\t\tif (this._onStartCallback !== null) {\n\t\t\t\tthis._onStartCallback(this._object);\n\t\t\t}\n\n\t\t\tthis._onStartCallbackFired = true;\n\t\t}\n\n\t\telapsed = (time - this._startTime) / this._duration;\n\t\telapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;\n\n\t\tvalue = this._easingFunction(elapsed);\n\n\t\tfor (property in this._valuesEnd) {\n\n\t\t\t// Don't update properties that do not exist in the source object\n\t\t\tif (this._valuesStart[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar start = this._valuesStart[property] || 0;\n\t\t\tvar end = this._valuesEnd[property];\n\n\t\t\tif (end instanceof Array) {\n\n\t\t\t\tthis._object[property] = this._interpolationFunction(end, value);\n\n\t\t\t} else {\n\n\t\t\t\t// Parses relative end values with start as base (e.g.: +10, -3)\n\t\t\t\tif (typeof (end) === 'string') {\n\n\t\t\t\t\tif (end.charAt(0) === '+' || end.charAt(0) === '-') {\n\t\t\t\t\t\tend = start + parseFloat(end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend = parseFloat(end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Protect against non numeric properties.\n\t\t\t\tif (typeof (end) === 'number') {\n\t\t\t\t\tthis._object[property] = start + (end - start) * value;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (this._onUpdateCallback !== null) {\n\t\t\tthis._onUpdateCallback(this._object, elapsed);\n\t\t}\n\n\t\tif (elapsed === 1) {\n\n\t\t\tif (this._repeat > 0) {\n\n\t\t\t\tif (isFinite(this._repeat)) {\n\t\t\t\t\tthis._repeat--;\n\t\t\t\t}\n\n\t\t\t\t// Reassign starting values, restart by making startTime = now\n\t\t\t\tfor (property in this._valuesStartRepeat) {\n\n\t\t\t\t\tif (typeof (this._valuesEnd[property]) === 'string') {\n\t\t\t\t\t\tthis._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._yoyo) {\n\t\t\t\t\t\tvar tmp = this._valuesStartRepeat[property];\n\n\t\t\t\t\t\tthis._valuesStartRepeat[property] = this._valuesEnd[property];\n\t\t\t\t\t\tthis._valuesEnd[property] = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._valuesStart[property] = this._valuesStartRepeat[property];\n\n\t\t\t\t}\n\n\t\t\t\tif (this._yoyo) {\n\t\t\t\t\tthis._reversed = !this._reversed;\n\t\t\t\t}\n\n\t\t\t\tif (this._repeatDelayTime !== undefined) {\n\t\t\t\t\tthis._startTime = time + this._repeatDelayTime;\n\t\t\t\t} else {\n\t\t\t\t\tthis._startTime = time + this._delayTime;\n\t\t\t\t}\n\n\t\t\t\tif (this._onRepeatCallback !== null) {\n\t\t\t\t\tthis._onRepeatCallback(this._object);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\tif (this._onCompleteCallback !== null) {\n\n\t\t\t\t\tthis._onCompleteCallback(this._object);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t\t\t// Make the chained tweens start exactly at the time they should,\n\t\t\t\t\t// even if the `update()` method was called way past the duration of the tween\n\t\t\t\t\tthis._chainedTweens[i].start(this._startTime + this._duration);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n};\n\n\nTWEEN.Easing = {\n\n\tLinear: {\n\n\t\tNone: function (k) {\n\n\t\t\treturn k;\n\n\t\t}\n\n\t},\n\n\tQuadratic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k * (2 - k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * (--k * (k - 2) - 1);\n\n\t\t}\n\n\t},\n\n\tCubic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tQuartic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn 1 - (--k * k * k * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * ((k -= 2) * k * k * k - 2);\n\n\t\t}\n\n\t},\n\n\tQuintic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tSinusoidal: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.cos(k * Math.PI / 2);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sin(k * Math.PI / 2);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\treturn 0.5 * (1 - Math.cos(Math.PI * k));\n\n\t\t}\n\n\t},\n\n\tExponential: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k === 0 ? 0 : Math.pow(1024, k - 1);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(1024, k - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);\n\n\t\t}\n\n\t},\n\n\tCircular: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.sqrt(1 - k * k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sqrt(1 - (--k * k));\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn - 0.5 * (Math.sqrt(1 - k * k) - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\n\t\t}\n\n\t},\n\n\tElastic: {\n\n\t\tIn: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tk *= 2;\n\n\t\t\tif (k < 1) {\n\t\t\t\treturn -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\t\t}\n\n\t\t\treturn 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n\n\t\t}\n\n\t},\n\n\tBack: {\n\n\t\tIn: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn k * k * ((s + 1) * k - s);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn --k * k * ((s + 1) * k + s) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tvar s = 1.70158 * 1.525;\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * (k * k * ((s + 1) * k - s));\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\n\t\t}\n\n\t},\n\n\tBounce: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - TWEEN.Easing.Bounce.Out(1 - k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k < (1 / 2.75)) {\n\t\t\t\treturn 7.5625 * k * k;\n\t\t\t} else if (k < (2 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t\t\t} else if (k < (2.5 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t\t\t} else {\n\t\t\t\treturn 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t\t\t}\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k < 0.5) {\n\t\t\t\treturn TWEEN.Easing.Bounce.In(k * 2) * 0.5;\n\t\t\t}\n\n\t\t\treturn TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n\n\t\t}\n\n\t}\n\n};\n\nTWEEN.Interpolation = {\n\n\tLinear: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.Linear;\n\n\t\tif (k < 0) {\n\t\t\treturn fn(v[0], v[1], f);\n\t\t}\n\n\t\tif (k > 1) {\n\t\t\treturn fn(v[m], v[m - 1], m - f);\n\t\t}\n\n\t\treturn fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n\n\t},\n\n\tBezier: function (v, k) {\n\n\t\tvar b = 0;\n\t\tvar n = v.length - 1;\n\t\tvar pw = Math.pow;\n\t\tvar bn = TWEEN.Interpolation.Utils.Bernstein;\n\n\t\tfor (var i = 0; i <= n; i++) {\n\t\t\tb += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n\t\t}\n\n\t\treturn b;\n\n\t},\n\n\tCatmullRom: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.CatmullRom;\n\n\t\tif (v[0] === v[m]) {\n\n\t\t\tif (k < 0) {\n\t\t\t\ti = Math.floor(f = m * (1 + k));\n\t\t\t}\n\n\t\t\treturn fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n\n\t\t} else {\n\n\t\t\tif (k < 0) {\n\t\t\t\treturn v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n\t\t\t}\n\n\t\t\tif (k > 1) {\n\t\t\t\treturn v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n\t\t\t}\n\n\t\t\treturn fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n\n\t\t}\n\n\t},\n\n\tUtils: {\n\n\t\tLinear: function (p0, p1, t) {\n\n\t\t\treturn (p1 - p0) * t + p0;\n\n\t\t},\n\n\t\tBernstein: function (n, i) {\n\n\t\t\tvar fc = TWEEN.Interpolation.Utils.Factorial;\n\n\t\t\treturn fc(n) / fc(i) / fc(n - i);\n\n\t\t},\n\n\t\tFactorial: (function () {\n\n\t\t\tvar a = [1];\n\n\t\t\treturn function (n) {\n\n\t\t\t\tvar s = 1;\n\n\t\t\t\tif (a[n]) {\n\t\t\t\t\treturn a[n];\n\t\t\t\t}\n\n\t\t\t\tfor (var i = n; i > 1; i--) {\n\t\t\t\t\ts *= i;\n\t\t\t\t}\n\n\t\t\t\ta[n] = s;\n\t\t\t\treturn s;\n\n\t\t\t};\n\n\t\t})(),\n\n\t\tCatmullRom: function (p0, p1, p2, p3, t) {\n\n\t\t\tvar v0 = (p2 - p0) * 0.5;\n\t\t\tvar v1 = (p3 - p1) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\n\t\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n};\nTWEEN.version = version;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TWEEN);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/@tweenjs/tween.js/dist/tween.esm.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/earcut/src/earcut.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/immediate/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/immediate/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/immediate/lib/browser.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Controls/FirstPersonControls.js":
/*!*****************************************************************!*\
  !*** ./node_modules/itowns/lib/Controls/FirstPersonControls.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _MainLoop = __webpack_require__(/*! ../Core/MainLoop */ \"./node_modules/itowns/lib/Core/MainLoop.js\");\n\n// Note: we could use existing three.js controls (like https://github.com/mrdoob/three.js/blob/dev/examples/js/controls/FirstPersonControls.js)\n// but including these controls in itowns allows use to integrate them tightly with itowns.\n// Especially the existing controls are expecting a continuous update loop while we have a pausable one (so our controls use .notifyChange when needed)\nfunction limitRotation(camera3D, rot, verticalFOV) {\n  // Limit vertical rotation (look up/down) to make sure the user cannot see\n  // outside of the cone defined by verticalFOV\n  var limit = THREE.Math.degToRad(verticalFOV - camera3D.fov) * 0.5;\n  return THREE.Math.clamp(rot, -limit, limit);\n}\n\nvar axisY = new THREE.Vector3(0, 1, 0);\n\nfunction applyRotation(view, camera3D, state) {\n  camera3D.quaternion.setFromUnitVectors(axisY, camera3D.up);\n  camera3D.rotateY(state.rotateY);\n  camera3D.rotateX(state.rotateX);\n  view.notifyChange(view.camera.camera3D);\n}\n\nvar MOVEMENTS = {\n  38: {\n    method: 'translateZ',\n    sign: -1\n  },\n  // FORWARD: up key\n  40: {\n    method: 'translateZ',\n    sign: 1\n  },\n  // BACKWARD: down key\n  37: {\n    method: 'translateX',\n    sign: -1\n  },\n  // STRAFE_LEFT: left key\n  39: {\n    method: 'translateX',\n    sign: 1\n  },\n  // STRAFE_RIGHT: right key\n  33: {\n    method: 'translateY',\n    sign: 1\n  },\n  // UP: PageUp key\n  34: {\n    method: 'translateY',\n    sign: -1\n  } // DOWN: PageDown key\n\n};\n\nfunction moveCameraVerticalPlanar(value) {\n  this.camera.position.z += value;\n}\n\nvar normal = new THREE.Vector3();\nvar q = new THREE.Quaternion();\nvar e = new THREE.Euler(0, 0, 0, 'YXZ');\n\nfunction moveCameraVerticalGlobe(value) {\n  // compute geodesic normale\n  normal.copy(this.camera.position);\n  normal.normalize();\n  this.camera.position.add(normal.multiplyScalar(value));\n}\n\nvar FirstPersonControls =\n/*#__PURE__*/\nfunction (_THREE$EventDispatche) {\n  (0, _inherits2[\"default\"])(FirstPersonControls, _THREE$EventDispatche);\n\n  /**\n   * @Constructor\n   * @param {View} view\n   * @param {object} options\n   * @param {boolean} options.focusOnClick - whether or not to focus the renderer domElement on click\n   * @param {boolean} options.focusOnMouseOver - whether or not to focus when the mouse is over the domElement\n   * @param {boolean} options.moveSpeed - if > 0, pressing the arrow keys will move the camera\n   * @param {number} options.verticalFOV - define the max visible vertical angle of the scene in degrees (default 180)\n   * @param {number} options.panoramaRatio - alternative way to specify the max vertical angle when using a panorama.\n   * You can specify the panorama width/height ratio and the verticalFOV will be computed automatically\n   * @param {boolean} options.disableEventListeners - if true, the controls will not self listen to mouse/key events.\n   * You'll have to manually forward the events to the appropriate functions: onMouseDown, onMouseMove, onMouseUp,\n   * onKeyUp, onKeyDown and onMouseWheel.\n   */\n  function FirstPersonControls(view) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, FirstPersonControls);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(FirstPersonControls).call(this));\n    _this.isFirstPersonControls = true;\n    _this.camera = view.camera.camera3D;\n    _this.view = view;\n    _this.moves = new Set();\n\n    if (options.panoramaRatio) {\n      var radius = options.panoramaRatio * 200 / (2 * Math.PI);\n      options.verticalFOV = options.panoramaRatio == 2 ? 180 : THREE.Math.radToDeg(2 * Math.atan(200 / (2 * radius)));\n    }\n\n    options.verticalFOV = options.verticalFOV || 180;\n    options.moveSpeed = options.moveSpeed === undefined ? 10 : options.moveSpeed; // backward or forward move speed in m/s\n\n    _this.options = options;\n    _this._isMouseDown = false;\n    _this._onMouseDownMouseX = 0;\n    _this._onMouseDownMouseY = 0;\n    _this._state = {\n      rotateX: 0,\n      rotateY: 0,\n      snapshot: function snapshot() {\n        return {\n          rotateX: this.rotateX,\n          rotateY: this.rotateY\n        };\n      }\n    };\n\n    _this.reset();\n\n    var domElement = view.mainLoop.gfxEngine.renderer.domElement;\n\n    if (!options.disableEventListeners) {\n      domElement.addEventListener('mousedown', _this.onMouseDown.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n      domElement.addEventListener('touchstart', _this.onMouseDown.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n      domElement.addEventListener('mousemove', _this.onMouseMove.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n      domElement.addEventListener('touchmove', _this.onMouseMove.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n      domElement.addEventListener('mouseup', _this.onMouseUp.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n      domElement.addEventListener('touchend', _this.onMouseUp.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n      domElement.addEventListener('keyup', _this.onKeyUp.bind((0, _assertThisInitialized2[\"default\"])(_this)), true);\n      domElement.addEventListener('keydown', _this.onKeyDown.bind((0, _assertThisInitialized2[\"default\"])(_this)), true);\n      domElement.addEventListener('mousewheel', _this.onMouseWheel.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n      domElement.addEventListener('DOMMouseScroll', _this.onMouseWheel.bind((0, _assertThisInitialized2[\"default\"])(_this)), false); // firefox\n    }\n\n    _this.view.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.AFTER_CAMERA_UPDATE, _this.update.bind((0, _assertThisInitialized2[\"default\"])(_this))); // focus policy\n\n\n    if (options.focusOnMouseOver) {\n      domElement.addEventListener('mouseover', function () {\n        return domElement.focus();\n      });\n    }\n\n    if (options.focusOnClick) {\n      domElement.addEventListener('click', function () {\n        return domElement.focus();\n      });\n    }\n\n    if (view.referenceCrs == 'EPSG:4978') {\n      _this.moveCameraVertical = moveCameraVerticalGlobe;\n    } else {\n      _this.moveCameraVertical = moveCameraVerticalPlanar;\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(FirstPersonControls, [{\n    key: \"isUserInteracting\",\n    value: function isUserInteracting() {\n      return this.moves.size !== 0 && !this._isMouseDown;\n    }\n    /**\n     * Resets the controls internal state to match the camera' state.\n     * This must be called when manually modifying the camera's position or rotation.\n     * @param {boolean} preserveRotationOnX - if true, the look up/down rotation will\n     * not be copied from the camera\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var preserveRotationOnX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // Compute the correct init state, given the calculus in applyRotation:\n      // cam.quaternion = q * r\n      // => r = inverse(q) * cam.quaterion\n      // q is the quaternion derived from the up vector\n      q.setFromUnitVectors(axisY, this.camera.up);\n      q.inverse();\n      q.multiply(this.camera.quaternion); // tranform it to euler\n\n      e.setFromQuaternion(q);\n\n      if (!preserveRotationOnX) {\n        this._state.rotateX = e.x;\n      }\n\n      this._state.rotateY = e.y;\n    }\n    /**\n     * Updates the camera position / rotation based on occured input events.\n     * This is done automatically when needed but can also be done if needed.\n     * @param {number} dt - ellpased time since last update in seconds\n     * @param {boolean} updateLoopRestarted - true if itowns' update loop just restarted\n     * @param {boolean} force - set to true if you want to force the update, even if it\n     * appears unneeded.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(dt, updateLoopRestarted, force) {\n      if (this.enabled == false) {\n        return;\n      } // dt will not be relevant when we just started rendering, we consider a 1-frame move in this case\n\n\n      if (updateLoopRestarted) {\n        dt = 16;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.moves[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var move = _step.value;\n\n          if (move.method === 'translateY') {\n            this.moveCameraVertical(move.sign * this.options.moveSpeed * dt / 1000);\n          } else {\n            this.camera[move.method](move.sign * this.options.moveSpeed * dt / 1000);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (this._isMouseDown === true || force === true) {\n        applyRotation(this.view, this.camera, this._state);\n      }\n\n      if (this.moves.size) {\n        this.view.notifyChange(this.view.camera.camera3D);\n      }\n    } // Event callback functions\n    // Mouse movement handling\n\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      if (this.enabled == false) {\n        return;\n      } // next line is commented because, when I uncomment it, key binding doesn't work any more.\n      // event.preventDefault();\n\n\n      this._isMouseDown = true;\n      var coords = this.view.eventToViewCoords(event);\n      this._onMouseDownMouseX = coords.x;\n      this._onMouseDownMouseY = coords.y;\n      this._stateOnMouseDown = this._state.snapshot();\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      if (this.enabled == false) {\n        return;\n      }\n\n      this._isMouseDown = false;\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      if (this.enabled == false) {\n        return;\n      }\n\n      if (this._isMouseDown === true) {\n        // in rigor we have tan(theta) = tan(cameraFOV) * deltaH / H\n        // (where deltaH is the vertical amount we moved, and H the renderer height)\n        // we loosely approximate tan(x) by x\n        var pxToAngleRatio = THREE.Math.degToRad(this.camera.fov) / this.view.mainLoop.gfxEngine.height;\n        var coords = this.view.eventToViewCoords(event); // update state based on pointer movement\n\n        this._state.rotateY = (coords.x - this._onMouseDownMouseX) * pxToAngleRatio + this._stateOnMouseDown.rotateY;\n        this._state.rotateX = limitRotation(this.camera, (coords.y - this._onMouseDownMouseY) * pxToAngleRatio + this._stateOnMouseDown.rotateX, this.options.verticalFOV);\n        applyRotation(this.view, this.camera, this._state);\n      }\n    } // Mouse wheel\n\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(event) {\n      if (this.enabled == false) {\n        return;\n      }\n\n      var delta = 0;\n\n      if (event.wheelDelta !== undefined) {\n        delta = -event.wheelDelta; // Firefox\n      } else if (event.detail !== undefined) {\n        delta = event.detail;\n      }\n\n      this.camera.fov = THREE.Math.clamp(this.camera.fov + Math.sign(delta), 10, Math.min(100, this.options.verticalFOV));\n      this.camera.updateProjectionMatrix();\n      this._state.rotateX = limitRotation(this.camera, this._state.rotateX, this.options.verticalFOV);\n      applyRotation(this.view, this.camera, this._state);\n    } // Keyboard handling\n\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp(e) {\n      if (this.enabled == false) {\n        return;\n      }\n\n      var move = MOVEMENTS[e.keyCode];\n\n      if (move) {\n        this.moves[\"delete\"](move);\n        this.view.notifyChange(undefined, false);\n        e.preventDefault();\n      }\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(e) {\n      if (this.enabled == false) {\n        return;\n      }\n\n      var move = MOVEMENTS[e.keyCode];\n\n      if (move) {\n        this.moves.add(move);\n        this.view.notifyChange(undefined, false);\n        e.preventDefault();\n      }\n    }\n  }]);\n  return FirstPersonControls;\n}(THREE.EventDispatcher);\n\nvar _default = FirstPersonControls;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Controls/FirstPersonControls.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Controls/FlyControls.js":
/*!*********************************************************!*\
  !*** ./node_modules/itowns/lib/Controls/FlyControls.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _MainLoop = __webpack_require__(/*! ../Core/MainLoop */ \"./node_modules/itowns/lib/Core/MainLoop.js\");\n\nvar MOVEMENTS = {\n  38: {\n    method: 'translateZ',\n    sign: -1\n  },\n  // FORWARD: up key\n  40: {\n    method: 'translateZ',\n    sign: 1\n  },\n  // BACKWARD: down key\n  37: {\n    method: 'translateX',\n    sign: -1\n  },\n  // STRAFE_LEFT: left key\n  39: {\n    method: 'translateX',\n    sign: 1\n  },\n  // STRAFE_RIGHT: right key\n  33: {\n    method: 'rotateZ',\n    sign: 1,\n    noSpeed: true\n  },\n  // UP: PageUp key\n  34: {\n    method: 'rotateZ',\n    sign: -1,\n    noSpeed: true\n  },\n  // DOWN: PageDown key\n  wheelup: {\n    method: 'translateZ',\n    sign: 1,\n    oneshot: true\n  },\n  // WHEEL up\n  wheeldown: {\n    method: 'translateZ',\n    sign: -1,\n    oneshot: true\n  } // WHEEL down\n\n};\n\nfunction onDocumentMouseDown(event) {\n  event.preventDefault();\n  this._isMouseDown = true;\n  var coords = this.view.eventToViewCoords(event);\n  this._onMouseDownMouseX = coords.x;\n  this._onMouseDownMouseY = coords.y;\n}\n\nfunction onTouchStart(event) {\n  event.preventDefault();\n  this._isMouseDown = true;\n  this._onMouseDownMouseX = event.touches[0].pageX;\n  this._onMouseDownMouseY = event.touches[0].pageY;\n}\n\nfunction onPointerMove(event) {\n  if (this._isMouseDown === true) {\n    var coords = this.view.eventToViewCoords(event); // in rigor we have tan(theta) = tan(cameraFOV) * deltaH / H\n    // (where deltaH is the vertical amount we moved, and H the renderer height)\n    // we loosely approximate tan(x) by x\n\n    var pxToAngleRatio = THREE.Math.degToRad(this._camera3D.fov) / this.view.mainLoop.gfxEngine.height;\n\n    this._camera3D.rotateY((coords.x - this._onMouseDownMouseX) * pxToAngleRatio);\n\n    this._camera3D.rotateX((coords.y - this._onMouseDownMouseY) * pxToAngleRatio);\n\n    this._onMouseDownMouseX = coords.x;\n    this._onMouseDownMouseY = coords.y;\n    this.view.notifyChange(this._camera3D, false);\n  }\n}\n\nfunction onDocumentMouseUp() {\n  this._isMouseDown = false;\n}\n\nfunction onKeyUp(e) {\n  var move = MOVEMENTS[e.keyCode];\n\n  if (move) {\n    this.moves[\"delete\"](move);\n    e.preventDefault();\n  }\n}\n\nfunction onKeyDown(e) {\n  var move = MOVEMENTS[e.keyCode];\n\n  if (move) {\n    this.moves.add(move);\n    this.view.notifyChange(this._camera3D, false);\n    e.preventDefault();\n  }\n}\n\nfunction onDocumentMouseWheel(event) {\n  var delta = 0;\n\n  if (event.wheelDelta !== undefined) {\n    delta = event.wheelDelta; // Firefox\n  } else if (event.detail !== undefined) {\n    delta = -event.detail;\n  }\n\n  if (delta < 0) {\n    this.moves.add(MOVEMENTS.wheelup);\n  } else {\n    this.moves.add(MOVEMENTS.wheeldown);\n  }\n\n  this.view.notifyChange(this._camera3D, false);\n}\n/**\n * First-Person controls (at least a possible declination of it).\n *\n * Bindings:\n * - up + down keys: forward/backward\n * - left + right keys: strafing movements\n * - PageUp + PageDown: roll movement\n * - mouse click+drag: pitch and yaw movements (as looking at a panorama, not as in FPS games for instance)\n */\n\n\nvar FlyControls =\n/*#__PURE__*/\nfunction (_THREE$EventDispatche) {\n  (0, _inherits2[\"default\"])(FlyControls, _THREE$EventDispatche);\n\n  /**\n   * @Constructor\n   * @param {View} view\n   * @param {object} options\n   * @param {boolean} options.focusOnClick - whether or not to focus the renderer domElement on click\n   * @param {boolean} options.focusOnMouseOver - whether or not to focus when the mouse is over the domElement\n   */\n  function FlyControls(view) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, FlyControls);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(FlyControls).call(this));\n    var domElement = view.mainLoop.gfxEngine.renderer.domElement;\n    _this.view = view;\n    _this.options = options;\n    _this._camera3D = view.camera.camera3D;\n    _this.moves = new Set();\n    _this.moveSpeed = 10; // backward or forward move speed in m/s\n\n    _this._onMouseDownMouseX = 0;\n    _this._onMouseDownMouseY = 0;\n    _this._isMouseDown = false;\n    domElement.addEventListener('mousedown', onDocumentMouseDown.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n    domElement.addEventListener('touchstart', onTouchStart.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n    var bindedPM = onPointerMove.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    domElement.addEventListener('mousemove', bindedPM, false);\n    domElement.addEventListener('touchmove', bindedPM, false);\n    domElement.addEventListener('mouseup', onDocumentMouseUp.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n    domElement.addEventListener('touchend', onDocumentMouseUp.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n    domElement.addEventListener('mousewheel', onDocumentMouseWheel.bind((0, _assertThisInitialized2[\"default\"])(_this)), false);\n    domElement.addEventListener('DOMMouseScroll', onDocumentMouseWheel.bind((0, _assertThisInitialized2[\"default\"])(_this)), false); // firefox\n\n    domElement.addEventListener('keyup', onKeyUp.bind((0, _assertThisInitialized2[\"default\"])(_this)), true);\n    domElement.addEventListener('keydown', onKeyDown.bind((0, _assertThisInitialized2[\"default\"])(_this)), true);\n\n    _this.view.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.AFTER_CAMERA_UPDATE, _this.update.bind((0, _assertThisInitialized2[\"default\"])(_this))); // focus policy\n\n\n    if (options.focusOnMouseOver) {\n      domElement.addEventListener('mouseover', function () {\n        return domElement.focus();\n      });\n    }\n\n    if (options.focusOnClick) {\n      domElement.addEventListener('click', function () {\n        return domElement.focus();\n      });\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(FlyControls, [{\n    key: \"isUserInteracting\",\n    value: function isUserInteracting() {\n      return this.moves.size !== 0 || this._isMouseDown;\n    }\n  }, {\n    key: \"update\",\n    value: function update(dt, updateLoopRestarted) {\n      // if we are in a keypressed state, then update position\n      // dt will not be relevant when we just started rendering, we consider a 1-frame move in this case\n      if (updateLoopRestarted) {\n        dt = 16;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.moves[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _move = _step.value;\n\n          this._camera3D[_move.method](_move.sign * (_move.noSpeed ? 1 : this.moveSpeed) * dt / 1000);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (this.moves.size > 0 || this._isMouseDown) {\n        this.view.notifyChange(this._camera3D);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.moves[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var move = _step2.value;\n\n            if (move.oneshot) {\n              this.moves[\"delete\"](move);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  }]);\n  return FlyControls;\n}(THREE.EventDispatcher);\n\nvar _default = FlyControls;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Controls/FlyControls.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Controls/GlobeControls.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Controls/GlobeControls.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.CONTROL_EVENTS = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _AnimationPlayer = _interopRequireDefault(__webpack_require__(/*! ../Core/AnimationPlayer */ \"./node_modules/itowns/lib/Core/AnimationPlayer.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Ellipsoid = __webpack_require__(/*! ../Core/Math/Ellipsoid */ \"./node_modules/itowns/lib/Core/Math/Ellipsoid.js\");\n\nvar _CameraUtils = _interopRequireDefault(__webpack_require__(/*! ../Utils/CameraUtils */ \"./node_modules/itowns/lib/Utils/CameraUtils.js\"));\n\nvar _StateControl = _interopRequireDefault(__webpack_require__(/*! ./StateControl */ \"./node_modules/itowns/lib/Controls/StateControl.js\"));\n\n// private members\nvar EPS = 0.000001; // Orbit\n\nvar rotateStart = new THREE.Vector2();\nvar rotateEnd = new THREE.Vector2();\nvar rotateDelta = new THREE.Vector2();\nvar spherical = new THREE.Spherical(1.0, 0.01, 0);\nvar sphericalDelta = new THREE.Spherical(1.0, 0, 0);\nvar orbitScale = 1.0; // Pan\n\nvar panStart = new THREE.Vector2();\nvar panEnd = new THREE.Vector2();\nvar panDelta = new THREE.Vector2();\nvar panOffset = new THREE.Vector3(); // Dolly\n\nvar dollyStart = new THREE.Vector2();\nvar dollyEnd = new THREE.Vector2();\nvar dollyDelta = new THREE.Vector2(); // Globe move\n\nvar moveAroundGlobe = new THREE.Quaternion();\nvar cameraTarget = new THREE.Object3D();\ncameraTarget.matrixWorldInverse = new THREE.Matrix4();\nvar xyz = new _Coordinates[\"default\"]('EPSG:4978', 0, 0, 0);\nvar c = new _Coordinates[\"default\"]('EPSG:4326', 0, 0, 0); // Position object on globe\n\nfunction positionObject(newPosition, object) {\n  xyz.setFromVector3(newPosition).as('EPSG:4326', c);\n  object.position.copy(newPosition);\n  object.lookAt(c.geodesicNormal.add(newPosition));\n  object.rotateX(Math.PI * 0.5);\n  object.updateMatrixWorld(true);\n} // Save the last time of mouse move for damping\n\n\nvar lastTimeMouseMove = 0; // Animations and damping\n\nvar enableAnimation = true;\nvar dampingFactor = 0.25;\nvar dampingMove = new THREE.Quaternion(0, 0, 0, 1);\nvar durationDampingMove = 120;\nvar durationDampingOrbital = 60; // Pan Move\n\nvar panVector = new THREE.Vector3(); // Save last transformation\n\nvar lastPosition = new THREE.Vector3();\nvar lastQuaternion = new THREE.Quaternion(); // Tangent sphere to ellipsoid\n\nvar pickSphere = new THREE.Sphere();\nvar pickingPoint = new THREE.Vector3(); // Sphere intersection\n\nvar intersection = new THREE.Vector3(); // Set to true to enable target helper\n\nvar enableTargetHelper = false;\nvar helpers = {};\n// current downed key\nvar currentKey;\n/**\n * Globe control pan event. Fires after camera pan\n * @event GlobeControls#pan-changed\n * @property target {GlobeControls} dispatched on controls\n * @property type {string} orientation-changed\n */\n\n/**\n * Globe control orientation event. Fires when camera's orientation change\n * @event GlobeControls#orientation-changed\n * @property new {object}\n * @property new.tilt {number} the new value of the tilt of the camera\n * @property new.heading {number} the new value of the heading of the camera\n * @property previous {object}\n * @property previous.tilt {number} the previous value of the tilt of the camera\n * @property previous.heading {number} the previous value of the heading of the camera\n * @property target {GlobeControls} dispatched on controls\n * @property type {string} orientation-changed\n */\n\n/**\n * Globe control range event. Fires when camera's range to target change\n * @event GlobeControls#range-changed\n * @property new {number} the new value of the range\n * @property previous {number} the previous value of the range\n * @property target {GlobeControls} dispatched on controls\n * @property type {string} range-changed\n */\n\n/**\n * Globe control camera's target event. Fires when camera's target change\n * @event GlobeControls#camera-target-changed\n * @property new {object}\n * @property new {Coordinates} the new camera's target coordinates\n * @property previous {Coordinates} the previous camera's target coordinates\n * @property target {GlobeControls} dispatched on controls\n * @property type {string} camera-target-changed\n */\n\n/**\n * globe controls events\n * @property PAN_CHANGED {string} Fires after camera pan\n * @property ORIENTATION_CHANGED {string} Fires when camera's orientation change\n * @property RANGE_CHANGED {string} Fires when camera's range to target change\n * @property CAMERA_TARGET_CHANGED {string} Fires when camera's target change\n */\n\nvar CONTROL_EVENTS = {\n  PAN_CHANGED: 'pan-changed',\n  ORIENTATION_CHANGED: 'orientation-changed',\n  RANGE_CHANGED: 'range-changed',\n  CAMERA_TARGET_CHANGED: 'camera-target-changed'\n};\nexports.CONTROL_EVENTS = CONTROL_EVENTS;\nvar quaterPano = new THREE.Quaternion();\nvar quaterAxis = new THREE.Quaternion();\nvar axisX = new THREE.Vector3(1, 0, 0);\nvar minDistanceZ = Infinity;\nvar lastNormalizedIntersection = new THREE.Vector3();\nvar normalizedIntersection = new THREE.Vector3();\nvar raycaster = new THREE.Raycaster();\nvar targetPosition = new THREE.Vector3();\nvar pickedPosition = new THREE.Vector3();\nvar sphereCamera = new THREE.Sphere();\nvar previous;\n/**\n * GlobeControls is a camera controller\n *\n * @class      GlobeControls\n * @param      {GlobeView}  view the view where the control will be used\n * @param      {CameraTransformOptions}  targetCoordinate the target looked by camera, at initialization\n * @param      {number}  range distance between the target looked and camera, at initialization\n * @param      {object}  options\n * @param      {number}  options.zoomSpeed Speed zoom with mouse\n * @param      {number}  options.rotateSpeed Speed camera rotation in orbit and panoramic mode\n * @param      {number}  options.minDistance Minimum distance between ground and camera\n * @param      {number}  options.maxDistance Maximum distance between ground and camera\n * @param      {bool}  options.handleCollision enable collision camera with ground\n * @property   {bool} enabled enable control\n * @property   {number} minDistance Minimum distance between ground and camera\n * @property   {number} maxDistance Maximum distance between ground and camera\n * @property   {number} zoomSpeed Speed zoom with mouse\n * @property   {number} rotateSpeed Speed camera rotation in orbit and panoramic mode\n * @property   {number} minDistanceCollision Minimum distance collision between ground and camera\n * @property   {bool} enableDamping enable camera damping, if it's disabled the camera immediately when the mouse button is released.\n * If it's enabled, the camera movement is decelerate.\n */\n\nvar GlobeControls =\n/*#__PURE__*/\nfunction (_THREE$EventDispatche) {\n  (0, _inherits2[\"default\"])(GlobeControls, _THREE$EventDispatche);\n\n  function GlobeControls(view, placement) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2[\"default\"])(this, GlobeControls);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(GlobeControls).call(this));\n    _this.player = new _AnimationPlayer[\"default\"]();\n    _this.view = view;\n    _this.camera = view.camera.camera3D;\n    _this.domElement = view.mainLoop.gfxEngine.renderer.domElement; // State control\n\n    _this.states = new _StateControl[\"default\"]();\n    _this.state = _this.states.NONE; // Set to false to disable this control\n\n    _this.enabled = true; // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n\n    _this.zoomSpeed = options.zoomSpeed || 2.0; // Limits to how far you can dolly in and out ( PerspectiveCamera only )\n\n    _this.minDistance = options.minDistance || 250;\n    _this.maxDistance = options.maxDistance || _Ellipsoid.ellipsoidSizes.x * 8.0; // Limits to how far you can zoom in and out ( OrthographicCamera only )\n\n    _this.minZoom = 0;\n    _this.maxZoom = Infinity; // Set to true to disable this control\n\n    _this.rotateSpeed = options.rotateSpeed || 0.25; // Set to true to disable this control\n\n    _this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    // TODO Warning minPolarAngle = 0.01 -> it isn't possible to be perpendicular on Globe\n\n    _this.minPolarAngle = THREE.Math.degToRad(0.5); // radians\n\n    _this.maxPolarAngle = THREE.Math.degToRad(86); // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\n    _this.minAzimuthAngle = -Infinity; // radians\n\n    _this.maxAzimuthAngle = Infinity; // radians\n    // Set collision options\n\n    _this.handleCollision = typeof options.handleCollision !== 'undefined' ? options.handleCollision : true;\n    _this.minDistanceCollision = 60; // Set to true to disable use of the keys\n\n    _this.enableKeys = true; // Enable Damping\n\n    _this.enableDamping = true;\n    _this.startEvent = {\n      type: 'start'\n    };\n    _this.endEvent = {\n      type: 'end'\n    }; // Update helper\n\n    _this.updateHelper = enableTargetHelper ? function (position, helper) {\n      positionObject(position, helper);\n      view.notifyChange(_this.camera);\n    } : function () {};\n    _this._onEndingMove = null;\n    _this._onMouseMove = _this.onMouseMove.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._onMouseUp = _this.onMouseUp.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._onMouseDown = _this.onMouseDown.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._onMouseWheel = _this.onMouseWheel.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._onContextMenuListener = _this.onContextMenuListener.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._ondblclick = _this.ondblclick.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._onTouchStart = _this.onTouchStart.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._update = _this.update.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._onTouchMove = _this.onTouchMove.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._onKeyDown = _this.onKeyDown.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._onKeyUp = _this.onKeyUp.bind((0, _assertThisInitialized2[\"default\"])(_this));\n    _this._onBlurListener = _this.onBlurListener.bind((0, _assertThisInitialized2[\"default\"])(_this));\n\n    _this.domElement.addEventListener('contextmenu', _this._onContextMenuListener, false);\n\n    _this.domElement.addEventListener('mousedown', _this._onMouseDown, false);\n\n    _this.domElement.addEventListener('mousewheel', _this._onMouseWheel, false);\n\n    _this.domElement.addEventListener('dblclick', _this._ondblclick, false);\n\n    _this.domElement.addEventListener('DOMMouseScroll', _this._onMouseWheel, false); // firefox\n\n\n    _this.domElement.addEventListener('touchstart', _this._onTouchStart, false);\n\n    _this.domElement.addEventListener('touchend', _this._onMouseUp, false);\n\n    _this.domElement.addEventListener('touchmove', _this._onTouchMove, false); // refresh control for each animation's frame\n\n\n    _this.player.addEventListener('animation-frame', _this._update); // TODO: Why windows\n\n\n    window.addEventListener('keydown', _this._onKeyDown, false);\n    window.addEventListener('keyup', _this._onKeyUp, false); // Reset key/mouse when window loose focus\n\n    window.addEventListener('blur', _this._onBlurListener);\n    view.scene.add(cameraTarget);\n\n    if (enableTargetHelper) {\n      cameraTarget.add(helpers.target);\n      view.scene.add(helpers.picking);\n      var layerTHREEjs = view.mainLoop.gfxEngine.getUniqueThreejsLayer();\n      helpers.target.layers.set(layerTHREEjs);\n      helpers.picking.layers.set(layerTHREEjs);\n\n      _this.camera.layers.enable(layerTHREEjs);\n    }\n\n    positionObject(placement.coord.as('EPSG:4978', xyz), cameraTarget);\n    placement.tilt = placement.tilt || 89.5;\n    placement.heading = placement.heading || 0;\n\n    _this.lookAtCoordinate(placement, false);\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(GlobeControls, [{\n    key: \"onEndingMove\",\n    value: function onEndingMove(current) {\n      if (this._onEndingMove) {\n        this.player.removeEventListener('animation-stopped', this._onEndingMove);\n        this._onEndingMove = null;\n      }\n\n      this.state = this.states.NONE;\n      this.handlingEvent(current);\n    }\n  }, {\n    key: \"rotateLeft\",\n    value: function rotateLeft() {\n      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      sphericalDelta.theta -= angle;\n    }\n  }, {\n    key: \"rotateUp\",\n    value: function rotateUp() {\n      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      sphericalDelta.phi -= angle;\n    } // pass in distance in world space to move left\n\n  }, {\n    key: \"panLeft\",\n    value: function panLeft(distance) {\n      var te = this.camera.matrix.elements; // get X column of matrix\n\n      panOffset.fromArray(te);\n      panOffset.multiplyScalar(-distance);\n      panVector.add(panOffset);\n    } // pass in distance in world space to move up\n\n  }, {\n    key: \"panUp\",\n    value: function panUp(distance) {\n      var te = this.camera.matrix.elements; // get Y column of matrix\n\n      panOffset.fromArray(te, 4);\n      panOffset.multiplyScalar(distance);\n      panVector.add(panOffset);\n    } // pass in x,y of change desired in pixel space,\n    // right and down are positive\n\n  }, {\n    key: \"mouseToPan\",\n    value: function mouseToPan(deltaX, deltaY) {\n      var gfx = this.view.mainLoop.gfxEngine;\n      this.state = this.states.PAN;\n\n      if (this.camera.isPerspectiveCamera) {\n        var targetDistance = this.camera.position.distanceTo(this.getCameraTargetPosition()); // half of the fov is center to top of screen\n\n        targetDistance *= 2 * Math.tan(THREE.Math.degToRad(this.camera.fov * 0.5)); // we actually don't use screenWidth, since perspective camera is fixed to screen height\n\n        this.panLeft(deltaX * targetDistance / gfx.width * this.camera.aspect);\n        this.panUp(deltaY * targetDistance / gfx.height);\n      } else if (this.camera.isOrthographicCamera) {\n        // orthographic\n        this.panLeft(deltaX * (this.camera.right - this.camera.left) / gfx.width);\n        this.panUp(deltaY * (this.camera.top - this.camera.bottom) / gfx.height);\n      }\n    }\n  }, {\n    key: \"dollyIn\",\n    value: function dollyIn(dollyScale) {\n      if (dollyScale === undefined) {\n        dollyScale = this.dollyScale;\n      }\n\n      if (this.camera.isPerspectiveCamera) {\n        orbitScale /= dollyScale;\n      } else if (this.camera.isOrthographicCamera) {\n        this.camera.zoom = THREE.Math.clamp(this.camera.zoom * dollyScale, this.minZoom, this.maxZoom);\n        this.camera.updateProjectionMatrix();\n        this.view.notifyChange(this.camera);\n      }\n    }\n  }, {\n    key: \"dollyOut\",\n    value: function dollyOut(dollyScale) {\n      if (dollyScale === undefined) {\n        dollyScale = this.dollyScale;\n      }\n\n      if (this.camera.isPerspectiveCamera) {\n        orbitScale *= dollyScale;\n      } else if (this.camera.isOrthographicCamera) {\n        this.camera.zoom = THREE.Math.clamp(this.camera.zoom / dollyScale, this.minZoom, this.maxZoom);\n        this.camera.updateProjectionMatrix();\n        this.view.notifyChange(this.camera);\n      }\n    }\n  }, {\n    key: \"getMinDistanceCameraBoundingSphereObbsUp\",\n    value: function getMinDistanceCameraBoundingSphereObbsUp(tile) {\n      if (tile.level > 10 && tile.children.length == 1 && tile.geometry) {\n        var obb = tile.obb;\n        sphereCamera.center.copy(this.camera.position);\n        sphereCamera.radius = this.minDistanceCollision;\n\n        if (obb.isSphereAboveXYBox(sphereCamera)) {\n          minDistanceZ = Math.min(sphereCamera.center.z - obb.box3D.max.z, minDistanceZ);\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      // We compute distance between camera's bounding sphere and geometry's obb up face\n      if (this.handleCollision) {\n        // We check distance to the ground/surface geometry\n        // add minDistanceZ between camera's bounding and tiles's oriented bounding box (up face only)\n        // Depending on the distance of the camera with obbs, we add a slowdown or constrain to the movement.\n        // this constraint or deceleration is suitable for two types of movement MOVE_GLOBE and ORBIT.\n        // This constraint or deceleration inversely proportional to the camera/obb distance\n        if (this.view.tileLayer) {\n          minDistanceZ = Infinity;\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = this.view.tileLayer.level0Nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var tile = _step.value;\n              tile.traverse(this.getMinDistanceCameraBoundingSphereObbsUp.bind(this));\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n\n      switch (this.state) {\n        // MOVE_GLOBE Rotate globe with mouse\n        case this.states.MOVE_GLOBE:\n          if (minDistanceZ < 0) {\n            cameraTarget.translateY(-minDistanceZ);\n            this.camera.position.setLength(this.camera.position.length() - minDistanceZ);\n          } else if (minDistanceZ < this.minDistanceCollision) {\n            var translate = this.minDistanceCollision * (1.0 - minDistanceZ / this.minDistanceCollision);\n            cameraTarget.translateY(translate);\n            this.camera.position.setLength(this.camera.position.length() + translate);\n          }\n\n          lastNormalizedIntersection.copy(normalizedIntersection).applyQuaternion(moveAroundGlobe);\n          cameraTarget.position.applyQuaternion(moveAroundGlobe);\n          this.camera.position.applyQuaternion(moveAroundGlobe);\n          break;\n        // PAN Move camera in projection plan\n\n        case this.states.PAN:\n          this.camera.position.add(panVector);\n          cameraTarget.position.add(panVector);\n          break;\n        // PANORAMIC Move target camera\n\n        case this.states.PANORAMIC:\n          {\n            this.camera.worldToLocal(cameraTarget.position);\n            var normal = this.camera.position.clone().normalize().applyQuaternion(this.camera.quaternion.clone().inverse());\n            quaterPano.setFromAxisAngle(normal, sphericalDelta.theta).multiply(quaterAxis.setFromAxisAngle(axisX, sphericalDelta.phi));\n            cameraTarget.position.applyQuaternion(quaterPano);\n            this.camera.localToWorld(cameraTarget.position);\n            break;\n          }\n        // ZOOM/ORBIT Move Camera around the target camera\n\n        default:\n          {\n            // get camera position in local space of target\n            this.camera.position.applyMatrix4(cameraTarget.matrixWorldInverse); // angle from z-axis around y-axis\n\n            if (sphericalDelta.theta || sphericalDelta.phi) {\n              spherical.setFromVector3(this.camera.position);\n            } // far underground\n\n\n            var dynamicRadius = spherical.radius * Math.sin(this.minPolarAngle);\n            var slowdownLimit = dynamicRadius * 8;\n            var contraryLimit = dynamicRadius * 2;\n            var minContraintPhi = -0.01;\n\n            if (minDistanceZ < slowdownLimit && minDistanceZ > contraryLimit && sphericalDelta.phi > 0) {\n              // slowdown zone : slowdown sphericalDelta.phi\n              var slowdownZone = slowdownLimit - contraryLimit; // the deeper the camera is in this zone, the bigger the factor is\n\n              var slowdownFactor = 1 - (slowdownZone - (minDistanceZ - contraryLimit)) / slowdownZone; // apply slowdown factor on tilt mouvement\n\n              sphericalDelta.phi *= slowdownFactor * slowdownFactor;\n            } else if (minDistanceZ < contraryLimit && minDistanceZ > -contraryLimit && sphericalDelta.phi > minContraintPhi) {\n              // contraint zone : contraint sphericalDelta.phi\n              // calculation of the angle of rotation which allows to leave this zone\n              var contraryPhi = -Math.asin((contraryLimit - minDistanceZ) * 0.25 / spherical.radius); // clamp contraryPhi to make a less brutal exit\n\n              contraryPhi = THREE.Math.clamp(contraryPhi, minContraintPhi, 0); // the deeper the camera is in this zone, the bigger the factor is\n\n              var contraryFactor = 1 - (contraryLimit - minDistanceZ) / (2 * contraryLimit);\n              sphericalDelta.phi = THREE.Math.lerp(sphericalDelta.phi, contraryPhi, contraryFactor);\n              minDistanceZ -= Math.sin(sphericalDelta.phi) * spherical.radius;\n            }\n\n            spherical.theta += sphericalDelta.theta;\n            spherical.phi += sphericalDelta.phi; // restrict spherical.theta to be between desired limits\n\n            spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, spherical.theta)); // restrict spherical.phi to be between desired limits\n\n            spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, spherical.phi));\n            spherical.radius = this.camera.position.length() * orbitScale; // restrict spherical.phi to be betwee EPS and PI-EPS\n\n            spherical.makeSafe(); // restrict radius to be between desired limits\n\n            spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, spherical.radius));\n            this.camera.position.setFromSpherical(spherical); // if camera is underground, so move up camera\n\n            if (minDistanceZ < 0) {\n              this.camera.position.y -= minDistanceZ;\n              spherical.setFromVector3(this.camera.position);\n              sphericalDelta.phi = 0;\n            }\n\n            cameraTarget.localToWorld(this.camera.position);\n          }\n      }\n\n      this.camera.up.copy(cameraTarget.position).normalize();\n      this.camera.lookAt(cameraTarget.position);\n\n      if (!this.enableDamping) {\n        sphericalDelta.theta = 0;\n        sphericalDelta.phi = 0;\n        moveAroundGlobe.set(0, 0, 0, 1);\n      } else {\n        sphericalDelta.theta *= 1 - dampingFactor;\n        sphericalDelta.phi *= 1 - dampingFactor;\n        moveAroundGlobe.slerp(dampingMove, dampingFactor * 0.2);\n      }\n\n      orbitScale = 1;\n      panVector.set(0, 0, 0); // update condition is:\n      // min(camera displacement, camera rotation in radians)^2 > EPS\n      // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n      if (lastPosition.distanceToSquared(this.camera.position) > EPS || 8 * (1 - lastQuaternion.dot(this.camera.quaternion)) > EPS) {\n        this.view.notifyChange(this.camera);\n        lastPosition.copy(this.camera.position);\n        lastQuaternion.copy(this.camera.quaternion);\n      } // Launch animationdamping if mouse stops these movements\n\n\n      if (this.enableDamping && this.state === this.states.ORBIT && this.player.isStopped() && (sphericalDelta.theta > EPS || sphericalDelta.phi > EPS)) {\n        this.player.playLater(durationDampingOrbital, 2);\n      }\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      if (this.player.isPlaying()) {\n        this.player.stop();\n      }\n\n      if (this.enabled === false) {\n        return;\n      }\n\n      event.preventDefault();\n      var coords = this.view.eventToViewCoords(event);\n\n      switch (this.state) {\n        case this.states.ORBIT:\n        case this.states.PANORAMIC:\n          {\n            rotateEnd.copy(coords);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n            var gfx = this.view.mainLoop.gfxEngine;\n            this.rotateLeft(2 * Math.PI * rotateDelta.x / gfx.width * this.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n            this.rotateUp(2 * Math.PI * rotateDelta.y / gfx.height * this.rotateSpeed);\n            rotateStart.copy(rotateEnd);\n            break;\n          }\n\n        case this.states.DOLLY:\n          dollyEnd.copy(coords);\n          dollyDelta.subVectors(dollyEnd, dollyStart);\n\n          if (dollyDelta.y > 0) {\n            this.dollyIn();\n          } else if (dollyDelta.y < 0) {\n            this.dollyOut();\n          }\n\n          dollyStart.copy(dollyEnd);\n          break;\n\n        case this.states.PAN:\n          panEnd.copy(coords);\n          panDelta.subVectors(panEnd, panStart);\n          this.mouseToPan(panDelta.x, panDelta.y);\n          panStart.copy(panEnd);\n          break;\n\n        case this.states.MOVE_GLOBE:\n          {\n            var normalized = this.view.viewToNormalizedCoords(coords);\n            raycaster.setFromCamera(normalized, this.camera);\n            raycaster.ray.intersectSphere(pickSphere, intersection); // If there's intersection then move globe else we stop the move\n\n            if (intersection) {\n              normalizedIntersection.copy(intersection).normalize();\n              moveAroundGlobe.setFromUnitVectors(normalizedIntersection, lastNormalizedIntersection);\n              lastTimeMouseMove = Date.now();\n            } else {\n              this.onMouseUp();\n            }\n\n            break;\n          }\n\n        default:\n      }\n\n      if (this.state !== this.states.NONE) {\n        this.update();\n      }\n    }\n  }, {\n    key: \"updateTarget\",\n    value: function updateTarget() {\n      // Update camera's target position\n      this.view.getPickingPositionFromDepth(null, pickedPosition);\n      var distance = !isNaN(pickedPosition.x) ? this.camera.position.distanceTo(pickedPosition) : 100;\n      targetPosition.set(0, 0, -distance);\n      this.camera.localToWorld(targetPosition); // set new camera target on globe\n\n      positionObject(targetPosition, cameraTarget);\n      cameraTarget.matrixWorldInverse.getInverse(cameraTarget.matrixWorld);\n      targetPosition.copy(this.camera.position);\n      targetPosition.applyMatrix4(cameraTarget.matrixWorldInverse);\n      spherical.setFromVector3(targetPosition);\n    }\n  }, {\n    key: \"handlingEvent\",\n    value: function handlingEvent(current) {\n      current = current || _CameraUtils[\"default\"].getTransformCameraLookingAtTarget(this.view, this.camera);\n\n      var diff = _CameraUtils[\"default\"].getDiffParams(previous, current);\n\n      if (diff) {\n        if (diff.range) {\n          this.dispatchEvent({\n            type: CONTROL_EVENTS.RANGE_CHANGED,\n            previous: diff.range.previous,\n            \"new\": diff.range[\"new\"]\n          });\n        }\n\n        if (diff.coord) {\n          this.dispatchEvent({\n            type: CONTROL_EVENTS.CAMERA_TARGET_CHANGED,\n            previous: diff.coord.previous,\n            \"new\": diff.coord[\"new\"]\n          });\n        }\n\n        if (diff.tilt || diff.heading) {\n          var event = {\n            type: CONTROL_EVENTS.ORIENTATION_CHANGED\n          };\n\n          if (diff.tilt) {\n            event.previous = {\n              tilt: diff.tilt.previous\n            };\n            event[\"new\"] = {\n              tilt: diff.tilt[\"new\"]\n            };\n          }\n\n          if (diff.heading) {\n            event.previous = event.previous || {};\n            event[\"new\"] = event[\"new\"] || {};\n            event[\"new\"].heading = diff.heading[\"new\"];\n            event.previous.heading = diff.heading.previous;\n          }\n\n          this.dispatchEvent(event);\n        }\n      }\n    }\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      _CameraUtils[\"default\"].stop(this.view, this.camera);\n\n      this.player.stop();\n      this.onEndingMove();\n\n      if (this.enabled === false) {\n        return;\n      }\n\n      event.preventDefault();\n      this.updateTarget();\n      previous = _CameraUtils[\"default\"].getTransformCameraLookingAtTarget(this.view, this.camera);\n      this.state = this.states.inputToState(event.button, currentKey);\n      var coords = this.view.eventToViewCoords(event);\n\n      switch (this.state) {\n        case this.states.ORBIT:\n        case this.states.PANORAMIC:\n          rotateStart.copy(coords);\n          break;\n\n        case this.states.MOVE_GLOBE:\n          {\n            // update picking on sphere\n            if (this.view.getPickingPositionFromDepth(coords, pickingPoint)) {\n              pickSphere.radius = pickingPoint.length();\n              lastNormalizedIntersection.copy(pickingPoint).normalize();\n              this.updateHelper(pickingPoint, helpers.picking);\n            } else {\n              this.state = this.states.NONE;\n            }\n\n            break;\n          }\n\n        case this.states.DOLLY:\n          dollyStart.copy(coords);\n          break;\n\n        case this.states.PAN:\n          panStart.copy(coords);\n          break;\n\n        default:\n      }\n\n      if (this.state != this.states.NONE) {\n        this.domElement.addEventListener('mousemove', this._onMouseMove, false);\n        this.domElement.addEventListener('mouseup', this._onMouseUp, false);\n        this.domElement.addEventListener('mouseleave', this._onMouseUp, false);\n        this.dispatchEvent(this.startEvent);\n      }\n    }\n  }, {\n    key: \"ondblclick\",\n    value: function ondblclick(event) {\n      if (this.enabled === false || currentKey) {\n        return;\n      }\n\n      this.player.stop();\n      var point = this.view.getPickingPositionFromDepth(this.view.eventToViewCoords(event));\n      var range = this.getRange();\n\n      if (point && range > this.minDistance) {\n        this.lookAtCoordinate({\n          coord: new _Coordinates[\"default\"]('EPSG:4978', point),\n          range: range * 0.6,\n          time: 1500\n        });\n      }\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      var _this2 = this;\n\n      if (this.enabled === false) {\n        return;\n      }\n\n      this.domElement.removeEventListener('mousemove', this._onMouseMove, false);\n      this.domElement.removeEventListener('mouseup', this._onMouseUp, false);\n      this.domElement.removeEventListener('mouseleave', this._onMouseUp, false);\n      this.dispatchEvent(this.endEvent);\n      this.player.stop(); // Launch damping movement for :\n      //      * this.states.ORBIT\n      //      * this.states.MOVE_GLOBE\n\n      if (this.enableDamping) {\n        if (this.state === this.states.ORBIT && (sphericalDelta.theta > EPS || sphericalDelta.phi > EPS)) {\n          this.player.play(durationDampingOrbital);\n\n          this._onEndingMove = function () {\n            return _this2.onEndingMove();\n          };\n\n          this.player.addEventListener('animation-stopped', this._onEndingMove);\n        } else if (this.state === this.states.MOVE_GLOBE && Date.now() - lastTimeMouseMove < 50) {\n          // animation since mouse up event occurs less than 50ms after the last mouse move\n          this.player.play(durationDampingMove);\n\n          this._onEndingMove = function () {\n            return _this2.onEndingMove();\n          };\n\n          this.player.addEventListener('animation-stopped', this._onEndingMove);\n        } else {\n          this.onEndingMove();\n        }\n      } else {\n        this.onEndingMove();\n      }\n    }\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(event) {\n      this.player.stop();\n\n      if (!this.enabled || !this.states.DOLLY.enable) {\n        return;\n      }\n\n      _CameraUtils[\"default\"].stop(this.view, this.camera);\n\n      event.preventDefault();\n      this.updateTarget();\n      var delta = 0; // WebKit / Opera / Explorer 9\n\n      if (event.wheelDelta !== undefined) {\n        delta = event.wheelDelta; // Firefox\n      } else if (event.detail !== undefined) {\n        delta = -event.detail;\n      }\n\n      if (delta > 0) {\n        this.dollyOut();\n      } else if (delta < 0) {\n        this.dollyIn();\n      }\n\n      var previousRange = this.getRange();\n      this.update();\n      var newRange = this.getRange();\n\n      if (Math.abs(newRange - previousRange) / previousRange > 0.001) {\n        this.dispatchEvent({\n          type: CONTROL_EVENTS.RANGE_CHANGED,\n          previous: previousRange,\n          \"new\": newRange\n        });\n      }\n\n      this.dispatchEvent(this.startEvent);\n      this.dispatchEvent(this.endEvent);\n    }\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp() {\n      if (this.enabled === false || this.enableKeys === false) {\n        return;\n      }\n\n      currentKey = undefined;\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(event) {\n      this.player.stop();\n\n      if (this.enabled === false || this.enableKeys === false) {\n        return;\n      }\n\n      currentKey = event.keyCode;\n\n      switch (event.keyCode) {\n        case this.states.PAN.up:\n          this.mouseToPan(0, this.keyPanSpeed);\n          this.state = this.states.PAN;\n          this.update();\n          break;\n\n        case this.states.PAN.bottom:\n          this.mouseToPan(0, -this.keyPanSpeed);\n          this.state = this.states.PAN;\n          this.update();\n          break;\n\n        case this.states.PAN.left:\n          this.mouseToPan(this.keyPanSpeed, 0);\n          this.state = this.states.PAN;\n          this.update();\n          break;\n\n        case this.states.PAN.right:\n          this.mouseToPan(-this.keyPanSpeed, 0);\n          this.state = this.states.PAN;\n          this.update();\n          break;\n\n        default:\n      }\n    }\n  }, {\n    key: \"onTouchStart\",\n    value: function onTouchStart(event) {\n      // CameraUtils.stop(view);\n      this.player.stop();\n\n      if (this.enabled === false) {\n        return;\n      }\n\n      this.state = this.states.touchToState(event.touches.length);\n      this.updateTarget();\n\n      if (this.state !== this.states.NONE) {\n        switch (this.state) {\n          case this.states.MOVE_GLOBE:\n            {\n              var coords = this.view.eventToViewCoords(event);\n\n              if (this.view.getPickingPositionFromDepth(coords, pickingPoint)) {\n                pickSphere.radius = pickingPoint.length();\n                lastNormalizedIntersection.copy(pickingPoint).normalize();\n                this.updateHelper(pickingPoint, helpers.picking);\n              } else {\n                this.state = this.states.NONE;\n              }\n\n              break;\n            }\n\n          case this.states.ORBIT:\n          case this.states.DOLLY:\n            {\n              var x = event.touches[0].pageX;\n              var y = event.touches[0].pageY;\n              var dx = x - event.touches[1].pageX;\n              var dy = y - event.touches[1].pageY;\n              var distance = Math.sqrt(dx * dx + dy * dy);\n              dollyStart.set(0, distance);\n              rotateStart.set(x, y);\n              break;\n            }\n\n          case this.states.PAN:\n            panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n            break;\n\n          default:\n        }\n\n        this.dispatchEvent(this.startEvent);\n      }\n    }\n  }, {\n    key: \"onTouchMove\",\n    value: function onTouchMove(event) {\n      if (this.player.isPlaying()) {\n        this.player.stop();\n      }\n\n      if (this.enabled === false) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      switch (event.touches.length) {\n        case this.states.MOVE_GLOBE.finger:\n          {\n            var coords = this.view.eventToViewCoords(event);\n            var normalized = this.view.viewToNormalizedCoords(coords);\n            raycaster.setFromCamera(normalized, this.camera);\n            raycaster.ray.intersectSphere(pickSphere, intersection); // If there's intersection then move globe else we stop the move\n\n            if (intersection) {\n              normalizedIntersection.copy(intersection).normalize();\n              moveAroundGlobe.setFromUnitVectors(normalizedIntersection, lastNormalizedIntersection);\n              lastTimeMouseMove = Date.now();\n            } else {\n              this.onMouseUp.bind(this)();\n            }\n\n            break;\n          }\n\n        case this.states.ORBIT.finger:\n        case this.states.DOLLY.finger:\n          {\n            var gfx = this.view.mainLoop.gfxEngine;\n            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n            rotateDelta.subVectors(rotateEnd, rotateStart); // rotating across whole screen goes 360 degrees around\n\n            this.rotateLeft(2 * Math.PI * rotateDelta.x / gfx.width * this.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n            this.rotateUp(2 * Math.PI * rotateDelta.y / gfx.height * this.rotateSpeed);\n            rotateStart.copy(rotateEnd);\n            var dx = event.touches[0].pageX - event.touches[1].pageX;\n            var dy = event.touches[0].pageY - event.touches[1].pageY;\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            dollyEnd.set(0, distance);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n              this.dollyOut();\n            } else if (dollyDelta.y < 0) {\n              this.dollyIn();\n            }\n\n            dollyStart.copy(dollyEnd);\n            break;\n          }\n\n        case this.states.PAN.finger:\n          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n          panDelta.subVectors(panEnd, panStart);\n          this.mouseToPan(panDelta.x, panDelta.y);\n          panStart.copy(panEnd);\n          break;\n\n        default:\n          this.state = this.states.NONE;\n      }\n\n      if (this.state !== this.states.NONE) {\n        this.update();\n      }\n    }\n  }, {\n    key: \"onContextMenuListener\",\n    value: function onContextMenuListener(event) {\n      event.preventDefault();\n    }\n  }, {\n    key: \"onBlurListener\",\n    value: function onBlurListener() {\n      this.onKeyUp();\n      this.onMouseUp();\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.domElement.removeEventListener('contextmenu', this._onContextMenuListener, false);\n      this.domElement.removeEventListener('mousedown', this._onMouseDown, false);\n      this.domElement.removeEventListener('mousemove', this._onMouseMove, false);\n      this.domElement.removeEventListener('mousewheel', this._onMouseWheel, false);\n      this.domElement.removeEventListener('DOMMouseScroll', this._onMouseWheel, false); // firefox\n\n      this.domElement.removeEventListener('mouseup', this._onMouseUp, false);\n      this.domElement.removeEventListener('mouseleave', this._onMouseUp, false);\n      this.domElement.removeEventListener('dblclick', this._ondblclick, false);\n      this.domElement.removeEventListener('touchstart', this._onTouchStart, false);\n      this.domElement.removeEventListener('touchend', this._onMouseUp, false);\n      this.domElement.removeEventListener('touchmove', this._onTouchMove, false);\n      this.player.removeEventListener('animation-frame', this._onKeyUp);\n      window.removeEventListener('keydown', this._onKeyDown, false);\n      window.removeEventListener('keyup', this._onKeyUp, false);\n      window.removeEventListener('blur', this._onBlurListener);\n      this.dispatchEvent({\n        type: 'dispose'\n      });\n    }\n    /**\n     * Changes the tilt of the current camera, in degrees.\n     * @param {number}  tilt\n     * @param {boolean} isAnimated\n     * @return {Promise<void>}\n     */\n\n  }, {\n    key: \"setTilt\",\n    value: function setTilt(tilt, isAnimated) {\n      return this.lookAtCoordinate({\n        tilt: tilt\n      }, isAnimated);\n    }\n    /**\n     * Changes the heading of the current camera, in degrees.\n     * @param {number} heading\n     * @param {boolean} isAnimated\n     * @return {Promise<void>}\n     */\n\n  }, {\n    key: \"setHeading\",\n    value: function setHeading(heading, isAnimated) {\n      return this.lookAtCoordinate({\n        heading: heading\n      }, isAnimated);\n    }\n    /**\n     * Sets the \"range\": the distance in meters between the camera and the current central point on the screen.\n     * @param {number} range\n     * @param {boolean} isAnimated\n     * @return {Promise<void>}\n     */\n\n  }, {\n    key: \"setRange\",\n    value: function setRange(range, isAnimated) {\n      return this.lookAtCoordinate({\n        range: range\n      }, isAnimated);\n    }\n    /**\n     * Returns the {@linkcode Coordinates} of the globe point targeted by the camera in EPSG:4978 projection. See {@linkcode Coordinates} for conversion\n     * @return {THREE.Vector3} position\n     */\n\n  }, {\n    key: \"getCameraTargetPosition\",\n    value: function getCameraTargetPosition() {\n      return cameraTarget.position;\n    }\n    /**\n     * Returns the \"range\": the distance in meters between the camera and the current central point on the screen.\n     * @return {number} number\n     */\n\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      return _CameraUtils[\"default\"].getTransformCameraLookingAtTarget(this.view, this.camera).range;\n    }\n    /**\n     * Returns the tilt of the current camera in degrees.\n     * @return {Angle} number - The angle of the rotation in degrees.\n     */\n\n  }, {\n    key: \"getTilt\",\n    value: function getTilt() {\n      return _CameraUtils[\"default\"].getTransformCameraLookingAtTarget(this.view, this.camera).tilt;\n    }\n    /**\n     * Returns the heading of the current camera in degrees.\n     * @return {Angle} number - The angle of the rotation in degrees.\n     */\n\n  }, {\n    key: \"getHeading\",\n    value: function getHeading() {\n      return _CameraUtils[\"default\"].getTransformCameraLookingAtTarget(this.view, this.camera).heading;\n    }\n    /**\n     * Displaces the central point to a specific amount of pixels from its current position.\n     * The view flies to the desired coordinate, i.e.is not teleported instantly. Note : The results can be strange in some cases, if ever possible, when e.g.the camera looks horizontally or if the displaced center would not pick the ground once displaced.\n     * @param      {vector}  pVector  The vector\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"pan\",\n    value: function pan(pVector) {\n      this.mouseToPan(pVector.x, pVector.y);\n      this.update();\n      return Promise.resolve();\n    }\n    /**\n     * Returns the orientation angles of the current camera, in degrees.\n     * @return {Array<number>}\n     */\n\n  }, {\n    key: \"getCameraOrientation\",\n    value: function getCameraOrientation() {\n      return [this.getTilt(), this.getHeading()];\n    }\n    /**\n     * Returns the camera location projected on the ground in lat,lon. See {@linkcode Coordinates} for conversion.\n     * @return {Coordinates} position\n     */\n\n  }, {\n    key: \"getCameraCoordinate\",\n    value: function getCameraCoordinate() {\n      return new _Coordinates[\"default\"]('EPSG:4978', this.camera.position).as('EPSG:4326');\n    }\n    /**\n     * Returns the {@linkcode Coordinates} of the central point on screen in lat,lon. See {@linkcode Coordinates} for conversion.\n     * @return {Coordinates} coordinate\n     */\n\n  }, {\n    key: \"getLookAtCoordinate\",\n    value: function getLookAtCoordinate() {\n      return _CameraUtils[\"default\"].getTransformCameraLookingAtTarget(this.view, this.camera).coord;\n    }\n    /**\n     * Sets the animation enabled.\n     * @param      {boolean}  enable  enable\n     */\n\n  }, {\n    key: \"setAnimationEnabled\",\n    value: function setAnimationEnabled(enable) {\n      enableAnimation = enable;\n    }\n    /**\n     * Determines if animation enabled.\n     * @return     {boolean}  True if animation enabled, False otherwise.\n     */\n\n  }, {\n    key: \"isAnimationEnabled\",\n    value: function isAnimationEnabled() {\n      return enableAnimation;\n    }\n    /**\n     * Returns the actual zoom. The zoom will always be between the [getMinZoom(), getMaxZoom()].\n     * @return     {number}  The zoom .\n     */\n\n  }, {\n    key: \"getZoom\",\n    value: function getZoom() {\n      return this.view.tileLayer.computeTileZoomFromDistanceCamera(this.getRange(), this.view.camera);\n    }\n    /**\n     * Sets the current zoom, which is an index in the logical scales predefined for the application.\n     * The higher the zoom, the closer to the ground.\n     * The zoom is always in the [getMinZoom(), getMaxZoom()] range.\n     * @param      {number}  zoom    The zoom\n     * @param      {boolean}  isAnimated  Indicates if animated\n     * @return     {Promise}\n     */\n\n  }, {\n    key: \"setZoom\",\n    value: function setZoom(zoom, isAnimated) {\n      return this.lookAtCoordinate({\n        zoom: zoom\n      }, isAnimated);\n    }\n    /**\n     * Return the current zoom scale at the central point of the view.\n     * This function compute the scale of a map\n     * @param      {number}  pitch   Screen pitch, in millimeters ; 0.28 by default\n     * @return     {number}  The zoom scale.\n     *\n     * @deprecated Use View#getScale instead.\n     */\n\n  }, {\n    key: \"getScale\",\n    value: function getScale(pitch) {\n      console.warn('Deprecated, use View#getScale instead.');\n      return this.view.getScale(pitch);\n    }\n    /**\n     * To convert the projection in meters on the globe of a number of pixels of screen\n     * @param      {number} pixels count pixels to project\n     * @param      {number} pixelPitch Screen pixel pitch, in millimeters (default = 0.28 mm / standard pixel size of 0.28 millimeters as defined by the OGC)\n     * @return     {number} projection in meters on globe\n     *\n     * @deprecated Use `View#getPixelsToMeters` instead.\n     */\n\n  }, {\n    key: \"pixelsToMeters\",\n    value: function pixelsToMeters(pixels) {\n      var pixelPitch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.28;\n      console.warn('Deprecated use View#getPixelsToMeters instead.');\n      var scaled = this.getScale(pixelPitch);\n      return pixels * pixelPitch / scaled / 1000;\n    }\n    /**\n     * To convert the projection a number of horizontal pixels of screen to longitude degree WGS84 on the globe\n     * @param      {number} pixels count pixels to project\n     * @param      {number} pixelPitch Screen pixel pitch, in millimeters (default = 0.28 mm / standard pixel size of 0.28 millimeters as defined by the OGC)\n     * @return     {number} projection in degree on globe\n     *\n     * @deprecated Use `View#getPixelsToMeters` and `GlobeControls#metersToDegrees`\n     * instead.\n     */\n\n  }, {\n    key: \"pixelsToDegrees\",\n    value: function pixelsToDegrees(pixels) {\n      var pixelPitch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.28;\n      console.warn('Deprecated, use View#getPixelsToMeters and GlobeControls#getMetersToDegrees instead.');\n      var chord = this.pixelsToMeters(pixels, pixelPitch);\n      return THREE.Math.radToDeg(2 * Math.asin(chord / (2 * _Ellipsoid.ellipsoidSizes.x)));\n    }\n    /**\n     * Projection on screen in pixels of length in meter on globe\n     * @param      {number}  value Length in meter on globe\n     * @param      {number}  pixelPitch Screen pixel pitch, in millimeters (default = 0.28 mm / standard pixel size of 0.28 millimeters as defined by the OGC)\n     * @return     {number}  projection in pixels on screen\n     *\n     * @deprecated Use `View#getMetersToPixels` instead.\n     */\n\n  }, {\n    key: \"metersToPixels\",\n    value: function metersToPixels(value) {\n      var pixelPitch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.28;\n      console.warn('Deprecated, use View#getMetersToPixels instead.');\n      var scaled = this.getScale(pixelPitch);\n      pixelPitch /= 1000;\n      return value * scaled / pixelPitch;\n    }\n    /**\n     * Changes the zoom of the central point of screen so that screen acts as a map with a specified scale.\n     *  The view flies to the desired zoom scale;\n     * @param      {number}  scale  The scale\n     * @param      {number}  pitch  The pitch\n     * @param      {boolean}  isAnimated  Indicates if animated\n     * @return     {Promise}\n     */\n\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale, pitch, isAnimated) {\n      return this.lookAtCoordinate({\n        scale: scale,\n        pitch: pitch\n      }, isAnimated);\n    }\n    /**\n     * Changes the center of the scene on screen to the specified in lat, lon. See {@linkcode Coordinates} for conversion.\n     * This function allows to change the central position, the zoom, the range, the scale and the camera orientation at the same time.\n     * The zoom has to be between the [getMinZoom(), getMaxZoom()].\n     * Zoom parameter is ignored if range is set\n     * The tilt's interval is between 4 and 89.5 degree\n     *\n     * @param      {CameraUtils~CameraTransformOptions}   params camera transformation to apply\n     * @param      {number}   [params.zoom]   zoom\n     * @param      {number}   [params.scale]   scale\n     * @param      {boolean}  isAnimated  Indicates if animated\n     * @return     {Promise}  A promise that resolves when transformation is oppered\n     */\n\n  }, {\n    key: \"lookAtCoordinate\",\n    value: function lookAtCoordinate() {\n      var _this3 = this;\n\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var isAnimated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isAnimationEnabled();\n\n      if (params.zoom) {\n        params.range = this.view.tileLayer.computeDistanceCameraFromTileZoom(params.zoom, this.view.camera);\n      } else if (params.scale) {\n        params.range = this.view.getScaleFromDistance(params.pitch, params.scale);\n\n        if (params.range < this.minDistance || params.range > this.maxDistance) {\n          // eslint-disable-next-line no-console\n          console.warn(\"This scale \".concat(params.scale, \" can not be reached\"));\n          params.range = THREE.Math.clamp(params.range, this.minDistance, this.maxDistance);\n        }\n      }\n\n      if (params.tilt !== undefined) {\n        var minTilt = 90 - THREE.Math.radToDeg(this.maxPolarAngle);\n        var maxTilt = 90 - THREE.Math.radToDeg(this.minPolarAngle);\n\n        if (params.tilt < minTilt || params.tilt > maxTilt) {\n          params.tilt = THREE.Math.clamp(params.tilt, minTilt, maxTilt); // eslint-disable-next-line no-console\n\n          console.warn('Tilt was clamped to ', params.tilt, \" the interval is between \".concat(minTilt, \" and \").concat(maxTilt, \" degree\"));\n        }\n      }\n\n      previous = _CameraUtils[\"default\"].getTransformCameraLookingAtTarget(this.view, this.camera);\n\n      if (isAnimated) {\n        params.callback = function (r) {\n          return cameraTarget.position.copy(r.targetWorldPosition);\n        };\n\n        this.dispatchEvent({\n          type: 'animation-started'\n        });\n        return _CameraUtils[\"default\"].animateCameraToLookAtTarget(this.view, this.camera, params).then(function (result) {\n          _this3.dispatchEvent({\n            type: 'animation-ended'\n          });\n\n          _this3.handlingEvent(result);\n\n          return result;\n        });\n      } else {\n        return _CameraUtils[\"default\"].transformCameraToLookAtTarget(this.view, this.camera, params).then(function (result) {\n          cameraTarget.position.copy(result.targetWorldPosition);\n\n          _this3.handlingEvent(result);\n\n          return result;\n        });\n      }\n    }\n    /**\n     * Pick a position on the globe at the given position in lat,lon. See {@linkcode Coordinates} for conversion.\n     * @param {Vector2} windowCoords - window coordinates\n     * @param {number=} y - The y-position inside the Globe element.\n     * @return {Coordinates} position\n     */\n\n  }, {\n    key: \"pickGeoPosition\",\n    value: function pickGeoPosition(windowCoords) {\n      var pickedPosition = this.view.getPickingPositionFromDepth(windowCoords);\n\n      if (!pickedPosition) {\n        return;\n      }\n\n      return new _Coordinates[\"default\"]('EPSG:4978', pickedPosition).as('EPSG:4326');\n    }\n  }, {\n    key: \"dollyScale\",\n    get: function get() {\n      return Math.pow(0.95, this.zoomSpeed);\n    }\n  }, {\n    key: \"isPaused\",\n    get: function get() {\n      return this.state == this.states.NONE;\n    }\n  }]);\n  return GlobeControls;\n}(THREE.EventDispatcher);\n\nvar _default = GlobeControls;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Controls/GlobeControls.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Controls/PlanarControls.js":
/*!************************************************************!*\
  !*** ./node_modules/itowns/lib/Controls/PlanarControls.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _MainLoop = __webpack_require__(/*! ../Core/MainLoop */ \"./node_modules/itowns/lib/Core/MainLoop.js\");\n\n// event keycode\nvar keys = {\n  CTRL: 17,\n  SPACE: 32,\n  T: 84,\n  Y: 89\n};\nvar mouseButtons = {\n  LEFTCLICK: THREE.MOUSE.LEFT,\n  MIDDLECLICK: THREE.MOUSE.MIDDLE,\n  RIGHTCLICK: THREE.MOUSE.RIGHT\n}; // control state\n\nvar STATE = {\n  NONE: -1,\n  DRAG: 0,\n  PAN: 1,\n  ROTATE: 2,\n  TRAVEL: 3\n};\nvar vectorZero = new THREE.Vector3();\n/**\n * Options for the instantiation of a {@link PlanarControls}.\n *\n * @typedef {Object} PlanarControls~PlanarControlsOptions\n *\n * @property {boolean} [enableRotation=true] Enable the rotation with the `CTRL\n * + Left mouse button` and in animations, like the smart zoom.\n * @property {number} [rotateSpeed=2.0] Rotate speed.\n * @property {number} [maxPanSpeed=15] Pan speed when close to maxAltitude.\n * @property {number} [minPanSpeed=0.05] Pan speed when close to the ground.\n * @property {number} [zoomTravelTime=0.2] Animation time when zooming.\n * @property {number} [zoomInFactor=0.25] Zoom movement is equal to the distance\n * to the zoom target, multiplied by this factor when zooming in.\n * @property {number} [zoomOutFactor=0.4] Zoom movement is equal to the distance\n * to the zoom target, multiplied by this factor when zooming out.\n * @property {number} [maxAltitude=12000] Maximum altitude reachable when panning.\n * @property {number} [groundLevel=200] Minimum altitude reachable when panning.\n * @property {number} [autoTravelTimeMin=1.5] Minimum duration for animated\n * travels with the `auto` parameter.\n * @property {number} [autoTravelTimeMax=4]  Maximum duration for animated\n * travels with the `auto` parameter.\n * @property {number} [autoTravelTimeDist=20000] Maximum travel distance for\n * animated travel with the `auto` parameter.\n * @property {number} [smartZoomHeightMin=75] Minimum height above ground\n * reachable after a smart zoom.\n * @property {number} [smartZoomHeightMax=500] Maximum height above ground\n * reachable after a smart zoom.\n * @property {boolean} [instantTravel=false] If set to true, animated travels\n * will have no duration.\n * @property {number} [minZenithAngle=0] The minimum reachable zenith angle for\n * a camera rotation, in degrees.\n * @property {number} [maxZenithAngle=82.5] The maximum reachable zenith angle\n * for a camera rotation, in degrees.\n * @property {boolean} [focusOnMouseOver=true] Set the focus on the canvas if\n * hovered.\n * @property {boolean} [focusOnMouseClick=true] Set the focus on the canvas if\n * clicked.\n * @property {boolean} [handleCollision=true]\n */\n\n/**\n * Camera controls adapted for a planar view, with animated movements.\n * Usage is as follow:\n * <ul>\n *  <li><b>Left mouse button:</b> drag the camera (translation on the (xy) world\n *  plane).</li>\n *  <li><b>Right mouse button:</b> pan the camera (translation on the vertical\n *  (z) axis of the world plane).</li>\n *  <li><b>CTRL + Left mouse button:</b> rotate the camera around the focus point.</li>\n *  <li><b>Wheel scrolling:</b> zoom toward the cursor position.</li>\n *  <li><b>Wheel clicking:</b> smart zoom toward the cursor position (animated).</li>\n *  <li><b>Y key:</b> go to the starting view (animated).</li>\n *  <li><b>T key:</b> go to the top view (animated).</li>\n * </ul>\n *\n * This controls needs to be instantiated after the camera setup.\n *\n * @constructor\n *\n * @param {PlanarView} view\n * @param {PlanarControls~PlanarControlsOptions} [options]\n *\n * @example\n * // From the orthographic example\n * new itowns.PlanarControls(view, {\n *     // We do not want the user to zoom out too much\n *     maxAltitude: 40000000,\n *     // We want to keep the rotation disabled, to only have a view from the top\n *     enableRotation: false,\n *     // Faster zoom in/out speed\n *     zoomInFactor: 0.5,\n *     zoomOutFactor: 0.5,\n *     // Don't zoom too much on smart zoom\n *     smartZoomHeightMax: 100000,\n * });\n */\n\nfunction PlanarControls(view) {\n  var _this = this;\n\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  this.view = view;\n  this.camera = view.camera.camera3D;\n  this.domElement = view.mainLoop.gfxEngine.renderer.domElement;\n  this.enableRotation = typeof options.enableRotation !== 'undefined' ? options.enableRotation : true;\n  this.rotateSpeed = options.rotateSpeed || 2.0; // minPanSpeed when close to the ground, maxPanSpeed when close to maxAltitude\n\n  this.maxPanSpeed = options.maxPanSpeed || 15;\n  this.minPanSpeed = options.minPanSpeed || 0.05; // animation duration for the zoom\n\n  this.zoomTravelTime = options.zoomTravelTime || 0.2; // zoom movement is equal to the distance to the zoom target, multiplied by zoomFactor\n\n  this.zoomInFactor = options.zoomInFactor || 0.25;\n  this.zoomOutFactor = options.zoomOutFactor || 0.4; // pan movement is clamped between maxAltitude and groundLevel\n\n  this.maxAltitude = options.maxAltitude || 12000; // approximate ground altitude value\n\n  this.groundLevel = options.groundLevel || 200; // min and max duration in seconds, for animated travels with 'auto' parameter\n\n  this.autoTravelTimeMin = options.autoTravelTimeMin || 1.5;\n  this.autoTravelTimeMax = options.autoTravelTimeMax || 4; // max travel duration is reached for this travel distance (empirical smoothing value)\n\n  this.autoTravelTimeDist = options.autoTravelTimeDist || 20000; // after a smartZoom, camera height above ground will be between these two values\n\n  this.smartZoomHeightMin = options.smartZoomHeightMin || 75;\n  this.smartZoomHeightMax = options.smartZoomHeightMax || 500; // if set to true, animated travels have 0 duration\n\n  this.instantTravel = options.instantTravel || false;\n  this.minZenithAngle = options.minZenithAngle || 0 * Math.PI / 180; // should be less than 90 deg (90 = parallel to the ground)\n\n  this.maxZenithAngle = (options.maxZenithAngle || 82.5) * Math.PI / 180; // focus policy options\n\n  this.focusOnMouseOver = options.focusOnMouseOver || true;\n  this.focusOnMouseClick = options.focusOnMouseClick || true; // Set collision options\n\n  this.handleCollision = typeof options.handleCollision !== 'undefined' ? options.handleCollision : true;\n  this.minDistanceCollision = 30; // starting camera position and orientation target are setup before instanciating PlanarControls\n  // using: view.camera.setPosition() and view.camera.lookAt()\n  // startPosition and startQuaternion are stored to be able to return to the start view\n\n  var startPosition = this.camera.position.clone();\n  var startQuaternion = this.camera.quaternion.clone(); // control state\n\n  this.state = STATE.NONE; // mouse movement\n\n  var mousePosition = new THREE.Vector2();\n  var lastMousePosition = new THREE.Vector2();\n  var deltaMousePosition = new THREE.Vector2(0, 0); // drag movement\n\n  var dragStart = new THREE.Vector3();\n  var dragEnd = new THREE.Vector3();\n  var dragDelta = new THREE.Vector3(); // camera focus point : ground point at screen center\n\n  var centerPoint = new THREE.Vector3(0, 0, 0); // camera rotation\n\n  var phi = 0.0; // animated travel\n\n  var travelEndPos = new THREE.Vector3();\n  var travelStartPos = new THREE.Vector3();\n  var travelStartRot = new THREE.Quaternion();\n  var travelEndRot = new THREE.Quaternion();\n  var travelAlpha = 0;\n  var travelDuration = 0;\n  var travelUseRotation = false;\n  var travelUseSmooth = false; // eventListeners handlers\n\n  var _handlerOnKeyDown = onKeyDown.bind(this);\n\n  var _handlerOnMouseDown = onMouseDown.bind(this);\n\n  var _handlerOnMouseUp = onMouseUp.bind(this);\n\n  var _handlerOnMouseMove = onMouseMove.bind(this);\n\n  var _handlerOnMouseWheel = onMouseWheel.bind(this); // focus policy\n\n\n  if (this.focusOnMouseOver) {\n    this.domElement.addEventListener('mouseover', function () {\n      return _this.domElement.focus();\n    });\n  }\n\n  if (this.focusOnMouseClick) {\n    this.domElement.addEventListener('click', function () {\n      return _this.domElement.focus();\n    });\n  } // prevent the default contextmenu from appearing when right-clicking\n  // this allows to use right-click for input without the menu appearing\n\n\n  this.domElement.addEventListener('contextmenu', onContextMenu.bind(this), false); // Updates the view and camera if needed, and handles the animated travel\n\n  this.update = function (dt, updateLoopRestarted) {\n    // We test if camera collide to geometry layer or too close to ground and ajust it's altitude in case\n    if (this.handleCollision) {\n      // We check distance to the ground/surface geometry. (Could be another geometry layer)\n      this.view.camera.adjustAltitudeToAvoidCollisionWithLayer(this.view, this.view.tileLayer, this.minDistanceCollision);\n    } // dt will not be relevant when we just started rendering, we consider a 1-frame move in this case\n\n\n    if (updateLoopRestarted) {\n      dt = 16;\n    }\n\n    if (this.state === STATE.TRAVEL) {\n      this.handleTravel(dt);\n      this.view.notifyChange(this.camera);\n    }\n\n    if (this.state === STATE.DRAG) {\n      this.handleDragMovement();\n      this.view.notifyChange(this.camera);\n    }\n\n    if (this.state === STATE.ROTATE && this.enableRotation) {\n      this.handleRotation();\n      this.view.notifyChange(this.camera);\n    }\n\n    if (this.state === STATE.PAN) {\n      this.handlePanMovement();\n      this.view.notifyChange(this.camera);\n    }\n\n    deltaMousePosition.set(0, 0);\n  }; // add this PlanarControl instance to the view's framerequesters\n  // with this, PlanarControl.update() will be called each frame\n\n\n  this.view.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.AFTER_CAMERA_UPDATE, this.update.bind(this));\n  /**\n   * Initiate a drag movement (translation on xy plane). The movement value\n   * is derived from the actual world point under the mouse cursor. This\n   * allows the user to 'grab' a world point and drag it to move.\n   *\n   * @ignore\n   */\n\n  this.initiateDrag = function () {\n    this.state = STATE.DRAG; // the world point under mouse cursor when the drag movement is started\n\n    dragStart.copy(this.getWorldPointAtScreenXY(mousePosition)); // the difference between start and end cursor position\n\n    dragDelta.set(0, 0, 0);\n  };\n  /**\n   * Handle the drag movement (translation on xy plane) when user moves the\n   * mouse while in STATE.DRAG. The drag movement is previously initiated by\n   * [initiateDrag]{@link PlanarControls#initiateDrag}. Compute the drag value\n   * and update the camera controls. The movement value is derived from the\n   * actual world point under the mouse cursor. This allows the user to 'grab'\n   * a world point and drag it to move.\n   *\n   * @ignore\n   */\n\n\n  this.handleDragMovement = function () {\n    // the world point under the current mouse cursor position, at same altitude than dragStart\n    dragEnd.copy(this.getWorldPointFromMathPlaneAtScreenXY(mousePosition, dragStart.z)); // the difference between start and end cursor position\n\n    dragDelta.subVectors(dragStart, dragEnd);\n    this.camera.position.add(dragDelta);\n    dragDelta.set(0, 0, 0);\n  };\n  /**\n   * Initiate a pan movement (local translation on xz plane).\n   *\n   * @ignore\n   */\n\n\n  this.initiatePan = function () {\n    this.state = STATE.PAN;\n  };\n  /**\n   * Handle the pan movement (translation on local x / world z plane) when\n   * user moves the mouse while in STATE.PAN. The drag movement is previously\n   * initiated by [initiatePan]{@link PlanarControls#initiatePan}. Compute the\n   * pan value and update the camera controls.\n   *\n   * @function\n   * @ignore\n   */\n\n\n  this.handlePanMovement = function () {\n    var vec = new THREE.Vector3();\n    return function () {\n      // normalized (betwwen 0 and 1) distance between groundLevel and maxAltitude\n      var distToGround = THREE.Math.clamp((_this.camera.position.z - _this.groundLevel) / _this.maxAltitude, 0, 1); // pan movement speed, adujsted according to altitude\n\n      var panSpeed = THREE.Math.lerp(_this.minPanSpeed, _this.maxPanSpeed, distToGround); // lateral movement (local x axis)\n\n      vec.set(panSpeed * -1 * deltaMousePosition.x, 0, 0);\n\n      _this.camera.position.copy(_this.camera.localToWorld(vec)); // vertical movement (world z axis)\n\n\n      var newAltitude = _this.camera.position.z + panSpeed * deltaMousePosition.y; // check if altitude is valid\n\n      if (newAltitude < _this.maxAltitude && newAltitude > _this.groundLevel) {\n        _this.camera.position.z = newAltitude;\n      }\n    };\n  }();\n  /**\n   * Initiate a rotate (orbit) movement.\n   *\n   * @ignore\n   */\n\n\n  this.initiateRotation = function () {\n    this.state = STATE.ROTATE;\n    centerPoint.copy(this.getWorldPointAtScreenXY({\n      x: 0.5 * this.view.mainLoop.gfxEngine.width,\n      y: 0.5 * this.view.mainLoop.gfxEngine.height\n    }));\n    var r = this.camera.position.distanceTo(centerPoint);\n    phi = Math.acos((this.camera.position.z - centerPoint.z) / r);\n  };\n  /**\n   * Handle the rotate movement (orbit) when user moves the mouse while in\n   * STATE.ROTATE. The movement is an orbit around 'centerPoint', the camera\n   * focus point (ground point at screen center). The rotate movement is\n   * previously initiated in [initiateRotation]{@link PlanarControls#initiateRotation}.\n   * Compute the new position value and update the camera controls.\n   *\n   * @function\n   * @ignore\n   */\n\n\n  this.handleRotation = function () {\n    var vec = new THREE.Vector3();\n    var quat = new THREE.Quaternion();\n    return function () {\n      // angle deltas\n      // deltaMousePosition is computed in onMouseMove / onMouseDown s\n      var thetaDelta = -_this.rotateSpeed * deltaMousePosition.x / _this.view.mainLoop.gfxEngine.width;\n      var phiDelta = -_this.rotateSpeed * deltaMousePosition.y / _this.view.mainLoop.gfxEngine.height; // the vector from centerPoint (focus point) to camera position\n\n      var offset = _this.camera.position.clone().sub(centerPoint);\n\n      if (thetaDelta !== 0 || phiDelta !== 0) {\n        if (phi + phiDelta >= _this.minZenithAngle && phi + phiDelta <= _this.maxZenithAngle && phiDelta !== 0) {\n          // rotation around X (altitude)\n          phi += phiDelta;\n          vec.set(0, 0, 1);\n          quat.setFromUnitVectors(_this.camera.up, vec);\n          offset.applyQuaternion(quat);\n          vec.setFromMatrixColumn(_this.camera.matrix, 0);\n          quat.setFromAxisAngle(vec, phiDelta);\n          offset.applyQuaternion(quat);\n          vec.set(0, 0, 1);\n          quat.setFromUnitVectors(_this.camera.up, vec).inverse();\n          offset.applyQuaternion(quat);\n        }\n\n        if (thetaDelta !== 0) {\n          // rotation around Z (azimuth)\n          vec.set(0, 0, 1);\n          quat.setFromAxisAngle(vec, thetaDelta);\n          offset.applyQuaternion(quat);\n        }\n      }\n\n      _this.camera.position.copy(offset);\n\n      _this.camera.lookAt(vectorZero);\n\n      _this.camera.position.add(centerPoint);\n\n      _this.camera.updateMatrixWorld();\n    };\n  }();\n  /**\n   * Triggers a Zoom animated movement (travel) toward / away from the world\n   * point under the mouse cursor. The zoom intensity varies according to the\n   * distance between the camera and the point. The closer to the ground, the\n   * lower the intensity. Orientation will not change (null parameter in the\n   * call to [initiateTravel]{@link PlanarControls#initiateTravel} function).\n   *\n   * @param {Event} event - the mouse wheel event.\n   *\n   * @ignore\n   */\n\n\n  this.initiateZoom = function (event) {\n    var delta; // mousewheel delta\n\n    if (event.wheelDelta !== undefined) {\n      delta = event.wheelDelta;\n    } else if (event.detail !== undefined) {\n      delta = -event.detail;\n    }\n\n    var pointUnderCursor = this.getWorldPointAtScreenXY(mousePosition);\n    var newPos = new THREE.Vector3(); // Zoom IN\n\n    if (delta > 0) {\n      // target position\n      newPos.lerpVectors(this.camera.position, pointUnderCursor, this.zoomInFactor); // initiate travel\n\n      this.initiateTravel(newPos, this.zoomTravelTime, null, false); // Zoom OUT\n    } else if (delta < 0 && this.camera.position.z < this.maxAltitude) {\n      // target position\n      newPos.lerpVectors(this.camera.position, pointUnderCursor, -1 * this.zoomOutFactor); // initiate travel\n\n      this.initiateTravel(newPos, this.zoomTravelTime, null, false);\n    }\n  };\n  /**\n   * Triggers a 'smart zoom' animated movement (travel) toward the point under\n   * mouse cursor. The camera will be smoothly moved and oriented close to\n   * the target, at a determined height and distance.\n   *\n   * @ignore\n   */\n\n\n  this.initiateSmartZoom = function () {\n    var pointUnderCursor = this.getWorldPointAtScreenXY(mousePosition); // direction of the movement, projected on xy plane and normalized\n\n    var dir = new THREE.Vector3();\n    dir.copy(pointUnderCursor).sub(this.camera.position);\n    dir.z = 0;\n    dir.normalize();\n    var distanceToPoint = this.camera.position.distanceTo(pointUnderCursor); // camera height (altitude above ground) at the end of the travel, 5000 is an empirical smoothing distance\n\n    var targetHeight = THREE.Math.lerp(this.smartZoomHeightMin, this.smartZoomHeightMax, Math.min(distanceToPoint / 5000, 1)); // camera position at the end of the travel\n\n    var moveTarget = new THREE.Vector3();\n    moveTarget.copy(pointUnderCursor);\n\n    if (this.enableRotation) {\n      moveTarget.add(dir.multiplyScalar(-targetHeight * 2));\n    }\n\n    moveTarget.z = pointUnderCursor.z + targetHeight; // initiate the travel\n\n    this.initiateTravel(moveTarget, 'auto', pointUnderCursor, true);\n  };\n  /**\n   * Triggers an animated movement & rotation for the camera.\n   *\n   * @param {THREE.Vector3} targetPos - The target position of the camera\n   * (reached at the end).\n   * @param {number} travelTime - Set to `auto`, or set to a duration in\n   * seconds. If set to `auto` : travel time will be set to a duration between\n   * `autoTravelTimeMin` and `autoTravelTimeMax` according to the distance and\n   * the angular difference between start and finish.\n   * @param {(string|THREE.Vector3|THREE.Quaternion)} targetOrientation -\n   * Define the target rotation of the camera:\n   * <ul>\n   *  <li>if targetOrientation is a world point (Vector3) : the camera will\n   *  lookAt() this point</li>\n   *  <li>if targetOrientation is a quaternion : this quaternion will define\n   *  the final camera orientation</li>\n   *  <li>if targetOrientation is neither a quaternion nor a world point : the\n   *  camera will keep its starting orientation</li>\n   * </ul>\n   * @param {boolean} useSmooth - Animation is smoothed using the\n   * 'smooth(value)' function (slower at start and finish)\n   *\n   * @ignore\n   */\n\n\n  this.initiateTravel = function (targetPos, travelTime, targetOrientation, useSmooth) {\n    this.state = STATE.TRAVEL;\n    this.view.notifyChange(this.camera); // the progress of the travel (animation alpha)\n\n    travelAlpha = 0; // update cursor\n\n    this.updateMouseCursorType();\n    travelUseRotation = this.enableRotation && targetOrientation && (targetOrientation.isQuaternion || targetOrientation.isVector3);\n    travelUseSmooth = useSmooth; // start position (current camera position)\n\n    travelStartPos.copy(this.camera.position); // start rotation (current camera rotation)\n\n    travelStartRot.copy(this.camera.quaternion); // setup the end rotation :\n    // case where targetOrientation is a quaternion\n\n    if (travelUseRotation) {\n      if (targetOrientation.isQuaternion) {\n        travelEndRot.copy(targetOrientation);\n      } else if (targetOrientation.isVector3) {\n        // case where targetOrientation is a vector3\n        if (targetPos === targetOrientation) {\n          this.camera.lookAt(targetOrientation);\n          travelEndRot.copy(this.camera.quaternion);\n          this.camera.quaternion.copy(travelStartRot);\n        } else {\n          this.camera.position.copy(targetPos);\n          this.camera.lookAt(targetOrientation);\n          travelEndRot.copy(this.camera.quaternion);\n          this.camera.quaternion.copy(travelStartRot);\n          this.camera.position.copy(travelStartPos);\n        }\n      }\n    } // end position\n\n\n    travelEndPos.copy(targetPos); // beginning of the travel duration setup\n\n    if (this.instantTravel) {\n      travelDuration = 0;\n    } else if (travelTime === 'auto') {\n      // case where travelTime is set to 'auto' : travelDuration will be a value between autoTravelTimeMin and autoTravelTimeMax\n      // depending on travel distance and travel angular difference\n      // a value between 0 and 1 according to the travel distance. Adjusted by autoTravelTimeDist parameter\n      var normalizedDistance = Math.min(1, targetPos.distanceTo(this.camera.position) / this.autoTravelTimeDist);\n      travelDuration = THREE.Math.lerp(this.autoTravelTimeMin, this.autoTravelTimeMax, normalizedDistance); // if travel changes camera orientation, travel duration is adjusted according to angularDifference\n      // this allows for a smoother travel (more time for the camera to rotate)\n      // final duration will not excede autoTravelTimeMax\n\n      if (travelUseRotation) {\n        // value is normalized between 0 and 1\n        var angularDifference = 0.5 - 0.5 * travelEndRot.normalize().dot(this.camera.quaternion.normalize());\n        travelDuration *= 1 + 2 * angularDifference;\n        travelDuration = Math.min(travelDuration, this.autoTravelTimeMax);\n      }\n    } else {\n      // case where traveltime !== 'auto' : travelTime is a duration in seconds given as parameter\n      travelDuration = travelTime;\n    }\n  };\n  /**\n   * Resume normal behavior after a travel is completed\n   *\n   * @ignore\n   */\n\n\n  this.endTravel = function () {\n    this.camera.position.copy(travelEndPos);\n\n    if (travelUseRotation) {\n      this.camera.quaternion.copy(travelEndRot);\n    }\n\n    this.state = STATE.NONE;\n    this.updateMouseCursorType();\n  };\n  /**\n   * Handle the animated movement and rotation of the camera in 'travel'\n   * state.\n   * @param {number} dt - The deltatime between two updates in milliseconds.\n   *\n   * @ignore\n   */\n\n\n  this.handleTravel = function (dt) {\n    travelAlpha += dt / 1000 / travelDuration; // the animation alpha, between 0 (start) and 1 (finish)\n\n    var alpha = travelUseSmooth ? smooth(travelAlpha) : travelAlpha; // new position\n\n    this.camera.position.lerpVectors(travelStartPos, travelEndPos, alpha); // new rotation\n\n    if (travelUseRotation === true) {\n      THREE.Quaternion.slerp(travelStartRot, travelEndRot, this.camera.quaternion, alpha);\n    } // completion test\n\n\n    if (travelAlpha > 1) {\n      this.endTravel();\n    }\n  };\n  /**\n   * Triggers an animated movement (travel) to set the camera to top view,\n   * above the focus point, at altitude=distanceToFocusPoint.\n   *\n   * @ignore\n   */\n\n\n  this.goToTopView = function () {\n    var topViewPos = new THREE.Vector3();\n    var targetQuat = new THREE.Quaternion(); // the top view position is above the camera focus point, at an altitude = distanceToPoint\n\n    topViewPos.copy(this.getWorldPointAtScreenXY({\n      x: 0.5 * this.view.mainLoop.gfxEngine.width,\n      y: 0.5 * this.view.mainLoop.gfxEngine.height\n    }));\n    topViewPos.z += Math.min(this.maxAltitude, this.camera.position.distanceTo(topViewPos));\n    targetQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), 0); // initiate the travel\n\n    this.initiateTravel(topViewPos, 'auto', targetQuat, true);\n  };\n  /**\n   * Triggers an animated movement (travel) to set the camera to starting view\n   *\n   * @ignore\n   */\n\n\n  this.goToStartView = function () {\n    this.initiateTravel(startPosition, 'auto', startQuaternion, true);\n  };\n  /**\n   * Returns the world point (xyz) under the posXY screen point. The point\n   * belong to an abstract mathematical plane of specified altitude (doesn't\n   * use actual geometry).\n   *\n   * @param {THREE.Vector2} posXY - the mouse position in screen space (unit : pixel)\n   * @param {number} altitude - the altitude (z) of the mathematical plane\n   * @return {THREE.Vector3}\n   *\n   * @ignore\n   */\n\n\n  this.getWorldPointFromMathPlaneAtScreenXY = function () {\n    var vector = new THREE.Vector3();\n    return function (posXY, altitude) {\n      vector.set(posXY.x / _this.view.mainLoop.gfxEngine.width * 2 - 1, -(posXY.y / _this.view.mainLoop.gfxEngine.height) * 2 + 1, 0.5);\n      vector.unproject(_this.camera); // dir = direction toward the point on the plane\n\n      var dir = vector.sub(_this.camera.position).normalize(); // distance from camera to point on the plane\n\n      var distance = (altitude - _this.camera.position.z) / dir.z;\n      return _this.camera.position.clone().add(dir.multiplyScalar(distance));\n    };\n  }(); // point under mouse cursor\n\n\n  var pointUnderCursor = new THREE.Vector3();\n  /**\n   * Returns the world point (xyz) under the posXY screen point. If geometry\n   * is under the cursor, the point in obtained with\n   * getPickingPositionFromDepth. If no geometry is under the cursor, the\n   * point is obtained with getWorldPointFromMathPlaneAtScreenXY.\n   *\n   * @param {THREE.Vector2} posXY - the mouse position in screen space (unit : pixel)\n   * @return {THREE.Vector3}\n   *\n   * @ignore\n   */\n\n  this.getWorldPointAtScreenXY = function (posXY) {\n    this.view.getPickingPositionFromDepth(posXY, pointUnderCursor); // check if there is valid geometry under cursor\n\n    if (pointUnderCursor) {\n      return pointUnderCursor;\n    } else {\n      // if not, we use the mathematical plane at altitude = groundLevel\n      return this.getWorldPointFromMathPlaneAtScreenXY(posXY, this.groundLevel);\n    }\n  };\n\n  this.updateMousePositionAndDelta = function (event) {\n    mousePosition.set(event.clientX, event.clientY);\n    deltaMousePosition.copy(mousePosition).sub(lastMousePosition);\n    lastMousePosition.copy(mousePosition);\n  };\n  /**\n   * Adds all the input event listeners (activate the controls).\n   *\n   * @ignore\n   */\n\n\n  this.addInputListeners = function () {\n    this.domElement.addEventListener('keydown', _handlerOnKeyDown, true);\n    this.domElement.addEventListener('mousedown', _handlerOnMouseDown, false);\n    this.domElement.addEventListener('mouseup', _handlerOnMouseUp, false);\n    this.domElement.addEventListener('mousemove', _handlerOnMouseMove, false);\n    this.domElement.addEventListener('mousewheel', _handlerOnMouseWheel, false); // For firefox\n\n    this.domElement.addEventListener('MozMousePixelScroll', _handlerOnMouseWheel, false);\n  };\n  /**\n   * Removes all the input event listeners (desactivate the controls).\n   *\n   * @ignore\n   */\n\n\n  this.removeInputListeners = function () {\n    this.domElement.removeEventListener('keydown', _handlerOnKeyDown, true);\n    this.domElement.removeEventListener('mousedown', _handlerOnMouseDown, false);\n    this.domElement.removeEventListener('mouseup', _handlerOnMouseUp, false);\n    this.domElement.removeEventListener('mousemove', _handlerOnMouseMove, false);\n    this.domElement.removeEventListener('mousewheel', _handlerOnMouseWheel, false); // For firefox\n\n    this.domElement.removeEventListener('MozMousePixelScroll', _handlerOnMouseWheel, false);\n  };\n  /**\n   * Update the cursor image according to the control state.\n   *\n   * @ignore\n   */\n\n\n  this.updateMouseCursorType = function () {\n    switch (this.state) {\n      case STATE.NONE:\n        this.domElement.style.cursor = 'auto';\n        break;\n\n      case STATE.DRAG:\n        this.domElement.style.cursor = 'move';\n        break;\n\n      case STATE.PAN:\n        this.domElement.style.cursor = 'cell';\n        break;\n\n      case STATE.TRAVEL:\n        this.domElement.style.cursor = 'wait';\n        break;\n\n      case STATE.ROTATE:\n        this.domElement.style.cursor = 'move';\n        break;\n\n      default:\n        break;\n    }\n  }; // event listeners for user input (to activate the controls)\n\n\n  this.addInputListeners();\n}\n/**\n * Catch and manage the event when a touch on the mouse is down.\n * @param {event} event : the current event (mouse left button clicked or mouse wheel button actionned)\n * @ignore\n */\n\n\nfunction onMouseDown(event) {\n  event.preventDefault();\n\n  if (this.state === STATE.TRAVEL) {\n    return;\n  }\n\n  this.updateMousePositionAndDelta(event);\n\n  if (event.button === mouseButtons.LEFTCLICK) {\n    if (event.ctrlKey) {\n      this.initiateRotation();\n    } else {\n      this.initiateDrag();\n    }\n  } else if (event.button === mouseButtons.MIDDLECLICK) {\n    this.initiateSmartZoom(event);\n  } else if (event.button === mouseButtons.RIGHTCLICK) {\n    this.initiatePan();\n  }\n\n  this.updateMouseCursorType();\n}\n/**\n * Catch the event when a touch on the mouse is uped.\n *\n * @param {Event} event - the current event\n * @ignore\n */\n\n\nfunction onMouseUp(event) {\n  event.preventDefault();\n\n  if (this.state !== STATE.TRAVEL) {\n    this.state = STATE.NONE;\n  }\n\n  this.updateMouseCursorType();\n}\n/**\n * Catch and manage the event when the mouse is moved.\n *\n * @param {Event} event - the current event\n * @ignore\n */\n\n\nfunction onMouseMove(event) {\n  event.preventDefault();\n  this.updateMousePositionAndDelta(event); // notify change if moving\n\n  if (this.state !== STATE.NONE) {\n    this.view.notifyChange();\n  }\n}\n/**\n * Catch and manage the event when a key is down.\n *\n * @param {Event} event - the current event\n * @ignore\n */\n\n\nfunction onKeyDown(event) {\n  if (this.state === STATE.TRAVEL) {\n    return;\n  }\n\n  if (event.keyCode === keys.T) {\n    this.goToTopView();\n  }\n\n  if (event.keyCode === keys.Y) {\n    this.goToStartView();\n  }\n\n  if (event.keyCode === keys.SPACE) {\n    this.initiateSmartZoom(event);\n  }\n}\n/**\n * Catch and manage the event when the mouse wheel is rolled.\n *\n * @param {Event} event - the current event\n * @ignore\n */\n\n\nfunction onMouseWheel(event) {\n  event.preventDefault();\n  event.stopPropagation();\n\n  if (this.state === STATE.NONE) {\n    this.initiateZoom(event);\n  }\n}\n/**\n * Catch and manage the event when the context menu is called (by a right click\n * on the window).  We use this to prevent the context menu from appearing, so\n * we can use right click for other inputs.\n *\n * @param {Event} event - the current event\n * @ignore\n */\n\n\nfunction onContextMenu(event) {\n  event.preventDefault();\n}\n/**\n * Smoothing function (sigmoid) : based on h01 Hermite function.\n *\n * @param {number} value - The value to be smoothed, between 0 and 1\n * @return {number} A value between 0 and 1.\n * @ignore\n */\n\n\nfunction smooth(value) {\n  // p between 1.0 and 1.5 (empirical)\n  return Math.pow(Math.pow(value, 2) * (3 - 2 * value), 1.20);\n}\n\nvar _default = PlanarControls;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Controls/PlanarControls.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Controls/StateControl.js":
/*!**********************************************************!*\
  !*** ./node_modules/itowns/lib/Controls/StateControl.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar CONTROL_KEYS = {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  BOTTOM: 40,\n  SPACE: 32,\n  SHIFT: 16,\n  CTRL: 17,\n  S: 83\n};\n/**\n * @typedef {Object} state\n * @property {boolean} enable=true indicate whether the state is enable or not\n * @property {Number} [mouseButton] the mouse button to enter this state\n * @property {Number} [keyboard] the keyboard to enter this state\n * @property {Number} [finger] the number of fingers on the pad to enter this state\n */\n\n/**\n * It represents the control's states.\n * Each {@link state} is a control mode of the camera and how to interact with\n * the interface to activate this mode.\n * @class StateControl\n *\n */\n\nvar StateControl =\n/*#__PURE__*/\nfunction () {\n  function StateControl() {\n    (0, _classCallCheck2[\"default\"])(this, StateControl);\n    this.NONE = {};\n    /**\n     * The camera loot at target and moves at a constant distance from it\n     */\n\n    this.ORBIT = {\n      mouseButton: THREE.MOUSE.LEFT,\n      keyboard: CONTROL_KEYS.CTRL,\n      enable: true,\n      finger: 2\n    };\n    /**\n     * The camera loot at target and moves forward and backward from this point\n     */\n\n    this.DOLLY = {\n      mouseButton: THREE.MOUSE.MIDDLE,\n      enable: true\n    };\n    /**\n     * the camera moves parallel to the current view plane\n     */\n\n    this.PAN = {\n      mouseButton: THREE.MOUSE.RIGHT,\n      up: CONTROL_KEYS.UP,\n      bottom: CONTROL_KEYS.BOTTOM,\n      left: CONTROL_KEYS.LEFT,\n      right: CONTROL_KEYS.RIGHT,\n      enable: true,\n      finger: 3\n    };\n    this.MOVE_GLOBE = {\n      mouseButton: THREE.MOUSE.LEFT,\n      enable: true,\n      finger: 1\n    };\n    /**\n     * the camera and target camera rotate around the globe\n     */\n\n    this.PANORAMIC = {\n      mouseButton: THREE.MOUSE.LEFT,\n      keyboard: CONTROL_KEYS.SHIFT,\n      enable: true\n    };\n  }\n  /**\n   * get the state corresponding to the mouse button and the keyboard key\n   * @param      {Number}  mouseButton  The mouse button\n   * @param      {Number}  keyboard     The keyboard\n   * @return     {state}  the state corresponding\n   */\n\n\n  (0, _createClass2[\"default\"])(StateControl, [{\n    key: \"inputToState\",\n    value: function inputToState(mouseButton, keyboard) {\n      for (var _i = 0, _Object$keys = Object.keys(this); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        var state = this[key];\n\n        if (state.enable && state.mouseButton === mouseButton && state.keyboard === keyboard) {\n          return state;\n        }\n      }\n\n      return this.NONE;\n    }\n    /**\n     * get the state corresponding to the number of finger on the pad\n     *\n     * @param      {Number}  finger  The number of finger\n     * @return     {state}  the state corresponding\n     */\n\n  }, {\n    key: \"touchToState\",\n    value: function touchToState(finger) {\n      for (var _i2 = 0, _Object$keys2 = Object.keys(this); _i2 < _Object$keys2.length; _i2++) {\n        var key = _Object$keys2[_i2];\n        var state = this[key];\n\n        if (state.enable && finger == state.finger) {\n          return state;\n        }\n      }\n\n      return this.NONE;\n    }\n  }]);\n  return StateControl;\n}();\n\nvar _default = StateControl;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Controls/StateControl.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Controls/StreetControls.js":
/*!************************************************************!*\
  !*** ./node_modules/itowns/lib/Controls/StreetControls.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ \"./node_modules/@babel/runtime/helpers/get.js\"));\n\nvar _tween = _interopRequireDefault(__webpack_require__(/*! @tweenjs/tween.js */ \"./node_modules/@tweenjs/tween.js/dist/tween.esm.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _MainLoop = __webpack_require__(/*! ../Core/MainLoop */ \"./node_modules/itowns/lib/Core/MainLoop.js\");\n\nvar _FirstPersonControls2 = _interopRequireDefault(__webpack_require__(/*! ./FirstPersonControls */ \"./node_modules/itowns/lib/Controls/FirstPersonControls.js\"));\n\nvar material = new THREE.MeshBasicMaterial({\n  color: 0xffffff,\n  depthTest: false,\n  transparent: true,\n  opacity: 0.5\n});\n\nfunction createCircle() {\n  var geomCircle = new THREE.CircleGeometry(1, 32);\n  return new THREE.Mesh(geomCircle, material);\n}\n\nfunction createRectangle() {\n  var geomPlane = new THREE.PlaneGeometry(4, 2, 1);\n  var rectangle = new THREE.Mesh(geomPlane, material);\n  rectangle.rotateX(-Math.PI * 0.5);\n  return rectangle;\n} // update a surfaces node\n\n\nfunction updateSurfaces(surfaces, position, norm) {\n  surfaces.position.copy(position);\n  surfaces.up.copy(position).normalize();\n  surfaces.lookAt(norm);\n  surfaces.updateMatrixWorld(true);\n} // vector use in the pick method\n\n\nvar target = new THREE.Vector3();\nvar up = new THREE.Vector3();\nvar startQuaternion = new THREE.Quaternion();\n\nfunction pick(event, view, buildingsLayer) {\n  var pickGround = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n  var pickObject = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};\n  var pickNothing = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function () {};\n  // get real distance to ground, with a specific method to pick on the elevation layer\n  view.getPickingPositionFromDepth(view.eventToViewCoords(event), target);\n  var distanceToGround = view.camera.camera3D.position.distanceTo(target); // pick on building layer\n\n  var buildings = buildingsLayer ? view.pickObjectsAt(event, -1, buildingsLayer) : []; // to detect pick on building, compare first picked building distance to ground distance\n\n  if (buildings.length && buildings[0].distance < distanceToGround) {\n    // pick buildings\n    // callback\n    pickObject(buildings[0].point, buildings[0].face.normal);\n  } else if (view.tileLayer) {\n    var far = view.camera.camera3D.far * 0.95;\n\n    if (distanceToGround < far) {\n      // compute normal\n      if (view.tileLayer.isGlobeLayer) {\n        up.copy(target).multiplyScalar(1.1);\n      } else {\n        up.set(0, 0, 1);\n      } // callback\n\n\n      pickGround(target, up);\n    } else {\n      // callback\n      pickNothing();\n    }\n  } else {\n    pickNothing();\n  }\n} // default function to compute time (in millis), used for the animation to move to a distance (in meter)\n\n\nfunction computeTime(distance) {\n  return 100 + Math.sqrt(distance) * 30;\n}\n/**\n * @classdesc Camera controls that can follow a path.\n * It is used to simulate a street view.\n * It stores a currentPosition and nextPosition, and do a camera traveling to go to next position.\n * It also manages picking on the ground and on other object, like building.\n * <ul> It manages 2 surfaces, used as helpers for the end user :\n * <li> a circle is shown when mouse is moving on the ground </li>\n * <li> a rectangle is shown when mouse is moving on other 3d object </li>\n * </ul>\n * <ul>\n * This controls is designed\n * <li> to move forward when user click on the ground (click and go) </li>\n * <li> to rotate the camera when user click on other object (click to look at) </li>\n * </ul>\n * <ul> Bindings inherited from FirstPersonControls\n * <li><b> up + down keys : </b> forward/backward </li>\n * <li><b> left + right keys: </b> strafing movements </li>\n * <li><b> pageUp + pageDown: </b> vertical movements </li>\n * <li><b> mouse click+drag: </b> pitch and yaw movements (as looking at a panorama) </li>\n * </ul>\n * <ul> Bindings added\n * <li><b> keys Z : </b> Move camera to the next position </li>\n * <li><b> keys S : </b> Move camera to the previous position </li>\n * <li><b> keys A : </b> Set camera to current position and look at next position</li>\n * <li><b> keys Q : </b> Set camera to current position and look at previous position</li>\n * </ul>\n * Note that it only works in globe view.\n * @property {number} keyGoToNextPosition key code to go to next position, default to 90 for key Z\n * @property {number} keyGoToPreviousPosition key code to go to previous position, default to 83 for key S\n * @property {number} keySetCameraToCurrentPositionAndLookAtNext key code set camera to current position, default to 65 for key  A\n * @property {number} keySetCameraToCurrentPositionAndLookAtPrevious key code set camera to current position, default to 81 for key  Q\n * @extends FirstPersonControls\n */\n\n\nvar StreetControls =\n/*#__PURE__*/\nfunction (_FirstPersonControls) {\n  (0, _inherits2[\"default\"])(StreetControls, _FirstPersonControls);\n\n  /**\n   * @constructor\n   * @param { View } view - View where this control will be used\n   * @param { Object } options - Configuration of this controls\n   * @param { number } [options.wallMaxDistance=1000] - Maximum distance to click on a wall, in meter.\n   * @param { number } [options.animationDurationWall=200] - Time in millis for the animation when clicking on a wall.\n   * @param { THREE.Mesh } [options.surfaceGround] - Surface helper to see when mouse is on the ground, default is a transparent circle.\n   * @param { THREE.Mesh } [options.surfaceWall] - Surface helper to see when mouse is on a wall, default is a transparent rectangle.\n   * @param { string } [options.buildingsLayer='Buildings'] - Name of the building layer (used to pick on wall).\n   * @param { function } [options.computeTime] - Function to compute time (in millis), used for the animation to move to a distance (in meter)\n   * @param { number } [options.offset=4] - Altitude in meter up to the ground to move to when click on a target on the ground.\n   */\n  function StreetControls(view) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, StreetControls);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(StreetControls).call(this, view, options));\n    _this.isStreetControls = true;\n    var domElement = view.mainLoop.gfxEngine.renderer.domElement;\n    domElement.addEventListener('mouseout', (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(StreetControls.prototype), \"onMouseUp\", (0, _assertThisInitialized2[\"default\"])(_this)).bind((0, _assertThisInitialized2[\"default\"])(_this))); // two positions used by this control : current and next\n\n    _this.previousPosition = undefined;\n    _this.currentPosition = undefined;\n    _this.nextPosition = undefined;\n    _this.keyGoToNextPosition = 90;\n    _this.keyGoToPreviousPosition = 83;\n    _this.keySetCameraToCurrentPositionAndLookAtNext = 65;\n    _this.keySetCameraToCurrentPositionAndLookAtPrevious = 81; // Tween is used to make smooth animations\n\n    _this.tweenGroup = new _tween[\"default\"].Group(); // init surfaces used as helper for end user\n\n    _this.surfaceGround = options.surfaceGround || createCircle();\n    _this.surfaceWall = options.surfaceWall || createRectangle(); // surfaces is an object3D containing the two surfaces\n\n    _this.surfaces = new THREE.Object3D();\n\n    _this.surfaces.add(_this.surfaceGround);\n\n    _this.surfaces.add(_this.surfaceWall);\n\n    _this.view.scene.add(_this.surfaces);\n\n    _this.wallMaxDistance = options.wallMaxDistance || 1000;\n    _this.animationDurationWall = options.animationDurationWall || 200;\n    _this.buildingsLayer = options.buildingsLayer;\n    _this.computeTime = options.computeTime || computeTime;\n    _this.offset = options.offset || 4;\n\n    _this.transformationPositionPickOnTheGround = options.transformationPositionPickOnTheGround || function (position) {\n      return position;\n    };\n\n    _this.end = _this.camera.clone();\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(StreetControls, [{\n    key: \"setCurrentPosition\",\n    value: function setCurrentPosition(newCurrentPosition) {\n      this.currentPosition = newCurrentPosition;\n    }\n  }, {\n    key: \"setNextPosition\",\n    value: function setNextPosition(newNextPosition) {\n      this.nextPosition = newNextPosition;\n    }\n  }, {\n    key: \"setPreviousPosition\",\n    value: function setPreviousPosition(newPreviousPosition) {\n      this.previousPosition = newPreviousPosition;\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(event) {\n      if (this.enabled == false) {\n        return;\n      }\n\n      (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(StreetControls.prototype), \"onMouseUp\", this).call(this);\n\n      if (this._stateOnMouseDrag) {\n        this._stateOnMouseDrag = false;\n      } else {\n        pick(event, this.view, this.buildingsLayer, this.onClickOnGround.bind(this), this.onClickOnWall.bind(this));\n      }\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      var _this2 = this;\n\n      if (this.enabled == false) {\n        return;\n      }\n\n      (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(StreetControls.prototype), \"onMouseMove\", this).call(this, event);\n\n      if (this._isMouseDown) {\n        // state mouse drag (move + mouse click)\n        this._stateOnMouseDrag = true;\n        this.stopAnimations();\n      } else if (!this.tween) {\n        // mouse pick and manage surfaces\n        pick(event, this.view, this.buildingsLayer, function (groundTarget, normal) {\n          updateSurfaces(_this2.surfaces, groundTarget, normal);\n          _this2.surfaceGround.visible = true;\n          _this2.surfaceWall.visible = false;\n        }, function (wallTarget, normal) {\n          updateSurfaces(_this2.surfaces, wallTarget, normal);\n          _this2.surfaceWall.visible = true;\n          _this2.surfaceGround.visible = false;\n        });\n        this.view.notifyChange(this.surfaces);\n      }\n    }\n    /**\n     * Sets the camera to the current position (stored in this controls), looking at the next position (also stored in this controls).\n     *\n     * @param      { boolean }  lookAtPrevious   look at the previous position rather than the next one\n     */\n\n  }, {\n    key: \"setCameraToCurrentPosition\",\n    value: function setCameraToCurrentPosition(lookAtPrevious) {\n      if (lookAtPrevious) {\n        this.setCameraOnPosition(this.currentPosition, this.previousPosition);\n      } else {\n        this.setCameraOnPosition(this.currentPosition, this.nextPosition);\n      }\n    }\n    /**\n     * Set the camera on a position, looking at another position.\n     *\n     * @param      { THREE.Vector3 }  position   The position to set the camera\n     * @param      { THREE.Vector3 }  lookAt      The position where the camera look at.\n     */\n\n  }, {\n    key: \"setCameraOnPosition\",\n    value: function setCameraOnPosition(position, lookAt) {\n      if (!position || !lookAt) {\n        return;\n      }\n\n      this.camera.position.copy(position);\n\n      if (this.view.tileLayer && this.view.tileLayer.isGlobeLayer) {\n        this.camera.up.copy(position).normalize();\n      } else {\n        this.camera.up.set(0, 0, 1);\n      }\n\n      this.camera.lookAt(lookAt);\n      this.camera.updateMatrixWorld();\n      this.reset();\n    }\n    /**\n     * Method called when user click on the ground.</br>\n     * Note that this funtion contains default values that can be overrided, by overriding this class.\n     *\n     * @param {THREE.Vector3} position - The position\n     */\n\n  }, {\n    key: \"onClickOnGround\",\n    value: function onClickOnGround(position) {\n      position = this.transformationPositionPickOnTheGround(position);\n\n      if (this.view.tileLayer && this.view.tileLayer.isGlobeLayer) {\n        up.copy(position).normalize();\n      } else {\n        up.set(0, 0, 1);\n      }\n\n      position.add(up.multiplyScalar(this.offset)); // compute time to go there\n\n      var distance = this.camera.position.distanceTo(position); // 500 millis constant, plus an amount of time depending of the distance (but not linearly)\n\n      var time = this.computeTime(distance); // move the camera\n\n      this.moveCameraTo(position, time);\n    }\n    /**\n     * Method called when user click on oject that is not the ground.</br>\n     * Note that this function contains default values that can be overrided, by overriding this class.\n     *\n     * @param {THREE.Vector3} position - The position\n     */\n\n  }, {\n    key: \"onClickOnWall\",\n    value: function onClickOnWall(position) {\n      var distance = this.camera.position.distanceTo(position); // can't click on a wall that is at 1km distance.\n\n      if (distance < this.wallMaxDistance) {\n        this.animateCameraLookAt(position, this.animationDurationWall);\n      }\n    }\n    /**\n     * Animate the camera to make it look at a position, in a given time\n     *\n     * @param { THREE.Vector3 }  position - Position to look at\n     * @param { number } time - Time in millisecond\n     */\n\n  }, {\n    key: \"animateCameraLookAt\",\n    value: function animateCameraLookAt(position, time) {\n      var _this3 = this;\n\n      // stop existing animation\n      this.stopAnimations(); // prepare start point and end point\n\n      startQuaternion.copy(this.camera.quaternion);\n      this.end.copy(this.camera);\n      this.end.lookAt(position);\n      this.tween = new _tween[\"default\"].Tween({\n        t: 0\n      }, this.tweenGroup).to({\n        t: 1\n      }, time).easing(_tween[\"default\"].Easing.Quadratic.Out).onComplete(function () {\n        _this3.stopAnimations();\n      }).onUpdate(function (d) {\n        // 'manually' slerp the Quaternion to avoid rotation issues\n        THREE.Quaternion.slerp(startQuaternion, _this3.end.quaternion, _this3.camera.quaternion, d.t);\n      }).start();\n\n      this.animationFrameRequester = function () {\n        _this3.tweenGroup.update(); // call reset from super class FirsPersonControls to make mouse rotation managed by FirstPersonControl still aligned\n\n\n        _this3.reset();\n\n        _this3.view.notifyChange(_this3.camera);\n      };\n\n      this.view.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.BEFORE_RENDER, this.animationFrameRequester);\n      this.view.notifyChange(this.camera);\n    }\n    /**\n     * Move the camera smoothly to the position, in a given time.\n     *\n     * @param { THREE.Vector3 }  position - Destination of the movement.\n     * @param { number } time - Time in millisecond\n     * @return { Promise }\n     */\n\n  }, {\n    key: \"moveCameraTo\",\n    value: function moveCameraTo(position) {\n      var _this4 = this;\n\n      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n\n      if (!position) {\n        return Promise.resolve();\n      }\n\n      var resolve;\n      var promise = new Promise(function (r) {\n        resolve = r;\n      });\n      this.stopAnimations();\n      this.tween = new _tween[\"default\"].Tween(this.camera.position, this.tweenGroup) // Create a new tween that modifies camera position\n      .to(position.clone(), time).easing(_tween[\"default\"].Easing.Quadratic.Out) // Use an easing function to make the animation smooth.\n      .onComplete(function () {\n        _this4.stopAnimations();\n\n        resolve();\n      }).start();\n\n      this.animationFrameRequester = function () {\n        _this4.tweenGroup.update();\n\n        _this4.view.notifyChange(_this4.camera);\n      };\n\n      this.view.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.BEFORE_RENDER, this.animationFrameRequester);\n      this.view.notifyChange(this.camera);\n      return promise;\n    }\n  }, {\n    key: \"stopAnimations\",\n    value: function stopAnimations() {\n      if (this.tween) {\n        this.tween.stop();\n        this.tween = undefined;\n      }\n\n      if (this.animationFrameRequester) {\n        this.view.removeFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.BEFORE_RENDER, this.animationFrameRequester);\n        this.animationFrameRequester = null;\n      }\n    }\n    /**\n     * Move the camera to the 'currentPosition' stored in this control.\n     */\n\n  }, {\n    key: \"moveCameraToCurrentPosition\",\n    value: function moveCameraToCurrentPosition() {\n      this.moveCameraTo(this.currentPosition);\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(e) {\n      if (this.enabled == false) {\n        return;\n      }\n\n      (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(StreetControls.prototype), \"onKeyDown\", this).call(this, e); // key to move to next position (default to Z)\n\n      if (e.keyCode == this.keyGoToNextPosition) {\n        this.moveCameraTo(this.nextPosition);\n      } // key to move to previous position (default to S)\n\n\n      if (e.keyCode == this.keyGoToPreviousPosition) {\n        this.moveCameraTo(this.previousPosition);\n      } // key to set to camera to current position looking at next position (default to A)\n\n\n      if (e.keyCode == this.keySetCameraToCurrentPositionAndLookAtNext) {\n        this.setCameraToCurrentPosition();\n        this.view.notifyChange(this.view.camera.camera3D);\n      } // key to set to camera to current position looking at previous position (default to Q)\n\n\n      if (e.keyCode == this.keySetCameraToCurrentPositionAndLookAtPrevious) {\n        this.setCameraToCurrentPosition(true);\n        this.view.notifyChange(this.view.camera.camera3D);\n      }\n    }\n  }]);\n  return StreetControls;\n}(_FirstPersonControls2[\"default\"]);\n\nvar _default = StreetControls;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Controls/StreetControls.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Converter/Feature2Mesh.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Converter/Feature2Mesh.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _earcut = _interopRequireDefault(__webpack_require__(/*! earcut */ \"./node_modules/earcut/src/earcut.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Feature = __webpack_require__(/*! ../Core/Feature */ \"./node_modules/itowns/lib/Core/Feature.js\");\n\nfunction getProperty(name, options, defaultValue) {\n  var property = options[name];\n\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  if (property) {\n    if (typeof property === 'function') {\n      var p = property.apply(void 0, args);\n\n      if (p) {\n        return p;\n      }\n    } else {\n      return property;\n    }\n  }\n\n  if (typeof defaultValue === 'function') {\n    return defaultValue.apply(void 0, args);\n  }\n\n  return defaultValue;\n}\n\nfunction randomColor() {\n  return new THREE.Color(Math.random() * 0xffffff);\n}\n\nfunction fillColorArray(colors, length, color) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  offset *= 3;\n  var len = offset + length * 3;\n\n  for (var i = offset; i < len; i += 3) {\n    colors[i] = color.r * 255;\n    colors[i + 1] = color.g * 255;\n    colors[i + 2] = color.b * 255;\n  }\n}\n\nfunction fillBatchIdArray(batchId, batchIdArray, start, end) {\n  for (var i = start; i < end; i++) {\n    batchIdArray[i] = batchId;\n  }\n}\n/**\n * Convert coordinates to vertices positionned at a given altitude\n *\n * @param      {number[]} ptsIn - Coordinates of a feature.\n * @param      {number[]} normals - Coordinates of a feature.\n * @param      {number[]} target - Target to copy result.\n * @param      {(Function|number)}  altitude - Altitude of feature or function to get altitude.\n * @param      {number} extrude - The extrude amount to apply at each point\n * @param      {number} offsetOut - The offset array value to copy on target\n * @param      {number} countIn - The count of coordinates to read in ptsIn\n * @param      {number} startIn - The offser array to strat reading in ptsIn\n */\n\n\nvar coord = new _Coordinates[\"default\"]('EPSG:4326', 0, 0);\n\nfunction coordinatesToVertices(ptsIn, normals, target) {\n  var altitude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var extrude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var offsetOut = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var countIn = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ptsIn.length / 3;\n  var startIn = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : offsetOut;\n  startIn *= 3;\n  countIn *= 3;\n  offsetOut *= 3;\n  var endIn = startIn + countIn;\n  var fnAltitude;\n\n  if (!isNaN(altitude)) {\n    fnAltitude = function () {\n      return altitude;\n    };\n  } else if (Array.isArray(altitude)) {\n    fnAltitude = function (id) {\n      return altitude[(id - startIn) / 3];\n    };\n  } else {\n    fnAltitude = function (id) {\n      return altitude({}, coord.setFromArray(ptsIn, id));\n    };\n  }\n\n  for (var i = startIn, j = offsetOut; i < endIn; i += 3, j += 3) {\n    // move the vertex following the normal, to put the point on the good altitude\n    var t = fnAltitude(i) + (Array.isArray(extrude) ? extrude[(i - startIn) / 3] : extrude);\n\n    if (target.minAltitude) {\n      target.minAltitude = Math.min(t, target.minAltitude);\n    } // fill the vertices array at the offset position\n\n\n    target[j] = ptsIn[i] + normals[i] * t;\n    target[j + 1] = ptsIn[i + 1] + normals[i + 1] * t;\n    target[j + 2] = ptsIn[i + 2] + normals[i + 2] * t;\n  }\n}\n/*\n * Add indices for the side faces.\n * We loop over the contour and create a side face made of two triangles.\n *\n * For a ring made of (n) coordinates, there are (n*2) vertices.\n * The (n) first vertices are on the roof, the (n) other vertices are on the floor.\n *\n * If index (i) is on the roof, index (i+length) is on the floor.\n *\n * @param {number[]} indices - Array of indices to push to\n * @param {number} length - Total vertices count in the geom (excluding the extrusion ones)\n * @param {number} offset\n * @param {number} count\n * @param {boolean} isClockWise - Wrapping direction\n */\n\n\nfunction addExtrudedPolygonSideFaces(indices, length, offset, count, isClockWise) {\n  // loop over contour length, and for each point of the contour,\n  // add indices to make two triangle, that make the side face\n  var startIndice = indices.length;\n  indices.length += (count - 1) * 6;\n\n  for (var i = offset, j = startIndice; i < offset + count - 1; ++i, ++j) {\n    if (isClockWise) {\n      // first triangle indices\n      indices[j] = i;\n      indices[++j] = i + length;\n      indices[++j] = i + 1; // second triangle indices\n\n      indices[++j] = i + 1;\n      indices[++j] = i + length;\n      indices[++j] = i + length + 1;\n    } else {\n      // first triangle indices\n      indices[j] = i + length;\n      indices[++j] = i;\n      indices[++j] = i + length + 1; // second triangle indices\n\n      indices[++j] = i + length + 1;\n      indices[++j] = i;\n      indices[++j] = i + 1;\n    }\n  }\n}\n\nvar pointMaterial = new THREE.PointsMaterial();\n\nfunction featureToPoint(feature, options) {\n  var ptsIn = feature.vertices;\n  var normals = feature.normals;\n  var colors = new Uint8Array(ptsIn.length);\n  var batchIds = options.batchId ? new Uint32Array(ptsIn.length / 3) : undefined;\n  var featureId = 0;\n  var vertices;\n\n  if (options.altitude !== 0) {\n    vertices = new Float32Array(ptsIn.length);\n    coordinatesToVertices(ptsIn, normals, vertices, options.altitude);\n  } else {\n    vertices = new Float32Array(ptsIn);\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = feature.geometry[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var geometry = _step.value;\n\n      var _color = getProperty('color', options, randomColor, geometry.properties);\n\n      var start = geometry.indices[0].offset;\n      var count = geometry.indices[0].count;\n      fillColorArray(colors, count, _color, start);\n\n      if (batchIds) {\n        var id = options.batchId(geometry.properties, featureId);\n        fillBatchIdArray(id, batchIds, start, start + count);\n        featureId++;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var geom = new THREE.BufferGeometry();\n  geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true));\n\n  if (batchIds) {\n    geom.setAttribute('batchId', new THREE.BufferAttribute(batchIds, 1));\n  }\n\n  return new THREE.Points(geom, pointMaterial);\n}\n\nvar lineMaterial = new THREE.LineBasicMaterial({\n  vertexColors: THREE.VertexColors\n});\n\nfunction featureToLine(feature, options) {\n  var ptsIn = feature.vertices;\n  var normals = feature.normals;\n  var colors = new Uint8Array(ptsIn.length);\n  var count = ptsIn.length / 3;\n  var batchIds = options.batchId ? new Uint32Array(count) : undefined;\n  var featureId = 0;\n  var vertices;\n\n  if (options.altitude !== 0) {\n    vertices = new Float32Array(ptsIn.length);\n    coordinatesToVertices(ptsIn, normals, vertices, options.altitude);\n  } else {\n    vertices = new Float32Array(ptsIn);\n  }\n\n  var geom = new THREE.BufferGeometry();\n  geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n\n  if (feature.geometry.length > 1) {\n    var countIndices = (count - feature.geometry.length) * 2;\n    var indices = new Uint16Array(countIndices);\n    var i = 0; // Multi line case\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = feature.geometry[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var geometry = _step2.value;\n\n        var _color2 = getProperty('color', options, randomColor, geometry.properties);\n\n        var start = geometry.indices[0].offset; // To avoid integer overflow with indice value (16 bits)\n\n        if (start > 0xffff) {\n          console.warn('Feature to Line: integer overflow, too many points in lines');\n          break;\n        }\n\n        var _count = geometry.indices[0].count;\n        var end = start + _count;\n        fillColorArray(colors, _count, _color2, start);\n\n        for (var j = start; j < end - 1; j++) {\n          if (j < 0xffff) {\n            indices[i++] = j;\n            indices[i++] = j + 1;\n          } else {\n            break;\n          }\n        }\n\n        if (batchIds) {\n          var id = options.batchId(geometry.properties, featureId);\n          fillBatchIdArray(id, batchIds, start, end);\n          featureId++;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true));\n\n    if (batchIds) {\n      geom.setAttribute('batchId', new THREE.BufferAttribute(batchIds, 1));\n    }\n\n    geom.setIndex(new THREE.BufferAttribute(indices, 1));\n    return new THREE.LineSegments(geom, lineMaterial);\n  } else {\n    var _color3 = getProperty('color', options, randomColor, feature.geometry[0].properties);\n\n    fillColorArray(colors, count, _color3);\n    geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true));\n\n    if (batchIds) {\n      var _id = options.batchId(feature.geometry.properties, featureId);\n\n      fillBatchIdArray(_id, batchIds, 0, count);\n      geom.setAttribute('batchId', new THREE.BufferAttribute(batchIds, 1));\n    }\n\n    return new THREE.Line(geom, lineMaterial);\n  }\n}\n\nvar color = new THREE.Color();\nvar material = new THREE.MeshBasicMaterial();\n\nfunction featureToPolygon(feature, options) {\n  var ptsIn = feature.vertices;\n  var normals = feature.normals;\n  var vertices = new Float32Array(ptsIn);\n  var colors = new Uint8Array(ptsIn.length);\n  var indices = [];\n  vertices.minAltitude = Infinity;\n  var batchIds = options.batchId ? new Uint32Array(vertices.length / 3) : undefined;\n  var featureId = 0;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    var _loop = function () {\n      var geometry = _step3.value;\n      var start = geometry.indices[0].offset; // To avoid integer overflow with indice value (16 bits)\n\n      if (start > 0xffff) {\n        console.warn('Feature to Polygon: integer overflow, too many points in polygons');\n        return \"break\";\n      }\n\n      var color = getProperty('color', options, randomColor, geometry.properties);\n      var lastIndice = geometry.indices.slice(-1)[0];\n      var end = lastIndice.offset + lastIndice.count;\n      var count = end - start;\n      var altitude = getProperty('altitude', options, 0, geometry.properties);\n\n      if (altitude !== 0) {\n        coordinatesToVertices(ptsIn, normals, vertices, altitude, 0, start, count);\n      }\n\n      fillColorArray(colors, count, color, start);\n      var geomVertices = vertices.slice(start * 3, end * 3);\n      var holesOffsets = geometry.indices.map(function (i) {\n        return i.offset - start;\n      }).slice(1);\n      var triangles = (0, _earcut[\"default\"])(geomVertices, holesOffsets, 3);\n      var startIndice = indices.length;\n      indices.length += triangles.length;\n\n      for (var i = 0; i < triangles.length; i++) {\n        indices[startIndice + i] = triangles[i] + start;\n      }\n\n      if (batchIds) {\n        var id = options.batchId(geometry.properties, featureId);\n        fillBatchIdArray(id, batchIds, start, end);\n        featureId++;\n      }\n    };\n\n    for (var _iterator3 = feature.geometry[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _ret = _loop();\n\n      if (_ret === \"break\") break;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n        _iterator3[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  var geom = new THREE.BufferGeometry();\n  geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true));\n\n  if (batchIds) {\n    geom.setAttribute('batchId', new THREE.BufferAttribute(batchIds, 1));\n  }\n\n  geom.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));\n  var mesh = new THREE.Mesh(geom, material);\n  mesh.minAltitude = vertices.minAltitude;\n  return mesh;\n}\n\nfunction area(contour, offset, count) {\n  offset *= 3;\n  var n = count * 3;\n  var a = 0.0;\n\n  for (var p = n + offset - 3, q = offset; q < n; p = q, q += 3) {\n    a += contour[p] * contour[q + 1] - contour[q] * contour[p + 1];\n  }\n\n  return a * 0.5;\n}\n\nfunction featureToExtrudedPolygon(feature, options) {\n  var ptsIn = feature.vertices;\n  var offset = feature.geometry[0].indices[0].offset;\n  var count = feature.geometry[0].indices[0].count;\n  var isClockWise = area(ptsIn, offset, count) < 0;\n  var normals = feature.normals;\n  var vertices = new Float32Array(ptsIn.length * 2);\n  var colors = new Uint8Array(ptsIn.length * 2);\n  var indices = [];\n  var totalVertices = ptsIn.length / 3;\n  vertices.minAltitude = Infinity;\n  var batchIds = options.batchId ? new Uint32Array(vertices.length / 3) : undefined;\n  var featureId = 0;\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    var _loop2 = function () {\n      var geometry = _step4.value;\n      var altitude = getProperty('altitude', options, 0, geometry.properties);\n      var extrude = getProperty('extrude', options, 0, geometry.properties);\n      var colorTop = getProperty('color', options, randomColor, geometry.properties);\n      color.copy(colorTop);\n      color.multiplyScalar(0.6);\n      var start = geometry.indices[0].offset;\n      var lastIndice = geometry.indices.slice(-1)[0];\n      var end = lastIndice.offset + lastIndice.count;\n      var count = end - start;\n      coordinatesToVertices(ptsIn, normals, vertices, altitude, 0, start, count);\n      fillColorArray(colors, count, color, start);\n      var startTop = start + totalVertices;\n      var endTop = end + totalVertices;\n      coordinatesToVertices(ptsIn, normals, vertices, altitude, extrude, startTop, count, start);\n      fillColorArray(colors, count, colorTop, startTop);\n      var geomVertices = vertices.slice(startTop * 3, endTop * 3);\n      var holesOffsets = geometry.indices.map(function (i) {\n        return i.offset - start;\n      }).slice(1);\n      var triangles = (0, _earcut[\"default\"])(geomVertices, holesOffsets, 3);\n      var startIndice = indices.length;\n      indices.length += triangles.length;\n\n      for (var i = 0; i < triangles.length; i++) {\n        indices[startIndice + i] = triangles[i] + startTop;\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = geometry.indices[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var indice = _step5.value;\n          addExtrudedPolygonSideFaces(indices, totalVertices, indice.offset, indice.count, isClockWise);\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      if (batchIds) {\n        var id = options.batchId(geometry.properties, featureId);\n        fillBatchIdArray(id, batchIds, start, end);\n        fillBatchIdArray(id, batchIds, startTop, endTop);\n        featureId++;\n      }\n    };\n\n    for (var _iterator4 = feature.geometry[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      _loop2();\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n        _iterator4[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  var geom = new THREE.BufferGeometry();\n  geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true));\n\n  if (batchIds) {\n    geom.setAttribute('batchId', new THREE.BufferAttribute(batchIds, 1));\n  }\n\n  geom.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));\n  var mesh = new THREE.Mesh(geom, material);\n  mesh.minAltitude = vertices.minAltitude;\n  return mesh;\n}\n/**\n * Convert a [Feature]{@link Feature#geometry}'s geometry to a Mesh\n *\n * @param {Object} feature - a Feature's geometry\n * @param {Object} options - options controlling the conversion\n * @param {number|function} options.altitude - define the base altitude of the mesh\n * @param {number|function} options.extrude - if defined, polygons will be extruded by the specified amount\n * @param {object|function} options.color - define per feature color\n * @return {THREE.Mesh} mesh\n */\n\n\nfunction featureToMesh(feature, options) {\n  if (!feature.vertices) {\n    return;\n  }\n\n  var mesh;\n\n  switch (feature.type) {\n    case _Feature.FEATURE_TYPES.POINT:\n      mesh = featureToPoint(feature, options);\n      break;\n\n    case _Feature.FEATURE_TYPES.LINE:\n      mesh = featureToLine(feature, options);\n      break;\n\n    case _Feature.FEATURE_TYPES.POLYGON:\n      if (options.extrude) {\n        mesh = featureToExtrudedPolygon(feature, options);\n      } else {\n        mesh = featureToPolygon(feature, options);\n      }\n\n      break;\n\n    default:\n  } // set mesh material\n\n\n  mesh.material.vertexColors = THREE.VertexColors;\n  mesh.material.color = new THREE.Color(0xffffff);\n  mesh.feature = feature;\n  return mesh;\n}\n\nfunction featuresToThree(features, options) {\n  if (!features || features.length == 0) {\n    return;\n  }\n\n  if (features.length == 1) {\n    coord.crs = features[0].crs;\n    coord.setFromValues(0, 0, 0);\n    return featureToMesh(features[0], options);\n  }\n\n  var group = new THREE.Group();\n  group.minAltitude = Infinity;\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = features[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var feature = _step6.value;\n      coord.crs = feature.crs;\n      coord.setFromValues(0, 0, 0);\n      var mesh = featureToMesh(feature, options);\n      group.add(mesh);\n      group.minAltitude = Math.min(mesh.minAltitude, group.minAltitude);\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n        _iterator6[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n\n  return group;\n}\n/**\n * @module Feature2Mesh\n */\n\n\nvar _default = {\n  /**\n   * Return a function that converts [Features]{@link module:GeoJsonParser} to Meshes. Feature collection will be converted to a\n   * a THREE.Group.\n   *\n   * @param {Object} options - options controlling the conversion\n   * @param {number|function} options.altitude - define the base altitude of the mesh\n   * @param {number|function} options.extrude - if defined, polygons will be extruded by the specified amount\n   * @param {object|function} options.color - define per feature color\n   * @param {function} [options.batchId] - optional function to create batchId attribute. It is passed the feature property and the feature index. As the batchId is using an unsigned int structure on 32 bits, the batchId could be between 0 and 4,294,967,295.\n   * @return {function}\n   * @example <caption>Example usage of batchId with featureId.</caption>\n   * view.addLayer({\n   *     id: 'WFS Buildings',\n   *     type: 'geometry',\n   *     update: itowns.FeatureProcessing.update,\n   *     convert: itowns.Feature2Mesh.convert({\n   *         color: colorBuildings,\n   *         batchId: (property, featureId) => featureId,\n   *         altitude: altitudeBuildings,\n   *         extrude: extrudeBuildings }),\n   *     onMeshCreated: function scaleZ(mesh) {\n   *         mesh.scale.z = 0.01;\n   *         meshes.push(mesh);\n   *     },\n   *     filter: acceptFeature,\n   *     source,\n   * });\n   *\n   * @example <caption>Example usage of batchId with property.</caption>\n   * view.addLayer({\n   *     id: 'WFS Buildings',\n   *     type: 'geometry',\n   *     update: itowns.FeatureProcessing.update,\n   *     convert: itowns.Feature2Mesh.convert({\n   *         color: colorBuildings,\n   *         batchId: (property, featureId) => property.house ? 10 : featureId,\n   *         altitude: altitudeBuildings,\n   *         extrude: extrudeBuildings }),\n   *     onMeshCreated: function scaleZ(mesh) {\n   *         mesh.scale.z = 0.01;\n   *         meshes.push(mesh);\n   *     },\n   *     filter: acceptFeature,\n   *     source,\n   * });\n   */\n  convert: function convert() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return function (collection) {\n      if (!collection) {\n        return;\n      }\n\n      return featuresToThree(collection.features, options);\n    };\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Converter/Feature2Mesh.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Converter/Feature2Texture.js":
/*!**************************************************************!*\
  !*** ./node_modules/itowns/lib/Converter/Feature2Texture.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Feature = __webpack_require__(/*! ../Core/Feature */ \"./node_modules/itowns/lib/Core/Feature.js\");\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _extent = new _Extent[\"default\"]('EPSG:4326', [0, 0, 0, 0]);\n\nvar svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\nvar matrix = svg.createSVGMatrix();\n\nfunction drawPolygon(ctx, vertices) {\n  var indices = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [{\n    offset: 0,\n    count: 1\n  }];\n  var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var size = arguments.length > 4 ? arguments[4] : undefined;\n  var extent = arguments.length > 5 ? arguments[5] : undefined;\n  var invCtxScale = arguments.length > 6 ? arguments[6] : undefined;\n  var canBeFilled = arguments.length > 7 ? arguments[7] : undefined;\n\n  if (vertices.length === 0) {\n    return;\n  }\n\n  if (style.length) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = style[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var s = _step.value;\n\n        _drawPolygon(ctx, vertices, indices, s, size, extent, invCtxScale, canBeFilled);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } else {\n    _drawPolygon(ctx, vertices, indices, style, size, extent, invCtxScale, canBeFilled);\n  }\n}\n\nfunction _drawPolygon(ctx, vertices, indices, style, size, extent, invCtxScale, canBeFilled) {\n  // build contour\n  ctx.beginPath();\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = indices[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var indice = _step2.value;\n\n      if (indice.extent && indice.extent.intersectsExtent(extent)) {\n        var offset = indice.offset * size;\n        var count = offset + indice.count * size;\n        ctx.moveTo(vertices[offset], vertices[offset + 1]);\n\n        for (var j = offset + size; j < count; j += size) {\n          ctx.lineTo(vertices[j], vertices[j + 1]);\n        }\n      }\n    } // draw line or edge of polygon\n\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  if (style.stroke.color) {\n    strokeStyle(style, ctx, invCtxScale);\n    ctx.stroke();\n  } // fill polygon only\n\n\n  if (canBeFilled && (style.fill.color || style.fill.pattern)) {\n    fillStyle(style, ctx, invCtxScale);\n    ctx.fill();\n  }\n}\n\nfunction fillStyle(style, ctx, invCtxScale) {\n  if (style.fill.pattern && ctx.fillStyle.src !== style.fill.pattern.src) {\n    ctx.fillStyle = ctx.createPattern(style.fill.pattern, 'repeat');\n\n    if (ctx.fillStyle.setTransform) {\n      ctx.fillStyle.setTransform(matrix.scale(invCtxScale));\n    } else {\n      console.warn('Raster pattern isn\\'t completely supported on Ie and edge');\n    }\n  } else if (style.fill.color && ctx.fillStyle !== style.fill.color) {\n    ctx.fillStyle = style.fill.color;\n  }\n\n  if (style.fill.opacity !== ctx.globalAlpha) {\n    ctx.globalAlpha = style.fill.opacity;\n  }\n}\n\nfunction strokeStyle(style, ctx, invCtxScale) {\n  if (ctx.strokeStyle !== style.stroke.color) {\n    ctx.strokeStyle = style.stroke.color;\n  }\n\n  var width = (style.stroke.width || 2.0) * invCtxScale;\n\n  if (ctx.lineWidth !== width) {\n    ctx.lineWidth = width;\n  }\n\n  var alpha = style.stroke.opacity == undefined ? 1.0 : style.stroke.opacity;\n\n  if (alpha !== ctx.globalAlpha && typeof alpha == 'number') {\n    ctx.globalAlpha = alpha;\n  }\n\n  if (ctx.lineCap !== style.stroke.lineCap) {\n    ctx.lineCap = style.stroke.lineCap;\n  }\n\n  ctx.setLineDash(style.stroke.dasharray.map(function (a) {\n    return a * invCtxScale * 2;\n  }));\n}\n\nfunction drawPoint(ctx, x, y) {\n  var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var invCtxScale = arguments.length > 4 ? arguments[4] : undefined;\n  ctx.beginPath();\n  var opacity = style.point.opacity == undefined ? 1.0 : style.point.opacity;\n\n  if (opacity !== ctx.globalAlpha) {\n    ctx.globalAlpha = opacity;\n  }\n\n  ctx.arc(x, y, (style.point.radius || 3.0) * invCtxScale, 0, 2 * Math.PI, false);\n\n  if (style.point.color) {\n    ctx.fillStyle = style.point.color;\n    ctx.fill();\n  }\n\n  if (style.point.line) {\n    ctx.lineWidth = (style.point.width || 1.0) * invCtxScale;\n    ctx.strokeStyle = style.point.line;\n    ctx.stroke();\n  }\n}\n\nvar coord = new _Coordinates[\"default\"]('EPSG:4326', 0, 0, 0);\n\nfunction drawFeature(ctx, feature, extent, style, invCtxScale) {\n  var extentDim = extent.dimensions();\n  var scaleRadius = extentDim.x / ctx.canvas.width;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = feature.geometry[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var geometry = _step3.value;\n\n      if (geometry.extent.intersectsExtent(extent)) {\n        var geoStyle = style.isStyle ? style : geometry.properties.style;\n\n        if (feature.type === _Feature.FEATURE_TYPES.POINT) {\n          // cross multiplication to know in the extent system the real size of\n          // the point\n          var px = (Math.round(geoStyle.point.radius * invCtxScale) || 3 * invCtxScale) * scaleRadius;\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = geometry.indices[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var indice = _step4.value;\n              var offset = indice.offset * feature.size;\n              var count = offset + indice.count * feature.size;\n\n              for (var j = offset; j < count; j += feature.size) {\n                coord.setFromArray(feature.vertices, j);\n\n                if (extent.isPointInside(coord, px)) {\n                  drawPoint(ctx, feature.vertices[j], feature.vertices[j + 1], geoStyle, invCtxScale);\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n                _iterator4[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        } else {\n          drawPolygon(ctx, feature.vertices, geometry.indices, geoStyle, feature.size, extent, invCtxScale, feature.type == _Feature.FEATURE_TYPES.POLYGON);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n        _iterator3[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\n\nvar origin = new THREE.Vector2();\nvar dimension = new THREE.Vector2();\nvar scale = new THREE.Vector2();\nvar extentTransformed = new _Extent[\"default\"]('EPSG:4326', 0, 0, 0, 0);\nvar _default = {\n  // backgroundColor is a THREE.Color to specify a color to fill the texture\n  // with, given there is no feature passed in parameter\n  createTextureFromFeature: function createTextureFromFeature(collection, extent, sizeTexture, style, backgroundColor) {\n    var texture;\n\n    if (collection) {\n      // A texture is instancied drawn canvas\n      // origin and dimension are used to transform the feature's coordinates to canvas's space\n      extent.dimensions(dimension);\n      var c = document.createElement('canvas');\n      coord.crs = extent.crs;\n      c.width = sizeTexture;\n      c.height = sizeTexture;\n      var ctx = c.getContext('2d');\n\n      if (backgroundColor) {\n        ctx.fillStyle = backgroundColor.getStyle();\n        ctx.fillRect(0, 0, sizeTexture, sizeTexture);\n      }\n\n      ctx.globalCompositeOperation = style.globalCompositeOperation || 'source-over';\n      ctx.imageSmoothingEnabled = false;\n      ctx.lineJoin = 'round';\n      var ex = collection.crs == extent.crs ? extent : extent.as(collection.crs, _extent);\n      var t = collection.translation;\n      var s = collection.scale;\n      extentTransformed.transformedCopy(t, s, ex);\n      scale.set(ctx.canvas.width, ctx.canvas.width).divide(dimension);\n      origin.set(extent.west, extent.south).add(t).multiply(scale).negate();\n      ctx.setTransform(scale.x / s.x, 0, 0, scale.y / s.y, origin.x, origin.y); // to scale line width and radius circle\n\n      var invCtxScale = s.x / scale.x; // Draw the canvas\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = collection.features[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var feature = _step5.value;\n          drawFeature(ctx, feature, extentTransformed, feature.style || style, invCtxScale);\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      texture = new THREE.CanvasTexture(c);\n      texture.flipY = false;\n    } else if (backgroundColor) {\n      var data = new Uint8Array(3);\n      data[0] = backgroundColor.r * 255;\n      data[1] = backgroundColor.g * 255;\n      data[2] = backgroundColor.b * 255;\n      texture = new THREE.DataTexture(data, 1, 1, THREE.RGBFormat);\n    } else {\n      texture = new THREE.Texture();\n    }\n\n    return texture;\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Converter/Feature2Texture.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Converter/convertToTile.js":
/*!************************************************************!*\
  !*** ./node_modules/itowns/lib/Converter/convertToTile.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _TileMesh = _interopRequireDefault(__webpack_require__(/*! ../Core/TileMesh */ \"./node_modules/itowns/lib/Core/TileMesh.js\"));\n\nvar _LayeredMaterial = _interopRequireDefault(__webpack_require__(/*! ../Renderer/LayeredMaterial */ \"./node_modules/itowns/lib/Renderer/LayeredMaterial.js\"));\n\nvar _TileBuilder = _interopRequireDefault(__webpack_require__(/*! ../Core/Prefab/TileBuilder */ \"./node_modules/itowns/lib/Core/Prefab/TileBuilder.js\"));\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\nvar dimensions = new THREE.Vector2();\n\nfunction setTileFromTiledLayer(tile, tileLayer) {\n  tile.material.transparent = tileLayer.opacity < 1.0;\n  tile.material.opacity = tileLayer.opacity;\n\n  if (tileLayer.diffuse) {\n    tile.material.diffuse = tileLayer.diffuse;\n  }\n\n  if (tileLayer.isGlobeLayer) {\n    // Computes a point used for horizon culling.\n    // If the point is below the horizon,\n    // the tile is guaranteed to be below the horizon as well.\n    tile.horizonCullingPoint = tile.extent.center().as('EPSG:4978').toVector3();\n    tile.extent.dimensions(dimensions).multiplyScalar(THREE.Math.DEG2RAD); // alpha is maximum angle between two points of tile\n\n    var alpha = dimensions.length();\n    var h = Math.abs(1.0 / Math.cos(alpha * 0.5));\n    tile.horizonCullingPoint.setLength(h * tile.horizonCullingPoint.length());\n    tile.horizonCullingPointElevationScaled = tile.horizonCullingPoint.clone();\n  }\n}\n\nvar _default = {\n  convert: function convert(requester, extent, layer) {\n    var builder = layer.builder;\n    var parent = requester;\n    var level = parent !== undefined ? parent.level + 1 : 0;\n    var paramsGeometry = {\n      extent: extent,\n      level: level,\n      segment: layer.options.segments || 16,\n      disableSkirt: layer.disableSkirt\n    };\n    return (0, _TileBuilder[\"default\"])(builder, paramsGeometry).then(function (result) {\n      // build tile mesh\n      result.geometry._count++;\n      var crsCount = layer.tileMatrixSets.length;\n      var material = new _LayeredMaterial[\"default\"](layer.materialOptions, crsCount);\n      var tile = new _TileMesh[\"default\"](result.geometry, material, layer, extent, level); // Commented because layer.threejsLayer is undefined;\n      // Fix me: conflict with object3d added in view.scene;\n      // tile.layers.set(layer.threejsLayer);\n\n      if (parent && parent.isTileMesh) {\n        // get parent extent transformation\n        var pTrans = builder.computeSharableExtent(parent.extent); // place relative to his parent\n\n        result.position.sub(pTrans.position).applyQuaternion(pTrans.quaternion.inverse());\n        result.quaternion.premultiply(pTrans.quaternion);\n      }\n\n      tile.position.copy(result.position);\n      tile.quaternion.copy(result.quaternion);\n      tile.visible = false;\n      tile.updateMatrix();\n      tile.add(tile.obb);\n      setTileFromTiledLayer(tile, layer);\n\n      if (parent) {\n        tile.setBBoxZ(parent.obb.z.min, parent.obb.z.max);\n      }\n\n      return tile;\n    });\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Converter/convertToTile.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Converter/textureConverter.js":
/*!***************************************************************!*\
  !*** ./node_modules/itowns/lib/Converter/textureConverter.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Feature2Texture = _interopRequireDefault(__webpack_require__(/*! ./Feature2Texture */ \"./node_modules/itowns/lib/Converter/Feature2Texture.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\nvar extentTexture = new _Extent[\"default\"]('EPSG:4326', [0, 0, 0, 0]);\n\nvar textureLayer = function (texture) {\n  texture.generateMipmaps = false;\n  texture.magFilter = THREE.LinearFilter;\n  texture.minFilter = THREE.LinearFilter;\n  return texture;\n};\n\nfunction textureColorLayer(texture, transparent) {\n  texture.anisotropy = 16;\n  texture.premultiplyAlpha = transparent;\n  return textureLayer(texture);\n}\n\nvar _default = {\n  convert: function convert(data, extentDestination, layer) {\n    var texture;\n\n    if (data.isFeatureCollection) {\n      var backgroundLayer = layer.source.backgroundLayer;\n      var backgroundColor = backgroundLayer && backgroundLayer.paint ? new THREE.Color(backgroundLayer.paint['background-color']) : undefined;\n      extentDestination.as(_Crs[\"default\"].formatToEPSG(layer.projection), extentTexture);\n      texture = _Feature2Texture[\"default\"].createTextureFromFeature(data, extentTexture, 256, layer.style, backgroundColor);\n      texture.parsedData = data;\n      texture.extent = extentDestination;\n    } else if (data.isTexture) {\n      texture = data;\n    } else {\n      throw new Error('Data type is not supported to convert into texture');\n    }\n\n    if (layer.isColorLayer) {\n      return textureColorLayer(texture, layer.transparent);\n    } else if (layer.isElevationLayer) {\n      if (texture.flipY) {\n        // DataTexture default to false, so make sure other Texture types\n        // do the same (eg image texture)\n        // See UV construction for more details\n        texture.flipY = false;\n      }\n\n      return textureLayer(texture);\n    }\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Converter/textureConverter.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/AnimationPlayer.js":
/*!*********************************************************!*\
  !*** ./node_modules/itowns/lib/Core/AnimationPlayer.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar FRAMERATE = 60;\nvar FRAME_DURATION = 1000 / FRAMERATE; // player statut\n\nvar PLAYER_STATE = {\n  // player is stopped\n  STOP: 0,\n  // player plays animation\n  PLAY: 1,\n  // player is at the end of an animation\n  END: 2,\n  // player is paused\n  PAUSE: 3\n}; // Private functions\n// stop timer and re-init parameter\n\nvar resetTimer = function (player) {\n  if (player.id) {\n    clearInterval(player.id);\n    player.id = undefined;\n  }\n\n  if (player.waitTimer) {\n    clearInterval(player.waitTimer);\n    player.waitTimer = undefined;\n  }\n\n  player.keyframe = 0;\n}; // finish animation and re-init parameter\n\n\nvar finishAnimation = function (player) {\n  resetTimer(player);\n\n  if (player.isEnded()) {\n    player.dispatchEvent({\n      type: 'animation-ended'\n    });\n  }\n\n  player.dispatchEvent({\n    type: 'animation-stopped'\n  });\n  player.duration = 0;\n};\n/**\n * It can play, pause or stop Animation or AnimationExpression (See below).\n * AnimationPlayer is needed to use Animation or AnimationExpression\n * AnimationPlayer emits events :\n *       - for each animation's frame;\n *       - when Animation is stopped\n *       - when Animation is ending\n */\n\n\nvar AnimationPlayer =\n/*#__PURE__*/\nfunction (_THREE$EventDispatche) {\n  (0, _inherits2[\"default\"])(AnimationPlayer, _THREE$EventDispatche);\n\n  function AnimationPlayer() {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, AnimationPlayer);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(AnimationPlayer).call(this));\n    _this.id = null;\n    _this.keyframe = 0;\n    _this.duration = 0;\n    _this.state = PLAYER_STATE.STOP;\n    _this.waitTimer = null;\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(AnimationPlayer, [{\n    key: \"isPlaying\",\n    value: function isPlaying() {\n      return this.state === PLAYER_STATE.PLAY;\n    }\n  }, {\n    key: \"isStopped\",\n    value: function isStopped() {\n      return this.state === PLAYER_STATE.STOP;\n    }\n  }, {\n    key: \"isEnded\",\n    value: function isEnded() {\n      return this.state === PLAYER_STATE.END;\n    } // Public functions\n\n    /**\n     * Play one animation.\n     * If another animation is playing, it's stopped and the new animation is played.\n     *\n     * @param {number} duration - The duration to play\n     */\n\n  }, {\n    key: \"play\",\n    value: function play(duration) {\n      this.duration = duration;\n      this.dispatchEvent({\n        type: 'animation-started'\n      });\n      this.state = PLAYER_STATE.PLAY;\n      resetTimer(this);\n      this.id = setInterval(this.frame.bind(this), FRAME_DURATION);\n    }\n    /**\n     * Play an animation after a number of frames.\n     *\n     * @param      {number}  duration    The duration to play\n     * @param      {number}  waitingFrame    The waiting time before start animation (time in frame)\n     */\n\n  }, {\n    key: \"playLater\",\n    value: function playLater(duration, waitingFrame) {\n      var timew = Math.floor(FRAME_DURATION * waitingFrame);\n      window.clearInterval(this.waitTimer);\n      var self = this;\n      this.waitTimer = window.setTimeout(function () {\n        self.play(duration);\n      }, timew);\n    }\n    /**\n     * Stop the current animation.\n     *\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.state = PLAYER_STATE.STOP;\n      finishAnimation(this);\n    }\n    /**\n     * Executed for each frame.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"frame\",\n    value: function frame() {\n      if (this.keyframe < this.duration) {\n        this.keyframe++;\n        this.dispatchEvent({\n          type: 'animation-frame'\n        });\n      } else {\n        this.state = PLAYER_STATE.END;\n        finishAnimation(this);\n      }\n    }\n  }]);\n  return AnimationPlayer;\n}(THREE.EventDispatcher);\n\nvar _default = AnimationPlayer;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/AnimationPlayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Feature.js":
/*!*************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Feature.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FeatureCollection = exports[\"default\"] = exports.FEATURE_TYPES = exports.FeatureGeometry = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ./Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nfunction defaultExtent(crs) {\n  return new _Extent[\"default\"](crs, Infinity, -Infinity, Infinity, -Infinity);\n}\n\nfunction _extendBuffer(feature, size) {\n  feature.vertices.length += size * feature.size;\n\n  if (feature.normals) {\n    feature.normals.length = feature.vertices.length;\n  }\n}\n\nvar defaultNormal = new THREE.Vector3(0, 0, 1);\n/**\n * @property {Extent} extent - The 2D extent containing all the points\n * composing the geometry.\n * @property {Object[]} indices - Contains the indices that define the geometry.\n * Objects stored in this array have two properties, an `offset` and a `count`.\n * The offset is related to the overall number of vertices in the Feature.\n *\n * @property {Object} properties - Properties of the geometry. It can be\n * anything specified in the GeoJSON under the `properties` property.\n */\n\nvar FeatureGeometry =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Feature} feature geometry\n   */\n  function FeatureGeometry(feature) {\n    (0, _classCallCheck2[\"default\"])(this, FeatureGeometry);\n    this.extent = feature.extent ? defaultExtent(feature.crs) : undefined;\n    this.indices = [];\n    this._feature = feature;\n    this.properties = {};\n    this._currentExtent = feature.extent ? defaultExtent(feature.crs) : undefined;\n  }\n  /**\n   * Add a new marker to indicate the starting of sub geometry and extends the vertices buffer.\n   * Then you have to push new the coordinates of sub geometry.\n   * The sub geometry stored in indices, see constructor for more information.\n   * @param {number} count count of vertices\n   */\n\n\n  (0, _createClass2[\"default\"])(FeatureGeometry, [{\n    key: \"startSubGeometry\",\n    value: function startSubGeometry(count) {\n      var last = this.indices.length - 1;\n      var extent = this.extent ? defaultExtent(this._feature.crs) : undefined;\n      var offset = last > -1 ? this.indices[last].offset + this.indices[last].count : this._feature.vertices.length / this.size;\n      this.indices.push({\n        offset: offset,\n        count: count,\n        extent: extent\n      });\n      this._currentExtent = extent;\n\n      _extendBuffer(this._feature, count);\n    }\n    /**\n     * After you have pushed new the coordinates of sub geometry without\n     * `startSubGeometry`, this function close sub geometry. The sub geometry\n     * stored in indices, see constructor for more information.\n     * @param {number} count count of vertices\n     */\n\n  }, {\n    key: \"closeSubGeometry\",\n    value: function closeSubGeometry(count) {\n      var last = this.indices.length - 1;\n      var offset = last > -1 ? this.indices[last].offset + this.indices[last].count : this._feature.vertices.length / this.size - count;\n      this.indices.push({\n        offset: offset,\n        count: count,\n        extent: this._currentExtent\n      });\n\n      if (this.extent) {\n        this.extent.union(this._currentExtent);\n        this._currentExtent = defaultExtent(this._feature.crs);\n      }\n    }\n  }, {\n    key: \"getLastSubGeometry\",\n    value: function getLastSubGeometry() {\n      var last = this.indices.length - 1;\n      return this.indices[last];\n    }\n    /**\n     * Push new coordinates in vertices buffer.\n     * @param {Coordinates} coord The coordinates to push.\n     */\n\n  }, {\n    key: \"pushCoordinates\",\n    value: function pushCoordinates(coord) {\n      if (coord.crs !== this._feature.crs) {\n        coord.as(this._feature.crs, coord);\n      }\n\n      if (this._feature.normals) {\n        coord.geodesicNormal.toArray(this._feature.normals, this._feature._pos);\n      }\n\n      this._feature._pushValues(this._feature, coord.x, coord.y, coord.z); // expand extent if present\n\n\n      if (this._currentExtent) {\n        this._currentExtent.expandByCoordinates(coord);\n      }\n    }\n    /**\n    * Push new values coordinates in vertices buffer.\n    * No geographical conversion is made or the normal doesn't stored.\n    *\n    * @param {number} long The longitude coordinate.\n    * @param {number} lat The latitude coordinate.\n    * @param {number} [alt=0] The altitude coordinate.\n    * @param {THREE.Vector3} [normal=THREE.Vector3(0,0,1)] the normal on coordinates.\n    */\n\n  }, {\n    key: \"pushCoordinatesValues\",\n    value: function pushCoordinatesValues(_long, lat) {\n      var alt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var normal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultNormal;\n\n      if (this._feature.normals) {\n        normal.toArray(this._feature.normals, this._feature._pos);\n      }\n\n      this._feature._pushValues(this._feature, _long, lat, alt); // expand extent if present\n\n\n      if (this._currentExtent) {\n        this._currentExtent.expandByValuesCoordinates(_long, lat, alt);\n      }\n    }\n    /**\n     * @returns {number} the number of values of the array that should be associated with a coordinates.\n     * The size is 3 with altitude and 2 without altitude.\n     */\n\n  }, {\n    key: \"updateExtent\",\n\n    /**\n     * update geometry extent with the last sub geometry extent.\n     */\n    value: function updateExtent() {\n      if (this.extent) {\n        var last = this.indices[this.indices.length - 1];\n\n        if (last) {\n          this.extent.union(last.extent);\n        }\n      }\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._feature.size;\n    }\n  }]);\n  return FeatureGeometry;\n}();\n\nexports.FeatureGeometry = FeatureGeometry;\n\nfunction push2DValues(feature, value0, value1) {\n  feature.vertices[feature._pos++] = value0;\n  feature.vertices[feature._pos++] = value1;\n}\n\nfunction push3DValues(feature, value0, value1) {\n  var value2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  feature.vertices[feature._pos++] = value0;\n  feature.vertices[feature._pos++] = value1;\n  feature.vertices[feature._pos++] = value2;\n}\n\nvar FEATURE_TYPES = {\n  POINT: 0,\n  LINE: 1,\n  POLYGON: 2\n};\n/**\n *\n * This class improves and simplifies the construction and conversion of geographic data structures.\n * It's an intermediary structure between geomatic formats and THREE objects.\n *\n * @property {string} type - Geometry type, can be `point`, `line`, or\n * `polygon`.\n * @property {number[]} vertices - All the vertices of the Feature.\n * @property {number[]} normals - All the normals of the Feature.\n * @property {number} size - the number of values of the array that should be associated with a coordinates.\n * The size is 3 with altitude and 2 without altitude.\n * @property {string} crs - Geographic or Geocentric coordinates system.\n * @property {Array.<FeatureGeometry>} geometry - The feature's geometry.\n * @property {Extent?} extent - The extent containing all the geometries\n * composing the feature.\n */\n\nexports.FEATURE_TYPES = FEATURE_TYPES;\n\nvar Feature =\n/*#__PURE__*/\nfunction () {\n  /**\n   *\n   * @param {string} type type of Feature. It can be 'point', 'line' or 'polygon'.\n   * @param {string} crs Geographic or Geocentric coordinates system.\n   * @param {Object} [options={}] options to build feature.\n   * @param {boolean} [options.buildExtent] Build extent and update when adding new vertice.\n   * @param {boolean} [options.withAltitude] Set vertice altitude when adding new vertice.\n   * @param {boolean} [options.withNormal] Set vertice normal when adding new vertice.\n   */\n  function Feature(type, crs) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2[\"default\"])(this, Feature);\n\n    if (Object.keys(FEATURE_TYPES).find(function (t) {\n      return FEATURE_TYPES[t] === type;\n    })) {\n      this.type = type;\n    } else {\n      throw new Error(\"Unsupported Feature type: \".concat(type));\n    }\n\n    this.geometry = [];\n    this.vertices = [];\n    this.normals = options.withNormal ? [] : undefined;\n    this.crs = crs;\n    this.size = options.withAltitude ? 3 : 2;\n    this.extent = options.buildExtent ? defaultExtent(crs) : undefined;\n    this._pos = 0;\n    this._pushValues = this.size === 3 ? push3DValues : push2DValues;\n  }\n  /**\n   * Instance a new {@link FeatureGeometry}  and push in {@link Feature}.\n   * @returns {FeatureGeometry} the instancied geometry.\n   */\n\n\n  (0, _createClass2[\"default\"])(Feature, [{\n    key: \"bindNewGeometry\",\n    value: function bindNewGeometry() {\n      var geometry = new FeatureGeometry(this);\n      this.geometry.push(geometry);\n      return geometry;\n    }\n    /**\n     * Update {@link Extent} feature with {@link Extent} geometry\n     * @param {FeatureGeometry} geometry used to update Feature {@link Extent}\n     */\n\n  }, {\n    key: \"updateExtent\",\n    value: function updateExtent(geometry) {\n      if (this.extent) {\n        this.extent.union(geometry.extent);\n      }\n    }\n    /**\n     * @returns {number} the count of geometry.\n     */\n\n  }, {\n    key: \"geometryCount\",\n    get: function get() {\n      return this.geometry.length;\n    }\n  }]);\n  return Feature;\n}();\n\nvar _default = Feature;\n/**\n * @property {Feature[]} features - The array of features composing the\n * collection.\n * @property {Extent?} extent - The 2D extent containing all the features\n * composing the collection.\n * @property {string} crs - Geographic or Geocentric coordinates system.\n * @property {boolean} isFeatureCollection - Used to check whether this is FeatureCollection.\n * @property {THREE.Vector3} translation - Apply translation on vertices and extent to transform on coordinates system.\n * @property {THREE.Vector3} scale - Apply scale on vertices and extent to transform on coordinates system.\n *\n * An object regrouping a list of [features]{@link Feature} and the extent of this collection.\n */\n\nexports[\"default\"] = _default;\n\nvar FeatureCollection =\n/*#__PURE__*/\nfunction () {\n  function FeatureCollection(crs, options) {\n    (0, _classCallCheck2[\"default\"])(this, FeatureCollection);\n    this.isFeatureCollection = true;\n    this.crs = crs;\n    this.features = [];\n    this.optionsFeature = options || {};\n    this.extent = this.optionsFeature.buildExtent ? defaultExtent(crs) : undefined;\n    this.translation = new THREE.Vector3();\n    this.scale = new THREE.Vector3(1, 1, 1);\n  }\n  /**\n   * Update FeatureCollection extent with `extent` or all features extent if\n   * `extent` is `undefined`.\n   * @param {Extent} extent\n   */\n\n\n  (0, _createClass2[\"default\"])(FeatureCollection, [{\n    key: \"updateExtent\",\n    value: function updateExtent(extent) {\n      if (this.extent) {\n        var extents = extent ? [extent] : this.features.map(function (feature) {\n          return feature.extent;\n        });\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = extents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var ext = _step.value;\n            this.extent.union(ext);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Remove features that don't have [FeatureGeometry]{@link FeatureGeometry}.\n     */\n\n  }, {\n    key: \"removeEmptyFeature\",\n    value: function removeEmptyFeature() {\n      this.features = this.features.filter(function (feature) {\n        return feature.geometry.length;\n      });\n    }\n    /**\n     * Push the `feature` in FeatureCollection.\n     * @param {Feature} feature\n     */\n\n  }, {\n    key: \"pushFeature\",\n    value: function pushFeature(feature) {\n      this.features.push(feature);\n      this.updateExtent(feature.extent);\n    }\n  }, {\n    key: \"requestFeature\",\n    value: function requestFeature(type, callback) {\n      var feature = this.features.find(callback);\n\n      if (feature && this.optionsFeature.mergeFeatures) {\n        return feature;\n      } else {\n        var newFeature = new Feature(type, this.crs, this.optionsFeature);\n        this.features.push(newFeature);\n        return newFeature;\n      }\n    }\n    /**\n     * Returns the Feature by type if `mergeFeatures` is `true` or returns the\n     * new instance of typed Feature.\n     *\n     * @param {string} type the type requested\n     * @returns {Feature}\n     */\n\n  }, {\n    key: \"requestFeatureByType\",\n    value: function requestFeatureByType(type) {\n      return this.requestFeature(type, function (feature) {\n        return feature.type === type;\n      });\n    }\n    /**\n     * Returns the Feature by type if `mergeFeatures` is `true` or returns the\n     * new instance of typed Feature.\n     *\n     * @param {string} id the id requested\n     * @param {string} type the type requested\n     * @returns {Feature}\n     */\n\n  }, {\n    key: \"requestFeatureById\",\n    value: function requestFeatureById(id, type) {\n      return this.requestFeature(type, function (feature) {\n        return feature.id === id;\n      });\n    }\n    /**\n     * Add a new feature with references to all properties.\n     * It allows to have features with different styles\n     * without having to duplicate the geometry.\n     * @param      {Feature}   feature  The feature to reference.\n     * @return     {Feature}  The new referenced feature\n     */\n\n  }, {\n    key: \"newFeatureByReference\",\n    value: function newFeatureByReference(feature) {\n      var ref = new Feature(feature.type, this.crs, this.optionsFeature);\n      ref.extent = feature.extent;\n      ref.geometry = feature.geometry;\n      ref.normals = feature.normals;\n      ref.size = feature.size;\n      ref.vertices = feature.vertices;\n      ref._pos = feature._pos;\n      this.features.push(ref);\n      return ref;\n    }\n  }]);\n  return FeatureCollection;\n}();\n\nexports.FeatureCollection = FeatureCollection;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Feature.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Geographic/CoordStars.js":
/*!***************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Geographic/CoordStars.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ./Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\n/**\n * Generated On: 2016-02-25\n * Class: CoordStars\n * Description: get coord of stars like earth...\n */\nvar CoordStars = {\n  getSunPosition: function getSunPosition() {\n    var m = Math;\n    var PI = m.PI;\n    var sin = m.sin;\n    var cos = m.cos;\n    var tan = m.tan;\n    var asin = m.asin;\n    var atan = m.atan2;\n    var rad = PI / 180;\n    var e = rad * 23.4397; // obliquity of the Earth\n\n    function toJulian(date) {\n      return date.valueOf() / (1000 * 60 * 60 * 24) - 0.5 + 2440588;\n    }\n\n    function toDays(date) {\n      return toJulian(date) - 2451545;\n    }\n\n    function getRightAscension(l, b) {\n      return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l));\n    }\n\n    function getDeclination(l, b) {\n      return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l));\n    }\n\n    function getAzimuth(H, phi, dec) {\n      return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));\n    }\n\n    function getAltitude(H, phi, dec) {\n      return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));\n    }\n\n    function getSiderealTime(d, lw) {\n      return rad * (280.16 + 360.9856235 * d) - lw;\n    }\n\n    function getSolarMeanAnomaly(d) {\n      return rad * (357.5291 + 0.98560028 * d);\n    }\n\n    function getEquationOfCenter(M) {\n      return rad * (1.9148 * sin(M) + 0.0200 * sin(2 * M) + 0.0003 * sin(3 * M));\n    }\n\n    function getEclipticLongitude(M, C) {\n      // perihelion of the Earth\n      return M + C + rad * 102.9372 + PI;\n    }\n\n    return function (date, lat, lon) {\n      var phi = rad * lat;\n      var d = toDays(date);\n      var M = getSolarMeanAnomaly(d);\n      var C = getEquationOfCenter(M);\n      var L = getEclipticLongitude(M, C);\n      var D = getDeclination(L, 0);\n      var A = getRightAscension(L, 0);\n      var t = getSiderealTime(d, rad * -lon);\n      var H = t - A;\n      return {\n        EclipticLongitude: L,\n        declinaison: D,\n        ascension: A,\n        H: H,\n        SiderealTime: t,\n        altitude: getAltitude(H, phi, D),\n        azimuth: getAzimuth(H, phi, D) + PI / 2 // + PI// - PI/2 // origin: north !!! not like original Mourner code but more classical ref\n\n      };\n    };\n  },\n  // Return scene coordinate ({x,y,z}) of sun\n  getSunPositionInScene: function getSunPositionInScene(date, lat, lon) {\n    var sun = CoordStars.getSunPosition()(date, lat, lon);\n    var dayMilliSec = 24 * 3600000;\n    var longitude = sun.ascension + date % dayMilliSec / dayMilliSec * -360 + 180; // cause midday\n\n    var coSunCarto = new _Coordinates[\"default\"]('EPSG:4326', longitude, lat, 50000000).as('EPSG:4978').toVector3();\n    return coSunCarto;\n  }\n};\nvar _default = CoordStars;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Geographic/CoordStars.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Geographic/Coordinates.js":
/*!****************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Geographic/Coordinates.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _proj = _interopRequireDefault(__webpack_require__(/*! proj4 */ \"./node_modules/proj4/lib/index.js\"));\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ./Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\nvar _Ellipsoid = _interopRequireDefault(__webpack_require__(/*! ../Math/Ellipsoid */ \"./node_modules/itowns/lib/Core/Math/Ellipsoid.js\"));\n\n_proj[\"default\"].defs('EPSG:4978', '+proj=geocent +datum=WGS84 +units=m +no_defs');\n\nvar ellipsoid = new _Ellipsoid[\"default\"]();\nvar vectorPivot = new THREE.Vector3();\nvar coordPivot;\nvar projectionCache = {};\n\nfunction proj4cache(crsIn, crsOut) {\n  if (!projectionCache[crsIn]) {\n    projectionCache[crsIn] = {};\n  }\n\n  if (!projectionCache[crsIn][crsOut]) {\n    projectionCache[crsIn][crsOut] = (0, _proj[\"default\"])(crsIn, crsOut);\n  }\n\n  return projectionCache[crsIn][crsOut];\n} // Internal method, takes a coord and put some proj4 values in it\n\n\nfunction setFromProj4(coord, proj4value, z) {\n  return coord.setFromValues(proj4value[0], proj4value[1], z);\n}\n/**\n * A Coordinates object, defined by a [crs]{@link http://inspire.ec.europa.eu/theme/rs}\n * and three values. These values are accessible through `x`, `y` and `z`,\n * although it can also be accessible through `latitude`, `longitude` and\n * `altitude`. To change a value, prefer the `set()` method below.\n *\n * @property {boolean} isCoordinates - Used to checkout whether this coordinates\n * is a Coordinates. Default is true. You should not change this, as it is used\n * internally for optimisation.\n * @property {string} crs - A supported crs by default in\n * [`proj4js`](https://github.com/proj4js/proj4js#named-projections), or an\n * added crs to `proj4js` (using `proj4.defs`). Note that `EPSG:4978` is also\n * supported by default in itowns.\n * @property {number} x - The first value of the coordinate.\n * @property {number} y - The second value of the coordinate.\n * @property {number} z - The third value of the coordinate.\n * @property {number} latitude - The first value of the coordinate.\n * @property {number} longitude - The second value of the coordinate.\n * @property {number} altitude - The third value of the coordinate.\n * @property {THREE.Vector3} geodesicNormal - The geodesic normal of the\n * coordinate.\n *\n * @example\n * new Coordinates('EPSG:4978', 20885167, 849862, 23385912); //Geocentric coordinates\n *\n * @example\n * new Coordinates('EPSG:4326', 2.33, 48.24, 24999549); //Geographic coordinates\n */\n\n\nvar Coordinates =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   *\n   * @param {string} crs - A supported crs (see the `crs` property below).\n   * @param {number|Array<number>|Coordinates|THREE.Vector3} [v0=0] -\n   * x or longitude value, or a more complex one: it can be an array of three\n   * numbers, being x/lon, x/lat, z/alt, or it can be `THREE.Vector3`. It can\n   * also simply be a Coordinates.\n   * @param {number} [v1=0] - y or latitude value.\n   * @param {number} [v2=0] - z or altitude value.\n   */\n  function Coordinates(crs) {\n    var v0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var v1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var v2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    (0, _classCallCheck2[\"default\"])(this, Coordinates);\n    this.isCoordinates = true;\n\n    _Crs[\"default\"].isValid(crs);\n\n    this.crs = crs; // Storing the coordinates as is, not in arrays, as it is\n    // slower (see https://jsbench.me/40jumfag6g/1)\n\n    this.x = 0;\n    this.y = 0;\n    this.z = 0; // Normal\n\n    this._normal = new THREE.Vector3();\n\n    if (v0.length > 0) {\n      this.setFromArray(v0);\n    } else if (v0.isVector3 || v0.isCoordinates) {\n      this.setFromVector3(v0);\n    } else {\n      this.setFromValues(v0, v1, v2);\n    }\n\n    this._normalNeedsUpdate = true;\n  }\n  /**\n   * Set the values of this Coordinates.\n   *\n   * @param {number} [v0=0] - x or longitude value.\n   * @param {number} [v1=0] - y or latitude value.\n   * @param {number} [v2=0] - z or altitude value.\n   *\n   * @return {Coordinates} This Coordinates.\n   */\n\n\n  (0, _createClass2[\"default\"])(Coordinates, [{\n    key: \"setFromValues\",\n    value: function setFromValues() {\n      var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this.x = v0 == undefined ? 0 : v0;\n      this.y = v1 == undefined ? 0 : v1;\n      this.z = v2 == undefined ? 0 : v2;\n      this._normalNeedsUpdate = true;\n      return this;\n    }\n    /**\n     * Set the values of this Coordinates from an array.\n     *\n     * @param {Array<number>} array - An array of number to assign to the\n     * Coordinates.\n     * @param {number} [offset] - Optional offset into the array.\n     *\n     * @return {Coordinates} This Coordinates.\n     */\n\n  }, {\n    key: \"setFromArray\",\n    value: function setFromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.setFromValues(array[offset], array[offset + 1], array[offset + 2]);\n    }\n    /**\n     * Set the values of this Coordinates from a `THREE.Vector3` or an `Object`\n     * having `x/y/z` properties, like a `Coordinates`.\n     *\n     * @param {THREE.Vector3|Coordinates} v0 - The object to read the values\n     * from.\n     *\n     * @return {Coordinates} This Coordinates.\n     */\n\n  }, {\n    key: \"setFromVector3\",\n    value: function setFromVector3(v0) {\n      return this.setFromValues(v0.x, v0.y, v0.z);\n    }\n    /**\n     * Returns a new Coordinates with the same values as this one. It will\n     * instantiate a new Coordinates with the same CRS as this one.\n     *\n     * @return {Coordinates} The target with its new coordinates.\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Coordinates(this.crs, this);\n    }\n    /**\n     * Copies the values of the passed Coordinates to this one. The CRS is\n     * however not copied.\n     *\n     * @param {Coordinates} src - The source to copy from.\n     *\n     * @return {Coordinates} This Coordinates.\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(src) {\n      this.crs = src.crs;\n      return this.setFromVector3(src);\n    }\n  }, {\n    key: \"toVector3\",\n\n    /**\n     * Return this Coordinates values into a `THREE.Vector3`.\n     *\n     * @param {THREE.Vector3} [target] - The target to put the values in. If not\n     * specified, a new vector will be created.\n     *\n     * @return {THREE.Vector3}\n     */\n    value: function toVector3() {\n      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new THREE.Vector3();\n      return target.copy(this);\n    }\n    /**\n     * Returns coordinates in the wanted [CRS]{@link http://inspire.ec.europa.eu/theme/rs}.\n     *\n     * @param {string} crs - The CRS to convert the Coordinates into.\n     * @param {Coordinates} [target] - The target to put the converted\n     * Coordinates into. If not specified a new one will be created.\n     *\n     * @return {Coordinates} - The resulting Coordinates after the conversion.\n     *\n     * @example\n     * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };\n     * const coords = new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic system\n     * const coordinates = coords.as('EPSG:4978'); // Geocentric system\n     *\n     * @example\n     * const position = { x: 20885167, y: 849862, z: 23385912 };\n     * const coords = new Coordinates('EPSG:4978', position.x, position.y, position.z);  // Geocentric system\n     * const coordinates = coords.as('EPSG:4326');  // Geographic system\n     *\n     * @example\n     * new Coordinates('EPSG:4326', longitude: 2.33, latitude: 48.24, altitude: 24999549).as('EPSG:4978'); // Geocentric system\n     *\n     * @example\n     * new Coordinates('EPSG:4978', x: 20885167, y: 849862, z: 23385912).as('EPSG:4326'); // Geographic system\n     */\n\n  }, {\n    key: \"as\",\n    value: function as(crs) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Coordinates(crs);\n\n      if (this.crs == crs) {\n        target.copy(this); // there is a bug for converting anything from and to 4978 with proj4\n        // https://github.com/proj4js/proj4js/issues/195\n        // the workaround is to use an intermediate projection, like EPSG:4326\n      } else if (crs == 'EPSG:4978') {\n        if (_Crs[\"default\"].is4326(this.crs)) {\n          ellipsoid.cartographicToCartesian(this, vectorPivot);\n          target.setFromVector3(vectorPivot);\n        } else {\n          setFromProj4(coordPivot, proj4cache(this.crs, 'EPSG:4326').forward([this.x, this.y]), this.z);\n          coordPivot.as('EPSG:4978', target);\n        }\n      } else if (this.crs == 'EPSG:4978') {\n        if (_Crs[\"default\"].is4326(crs)) {\n          ellipsoid.cartesianToCartographic(this, target);\n        } else {\n          this.as('EPSG:4326', coordPivot);\n          setFromProj4(target, proj4cache('EPSG:4326', crs).forward([coordPivot.x, coordPivot.y]), coordPivot.z);\n        }\n      } else if (_Crs[\"default\"].is4326(this.crs) && crs == 'EPSG:3857') {\n        this.y = THREE.Math.clamp(this.y, -89.999999, 89.999999);\n        setFromProj4(target, proj4cache(this.crs, crs).forward([this.x, this.y]), this.z);\n      } else {\n        setFromProj4(target, proj4cache(this.crs, crs).forward([this.x, this.y]), this.z);\n      }\n\n      target.crs = crs;\n      return target;\n    }\n  }, {\n    key: \"longitude\",\n    get: function get() {\n      return this.x;\n    }\n  }, {\n    key: \"latitude\",\n    get: function get() {\n      return this.y;\n    }\n  }, {\n    key: \"altitude\",\n    get: function get() {\n      return this.z;\n    },\n    set: function set(value) {\n      this.z = value;\n    }\n  }, {\n    key: \"geodesicNormal\",\n    get: function get() {\n      if (this._normalNeedsUpdate) {\n        this._normalNeedsUpdate = false;\n\n        if (_Crs[\"default\"].is4326(this.crs)) {\n          ellipsoid.geodeticSurfaceNormalCartographic(this, this._normal);\n        } else if (this.crs == 'EPSG:4978') {\n          ellipsoid.geodeticSurfaceNormal(this, this._normal);\n        } else {\n          this._normal.set(0, 0, 1);\n        }\n      }\n\n      return this._normal;\n    }\n  }]);\n  return Coordinates;\n}();\n\ncoordPivot = new Coordinates('EPSG:4326');\nvar _default = Coordinates;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Geographic/Coordinates.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Geographic/Crs.js":
/*!********************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Geographic/Crs.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _proj = _interopRequireDefault(__webpack_require__(/*! proj4 */ \"./node_modules/proj4/lib/index.js\"));\n\n_proj[\"default\"].defs('EPSG:4978', '+proj=geocent +datum=WGS84 +units=m +no_defs');\n\nvar TMS = ['WMTS:WGS84', 'WMTS:PM'];\nvar EPSG = ['EPSG:4326', 'EPSG:3857'];\n\nfunction formatToTms(crs) {\n  if (crs) {\n    if (crs.includes('WMTS')) {\n      return crs;\n    }\n\n    var i = EPSG.indexOf(crs);\n\n    if (i > -1) {\n      return TMS[i];\n    } else if (crs.includes('EPSG')) {\n      return \"WMTS:TMS:\".concat(crs.replace('EPSG:', ''));\n    }\n  }\n}\n\nfunction formatToEPSG(crs) {\n  if (crs) {\n    if (crs.includes('EPSG')) {\n      return crs;\n    } else if (EPSG[TMS.indexOf(crs)]) {\n      return EPSG[TMS.indexOf(crs)];\n    } else {\n      return \"EPSG:\".concat(crs.match(/\\d+/)[0]);\n    }\n  }\n}\n\nvar UNIT = {\n  DEGREE: 1,\n  METER: 2\n};\n\nfunction is4326(crs) {\n  return crs.indexOf('EPSG:4326') == 0;\n}\n\nfunction _unitFromProj4Unit(projunit) {\n  if (projunit === 'degrees') {\n    return UNIT.DEGREE;\n  } else if (projunit === 'm') {\n    return UNIT.METER;\n  } else {\n    return undefined;\n  }\n}\n\nfunction toUnit(crs) {\n  switch (crs) {\n    case 'EPSG:4326':\n      return UNIT.DEGREE;\n\n    case 'EPSG:4978':\n      return UNIT.METER;\n\n    default:\n      {\n        var p = _proj[\"default\"].defs(formatToEPSG(crs));\n\n        if (!p) {\n          return undefined;\n        }\n\n        return _unitFromProj4Unit(p.units);\n      }\n  }\n}\n\nfunction toUnitWithError(crs) {\n  var u = toUnit(crs);\n\n  if (crs === undefined || u === undefined) {\n    throw new Error(\"Invalid crs parameter value '\".concat(crs, \"'\"));\n  }\n\n  return u;\n}\n/**\n * This module provides basic methods to manipulate a CRS (as a string).\n *\n * @module CRS\n */\n\n\nvar _default = {\n  /**\n   * Units that can be used for a CRS.\n   *\n   * @enum {number}\n   */\n  UNIT: UNIT,\n\n  /**\n   * Assert that the CRS is valid one.\n   *\n   * @param {string} crs - The CRS to validate.\n   *\n   * @throws {Error} if the CRS is not valid.\n   */\n  isValid: function isValid(crs) {\n    toUnitWithError(crs);\n  },\n\n  /**\n   * Assert that the CRS is geographic.\n   *\n   * @param {string} crs - The CRS to validate.\n   * @return {boolean}\n   * @throws {Error} if the CRS is not valid.\n   */\n  isGeographic: function isGeographic(crs) {\n    return toUnitWithError(crs) == UNIT.DEGREE;\n  },\n\n  /**\n   * Assert that the CRS is using metric units.\n   *\n   * @param {string} crs - The CRS to validate.\n   * @return {boolean}\n   * @throws {Error} if the CRS is not valid.\n   */\n  isMetricUnit: function isMetricUnit(crs) {\n    return toUnit(crs) == UNIT.METER;\n  },\n\n  /**\n   * Get the unit to use with the CRS.\n   *\n   * @param {string} crs - The CRS to get the unit from.\n   * @return {number} Either `UNIT.METER`, `UNIT.DEGREE` or `undefined`.\n   */\n  toUnit: toUnit,\n\n  /**\n   * Is the CRS EPSG:4326 ?\n   *\n   * @param {string} crs - The CRS to test.\n   * @return {boolean}\n   */\n  is4326: is4326,\n\n  /**\n   * Give a reasonnable epsilon to use with this CRS.\n   *\n   * @param {string} crs - The CRS to use.\n   * @return {number} 0.01 if the CRS is EPSG:4326, 0.001 otherwise.\n   */\n  reasonnableEpsilon: function reasonnableEpsilon(crs) {\n    if (is4326(crs)) {\n      return 0.01;\n    } else {\n      return 0.001;\n    }\n  },\n\n  /**\n   * format crs to European Petroleum Survey Group notation : EPSG:XXXX.\n   *\n   * @param      {string}  crs     The crs to format\n   * @return     {string}  formated crs\n   */\n  formatToEPSG: formatToEPSG,\n\n  /**\n   * format crs to tile matrix set notation : WMTS:XXXX.\n   *\n   * @param      {string}  crs     The crs to format\n   * @return     {string}  formated crs\n   */\n  formatToTms: formatToTms\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Geographic/Crs.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Geographic/Extent.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Geographic/Extent.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.schemeTiles = exports.globalExtentTMS = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ./Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ./Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\n/**\n * Extent is a SIG-area (so 2D)\n * It can use explicit coordinates (e.g: lon/lat) or implicit (WMTS coordinates)\n */\nvar _dim = new THREE.Vector2();\n\nvar _dim2 = new THREE.Vector2();\n\nvar _countTiles = new THREE.Vector2();\n\nvar tmsCoord = new THREE.Vector2();\nvar dimensionTile = new THREE.Vector2();\nvar defaultScheme = new THREE.Vector2(2, 2);\nvar r = {\n  row: 0,\n  col: 0,\n  invDiff: 0\n};\n\nfunction _rowColfromParent(extent, zoom) {\n  var diffLevel = extent.zoom - zoom;\n  var diff = Math.pow(2, diffLevel);\n  r.invDiff = 1 / diff;\n  r.row = (extent.row - extent.row % diff) * r.invDiff;\n  r.col = (extent.col - extent.col % diff) * r.invDiff;\n  return r;\n}\n\nvar _extent;\n\nvar _extent2;\n\nvar cardinals = new Array(8);\n\nfor (var i = cardinals.length - 1; i >= 0; i--) {\n  cardinals[i] = new _Coordinates[\"default\"]('EPSG:4326', 0, 0, 0, 0);\n}\n\nvar _c = new _Coordinates[\"default\"]('EPSG:4326', 0, 0);\n\nvar globalExtentTMS = new Map();\nexports.globalExtentTMS = globalExtentTMS;\nvar schemeTiles = new Map();\nexports.schemeTiles = schemeTiles;\n\nfunction getInfoTms(crs) {\n  var epsg = _Crs[\"default\"].formatToEPSG(crs);\n\n  var globalExtent = globalExtentTMS.get(epsg);\n  var globalDimension = globalExtent.dimensions(_dim2);\n\n  var tms = _Crs[\"default\"].formatToTms(crs);\n\n  var sTs = schemeTiles.get(tms) || schemeTiles.get('default'); // The isInverted parameter is to be set to the correct value, true or false\n  // (default being false) if the computation of the coordinates needs to be\n  // inverted to match the same scheme as OSM, Google Maps or other system.\n  // See link below for more information\n  // https://alastaira.wordpress.com/2011/07/06/converting-tms-tile-coordinates-to-googlebingosm-tile-coordinates/\n  // in crs includes ':NI' => tms isn't inverted (NOT INVERTED)\n\n  var isInverted = !tms.includes(':NI');\n  return {\n    epsg: epsg,\n    globalExtent: globalExtent,\n    globalDimension: globalDimension,\n    sTs: sTs,\n    isInverted: isInverted\n  };\n}\n\nfunction getCountTiles(crs, zoom) {\n  var sTs = schemeTiles.get(_Crs[\"default\"].formatToTms(crs)) || schemeTiles.get('default');\n  var count = Math.pow(2, zoom);\n\n  _countTiles.set(count, count).multiply(sTs);\n\n  return _countTiles;\n}\n\nvar Extent =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Extent is geographical bounding rectangle defined by 4 limits: west, east, south and north.\n   * If crs is tiled projection (WMTS or TMS), the extent is defined by zoom, row and column.\n   *\n   * @param {String} crs projection of limit values.\n   * @param {number|Array.<number>|Coordinates|Object} v0 west value, zoom\n   * value, Array of values [west, east, south and north], Coordinates of\n   * west-south corner or object {west, east, south and north}\n   * @param {number|Coordinates} [v1] east value, row value or Coordinates of\n   * east-north corner\n   * @param {number} [v2] south value or column value\n   * @param {number} [v3] north value\n   */\n  function Extent(crs, v0, v1, v2, v3) {\n    (0, _classCallCheck2[\"default\"])(this, Extent);\n    this.isExtent = true;\n    this.crs = crs; // Scale/zoom\n\n    this.zoom = 0;\n\n    if (this.isTiledCrs()) {\n      this.row = 0;\n      this.col = 0;\n    } else {\n      this.west = 0;\n      this.east = 0;\n      this.south = 0;\n      this.north = 0;\n    }\n\n    this.set(v0, v1, v2, v3);\n  }\n  /**\n   * Clone this extent\n   * @return {Extent} cloned extent\n   */\n\n\n  (0, _createClass2[\"default\"])(Extent, [{\n    key: \"clone\",\n    value: function clone() {\n      if (this.isTiledCrs()) {\n        return new Extent(this.crs, this.zoom, this.row, this.col);\n      } else {\n        return new Extent(this.crs, this.west, this.east, this.south, this.north);\n      }\n    }\n    /**\n     * Return true is tiled Extent (WGS84, PM)\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isTiledCrs\",\n    value: function isTiledCrs() {\n      return this.crs.indexOf('WMTS:') == 0;\n    }\n    /**\n     * get tiled extents convering this extent\n     *\n     * @param      {string}  crs WMTS, TMS crs\n     * @return     {Array<Extent>}   array of extents covering\n     */\n\n  }, {\n    key: \"tiledCovering\",\n    value: function tiledCovering(crs) {\n      if (this.crs == 'EPSG:4326' && crs == 'WMTS:PM') {\n        var extents_WMTS_PM = [];\n\n        var extent = _extent.copy(this).as(_Crs[\"default\"].formatToEPSG(crs), _extent2);\n\n        var _getInfoTms = getInfoTms(_Crs[\"default\"].formatToEPSG(crs)),\n            globalExtent = _getInfoTms.globalExtent,\n            globalDimension = _getInfoTms.globalDimension,\n            sTs = _getInfoTms.sTs;\n\n        extent.clampByExtent(globalExtent);\n        extent.dimensions(dimensionTile);\n        var zoom = this.zoom + 1 || Math.floor(Math.log2(Math.round(globalDimension.x / (dimensionTile.x * sTs.x))));\n        var countTiles = getCountTiles(crs, zoom);\n        var center = extent.center(_c);\n        tmsCoord.x = center.x - globalExtent.west;\n        tmsCoord.y = globalExtent.north - extent.north;\n        tmsCoord.divide(globalDimension).multiply(countTiles).floor(); // ]N; N+1] => N\n\n        var maxRow = Math.ceil((globalExtent.north - extent.south) / globalDimension.x * countTiles.y) - 1;\n\n        for (var _r = maxRow; _r >= tmsCoord.y; _r--) {\n          extents_WMTS_PM.push(new Extent(crs, zoom, _r, tmsCoord.x));\n        }\n\n        return extents_WMTS_PM;\n      } else {\n        var target = new Extent('WMTS:PM', 0, 0, 0);\n\n        var _getInfoTms2 = getInfoTms(this.crs),\n            _globalExtent = _getInfoTms2.globalExtent,\n            _globalDimension = _getInfoTms2.globalDimension,\n            _sTs = _getInfoTms2.sTs,\n            isInverted = _getInfoTms2.isInverted;\n\n        var _center = this.center(_c);\n\n        this.dimensions(dimensionTile); // Each level has 2^n * 2^n tiles...\n        // ... so we count how many tiles of the same width as tile we can fit in the layer\n        // ... 2^zoom = tilecount => zoom = log2(tilecount)\n\n        var _zoom = Math.floor(Math.log2(Math.round(_globalDimension.x / (dimensionTile.x * _sTs.x))));\n\n        var _countTiles2 = getCountTiles(crs, _zoom); // Now that we have computed zoom, we can deduce x and y (or row / column)\n\n\n        tmsCoord.x = _center.x - _globalExtent.west;\n        tmsCoord.y = isInverted ? _globalExtent.north - _center.y : _center.y - _globalExtent.south;\n        tmsCoord.divide(_globalDimension).multiply(_countTiles2).floor();\n        target.crs = crs;\n        target.set(_zoom, tmsCoord.y, tmsCoord.x);\n        return [target];\n      }\n    }\n    /**\n     * Convert Extent to the specified projection.\n     * @param {string} crs the projection of destination.\n     * @param {Extent} target copy the destination to target.\n     * @return {Extent}\n     */\n\n  }, {\n    key: \"as\",\n    value: function as(crs, target) {\n      _Crs[\"default\"].isValid(crs);\n\n      target = target || new Extent('EPSG:4326', [0, 0, 0, 0]);\n\n      if (this.isTiledCrs()) {\n        var _getInfoTms3 = getInfoTms(this.crs),\n            epsg = _getInfoTms3.epsg,\n            globalExtent = _getInfoTms3.globalExtent,\n            globalDimension = _getInfoTms3.globalDimension;\n\n        var countTiles = getCountTiles(this.crs, this.zoom);\n        dimensionTile.set(1, 1).divide(countTiles).multiply(globalDimension);\n        target.west = globalExtent.west + (globalDimension.x - dimensionTile.x * (countTiles.x - this.col));\n        target.east = target.west + dimensionTile.x;\n        target.south = globalExtent.south + dimensionTile.y * (countTiles.y - this.row - 1);\n        target.north = target.south + dimensionTile.y;\n        target.crs = epsg;\n        target.zoom = this.zoom;\n        return crs == epsg ? target : target.as(crs, target);\n      } else if (!crs.includes('WMTS:')) {\n        if (this.crs != crs) {\n          // Compute min/max in x/y by projecting 8 cardinal points,\n          // and then taking the min/max of each coordinates.\n          var center = this.center(_c);\n          cardinals[0].setFromValues(this.west, this.north);\n          cardinals[1].setFromValues(center.x, this.north);\n          cardinals[2].setFromValues(this.east, this.north);\n          cardinals[3].setFromValues(this.east, center.y);\n          cardinals[4].setFromValues(this.east, this.south);\n          cardinals[5].setFromValues(center.x, this.south);\n          cardinals[6].setFromValues(this.west, this.south);\n          cardinals[7].setFromValues(this.west, center.y);\n          target.set(Infinity, -Infinity, Infinity, -Infinity); // loop over the coordinates\n\n          for (var _i = 0; _i < cardinals.length; _i++) {\n            // convert the coordinate.\n            cardinals[_i].crs = this.crs;\n\n            cardinals[_i].as(crs, _c);\n\n            target.north = Math.max(target.north, _c.y);\n            target.south = Math.min(target.south, _c.y);\n            target.east = Math.max(target.east, _c.x);\n            target.west = Math.min(target.west, _c.x);\n          }\n\n          target.zoom = this.zoom;\n          target.crs = crs;\n          return target;\n        }\n\n        target.crs = crs;\n        target.set(this.west, this.east, this.south, this.north);\n        return target;\n      }\n    }\n    /**\n     * Return the center of Extent\n     * @param {Coordinates} target copy the center to the target.\n     * @return {Coordinates}\n     */\n\n  }, {\n    key: \"center\",\n    value: function center() {\n      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _Coordinates[\"default\"](this.crs);\n\n      if (this.isTiledCrs()) {\n        throw new Error('Invalid operation for WMTS bbox');\n      }\n\n      this.dimensions(_dim);\n      target.crs = this.crs;\n      target.setFromValues(this.west + _dim.x * 0.5, this.south + _dim.y * 0.5);\n      return target;\n    }\n    /**\n    * Returns the dimension of the extent, in a `THREE.Vector2`.\n    *\n    * @param {THREE.Vector2} [target] - The target to assign the result in.\n    *\n    * @return {THREE.Vector2}\n    */\n\n  }, {\n    key: \"dimensions\",\n    value: function dimensions() {\n      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new THREE.Vector2();\n      target.x = Math.abs(this.east - this.west);\n      target.y = Math.abs(this.north - this.south);\n      return target;\n    }\n    /**\n     * Return true if `coord` is inside the bounding box.\n     *\n     * @param {Coordinates} coord\n     * @param {number} [epsilon=0] - to take into account when comparing to the\n     * point.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isPointInside\",\n    value: function isPointInside(coord) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var c = this.crs == coord.crs ? coord : coord.as(this.crs, _c); // TODO this ignores altitude\n\n      return c.x <= this.east + epsilon && c.x >= this.west - epsilon && c.y <= this.north + epsilon && c.y >= this.south - epsilon;\n    }\n    /**\n     * Return true if `extent` is inside this extent.\n     *\n     * @param {Extent} extent the extent to check\n     * @param {number} epsilon to take into account when comparing to the\n     * point.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isInside\",\n    value: function isInside(extent, epsilon) {\n      if (this.isTiledCrs()) {\n        if (this.zoom == extent.zoom) {\n          return this.row == extent.row && this.col == extent.col;\n        } else if (this.zoom < extent.zoom) {\n          return false;\n        } else {\n          _rowColfromParent(this, extent.zoom);\n\n          return r.row == extent.row && r.col == extent.col;\n        }\n      } else {\n        extent.as(this.crs, _extent);\n        epsilon = epsilon == undefined ? _Crs[\"default\"].reasonnableEpsilon(this.crs) : epsilon;\n        return this.east - _extent.east <= epsilon && _extent.west - this.west <= epsilon && this.north - _extent.north <= epsilon && _extent.south - this.south <= epsilon;\n      }\n    }\n    /**\n     * Return the translation and scale to transform this extent to input extent.\n     *\n     * @param {Extent} extent input extent\n     * @param {THREE.Vector4} target copy the result to target.\n     * @return {THREE.Vector4} {x: translation on west-east, y: translation on south-north, z: scale on west-east, w: scale on south-north}\n     */\n\n  }, {\n    key: \"offsetToParent\",\n    value: function offsetToParent(extent) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector4();\n\n      if (this.crs != extent.crs) {\n        throw new Error('unsupported mix');\n      }\n\n      if (this.isTiledCrs()) {\n        _rowColfromParent(this, extent.zoom);\n\n        return target.set(this.col * r.invDiff - r.col, this.row * r.invDiff - r.row, r.invDiff, r.invDiff);\n      }\n\n      extent.dimensions(_dim);\n      this.dimensions(_dim2);\n      var originX = (this.west - extent.west) / _dim.x;\n      var originY = (extent.north - this.north) / _dim.y;\n      var scaleX = _dim2.x / _dim.x;\n      var scaleY = _dim2.y / _dim.y;\n      return target.set(originX, originY, scaleX, scaleY);\n    }\n    /**\n     * Return parent tiled extent with input level\n     *\n     * @param {number} levelParent level of parent.\n     * @return {Extent}\n     */\n\n  }, {\n    key: \"tiledExtentParent\",\n    value: function tiledExtentParent(levelParent) {\n      if (levelParent && levelParent < this.zoom) {\n        _rowColfromParent(this, levelParent);\n\n        return new Extent(this.crs, levelParent, r.row, r.col);\n      } else {\n        return this;\n      }\n    }\n    /**\n     * Return true if this bounding box intersect with the bouding box parameter\n     * @param {Extent} extent\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"intersectsExtent\",\n    value: function intersectsExtent(extent) {\n      // TODO don't work when is on limit\n      var other = extent.crs == this.crs ? extent : extent.as(this.crs, _extent);\n      return !(this.west >= other.east || this.east <= other.west || this.south >= other.north || this.north <= other.south);\n    }\n    /**\n     * Return the intersection of this extent with another one\n     * @param {Extent} extent\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"intersect\",\n    value: function intersect(extent) {\n      if (!this.intersectsExtent(extent)) {\n        return new Extent(this.crs, 0, 0, 0, 0);\n      }\n\n      if (extent.crs != this.crs) {\n        extent = extent.as(this.crs, _extent);\n      }\n\n      return new Extent(this.crs, Math.max(this.west, extent.west), Math.min(this.east, extent.east), Math.max(this.south, extent.south), Math.min(this.north, extent.north));\n    }\n    /**\n     * Set west, east, south and north values.\n     * Or if tiled extent, set zoom, row and column values\n     *\n     * @param {number|Array.<number>|Coordinates|Object|Extent} v0 west value,\n     * zoom value, Array of values [west, east, south and north], Extent of same\n     * type (tiled or not), Coordinates of west-south corner or object {west,\n     * east, south and north}\n     * @param {number|Coordinates} [v1] east value, row value or Coordinates of\n     * east-north corner\n     * @param {number} [v2] south value or column value\n     * @param {number} [v3] north value\n     *\n     * @return {Extent}\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(v0, v1, v2, v3) {\n      if (v0.isExtent) {\n        if (v0.isTiledCrs()) {\n          v1 = v0.row;\n          v2 = v0.col;\n          v0 = v0.zoom;\n        } else {\n          v1 = v0.east;\n          v2 = v0.south;\n          v3 = v0.north;\n          v0 = v0.west;\n        }\n      }\n\n      if (this.isTiledCrs()) {\n        if (v0 !== undefined) {\n          if (this.zoom < 0) {\n            throw new Error('Invalid zoom value for tiled extent');\n          }\n\n          this.zoom = v0;\n          this.row = v1;\n          this.col = v2;\n        } else {\n          throw new Error('Invalid values to set');\n        }\n      } else if (v0.isCoordinates) {\n        // seem never used\n        this.west = v0.x;\n        this.east = v1.x;\n        this.south = v0.y;\n        this.north = v1.y;\n      } else if (v0 && v0.west !== undefined) {\n        this.west = v0.west;\n        this.east = v0.east;\n        this.south = v0.south;\n        this.north = v0.north;\n      } else if (v0 && v0.length == 4) {\n        this.west = v0[0];\n        this.east = v0[1];\n        this.south = v0[2];\n        this.north = v0[3];\n      } else if (v0 !== undefined) {\n        this.west = v0;\n        this.east = v1;\n        this.south = v2;\n        this.north = v3;\n      } else {\n        throw new Error('No values to set in the extent');\n      }\n\n      return this;\n    }\n    /**\n     * Copy to this extent to input extent.\n     * @param {Extent} extent\n     * @return {Extent} copied extent\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(extent) {\n      this.crs = extent.crs;\n      return this.set(extent);\n    }\n    /**\n     * Union this extent with the input extent.\n     * @param {Extent} extent the extent to union.\n     */\n\n  }, {\n    key: \"union\",\n    value: function union(extent) {\n      if (extent.crs != this.crs) {\n        throw new Error('unsupported union between 2 diff crs');\n      }\n\n      if (this.west === Infinity) {\n        this.copy(extent);\n      } else {\n        var west = extent.west;\n\n        if (west < this.west) {\n          this.west = west;\n        }\n\n        var east = extent.east;\n\n        if (east > this.east) {\n          this.east = east;\n        }\n\n        var south = extent.south;\n\n        if (south < this.south) {\n          this.south = south;\n        }\n\n        var north = extent.north;\n\n        if (north > this.north) {\n          this.north = north;\n        }\n      }\n    }\n    /**\n     * expandByCoordinates perfoms the minimal extension\n     * for the coordinates to belong to this Extent object\n     * @param {Coordinates} coordinates  The coordinates to belong\n     */\n\n  }, {\n    key: \"expandByCoordinates\",\n    value: function expandByCoordinates(coordinates) {\n      var coords = coordinates.crs == this.crs ? coordinates : coordinates.as(this.crs, _c);\n      this.expandByValuesCoordinates(coords.x, coords.y);\n    }\n    /**\n    * expandByValuesCoordinates perfoms the minimal extension\n    * for the coordinates values to belong to this Extent object\n    * @param {number} we  The coordinate on west-east\n    * @param {number} sn  The coordinate on south-north\n    *\n    */\n\n  }, {\n    key: \"expandByValuesCoordinates\",\n    value: function expandByValuesCoordinates(we, sn) {\n      if (we < this.west) {\n        this.west = we;\n      }\n\n      if (we > this.east) {\n        this.east = we;\n      }\n\n      if (sn < this.south) {\n        this.south = sn;\n      }\n\n      if (sn > this.north) {\n        this.north = sn;\n      }\n    }\n    /**\n     * Instance Extent with THREE.Box2\n     * @param {string} crs Projection of extent to instancied.\n     * @param {THREE.Box2} box\n     * @return {Extent}\n     */\n\n  }, {\n    key: \"toString\",\n\n    /**\n     * Return values of extent in string, separated by the separator input.\n     * @param {string} separator\n     * @return {string}\n     */\n    value: function toString() {\n      var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      if (this.isTiledCrs()) {\n        return \"\".concat(this.zoom).concat(separator).concat(this.row).concat(separator).concat(this.col);\n      } else {\n        return \"\".concat(this.east).concat(separator).concat(this.north).concat(separator).concat(this.west).concat(separator).concat(this.south);\n      }\n    }\n    /**\n     * Subdivide equally an extent from its center to return four extents:\n     * north-west, north-east, south-west and south-east.\n     *\n     * @returns {Extent[]} An array containing the four sections of the extent. The\n     * order of the sections is [NW, NE, SW, SE].\n     */\n\n  }, {\n    key: \"subdivision\",\n    value: function subdivision() {\n      return this.subdivisionByScheme();\n    }\n    /**\n     * subdivise extent by scheme.x on west-east and scheme.y on south-north.\n     *\n     * @param      {Vector2}  [scheme=Vector2(2,2)]  The scheme to subdivise.\n     * @return     {Array<Extent>}   subdivised extents.\n     */\n\n  }, {\n    key: \"subdivisionByScheme\",\n    value: function subdivisionByScheme() {\n      var scheme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultScheme;\n      var subdivisedExtents = [];\n      var dimSub = this.dimensions(_dim).divide(scheme);\n\n      for (var x = scheme.x - 1; x >= 0; x--) {\n        for (var y = scheme.y - 1; y >= 0; y--) {\n          var west = this.west + x * dimSub.x;\n          var south = this.south + y * dimSub.y;\n          subdivisedExtents.push(new Extent(this.crs, west, west + dimSub.x, south, south + dimSub.y));\n        }\n      }\n\n      return subdivisedExtents;\n    }\n    /**\n     * Apply transform and copy this extent to input.  The `transformedCopy`\n     * doesn't handle the issue of overflow of geographic limits.\n     * @param {THREE.Vector2} t translation transform\n     * @param {THREE.Vector2} s scale transform\n     * @param {Extent} extent Extent to copy after transformation.\n     */\n\n  }, {\n    key: \"transformedCopy\",\n    value: function transformedCopy(t, s, extent) {\n      if (!extent.isTiledCrs()) {\n        this.crs = extent.crs;\n        this.west = (extent.west + t.x) * s.x;\n        this.east = (extent.east + t.x) * s.x;\n\n        if (this.west > this.east) {\n          var temp = this.west;\n          this.west = this.east;\n          this.east = temp;\n        }\n\n        this.south = (extent.south + t.y) * s.y;\n        this.north = (extent.north + t.y) * s.y;\n\n        if (this.south > this.north) {\n          var _temp = this.south;\n          this.south = this.north;\n          this.north = _temp;\n        }\n      }\n    }\n    /**\n     * clamp south and north values\n     *\n     * @param      {number}  [south=this.south]  The min south\n     * @param      {number}  [north=this.north]  The max north\n     * @return     {Extent}  this extent\n     */\n\n  }, {\n    key: \"clampSouthNorth\",\n    value: function clampSouthNorth() {\n      var south = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.south;\n      var north = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.north;\n      this.south = Math.max(this.south, south);\n      this.north = Math.min(this.north, north);\n      return this;\n    }\n    /**\n     * clamp west and east values\n     *\n     * @param      {number}  [west=this.west]  The min west\n     * @param      {number}  [east=this.east]  The max east\n     * @return     {Extent}  this extent\n     */\n\n  }, {\n    key: \"clampWestEast\",\n    value: function clampWestEast() {\n      var west = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.west;\n      var east = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.east;\n      this.west = Math.max(this.west, west);\n      this.east = Math.min(this.east, east);\n      return this;\n    }\n    /**\n     * clamp this extent by passed extent\n     *\n     * @param      {Extent}  extent  The maximum extent.\n     * @return     {Extent}  this extent.\n     */\n\n  }, {\n    key: \"clampByExtent\",\n    value: function clampByExtent(extent) {\n      this.clampSouthNorth(extent.south, extent.north);\n      return this.clampWestEast(extent.west, extent.east);\n    }\n  }], [{\n    key: \"fromBox3\",\n    value: function fromBox3(crs, box) {\n      return new Extent(crs, {\n        west: box.min.x,\n        east: box.max.x,\n        south: box.min.y,\n        north: box.max.y\n      });\n    }\n  }]);\n  return Extent;\n}();\n\n_extent = new Extent('EPSG:4326', [0, 0, 0, 0]);\n_extent2 = new Extent('EPSG:4326', [0, 0, 0, 0]);\nglobalExtentTMS.set('EPSG:4326', new Extent('EPSG:4326', -180, 180, -90, 90)); // Compute global extent of WMTS:PM EPSG:3857\n// It's square whose a side is between -180° to 180°.\n// So, west extent, it's 180 convert in EPSG:3857\n\nvar extent3857 = globalExtentTMS.get('EPSG:4326').as('EPSG:3857');\nextent3857.clampSouthNorth(extent3857.west, extent3857.east);\nglobalExtentTMS.set('EPSG:3857', extent3857);\nschemeTiles.set('default', new THREE.Vector2(1, 1));\nschemeTiles.set('WMTS:PM', schemeTiles.get('default'));\nschemeTiles.set('WMTS:WGS84', new THREE.Vector2(2, 1));\nvar _default = Extent;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Geographic/Extent.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/MainLoop.js":
/*!**************************************************!*\
  !*** ./node_modules/itowns/lib/Core/MainLoop.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.MAIN_LOOP_EVENTS = exports.RENDERING_SCHEDULED = exports.RENDERING_PAUSED = void 0;\n\nvar _three = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _Cache = _interopRequireDefault(__webpack_require__(/*! ./Scheduler/Cache */ \"./node_modules/itowns/lib/Core/Scheduler/Cache.js\"));\n\nvar RENDERING_PAUSED = 0;\nexports.RENDERING_PAUSED = RENDERING_PAUSED;\nvar RENDERING_SCHEDULED = 1;\n/**\n * MainLoop's update events list that are fired using\n * {@link View#execFrameRequesters}.\n *\n * @property UPDATE_START {string} fired at the start of the update\n * @property BEFORE_CAMERA_UPDATE {string} fired before the camera update\n * @property AFTER_CAMERA_UPDATE {string} fired after the camera update\n * @property BEFORE_LAYER_UPDATE {string} fired before the layer update\n * @property AFTER_LAYER_UPDATE {string} fired after the layer update\n * @property BEFORE_RENDER {string} fired before the render\n * @property AFTER_RENDER {string} fired after the render\n * @property UPDATE_END {string} fired at the end of the update\n */\n\nexports.RENDERING_SCHEDULED = RENDERING_SCHEDULED;\nvar MAIN_LOOP_EVENTS = {\n  UPDATE_START: 'update_start',\n  BEFORE_CAMERA_UPDATE: 'before_camera_update',\n  AFTER_CAMERA_UPDATE: 'after_camera_update',\n  BEFORE_LAYER_UPDATE: 'before_layer_update',\n  AFTER_LAYER_UPDATE: 'after_layer_update',\n  BEFORE_RENDER: 'before_render',\n  AFTER_RENDER: 'after_render',\n  UPDATE_END: 'update_end'\n};\nexports.MAIN_LOOP_EVENTS = MAIN_LOOP_EVENTS;\n\nfunction MainLoop(scheduler, engine) {\n  this.renderingState = RENDERING_PAUSED;\n  this.needsRedraw = false;\n  this.scheduler = scheduler;\n  this.gfxEngine = engine; // TODO: remove me\n\n  this._updateLoopRestarted = true;\n}\n\nMainLoop.prototype = Object.create(_three.EventDispatcher.prototype);\nMainLoop.prototype.constructor = MainLoop;\n\nMainLoop.prototype.scheduleViewUpdate = function (view, forceRedraw) {\n  var _this = this;\n\n  this.needsRedraw |= forceRedraw;\n\n  if (this.renderingState !== RENDERING_SCHEDULED) {\n    this.renderingState = RENDERING_SCHEDULED;\n    requestAnimationFrame(function (timestamp) {\n      _this._step(view, timestamp);\n    });\n  }\n};\n\nfunction updateElements(context, geometryLayer, elements) {\n  if (!elements) {\n    return;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion = (_step2 = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var element = _step2.value;\n      // update element\n      // TODO find a way to notify attachedLayers when geometryLayer deletes some elements\n      // and then update Debug.js:addGeometryLayerDebugFeatures\n      var newElementsToUpdate = geometryLayer.update(context, geometryLayer, element);\n      var sub = geometryLayer.getObjectToUpdateForAttachedLayers(element);\n\n      if (sub) {\n        if (sub.element) {\n          // update attached layers\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = geometryLayer.attachedLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion2 = (_step3 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var attachedLayer = _step3.value;\n\n              if (attachedLayer.ready) {\n                attachedLayer.update(context, attachedLayer, sub.element, sub.parent);\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                _iterator2[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        } else if (sub.elements) {\n          for (var i = 0; i < sub.elements.length; i++) {\n            if (!sub.elements[i].isObject3D) {\n              throw new Error(\"\\n                            Invalid object for attached layer to update.\\n                            Must be a THREE.Object and have a THREE.Material\");\n            } // update attached layers\n\n\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n              for (var _iterator3 = geometryLayer.attachedLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion3 = (_step4 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var _attachedLayer = _step4.value;\n\n                if (_attachedLayer.ready) {\n                  _attachedLayer.update(context, _attachedLayer, sub.elements[i], sub.parent);\n                }\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n                  _iterator3[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      updateElements(context, geometryLayer, newElementsToUpdate);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nfunction filterChangeSources(updateSources, geometryLayer) {\n  var fullUpdate = false;\n  var filtered = new Set();\n  updateSources.forEach(function (src) {\n    if (src === geometryLayer || src.isCamera) {\n      geometryLayer.info.clear();\n      fullUpdate = true;\n    } else if (src.layer === geometryLayer) {\n      filtered.add(src);\n    }\n  });\n  return fullUpdate ? new Set([geometryLayer]) : filtered;\n}\n\nMainLoop.prototype._update = function (view, updateSources, dt) {\n  var context = {\n    camera: view.camera,\n    engine: this.gfxEngine,\n    scheduler: this.scheduler,\n    view: view\n  }; // replace layer with their parent where needed\n\n  updateSources.forEach(function (src) {\n    var layer = src.layer || src;\n\n    if (layer.isLayer) {\n      var parentLayer = view.getParentLayer(layer);\n\n      if (parentLayer) {\n        // add the parent layer to update sources\n        updateSources.add(parentLayer);\n      }\n    }\n  });\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = view.getLayers(function (x, y) {\n      return !y;\n    })[Symbol.iterator](), _step5; !(_iteratorNormalCompletion4 = (_step5 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var geometryLayer = _step5.value;\n      context.geometryLayer = geometryLayer;\n\n      if (geometryLayer.ready && geometryLayer.visible && !geometryLayer.frozen) {\n        view.execFrameRequesters(MAIN_LOOP_EVENTS.BEFORE_LAYER_UPDATE, dt, this._updateLoopRestarted, geometryLayer); // Filter updateSources that are relevant for the geometryLayer\n\n        var srcs = filterChangeSources(updateSources, geometryLayer);\n\n        if (srcs.size > 0) {\n          // pre update attached layer\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = geometryLayer.attachedLayers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion5 = (_step6 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var attachedLayer = _step6.value;\n\n              if (attachedLayer.ready && attachedLayer.preUpdate) {\n                attachedLayer.preUpdate(context, srcs);\n              }\n            } // `preUpdate` returns an array of elements to update\n\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n                _iterator5[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n\n          var elementsToUpdate = geometryLayer.preUpdate(context, srcs); // `update` is called in `updateElements`.\n\n          updateElements(context, geometryLayer, elementsToUpdate); // `postUpdate` is called when this geom layer update process is finished\n\n          geometryLayer.postUpdate(context, geometryLayer, updateSources);\n        }\n\n        view.execFrameRequesters(MAIN_LOOP_EVENTS.AFTER_LAYER_UPDATE, dt, this._updateLoopRestarted, geometryLayer);\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n        _iterator4[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n};\n\nMainLoop.prototype._step = function (view, timestamp) {\n  var dt = timestamp - this._lastTimestamp;\n\n  view._executeFrameRequestersRemovals();\n\n  view.execFrameRequesters(MAIN_LOOP_EVENTS.UPDATE_START, dt, this._updateLoopRestarted);\n  var willRedraw = this.needsRedraw;\n  this._lastTimestamp = timestamp; // Reset internal state before calling _update (so future calls to View.notifyChange()\n  // can properly change it)\n\n  this.needsRedraw = false;\n  this.renderingState = RENDERING_PAUSED;\n  var updateSources = new Set(view._changeSources);\n\n  view._changeSources.clear(); // update camera\n\n\n  var dim = this.gfxEngine.getWindowSize();\n  view.execFrameRequesters(MAIN_LOOP_EVENTS.BEFORE_CAMERA_UPDATE, dt, this._updateLoopRestarted);\n  view.camera.update(dim.x, dim.y);\n  view.execFrameRequesters(MAIN_LOOP_EVENTS.AFTER_CAMERA_UPDATE, dt, this._updateLoopRestarted); // Disable camera's matrix auto update to make sure the camera's\n  // world matrix is never updated mid-update.\n  // Otherwise inconsistencies can appear because object visibility\n  // testing and object drawing could be performed using different\n  // camera matrixWorld.\n  // Note: this is required at least because WEBGLRenderer calls\n  // camera.updateMatrixWorld()\n\n  var oldAutoUpdate = view.camera.camera3D.matrixAutoUpdate;\n  view.camera.camera3D.matrixAutoUpdate = false; // update data-structure\n\n  this._update(view, updateSources, dt);\n\n  if (this.scheduler.commandsWaitingExecutionCount() == 0) {\n    this.dispatchEvent({\n      type: 'command-queue-empty'\n    });\n  } // Redraw *only* if needed.\n  // (redraws only happen when this.needsRedraw is true, which in turn only happens when\n  // view.notifyChange() is called with redraw=true)\n  // As such there's no continuous update-loop, instead we use a ad-hoc update/render\n  // mechanism.\n\n\n  if (willRedraw) {\n    this._renderView(view, dt);\n  } // next time, we'll consider that we've just started the loop if we are still PAUSED now\n\n\n  this._updateLoopRestarted = this.renderingState === RENDERING_PAUSED;\n  view.camera.camera3D.matrixAutoUpdate = oldAutoUpdate; // Clear the cache of expired resources\n\n  _Cache[\"default\"].flush();\n\n  view.execFrameRequesters(MAIN_LOOP_EVENTS.UPDATE_END, dt, this._updateLoopRestarted);\n};\n\nMainLoop.prototype._renderView = function (view, dt) {\n  view.execFrameRequesters(MAIN_LOOP_EVENTS.BEFORE_RENDER, dt, this._updateLoopRestarted);\n\n  if (view.render) {\n    view.render();\n  } else {\n    // use default rendering method\n    this.gfxEngine.renderView(view);\n  }\n\n  view.execFrameRequesters(MAIN_LOOP_EVENTS.AFTER_RENDER, dt, this._updateLoopRestarted);\n};\n\nvar _default = MainLoop;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/MainLoop.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Math/Ellipsoid.js":
/*!********************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Math/Ellipsoid.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.ellipsoidSizes = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _proj = _interopRequireDefault(__webpack_require__(/*! proj4 */ \"./node_modules/proj4/lib/index.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar ellipsoidSizes = new THREE.Vector3(_proj[\"default\"].WGS84.a, _proj[\"default\"].WGS84.a, _proj[\"default\"].WGS84.b);\nexports.ellipsoidSizes = ellipsoidSizes;\nvar normal = new THREE.Vector3();\n\nvar Ellipsoid =\n/*#__PURE__*/\nfunction () {\n  function Ellipsoid() {\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ellipsoidSizes;\n    (0, _classCallCheck2[\"default\"])(this, Ellipsoid);\n    this.size = new THREE.Vector3();\n    this._radiiSquared = new THREE.Vector3();\n    this._invRadiiSquared = new THREE.Vector3();\n    this.setSize(size);\n  }\n\n  (0, _createClass2[\"default\"])(Ellipsoid, [{\n    key: \"geodeticSurfaceNormal\",\n    value: function geodeticSurfaceNormal(cartesian) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();\n      return cartesian.toVector3(target).multiply(this._invRadiiSquared).normalize();\n    }\n  }, {\n    key: \"geodeticSurfaceNormalCartographic\",\n    value: function geodeticSurfaceNormalCartographic(coordCarto) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();\n      var longitude = THREE.Math.degToRad(coordCarto.longitude);\n      var latitude = THREE.Math.degToRad(coordCarto.latitude);\n      var cosLatitude = Math.cos(latitude);\n      return target.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude));\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(size) {\n      this.size.set(size.x, size.y, size.z);\n\n      this._radiiSquared.multiplyVectors(size, size);\n\n      this._invRadiiSquared.x = size.x == 0 ? 0 : 1 / this._radiiSquared.x;\n      this._invRadiiSquared.y = size.y == 0 ? 0 : 1 / this._radiiSquared.y;\n      this._invRadiiSquared.z = size.z == 0 ? 0 : 1 / this._radiiSquared.z;\n    }\n  }, {\n    key: \"cartographicToCartesian\",\n    value: function cartographicToCartesian(coordCarto) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();\n      normal.copy(coordCarto.geodesicNormal);\n      target.multiplyVectors(this._radiiSquared, normal);\n      var gamma = Math.sqrt(normal.dot(target));\n      target.divideScalar(gamma);\n      normal.multiplyScalar(coordCarto.altitude);\n      return target.add(normal);\n    }\n    /**\n     * Convert cartesian coordinates to geographic according to the current ellipsoid of revolution.\n     * @param {Object} position - The coordinate to convert\n     * @param {number} position.x\n     * @param {number} position.y\n     * @param {number} position.z\n     * @param {Coordinate} [target] coordinate to copy result\n     * @returns {Coordinate} an object describing the coordinates on the reference ellipsoid, angles are in degree\n     */\n\n  }, {\n    key: \"cartesianToCartographic\",\n    value: function cartesianToCartographic(position) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _Coordinates[\"default\"]('EPSG:4326', 0, 0, 0);\n      // for details, see for example http://www.linz.govt.nz/data/geodetic-system/coordinate-conversion/geodetic-datum-conversions/equations-used-datum\n      // TODO the following is only valable for oblate ellipsoid of revolution. do we want to support triaxial ellipsoid?\n      var R = Math.sqrt(position.x * position.x + position.y * position.y + position.z * position.z);\n      var a = this.size.x; // x\n\n      var b = this.size.z; // z\n\n      var e = Math.abs((a * a - b * b) / (a * a));\n      var f = 1 - Math.sqrt(1 - e);\n      var rsqXY = Math.sqrt(position.x * position.x + position.y * position.y);\n      var theta = Math.atan2(position.y, position.x);\n      var nu = Math.atan(position.z / rsqXY * (1 - f + e * a / R));\n      var sinu = Math.sin(nu);\n      var cosu = Math.cos(nu);\n      var phi = Math.atan((position.z * (1 - f) + e * a * sinu * sinu * sinu) / ((1 - f) * (rsqXY - e * a * cosu * cosu * cosu)));\n      var h = rsqXY * Math.cos(phi) + position.z * Math.sin(phi) - a * Math.sqrt(1 - e * Math.sin(phi) * Math.sin(phi));\n      return target.setFromValues(THREE.Math.radToDeg(theta), THREE.Math.radToDeg(phi), h);\n    }\n  }, {\n    key: \"cartographicToCartesianArray\",\n    value: function cartographicToCartesianArray(coordCartoArray) {\n      var cartesianArray = [];\n\n      for (var i = 0; i < coordCartoArray.length; i++) {\n        cartesianArray.push(this.cartographicToCartesian(coordCartoArray[i]));\n      }\n\n      return cartesianArray;\n    }\n  }, {\n    key: \"intersection\",\n    value: function intersection(ray) {\n      var EPSILON = 0.0001;\n      var O_C = ray.origin;\n      var dir = ray.direction; // normalizeVector( dir );\n\n      var a = dir.x * dir.x * this._invRadiiSquared.x + dir.y * dir.y * this._invRadiiSquared.y + dir.z * dir.z * this._invRadiiSquared.z;\n      var b = 2 * O_C.x * dir.x * this._invRadiiSquared.x + 2 * O_C.y * dir.y * this._invRadiiSquared.y + 2 * O_C.z * dir.z * this._invRadiiSquared.z;\n      var c = O_C.x * O_C.x * this._invRadiiSquared.x + O_C.y * O_C.y * this._invRadiiSquared.y + O_C.z * O_C.z * this._invRadiiSquared.z - 1;\n      var d = b * b - 4 * a * c;\n\n      if (d < 0 || a === 0 || b === 0 || c === 0) {\n        return false;\n      }\n\n      d = Math.sqrt(d);\n      var t1 = (-b + d) / (2 * a);\n      var t2 = (-b - d) / (2 * a);\n\n      if (t1 <= EPSILON && t2 <= EPSILON) {\n        return false;\n      } // both intersections are behind the ray origin\n      // var back = (t1 <= EPSILON || t2 <= EPSILON); // If only one intersection (t>0) then we are inside the ellipsoid and the intersection is at the back of the ellipsoid\n\n\n      var t = 0;\n\n      if (t1 <= EPSILON) {\n        t = t2;\n      } else if (t2 <= EPSILON) {\n        t = t1;\n      } else {\n        t = t1 < t2 ? t1 : t2;\n      }\n\n      if (t < EPSILON) {\n        return false;\n      } // Too close to intersection\n\n\n      var inter = new THREE.Vector3();\n      inter.addVectors(ray.origin, dir.clone().setLength(t));\n      return inter;\n    }\n  }, {\n    key: \"computeDistance\",\n    value: function computeDistance(coordCarto1, coordCarto2) {\n      var longitude1 = THREE.Math.degToRad(coordCarto1.longitude);\n      var latitude1 = THREE.Math.degToRad(coordCarto1.latitude);\n      var longitude2 = THREE.Math.degToRad(coordCarto2.longitude);\n      var latitude2 = THREE.Math.degToRad(coordCarto2.latitude);\n      var distRad = Math.acos(Math.sin(latitude1) * Math.sin(latitude2) + Math.cos(latitude1) * Math.cos(latitude2) * Math.cos(longitude2 - longitude1));\n      var a = this.size.x;\n      var b = this.size.z;\n      var e = Math.sqrt((a * a - b * b) / (a * a));\n      var latMoy = (latitude1 + latitude2) / 2;\n      var rho = a * (1 - e * e) / Math.sqrt(1 - e * e * Math.sin(latMoy) * Math.sin(latMoy));\n      var N = a / Math.sqrt(1 - e * e * Math.sin(latMoy) * Math.sin(latMoy));\n      var distMeter = distRad * Math.sqrt(rho * N);\n      return distMeter;\n    }\n  }]);\n  return Ellipsoid;\n}();\n\nvar _default = Ellipsoid;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Math/Ellipsoid.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Picking.js":
/*!*************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Picking.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _RenderMode = _interopRequireDefault(__webpack_require__(/*! ../Renderer/RenderMode */ \"./node_modules/itowns/lib/Renderer/RenderMode.js\"));\n\nvar _LayeredMaterial = __webpack_require__(/*! ../Renderer/LayeredMaterial */ \"./node_modules/itowns/lib/Renderer/LayeredMaterial.js\");\n\nfunction hideEverythingElse(view) {\n  var threejsLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // We want to render only 'object' and its hierarchy.\n  // So if it uses threejsLayer defined -> force it on the camera\n  // (or use the default one: 0)\n  var prev = view.camera.camera3D.layers.mask;\n  view.camera.camera3D.layers.mask = 1 << threejsLayer;\n  return function () {\n    view.camera.camera3D.layers.mask = prev;\n  };\n}\n\nvar depthRGBA = new THREE.Vector4(); // TileMesh picking support function\n\nfunction screenCoordsToNodeId(view, tileLayer, viewCoords) {\n  var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var dim = view.mainLoop.gfxEngine.getWindowSize();\n  viewCoords = viewCoords || new THREE.Vector2(Math.floor(dim.x / 2), Math.floor(dim.y / 2));\n  var restore = tileLayer.level0Nodes.map(function (n) {\n    return _RenderMode[\"default\"].push(n, _RenderMode[\"default\"].MODES.ID);\n  });\n  var undoHide = hideEverythingElse(view, tileLayer.object3d, tileLayer.threejsLayer);\n  var buffer = view.mainLoop.gfxEngine.renderViewToBuffer({\n    camera: view.camera,\n    scene: tileLayer.object3d\n  }, {\n    x: viewCoords.x - radius,\n    y: viewCoords.y - radius,\n    width: 1 + radius * 2,\n    height: 1 + radius * 2\n  });\n  undoHide();\n  restore.forEach(function (r) {\n    return r();\n  });\n  var ids = [];\n  traversePickingCircle(radius, function (x, y) {\n    var idx = (y * 2 * radius + x) * 4;\n    var data = buffer.slice(idx, idx + 4 || undefined);\n    depthRGBA.fromArray(data).divideScalar(255.0);\n    var unpack = (0, _LayeredMaterial.unpack1K)(depthRGBA, Math.pow(256, 3));\n\n    var _id = Math.round(unpack);\n\n    if (!ids.includes(_id)) {\n      ids.push(_id);\n    }\n  });\n  return ids;\n}\n\nfunction traversePickingCircle(radius, callback) {\n  // iterate on radius so we get closer to the mouse\n  // results first.\n  // Result traversal order for radius=2\n  // --3--\n  // -323-\n  // 32123\n  // -323\n  // --3--\n  var prevSq;\n\n  for (var r = 0; r <= radius; r++) {\n    var sq = r * r;\n\n    for (var x = -r; x <= r; x++) {\n      var sqx = x * x;\n\n      for (var y = -r; y <= r; y++) {\n        var dist = sqx + y * y; // skip if too far\n\n        if (dist > sq) {\n          continue;\n        } // skip if belongs to previous\n\n\n        if (dist <= prevSq) {\n          continue;\n        }\n\n        if (callback(x, y) === false) {\n          return;\n        }\n      }\n    }\n\n    prevSq = sq;\n  }\n}\n\nfunction findLayerInParent(obj) {\n  if (obj.layer) {\n    return obj.layer;\n  }\n\n  if (obj.parent) {\n    return findLayerInParent(obj.parent);\n  }\n}\n\nvar raycaster = new THREE.Raycaster();\n/**\n * @module Picking\n *\n * Implement various picking methods for geometry layers.\n * These methods are not meant to be used directly, see View.pickObjectsAt\n * instead.\n *\n * All the methods here takes the same parameters:\n *   - the View instance\n *   - view coordinates (in pixels) where picking should be done\n *   - radius (in pixels) of the picking circle\n *   - layer: the geometry layer used for picking\n */\n\nvar _default = {\n  pickTilesAt: function pickTilesAt(view, viewCoords, radius, layer) {\n    var results = [];\n\n    var _ids = screenCoordsToNodeId(view, layer, viewCoords, radius);\n\n    var extractResult = function (node) {\n      if (_ids.includes(node.id) && node.isTileMesh) {\n        results.push({\n          object: node,\n          layer: layer\n        });\n      }\n    };\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = layer.level0Nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var n = _step.value;\n        n.traverse(extractResult);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return results;\n  },\n  pickPointsAt: function pickPointsAt(view, viewCoords, radius, layer) {\n    if (!layer.root) {\n      return;\n    } // enable picking mode for points material\n\n\n    layer.object3d.traverse(function (o) {\n      if (o.isPoints && o.baseId) {\n        o.material.enablePicking(true);\n      }\n    });\n    var undoHide = hideEverythingElse(view, layer.object3d, layer.threejsLayer); // render 1 pixel\n    // TODO: support more than 1 pixel selection\n\n    var buffer = view.mainLoop.gfxEngine.renderViewToBuffer({\n      camera: view.camera,\n      scene: layer.object3d\n    }, {\n      x: viewCoords.x - radius,\n      y: viewCoords.y - radius,\n      width: 1 + radius * 2,\n      height: 1 + radius * 2\n    });\n    undoHide();\n    var candidates = [];\n    traversePickingCircle(radius, function (x, y) {\n      var idx = (y * 2 * radius + x) * 4;\n      var data = buffer.slice(idx, idx + 4); // see PointCloudProvider and the construction of unique_id\n\n      var objId = data[0] << 8 | data[1];\n      var index = data[2] << 8 | data[3];\n      var r = {\n        objId: objId,\n        index: index\n      };\n\n      for (var i = 0; i < candidates.length; i++) {\n        if (candidates[i].objId == r.objId && candidates[i].index == r.index) {\n          return;\n        }\n      }\n\n      candidates.push(r);\n    });\n    var result = [];\n    layer.object3d.traverse(function (o) {\n      if (o.isPoints && o.baseId) {\n        // disable picking mode\n        o.material.enablePicking(false); // if baseId matches objId, the clicked point belongs to `o`\n\n        for (var i = 0; i < candidates.length; i++) {\n          if (candidates[i].objId == o.baseId) {\n            result.push({\n              object: o,\n              index: candidates[i].index,\n              layer: layer\n            });\n          }\n        }\n      }\n    });\n    return result;\n  },\n\n  /*\n   * Default picking method. Uses THREE.Raycaster\n   */\n  pickObjectsAt: function pickObjectsAt(view, viewCoords, radius, object) {\n    var target = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n    if (radius < 0) {\n      var _normalized = view.viewToNormalizedCoords(viewCoords);\n\n      raycaster.setFromCamera(_normalized, view.camera.camera3D);\n      var intersects = raycaster.intersectObject(object, true);\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = intersects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var inter = _step2.value;\n          inter.layer = findLayerInParent(inter.object);\n          target.push(inter);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return target;\n    } // Instead of doing N raycast (1 per x,y returned by traversePickingCircle),\n    // we force render the zone of interest.\n    // Then we'll only do raycasting for the pixels where something was drawn.\n\n\n    var zone = {\n      x: viewCoords.x - radius,\n      y: viewCoords.y - radius,\n      width: 1 + radius * 2,\n      height: 1 + radius * 2\n    };\n    var pixels = view.mainLoop.gfxEngine.renderViewToBuffer({\n      scene: object,\n      camera: view.camera\n    }, zone);\n    var clearColor = view.mainLoop.gfxEngine.renderer.getClearColor();\n    var clearR = Math.round(255 * clearColor.r);\n    var clearG = Math.round(255 * clearColor.g);\n    var clearB = Math.round(255 * clearColor.b); // Raycaster use NDC coordinate\n\n    var normalized = view.viewToNormalizedCoords(viewCoords);\n    var tmp = normalized.clone();\n    traversePickingCircle(radius, function (x, y) {\n      // x, y are offset from the center of the picking circle,\n      // and pixels is a square where 0, 0 is the top-left corner.\n      // So we need to shift x,y by radius.\n      var offset = ((y + radius) * (radius * 2 + 1) + (x + radius)) * 4;\n      var r = pixels[offset];\n      var g = pixels[offset + 1];\n      var b = pixels[offset + 2]; // Use approx. test to avoid rounding error or to behave\n      // differently depending on hardware rounding mode.\n\n      if (Math.abs(clearR - r) <= 1 && Math.abs(clearG - g) <= 1 && Math.abs(clearB - b) <= 1) {\n        // skip because nothing has been rendered here\n        return;\n      } // Perform raycasting\n\n\n      tmp.setX(normalized.x + x / view.camera.width).setY(normalized.y + y / view.camera.height);\n      raycaster.setFromCamera(tmp, view.camera.camera3D);\n      var intersects = raycaster.intersectObject(object, true);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = intersects[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _inter = _step3.value;\n          _inter.layer = findLayerInParent(_inter.object);\n          target.push(_inter);\n        } // Stop at first hit\n\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return target.length == 0;\n    });\n    return target;\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Picking.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/Globe/Atmosphere.js":
/*!*****************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/Globe/Atmosphere.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _GeometryLayer2 = _interopRequireDefault(__webpack_require__(/*! ../../../Layer/GeometryLayer */ \"./node_modules/itowns/lib/Layer/GeometryLayer.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../../Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Ellipsoid = __webpack_require__(/*! ../../Math/Ellipsoid */ \"./node_modules/itowns/lib/Core/Math/Ellipsoid.js\");\n\nvar _CoordStars = _interopRequireDefault(__webpack_require__(/*! ../../Geographic/CoordStars */ \"./node_modules/itowns/lib/Core/Geographic/CoordStars.js\"));\n\nvar _SkyShader = _interopRequireDefault(__webpack_require__(/*! ./SkyShader */ \"./node_modules/itowns/lib/Core/Prefab/Globe/SkyShader.js\"));\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/* babel-plugin-inline-import './Shaders/skyFS.glsl' */\nvar skyFS = \"uniform vec3 v3LightPos;\\nuniform float g;\\nuniform float g2;\\n\\nvarying vec3 v3Direction;\\nvarying vec3 c0;\\nvarying vec3 c1;\\n\\n// Calculates the Mie phase function\\nfloat getMiePhase(float fCos, float fCos2, float g, float g2) {\\n    return 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos2) / pow(1.0 + g2 - 2.0 * g * fCos, 1.5);\\n}\\n\\n// Calculates the Rayleigh phase function\\nfloat getRayleighPhase(float fCos2) {\\n    return 0.75 + 0.75 * fCos2;\\n}\\n\\nvoid main (void) {\\n    float fCos = dot(v3LightPos, v3Direction) / length(v3Direction);\\n    float fCos2 = fCos * fCos;\\n\\n    vec3 color = getRayleighPhase(fCos2) * c0 + getMiePhase(fCos, fCos2, g, g2) * c1;\\n\\n    gl_FragColor = vec4(color, 1.0);\\n    gl_FragColor.a = gl_FragColor.b;\\n}\";\n\n/* babel-plugin-inline-import './Shaders/skyVS.glsl' */\nvar skyVS = \"uniform vec3 v3LightPosition;   // The direction vector to the light source\\nuniform vec3 v3InvWavelength;   // 1 / pow(wavelength, 4) for the red, green, and blue channels\\nuniform float fCameraHeight;    // The camera's current height\\nuniform float fCameraHeight2;   // fCameraHeight^2\\nuniform float fOuterRadius;     // The outer (atmosphere) radius\\nuniform float fOuterRadius2;    // fOuterRadius^2\\nuniform float fInnerRadius;     // The inner (planetary) radius\\nuniform float fInnerRadius2;    // fInnerRadius^2\\nuniform float fKrESun;          // Kr * ESun\\nuniform float fKmESun;          // Km * ESun\\nuniform float fKr4PI;           // Kr * 4 * PI\\nuniform float fKm4PI;           // Km * 4 * PI\\nuniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)\\nuniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\\nuniform float fScaleOverScaleDepth; // fScale / fScaleDepth\\n\\nconst int nSamples = 3;\\nconst float fSamples = 3.0;\\n\\nvarying vec3 v3Direction;\\nvarying vec3 c0;\\nvarying vec3 c1;\\n\\nfloat scale(float fCos) {\\n    float x = 1.0 - fCos;\\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\n}\\n\\nvoid main(void) {\\n    float lengthCamera = length(cameraPosition);\\n    float cameraHeight2 = lengthCamera * lengthCamera;\\n\\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\n    vec3 v3Ray = position - cameraPosition;\\n    float fFar = length(v3Ray);\\n    v3Ray /= fFar;\\n\\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\n    float B = 2.0 * dot(cameraPosition, v3Ray);\\n    float C = cameraHeight2 - fOuterRadius2;\\n    float fDet = max(0.0, B*B - 4.0 * C);\\n    float fNear = 0.5 * (-B - sqrt(fDet));\\n\\n    // Calculate the ray's starting position, then calculate its scattering offset\\n    vec3 v3Start = cameraPosition + v3Ray * fNear;\\n    fFar -= fNear;\\n    float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\\n    float fStartDepth = exp(-1.0 / fScaleDepth);\\n    float fStartOffset = fStartDepth * scale(fStartAngle);\\n\\n    // Initialize the scattering loop variables\\n    float fSampleLength = fFar / fSamples;\\n    float fScaledLength = fSampleLength * fScale;\\n    vec3 v3SampleRay = v3Ray * fSampleLength;\\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\n\\n    // Now loop through the sample rays\\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\n    for(int i=0; i<nSamples; i++)\\n    {\\n        float fHeight = length(v3SamplePoint);\\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\n        float fLightAngle = dot(v3LightPosition, v3SamplePoint) / fHeight;\\n        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\\n        float fScatter = (fStartOffset + fDepth * (scale(fLightAngle) - scale(fCameraAngle)));\\n        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\n\\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\n        v3SamplePoint += v3SampleRay;\\n    }\\n\\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n    c0 = v3FrontColor * (v3InvWavelength * fKrESun);\\n    c1 = v3FrontColor * fKmESun;\\n    v3Direction = cameraPosition - position;\\n}\";\n\n/* babel-plugin-inline-import './Shaders/groundFS.glsl' */\nvar groundFS = \"varying vec3 c0;\\nvarying vec3 c1;\\n\\nvoid main (void) {\\n\\tgl_FragColor = vec4(c1, 1.0 - c0/4.);\\n}\";\n\n/* babel-plugin-inline-import './Shaders/groundVS.glsl' */\nvar groundVS = \"uniform vec3 v3LightPosition;   // The direction vector to the light source\\nuniform vec3 v3InvWavelength;   // 1 / pow(wavelength, 4) for the red, green, and blue channels\\nuniform float fCameraHeight;    // The camera's current height\\nuniform float fCameraHeight2;   // fCameraHeight^2\\nuniform float fOuterRadius;     // The outer (atmosphere) radius\\nuniform float fOuterRadius2;    // fOuterRadius^2\\nuniform float fInnerRadius;     // The inner (planetary) radius\\nuniform float fInnerRadius2;    // fInnerRadius^2\\nuniform float fKrESun;          // Kr * ESun\\nuniform float fKmESun;          // Km * ESun\\nuniform float fKr4PI;           // Kr * 4 * PI\\nuniform float fKm4PI;           // Km * 4 * PI\\nuniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)\\nuniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\\nuniform float fScaleOverScaleDepth; // fScale / fScaleDepth\\n\\nvarying vec3 c0;\\nvarying vec3 c1;\\n\\nconst int nSamples = 3;\\nconst float fSamples = 3.0;\\n\\nfloat scale(float fCos)\\n{\\n    float x = 1.0 - fCos;\\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\n}\\n\\nvoid main(void) {\\n\\n     float cameraHeight2 = length(cameraPosition) * length(cameraPosition);\\n\\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\n    vec3 v3Ray = position - cameraPosition;\\n    float fFar = length(v3Ray);\\n    v3Ray /= fFar;\\n\\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\n    float B = 2.0 * dot(cameraPosition, v3Ray);\\n    float C = cameraHeight2 - fOuterRadius2;\\n    float fDet = max(0.0, B*B - 4.0 * C);\\n    float fNear = 0.5 * (-B - sqrt(fDet));\\n\\n    // Calculate the ray's starting position, then calculate its scattering offset\\n    vec3 v3Start = cameraPosition + v3Ray * fNear;\\n    fFar -= fNear;\\n    float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\\n    float fCameraAngle = dot(-v3Ray, position) / length(position);\\n    float fLightAngle = dot(v3LightPosition, position) / length(position);\\n    float fCameraScale = scale(fCameraAngle);\\n    float fLightScale = scale(fLightAngle);\\n    float fCameraOffset = fDepth*fCameraScale;\\n    float fTemp = (fLightScale + fCameraScale);\\n\\n    // Initialize the scattering loop variables\\n    float fSampleLength = fFar / fSamples;\\n    float fScaledLength = fSampleLength * fScale;\\n    vec3 v3SampleRay = v3Ray * fSampleLength;\\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\n\\n    // Now loop through the sample rays\\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\n    vec3 v3Attenuate = vec3(0.0, 0.0, 0.0);\\n    for(int i=0; i<nSamples; i++)\\n    {\\n        float fHeight = length(v3SamplePoint);\\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\n        float fScatter = fDepth*fTemp - fCameraOffset;\\n        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\n        v3SamplePoint += v3SampleRay;\\n    }\\n\\n    // Calculate the attenuation factor for the ground\\n    c0 = v3Attenuate;\\n    c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\n\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\n/* babel-plugin-inline-import './Shaders/GlowFS.glsl' */\nvar GlowFS = \"#include <logdepthbuf_pars_fragment>\\n\\nuniform int atmoIN;\\nvarying float intensity;\\n\\nvec4 glowColor = vec4(0.45, 0.74, 1. ,1.0);\\n\\nvoid main() {\\n    #include <logdepthbuf_fragment>\\n    gl_FragColor = glowColor * intensity;\\n}\\n\\n\";\n\n/* babel-plugin-inline-import './Shaders/GlowVS.glsl' */\nvar GlowVS = \"#include <common>\\n#include <logdepthbuf_pars_vertex>\\n\\nuniform int atmoIN;\\nvarying float intensity;\\n\\nvoid main()\\n{\\n    vec3 normalES    = normalize( normalMatrix * normal );\\n    vec3 normalCAMES = normalize( normalMatrix * cameraPosition );\\n\\n    if(atmoIN == 0) {\\n        intensity = pow(0.666 - dot(normalES, normalCAMES), 4. );\\n    } else {\\n        intensity = pow( 1.  - dot(normalES, normalCAMES), 0.8 );\\n    }\\n\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position,  1.0 );\\n\\n    #include <logdepthbuf_vertex>\\n}\\n\\n\\n\";\nvar LIGHTING_POSITION = new THREE.Vector3(1, 0, 0);\nvar v = new THREE.Vector3();\nvar coordCam = new _Coordinates[\"default\"]('EPSG:4326');\nvar coordGeoCam = new _Coordinates[\"default\"]('EPSG:4326');\nvar skyBaseColor = new THREE.Color(0x93d5f8);\nvar colorSky = new THREE.Color();\nvar spaceColor = new THREE.Color(0x030508);\nvar limitAlti = 600000;\nvar mfogDistance = _Ellipsoid.ellipsoidSizes.x * 160.0;\n\nvar Atmosphere =\n/*#__PURE__*/\nfunction (_GeometryLayer) {\n  (0, _inherits2[\"default\"])(Atmosphere, _GeometryLayer);\n\n  function Atmosphere() {\n    var _this;\n\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'atmosphere';\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, Atmosphere);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Atmosphere).call(this, id, new THREE.Object3D(), options));\n    var material = new THREE.ShaderMaterial({\n      uniforms: {\n        atmoIN: {\n          type: 'i',\n          value: 0\n        },\n        screenSize: {\n          type: 'v2',\n          value: new THREE.Vector2(window.innerWidth, window.innerHeight)\n        } // Should be updated on screen resize...\n\n      },\n      vertexShader: GlowVS,\n      fragmentShader: GlowFS,\n      side: THREE.BackSide,\n      blending: THREE.AdditiveBlending,\n      transparent: true,\n      wireframe: false\n    });\n    var sphereGeometry = new THREE.SphereGeometry(1, 64, 64);\n    var basicAtmosphereOut = new THREE.Mesh(sphereGeometry, material);\n    basicAtmosphereOut.scale.copy(_Ellipsoid.ellipsoidSizes).multiplyScalar(1.14);\n    _this.basicAtmosphere = new THREE.Object3D();\n    _this.realisticAtmosphere = new THREE.Object3D();\n    _this.realisticAtmosphere.visible = false;\n\n    _this.object3d.add(_this.basicAtmosphere);\n\n    _this.object3d.add(_this.realisticAtmosphere);\n\n    _this.basicAtmosphere.add(basicAtmosphereOut);\n\n    var materialAtmoIn = new THREE.ShaderMaterial({\n      uniforms: {\n        atmoIN: {\n          type: 'i',\n          value: 1\n        },\n        screenSize: {\n          type: 'v2',\n          value: new THREE.Vector2(window.innerWidth, window.innerHeight)\n        } // Should be updated on screen resize...\n\n      },\n      vertexShader: GlowVS,\n      fragmentShader: GlowFS,\n      side: THREE.FrontSide,\n      blending: THREE.AdditiveBlending,\n      transparent: true,\n      depthWrite: false\n    });\n    var basicAtmosphereIn = new THREE.Mesh(sphereGeometry, materialAtmoIn);\n    basicAtmosphereIn.scale.copy(_Ellipsoid.ellipsoidSizes).multiplyScalar(1.002);\n\n    _this.basicAtmosphere.add(basicAtmosphereIn);\n\n    _this.realisticLightingPosition = {\n      x: -0.5,\n      y: 0.0,\n      z: 1.0\n    };\n    _this.fog = {\n      enable: true,\n      distance: mfogDistance\n    };\n\n    _this.object3d.updateMatrixWorld();\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(Atmosphere, [{\n    key: \"update\",\n    value: function update(context, layer, node) {\n      // update uniforms\n      node.material.fogDistance = this.fog.distance;\n      node.material.lightingEnabled = this.realisticAtmosphere.visible;\n      node.material.lightPosition = this.realisticLightingPosition;\n    } // eslint-disable-next-line no-unused-vars\n\n  }, {\n    key: \"preUpdate\",\n    value: function preUpdate(context) {\n      var cameraPosition = context.view.camera.camera3D.position;\n\n      if (this.fog.enable) {\n        v.setFromMatrixPosition(context.view.tileLayer.object3d.matrixWorld);\n        var len = v.distanceTo(cameraPosition); // Compute fog distance, this function makes it possible to have a shorter distance\n        // when the camera approaches the ground\n\n        this.fog.distance = mfogDistance * Math.pow((len - _Ellipsoid.ellipsoidSizes.x * 0.99) * 0.25 / _Ellipsoid.ellipsoidSizes.x, 1.5);\n      } else {\n        this.fog.distance = 10e10;\n      }\n\n      var renderer = context.view.mainLoop.gfxEngine.renderer; // get altitude camera\n\n      coordCam.crs = context.view.referenceCrs;\n      coordCam.setFromVector3(cameraPosition).as('EPSG:4326', coordGeoCam);\n      var altitude = coordGeoCam.altitude; // If the camera altitude is below limitAlti,\n      // we interpolate between the sky color and the space color\n\n      if (altitude < limitAlti) {\n        colorSky.copy(spaceColor).lerp(skyBaseColor, (limitAlti - altitude) / limitAlti);\n        renderer.setClearColor(colorSky, renderer.getClearAlpha());\n      } else {\n        renderer.setClearColor(spaceColor, renderer.getClearAlpha());\n      }\n    } // default to non-realistic lightning\n\n  }, {\n    key: \"_initRealisticLighning\",\n    value: function _initRealisticLighning() {\n      // Atmosphere Shader From Space (Atmospheric scattering)\n      // http://stainlessbeer.weebly.com/planets-9-atmospheric-scattering.html\n      var atmosphere = {\n        Kr: 0.0025,\n        Km: 0.0010,\n        ESun: 20.0,\n        g: -0.950,\n        innerRadius: 6400000,\n        outerRadius: 6700000,\n        wavelength: [0.650, 0.570, 0.475],\n        scaleDepth: 0.25,\n        mieScaleDepth: 0.1\n      };\n      var uniformsAtmosphere = {\n        v3LightPosition: {\n          value: LIGHTING_POSITION.clone().normalize()\n        },\n        v3InvWavelength: {\n          value: new THREE.Vector3(1 / Math.pow(atmosphere.wavelength[0], 4), 1 / Math.pow(atmosphere.wavelength[1], 4), 1 / Math.pow(atmosphere.wavelength[2], 4))\n        },\n        fCameraHeight: {\n          value: 0.0\n        },\n        fCameraHeight2: {\n          value: 0.0\n        },\n        fInnerRadius: {\n          value: atmosphere.innerRadius\n        },\n        fInnerRadius2: {\n          value: atmosphere.innerRadius * atmosphere.innerRadius\n        },\n        fOuterRadius: {\n          value: atmosphere.outerRadius\n        },\n        fOuterRadius2: {\n          value: atmosphere.outerRadius * atmosphere.outerRadius\n        },\n        fKrESun: {\n          value: atmosphere.Kr * atmosphere.ESun\n        },\n        fKmESun: {\n          value: atmosphere.Km * atmosphere.ESun\n        },\n        fKr4PI: {\n          value: atmosphere.Kr * 4.0 * Math.PI\n        },\n        fKm4PI: {\n          value: atmosphere.Km * 4.0 * Math.PI\n        },\n        fScale: {\n          value: 1 / (atmosphere.outerRadius - atmosphere.innerRadius)\n        },\n        fScaleDepth: {\n          value: atmosphere.scaleDepth\n        },\n        fScaleOverScaleDepth: {\n          value: 1 / (atmosphere.outerRadius - atmosphere.innerRadius) / atmosphere.scaleDepth\n        },\n        g: {\n          value: atmosphere.g\n        },\n        g2: {\n          value: atmosphere.g * atmosphere.g\n        },\n        nSamples: {\n          value: 3\n        },\n        fSamples: {\n          value: 3.0\n        },\n        tDisplacement: {\n          value: new THREE.Texture()\n        },\n        tSkyboxDiffuse: {\n          value: new THREE.Texture()\n        },\n        fNightScale: {\n          value: 1.0\n        }\n      };\n      var geometryAtmosphereIn = new THREE.SphereGeometry(atmosphere.innerRadius, 50, 50);\n      var materialAtmosphereIn = new THREE.ShaderMaterial({\n        uniforms: uniformsAtmosphere,\n        vertexShader: groundVS,\n        fragmentShader: groundFS,\n        blending: THREE.AdditiveBlending,\n        transparent: true,\n        depthTest: false,\n        depthWrite: false\n      });\n      var ground = new THREE.Mesh(geometryAtmosphereIn, materialAtmosphereIn);\n      var geometryAtmosphereOut = new THREE.SphereGeometry(atmosphere.outerRadius, 196, 196);\n      var materialAtmosphereOut = new THREE.ShaderMaterial({\n        uniforms: uniformsAtmosphere,\n        vertexShader: skyVS,\n        fragmentShader: skyFS,\n        transparent: true,\n        side: THREE.BackSide\n      });\n      var sky = new THREE.Mesh(geometryAtmosphereOut, materialAtmosphereOut);\n      var skyDome = new _SkyShader[\"default\"]();\n      skyDome.frustumCulled = false;\n      ground.layers.mask = this.object3d.layers.mask;\n      sky.layers.mask = this.object3d.layers.mask;\n      skyDome.layers.mask = this.object3d.layers.mask;\n      this.realisticAtmosphere.add(ground);\n      this.realisticAtmosphere.add(sky);\n      this.realisticAtmosphere.add(skyDome);\n      var effectController = {\n        turbidity: 10,\n        reileigh: 2,\n        mieCoefficient: 0.005,\n        mieDirectionalG: 0.8,\n        luminance: 1,\n        inclination: 0.49,\n        // elevation / inclination\n        azimuth: 0.25,\n        // Facing front,\n        sun: !true\n      };\n      skyDome.material.uniforms.turbidity.value = effectController.turbidity;\n      skyDome.material.uniforms.reileigh.value = effectController.reileigh;\n      skyDome.material.uniforms.luminance.value = effectController.luminance;\n      skyDome.material.uniforms.mieCoefficient.value = effectController.mieCoefficient;\n      skyDome.material.uniforms.mieDirectionalG.value = effectController.mieDirectionalG;\n      skyDome.material.uniforms.up.value = new THREE.Vector3(); // no more necessary, estimate normal from cam..\n    }\n  }, {\n    key: \"setRealisticOn\",\n    value: function setRealisticOn(bool) {\n      var _this2 = this;\n\n      if (bool && !this.sky) {\n        this._initRealisticLighning();\n      }\n\n      this.basicAtmosphere.visible = !bool;\n      this.realisticAtmosphere.visible = bool;\n\n      if (bool) {\n        this.realisticLightingPosition = _CoordStars[\"default\"].getSunPositionInScene(new Date().getTime(), 48.85, 2.35).normalize();\n        this.realisticAtmosphere.children.forEach(function (obj) {\n          return obj.material.uniforms.v3LightPosition.value.copy(_this2.realisticLightingPosition);\n        });\n      }\n    }\n  }]);\n  return Atmosphere;\n}(_GeometryLayer2[\"default\"]);\n\nvar _default = Atmosphere;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/Globe/Atmosphere.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/Globe/BuilderEllipsoidTile.js":
/*!***************************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/Globe/BuilderEllipsoidTile.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../../Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _OBB2 = _interopRequireDefault(__webpack_require__(/*! ../../../Renderer/OBB */ \"./node_modules/itowns/lib/Renderer/OBB.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../../Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar PI_OV_FOUR = Math.PI / 4;\nvar INV_TWO_PI = 1.0 / (Math.PI * 2);\nvar axisZ = new THREE.Vector3(0, 0, 1);\nvar axisY = new THREE.Vector3(0, 1, 0);\nvar quatToAlignLongitude = new THREE.Quaternion();\nvar quatToAlignLatitude = new THREE.Quaternion();\nvar quatNormalToZ = new THREE.Quaternion();\n\nfunction WGS84ToOneSubY(latitude) {\n  return 1.0 - (0.5 - Math.log(Math.tan(PI_OV_FOUR + THREE.Math.degToRad(latitude) * 0.5)) * INV_TWO_PI);\n}\n\nvar BuilderEllipsoidTile =\n/*#__PURE__*/\nfunction () {\n  function BuilderEllipsoidTile() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2[\"default\"])(this, BuilderEllipsoidTile);\n    this.tmp = {\n      coords: [new _Coordinates[\"default\"]('EPSG:4326', 0, 0), new _Coordinates[\"default\"]('EPSG:4326', 0, 0)],\n      position: new THREE.Vector3(),\n      dimension: new THREE.Vector2()\n    };\n    this.projection = options.projection; // Order projection on tiles\n\n    this.uvCount = options.uvCount;\n    this.computeUvs = [// Normalized coordinates (from degree) on the entire tile\n    // EPSG:4326\n    function () {}, // Float row coordinate from Pseudo mercator coordinates\n    // EPSG:3857\n    function (params) {\n      var t = WGS84ToOneSubY(params.projected.latitude) * params.nbRow;\n      return (!isFinite(t) ? 0 : t) - params.deltaUV1;\n    }];\n  } // prepare params\n  // init projected object -> params.projected\n\n\n  (0, _createClass2[\"default\"])(BuilderEllipsoidTile, [{\n    key: \"prepare\",\n    value: function prepare(params) {\n      params.nbRow = Math.pow(2, params.level + 1.0);\n      var st1 = WGS84ToOneSubY(params.extent.south);\n\n      if (!isFinite(st1)) {\n        st1 = 0;\n      }\n\n      var sizeTexture = 1.0 / params.nbRow;\n      var start = st1 % sizeTexture;\n      params.deltaUV1 = (st1 - start) * params.nbRow; // transformation to align tile's normal to z axis\n\n      params.quatNormalToZ = quatNormalToZ.setFromAxisAngle(axisY, -(Math.PI * 0.5 - THREE.Math.degToRad(params.extent.center().latitude))); // let's avoid building too much temp objects\n\n      params.projected = {\n        longitude: 0,\n        latitude: 0\n      };\n      params.extent.dimensions(this.tmp.dimension);\n    } // get center tile in cartesian 3D\n\n  }, {\n    key: \"center\",\n    value: function center(extent) {\n      return extent.center(this.tmp.coords[0]).as(this.projection, this.tmp.coords[1]).toVector3();\n    } // get position 3D cartesian\n\n  }, {\n    key: \"vertexPosition\",\n    value: function vertexPosition(params) {\n      this.tmp.coords[0].setFromValues(params.projected.longitude, params.projected.latitude);\n      this.tmp.coords[0].as(this.projection, this.tmp.coords[1]).toVector3(this.tmp.position);\n      return this.tmp.position;\n    } // get normal for last vertex\n\n  }, {\n    key: \"vertexNormal\",\n    value: function vertexNormal() {\n      return this.tmp.coords[1].geodesicNormal;\n    } // coord u tile to projected\n\n  }, {\n    key: \"uProjecte\",\n    value: function uProjecte(u, params) {\n      params.projected.longitude = params.extent.west + u * this.tmp.dimension.x;\n    } // coord v tile to projected\n\n  }, {\n    key: \"vProjecte\",\n    value: function vProjecte(v, params) {\n      params.projected.latitude = params.extent.south + v * this.tmp.dimension.y;\n    }\n  }, {\n    key: \"computeSharableExtent\",\n    value: function computeSharableExtent(extent) {\n      // Compute sharable extent to pool the geometries\n      // the geometry in common extent is identical to the existing input\n      // with a transformation (translation, rotation)\n      // TODO: It should be possible to use equatorial plan symetrie,\n      // but we should be reverse UV on tile\n      // Common geometry is looking for only on longitude\n      var sizeLongitude = Math.abs(extent.west - extent.east) / 2;\n      var sharableExtent = new _Extent[\"default\"](extent.crs, -sizeLongitude, sizeLongitude, extent.south, extent.north); // compute rotation to transform tile to position it on ellipsoid\n      // this transformation take into account the transformation of the parents\n\n      var rotLon = THREE.Math.degToRad(extent.west - sharableExtent.west);\n      var rotLat = THREE.Math.degToRad(90 - extent.center(this.tmp.coords[0]).latitude);\n      quatToAlignLongitude.setFromAxisAngle(axisZ, rotLon);\n      quatToAlignLatitude.setFromAxisAngle(axisY, rotLat);\n      quatToAlignLongitude.multiply(quatToAlignLatitude);\n      return {\n        sharableExtent: sharableExtent,\n        quaternion: quatToAlignLongitude.clone(),\n        position: this.center(extent)\n      };\n    } // use for region for adaptation boundingVolume\n\n  }, {\n    key: \"OBB\",\n    value: function OBB(boundingBox) {\n      return new _OBB2[\"default\"](boundingBox.min, boundingBox.max);\n    }\n  }]);\n  return BuilderEllipsoidTile;\n}();\n\nvar _default = BuilderEllipsoidTile;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/Globe/BuilderEllipsoidTile.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/Globe/GlobeLayer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/Globe/GlobeLayer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ \"./node_modules/@babel/runtime/helpers/get.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _TiledGeometryLayer2 = _interopRequireDefault(__webpack_require__(/*! ../../../Layer/TiledGeometryLayer */ \"./node_modules/itowns/lib/Layer/TiledGeometryLayer.js\"));\n\nvar _Ellipsoid = __webpack_require__(/*! ../../Math/Ellipsoid */ \"./node_modules/itowns/lib/Core/Math/Ellipsoid.js\");\n\nvar _Extent = __webpack_require__(/*! ../../Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\");\n\nvar _BuilderEllipsoidTile = _interopRequireDefault(__webpack_require__(/*! ./BuilderEllipsoidTile */ \"./node_modules/itowns/lib/Core/Prefab/Globe/BuilderEllipsoidTile.js\"));\n\nvar _LayeredMaterialNodeProcessing = __webpack_require__(/*! ../../../Process/LayeredMaterialNodeProcessing */ \"./node_modules/itowns/lib/Process/LayeredMaterialNodeProcessing.js\");\n\n// matrix to convert sphere to ellipsoid\nvar worldToScaledEllipsoid = new THREE.Matrix4(); // camera's position in worldToScaledEllipsoid system\n\nvar cameraPosition = new THREE.Vector3();\nvar magnitudeSquared = 0.0; // vectors for operation purpose\n\nvar scaledHorizonCullingPoint = new THREE.Vector3();\n/**\n * @property {boolean} isGlobeLayer - Used to checkout whether this layer is a\n * GlobeLayer. Default is true. You should not change this, as it is used\n * internally for optimisation.\n */\n\nvar GlobeLayer =\n/*#__PURE__*/\nfunction (_TiledGeometryLayer) {\n  (0, _inherits2[\"default\"])(GlobeLayer, _TiledGeometryLayer);\n\n  /**\n   * A {@link TiledGeometryLayer} to use with a {@link GlobeView}. It has\n   * specific method for updating and subdivising its grid.\n   *\n   * @constructor\n   * @extends TiledGeometryLayer\n   *\n   * @param {string} id - The id of the layer, that should be unique. It is\n   * not mandatory, but an error will be emitted if this layer is added a\n   * {@link View} that already has a layer going by that id.\n   * @param {THREE.Object3d} [object3d=THREE.Group] - The object3d used to\n   * contain the geometry of the TiledGeometryLayer. It is usually a\n   * `THREE.Group`, but it can be anything inheriting from a `THREE.Object3d`.\n   * @param {Object} [config] - Optional configuration, all elements in it\n   * will be merged as is in the layer. For example, if the configuration\n   * contains three elements `name, protocol, extent`, these elements will be\n   * available using `layer.name` or something else depending on the property\n   * name.\n   * @param {number} [config.minSubdivisionLevel=2] - Minimum subdivision\n   * level for this tiled layer.\n   * @param {number} [config.maxSubdivisionLevel=18] - Maximum subdivision\n   * level for this tiled layer.\n   * @param {number} [config.sseSubdivisionThreshold=1] - Threshold level for\n   * the SSE.\n   * @param {number} [config.maxDeltaElevationLevel=4] - Maximum delta between\n   * two elevations tile.\n   *\n   * @throws {Error} `object3d` must be a valid `THREE.Object3d`.\n   */\n  function GlobeLayer(id, object3d) {\n    var _this;\n\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2[\"default\"])(this, GlobeLayer);\n\n    // Configure tiles\n    var scheme = _Extent.schemeTiles.get('WMTS:WGS84');\n\n    var schemeTile = _Extent.globalExtentTMS.get('EPSG:4326').subdivisionByScheme(scheme); // Supported tile matrix set for color/elevation layer\n\n\n    config.tileMatrixSets = ['WMTS:WGS84', 'WMTS:PM'];\n    var uvCount = config.tileMatrixSets.length;\n    var builder = new _BuilderEllipsoidTile[\"default\"]({\n      projection: 'EPSG:4978',\n      uvCount: uvCount\n    });\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(GlobeLayer).call(this, id, object3d || new THREE.Group(), schemeTile, builder, config));\n    _this.isGlobeLayer = true;\n    _this.options.defaultPickingRadius = 5;\n    _this.minSubdivisionLevel = _this.minSubdivisionLevel || 2.0;\n    _this.maxSubdivisionLevel = _this.maxSubdivisionLevel || 19.0;\n    _this.maxDeltaElevation = _this.maxDeltaElevation || 4.0;\n    _this.extent = _this.schemeTile[0].clone();\n\n    for (var i = 1; i < _this.schemeTile.length; i++) {\n      _this.extent.union(_this.schemeTile[i]);\n    } // We're going to use the method described here:\n    //    https://cesiumjs.org/2013/04/25/Horizon-culling/\n    // This method assumes that the globe is a unit sphere at 0,0,0 so\n    // we setup a world-to-scaled-ellipsoid matrix4\n\n\n    worldToScaledEllipsoid.getInverse(_this.object3d.matrixWorld);\n    worldToScaledEllipsoid.premultiply(new THREE.Matrix4().makeScale(1 / _Ellipsoid.ellipsoidSizes.x, 1 / _Ellipsoid.ellipsoidSizes.y, 1 / _Ellipsoid.ellipsoidSizes.z));\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(GlobeLayer, [{\n    key: \"preUpdate\",\n    value: function preUpdate(context, changeSources) {\n      // pre-horizon culling\n      cameraPosition.copy(context.camera.camera3D.position).applyMatrix4(worldToScaledEllipsoid);\n      magnitudeSquared = cameraPosition.lengthSq() - 1.0;\n      return (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(GlobeLayer.prototype), \"preUpdate\", this).call(this, context, changeSources);\n    }\n  }, {\n    key: \"countColorLayersTextures\",\n    value: function countColorLayersTextures() {\n      var occupancy = 0;\n\n      for (var _len = arguments.length, layers = new Array(_len), _key = 0; _key < _len; _key++) {\n        layers[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _layers = layers; _i < _layers.length; _i++) {\n        var layer = _layers[_i];\n        var projection = layer.projection || layer.source.projection; // 'EPSG:3857' occupies the maximum 3 textures on tiles\n        // 'EPSG:4326' occupies 1 textures on tile\n\n        occupancy += projection == 'EPSG:3857' ? 3 : 1;\n      }\n\n      return occupancy;\n    }\n  }, {\n    key: \"culling\",\n    value: function culling(node, camera) {\n      if ((0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(GlobeLayer.prototype), \"culling\", this).call(this, node, camera)) {\n        return true;\n      }\n\n      if (node.level < this.minSubdivisionLevel) {\n        return false;\n      } // see https://cesiumjs.org/2013/04/25/Horizon-culling/\n\n\n      scaledHorizonCullingPoint.copy(node.horizonCullingPointElevationScaled).applyMatrix4(worldToScaledEllipsoid);\n      scaledHorizonCullingPoint.sub(cameraPosition);\n      var vtMagnitudeSquared = scaledHorizonCullingPoint.lengthSq();\n      var dot = -scaledHorizonCullingPoint.dot(cameraPosition);\n      var isOccluded = magnitudeSquared < 0 ? dot > 0 : magnitudeSquared < dot && magnitudeSquared < dot * dot / vtMagnitudeSquared;\n      return isOccluded;\n    }\n  }, {\n    key: \"computeTileZoomFromDistanceCamera\",\n    value: function computeTileZoomFromDistanceCamera(distance, camera) {\n      var preSinus = _LayeredMaterialNodeProcessing.SIZE_DIAGONAL_TEXTURE * (this.sseSubdivisionThreshold * 0.5) / camera._preSSE / _Ellipsoid.ellipsoidSizes.x;\n      var sinus = distance * preSinus;\n      var zoom = Math.log(Math.PI / (2.0 * Math.asin(sinus))) / Math.log(2);\n      var delta = Math.PI / Math.pow(2, zoom);\n      var circleChord = 2.0 * _Ellipsoid.ellipsoidSizes.x * Math.sin(delta * 0.5);\n      // adjust with bounding sphere rayon\n      sinus = (distance - circleChord * 0.5) * preSinus;\n      zoom = Math.log(Math.PI / (2.0 * Math.asin(sinus))) / Math.log(2);\n      return isNaN(zoom) ? 0 : Math.round(zoom);\n    }\n  }, {\n    key: \"computeDistanceCameraFromTileZoom\",\n    value: function computeDistanceCameraFromTileZoom(zoom, camera) {\n      var delta = Math.PI / Math.pow(2, zoom);\n      var circleChord = 2.0 * _Ellipsoid.ellipsoidSizes.x * Math.sin(delta * 0.5);\n      var radius = circleChord * 0.5;\n      return camera._preSSE * (radius / _LayeredMaterialNodeProcessing.SIZE_DIAGONAL_TEXTURE) / (this.sseSubdivisionThreshold * 0.5) + radius;\n    }\n  }]);\n  return GlobeLayer;\n}(_TiledGeometryLayer2[\"default\"]);\n\nvar _default = GlobeLayer;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/Globe/GlobeLayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/Globe/SkyShader.js":
/*!****************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/Globe/SkyShader.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\n/**\n * @author zz85 / https://github.com/zz85\n *\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n */\nvar skyShader = {\n  uniforms: {\n    luminance: {\n      type: 'f',\n      value: 1\n    },\n    turbidity: {\n      type: 'f',\n      value: 2\n    },\n    reileigh: {\n      type: 'f',\n      value: 1\n    },\n    mieCoefficient: {\n      type: 'f',\n      value: 0.005\n    },\n    mieDirectionalG: {\n      type: 'f',\n      value: 0.8\n    },\n    v3LightPosition: {\n      type: 'v3',\n      value: new THREE.Vector3()\n    },\n    up: {\n      type: 'v3',\n      value: new THREE.Vector3(0.0, 1.0, 0.0)\n    }\n  },\n  vertexShader: ['varying vec3 vWorldPosition;', 'void main() {', 'vec4 worldPosition = modelMatrix *  vec4( cameraPosition + position, 1.0 );', 'vWorldPosition = worldPosition.xyz;', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( cameraPosition + position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D skySampler;', 'uniform vec3 v3LightPosition;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', // \"vec3 cameraPos = cameraPosition; //vec3(0., 0., 0.);\",\n  '// uniform sampler2D sDiffuse;', '// const float turbidity = 10.0; //', '// const float reileigh = 2.; //', '// const float luminance = 1.0; //', '// const float mieCoefficient = 0.005;', '// const float mieDirectionalG = 0.8;', 'uniform float luminance;', 'uniform float turbidity;', 'uniform float reileigh;', 'uniform float mieCoefficient;', 'uniform float mieDirectionalG;', '// constants for atmospheric scattering', 'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003; // refractive index of air', 'const float N = 2.545E25; // number of molecules per unit volume for air at', '// 288.15K and 1013mb (sea level -45 celsius)', 'const float pn = 0.035; // depolatization factor for standard air', '// wavelength of used primaries, according to preetham', 'const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);', '// mie stuff', '// K coefficient for the primaries', 'const vec3 K = vec3(0.686, 0.678, 0.666);', 'const float v = 4.0;', '// optical length at zenith for molecules', 'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // \"const vec3 up = vec3(0.0, 1.0, 0.0);\",\n  'const float EE = 1000.0;', 'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', '// 66 arc seconds -> degrees, and the cosine of that', '// earth shadow hack', 'const float cutoffAngle = pi/1.95;', 'const float steepness = 1.5;', 'vec3 totalRayleigh(vec3 lambda)', '{', 'return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));', '}', // see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness\n  '// A simplied version of the total Reayleigh scattering to works on browsers that use ANGLE', 'vec3 simplifiedRayleigh()', '{', 'return 0.0005 / vec3(94, 40, 18);', // return 0.00054532832366 / (3.0 * 2.545E25 * pow(vec3(680E-9, 550E-9, 450E-9), vec3(4.0)) * 6.245);\n  '}', 'float rayleighPhase(float cosTheta)', '{ ', 'return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));', '// return (1.0 / (3.0*pi)) * (1.0 + pow(cosTheta, 2.0));', '// return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));', '}', 'vec3 totalMie(vec3 lambda, vec3 K, float T)', '{', 'float c = (0.2 * T ) * 10E-18;', 'return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;', '}', 'float hgPhase(float cosTheta, float g)', '{', 'return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));', '}', 'float sunIntensity(float zenithAngleCos)', '{', 'return EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));', '}', '// float logLuminance(vec3 c)', '// {', '//     return log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);', '// }', '// Filmic ToneMapping http://filmicgames.com/archives/75', 'float A = 0.15;', 'float B = 0.50;', 'float C = 0.10;', 'float D = 0.20;', 'float E = 0.02;', 'float F = 0.30;', 'float W = 1000.0;', 'vec3 Uncharted2Tonemap(vec3 x)', '{', 'return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;', '}', 'void main() ', '{', 'vec3 up2 = normalize(cameraPosition.xyz);', 'float sunfade = 1.0-clamp(1.0-exp((v3LightPosition.y/450000.0)),0.0,1.0);', 'float reileighCoefficient = reileigh - (1.0* (1.0-sunfade));', 'vec3 sunDirection = normalize(v3LightPosition);', 'float sunE = sunIntensity(dot(sunDirection, up2));', '// extinction (absorbtion + out scattering) ', '// rayleigh coefficients', // \"vec3 betaR = totalRayleigh(lambda) * reileighCoefficient;\",\n  'vec3 betaR = simplifiedRayleigh() * reileighCoefficient;', '// mie coefficients', 'vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;', '// optical length', '// cutoff angle at 90 to avoid singularity in next formula.', 'float zenithAngle = acos(max(0.0, dot(up2, normalize(vWorldPosition - cameraPosition))));', 'float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));', 'float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));', '// combined extinction factor', 'vec3 Fex = exp(-(betaR * sR + betaM * sM));', '// in scattering', 'float cosTheta = dot(normalize(vWorldPosition - cameraPosition), sunDirection);', 'float rPhase = rayleighPhase(cosTheta*0.5+0.5);', 'vec3 betaRTheta = betaR * rPhase;', 'float mPhase = hgPhase(cosTheta, mieDirectionalG);', 'vec3 betaMTheta = betaM * mPhase;', 'vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));', 'Lin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up2, sunDirection),5.0),0.0,1.0));', '//nightsky', 'vec3 direction = normalize(vWorldPosition - cameraPosition);', 'float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]', 'float phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]', 'vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);', '// vec3 L0 = texture2D(skySampler, uv).rgb+0.1 * Fex;', 'vec3 L0 = vec3(0.1) * Fex;', '// composition + solar disc', '//if (cosTheta > sunAngularDiameterCos)', 'float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);', '// if (normalize(vWorldPosition - cameraPosition).y>0.0)', 'L0 += (sunE * 19000.0 * Fex)*sundisk;', 'vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));', 'vec3 texColor = (Lin+L0);   ', 'texColor *= 0.04 ;', 'texColor += vec3(0.0,0.001,0.0025)*0.3;', 'float g_fMaxLuminance = 1.0;', 'float fLumScaled = 0.1 / luminance;     ', 'float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); ', 'float ExposureBias = fLumCompressed;', 'vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);', 'vec3 color = curr*whiteScale;', 'vec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));', 'gl_FragColor.rgb = retColor;', 'gl_FragColor.a = 1. - ( (length(cameraPosition) - 6400000.) / 1000.);', '}'].join('\\n')\n};\n\nvar Sky =\n/*#__PURE__*/\nfunction (_THREE$Mesh) {\n  (0, _inherits2[\"default\"])(Sky, _THREE$Mesh);\n\n  function Sky() {\n    (0, _classCallCheck2[\"default\"])(this, Sky);\n    var skyUniforms = THREE.UniformsUtils.clone(skyShader.uniforms);\n    var skyMat = new THREE.ShaderMaterial({\n      fragmentShader: skyShader.fragmentShader,\n      vertexShader: skyShader.vertexShader,\n      uniforms: skyUniforms,\n      side: THREE.BackSide,\n      transparent: true,\n      depthWrite: false\n    });\n    var skyGeo = new THREE.SphereBufferGeometry(40000, 32, 15);\n    return (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Sky).call(this, skyGeo, skyMat));\n  }\n\n  return Sky;\n}(THREE.Mesh);\n\nvar _default = Sky;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/Globe/SkyShader.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/GlobeView.js":
/*!**********************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/GlobeView.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.GLOBE_VIEW_EVENTS = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ \"./node_modules/@babel/runtime/helpers/get.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _View2 = _interopRequireWildcard(__webpack_require__(/*! ../View */ \"./node_modules/itowns/lib/Core/View.js\"));\n\nvar _GlobeControls = _interopRequireDefault(__webpack_require__(/*! ../../Controls/GlobeControls */ \"./node_modules/itowns/lib/Controls/GlobeControls.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _GlobeLayer = _interopRequireDefault(__webpack_require__(/*! ./Globe/GlobeLayer */ \"./node_modules/itowns/lib/Core/Prefab/Globe/GlobeLayer.js\"));\n\nvar _Atmosphere = _interopRequireDefault(__webpack_require__(/*! ./Globe/Atmosphere */ \"./node_modules/itowns/lib/Core/Prefab/Globe/Atmosphere.js\"));\n\nvar _CameraUtils = _interopRequireDefault(__webpack_require__(/*! ../../Utils/CameraUtils */ \"./node_modules/itowns/lib/Utils/CameraUtils.js\"));\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ../Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\nvar _Ellipsoid = __webpack_require__(/*! ../Math/Ellipsoid */ \"./node_modules/itowns/lib/Core/Math/Ellipsoid.js\");\n\n/**\n * Fires when the view is completely loaded. Controls and view's functions can be called then.\n * @event GlobeView#initialized\n * @property target {view} dispatched on view\n * @property type {string} initialized\n */\n\n/**\n * Fires when a layer is added\n * @event GlobeView#layer-added\n * @property layerId {string} the id of the layer\n * @property target {view} dispatched on view\n * @property type {string} layers-added\n */\n\n/**\n * Fires when a layer is removed\n * @event GlobeView#layer-removed\n * @property layerId {string} the id of the layer\n * @property target {view} dispatched on view\n * @property type {string} layers-added\n */\n\n/**\n * Fires when the layers oder has changed\n * @event GlobeView#layers-order-changed\n * @property new {object}\n * @property new.sequence {array}\n * @property new.sequence.0 {number} the new layer at position 0\n * @property new.sequence.1 {number} the new layer at position 1\n * @property new.sequence.2 {number} the new layer at position 2\n * @property previous {object}\n * @property previous.sequence {array}\n * @property previous.sequence.0 {number} the previous layer at position 0\n * @property previous.sequence.1 {number} the previous layer at position 1\n * @property previous.sequence.2 {number} the previous layer at position 2\n * @property target {view} dispatched on view\n * @property type {string} layers-order-changed\n */\n\n/**\n * Globe's EVENT\n * @property GLOBE_INITIALIZED {string} Deprecated: emit one time when globe is initialized (use VIEW_EVENTS.INITIALIZED instead).\n * @property LAYER_ADDED {string} Deprecated: emit when layer id added in viewer (use VIEW_EVENTS.LAYER_ADDED instead).\n * @property LAYER_REMOVED {string} Deprecated: emit when layer id removed in viewer (use VIEW_EVENTS.LAYER_REMOVED instead).\n * @property COLOR_LAYERS_ORDER_CHANGED {string} Deprecated: emit when  color layers order change (use VIEW_EVENTS.COLOR_LAYERS_ORDER_CHANGED instead).\n */\nvar GLOBE_VIEW_EVENTS = {\n  GLOBE_INITIALIZED: _View2.VIEW_EVENTS.INITIALIZED,\n  LAYER_ADDED: _View2.VIEW_EVENTS.LAYER_ADDED,\n  LAYER_REMOVED: _View2.VIEW_EVENTS.LAYER_REMOVED,\n  COLOR_LAYERS_ORDER_CHANGED: _View2.VIEW_EVENTS.COLOR_LAYERS_ORDER_CHANGED\n};\nexports.GLOBE_VIEW_EVENTS = GLOBE_VIEW_EVENTS;\n\nvar GlobeView =\n/*#__PURE__*/\nfunction (_View) {\n  (0, _inherits2[\"default\"])(GlobeView, _View);\n\n  /**\n   * Creates a view of a globe.\n   *\n   * @constructor\n   *\n   * @example\n   * var viewerDiv = document.getElementById('viewerDiv');\n   * var position = new itowns.Coordinates('WGS84', 2.35, 48.8, 25e6);\n   * var view = new itowns.GlobeView(viewerDiv, position);\n   *\n   * @example\n   * var viewerDiv = document.getElementById('viewerDiv');\n   * var position = { longitude: 2.35, latitude: 48.8, altitude: 25e6 };\n   * var view = new itowns.GlobeView(viewerDiv, position);\n   *\n   * @param {HTMLDivElement} viewerDiv - Where to attach the view and display it\n   * in the DOM.\n   * @param {CameraTransformOptions} placement - An object to place view\n   * @param {object=} options - See options of {@link View}.\n   */\n  function GlobeView(viewerDiv) {\n    var _this;\n\n    var placement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2[\"default\"])(this, GlobeView);\n    THREE.Object3D.DefaultUp.set(0, 0, 1); // Setup View\n\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(GlobeView).call(this, 'EPSG:4978', viewerDiv, options));\n    _this.isGlobeView = true;\n    _this.camera.camera3D.near = Math.max(15.0, 0.000002352 * _Ellipsoid.ellipsoidSizes.x);\n    _this.camera.camera3D.far = _Ellipsoid.ellipsoidSizes.x * 10;\n    var tileLayer = new _GlobeLayer[\"default\"]('globe', options.object3d, options);\n    var sun = new THREE.DirectionalLight();\n    sun.position.set(-0.5, 0, 1);\n    sun.updateMatrixWorld(true);\n    tileLayer.object3d.add(sun);\n\n    _this.addLayer(tileLayer);\n\n    _this.tileLayer = tileLayer;\n    placement.coord = placement.coord || new _Coordinates[\"default\"]('EPSG:4326', 0, 0);\n    placement.tilt = placement.tilt || 89.5;\n    placement.heading = placement.heading || 0;\n    placement.range = placement.range || _Ellipsoid.ellipsoidSizes.x * 2.0;\n\n    if (options.noControls) {\n      _CameraUtils[\"default\"].transformCameraToLookAtTarget((0, _assertThisInitialized2[\"default\"])(_this), _this.camera.camera3D, placement);\n    } else {\n      _this.controls = new _GlobeControls[\"default\"]((0, _assertThisInitialized2[\"default\"])(_this), placement);\n      _this.controls.handleCollision = typeof options.handleCollision !== 'undefined' ? options.handleCollision : true;\n    }\n\n    _this.addLayer(new _Atmosphere[\"default\"]()); // GlobeView needs this.camera.resize to set perpsective matrix camera\n\n\n    _this.camera.resize(viewerDiv.clientWidth, viewerDiv.clientHeight);\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(GlobeView, [{\n    key: \"addLayer\",\n    value: function addLayer(layer) {\n      if (!layer) {\n        return new Promise(function (resolve, reject) {\n          return reject(new Error('layer is undefined'));\n        });\n      }\n\n      if (layer.isColorLayer) {\n        var colorLayerCount = this.getLayers(function (l) {\n          return l.isColorLayer;\n        }).length;\n        layer.sequence = colorLayerCount;\n\n        if (!this.tileLayer.tileMatrixSets.includes(_Crs[\"default\"].formatToTms(layer.source.projection))) {\n          throw new Error(\"Only \".concat(this.tileLayer.tileMatrixSets, \" tileMatrixSet are currently supported for color layers\"));\n        }\n      } else if (layer.isElevationLayer) {\n        if (_Crs[\"default\"].formatToTms(layer.source.projection) !== this.tileLayer.tileMatrixSets[0]) {\n          throw new Error(\"Only \".concat(this.tileLayer.tileMatrixSets[0], \" tileMatrixSet is currently supported for elevation layers\"));\n        }\n      }\n\n      return (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(GlobeView.prototype), \"addLayer\", this).call(this, layer, this.tileLayer);\n    }\n  }, {\n    key: \"getPixelsToDegrees\",\n    value: function getPixelsToDegrees() {\n      var pixels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var screenCoord = arguments.length > 1 ? arguments[1] : undefined;\n      return this.getMetersToDegrees(this.getPixelsToMeters(pixels, screenCoord));\n    }\n  }, {\n    key: \"getPixelsToDegreesFromDistance\",\n    value: function getPixelsToDegreesFromDistance() {\n      var pixels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this.getMetersToDegrees(this.getPixelsToMetersFromDistance(pixels, distance));\n    }\n  }, {\n    key: \"getMetersToDegrees\",\n    value: function getMetersToDegrees() {\n      var meters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      return THREE.Math.radToDeg(2 * Math.asin(meters / (2 * _Ellipsoid.ellipsoidSizes.x)));\n    }\n  }]);\n  return GlobeView;\n}(_View2[\"default\"]);\n\nvar _default = GlobeView;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/GlobeView.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/Planar/PlanarLayer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/Planar/PlanarLayer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _TiledGeometryLayer2 = _interopRequireDefault(__webpack_require__(/*! ../../../Layer/TiledGeometryLayer */ \"./node_modules/itowns/lib/Layer/TiledGeometryLayer.js\"));\n\nvar _Extent = __webpack_require__(/*! ../../Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\");\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ../../Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\nvar _PlanarTileBuilder = _interopRequireDefault(__webpack_require__(/*! ./PlanarTileBuilder */ \"./node_modules/itowns/lib/Core/Prefab/Planar/PlanarTileBuilder.js\"));\n\n/**\n * @property {boolean} isPlanarLayer - Used to checkout whether this layer is a\n * PlanarLayer. Default is true. You should not change this, as it is used\n * internally for optimisation.\n */\nvar PlanarLayer =\n/*#__PURE__*/\nfunction (_TiledGeometryLayer) {\n  (0, _inherits2[\"default\"])(PlanarLayer, _TiledGeometryLayer);\n\n  /**\n   * A {@link TiledGeometryLayer} to use with a {@link PlanarView}. It has\n   * specific method for updating and subdivising its grid.\n   *\n   * @constructor\n   * @extends TiledGeometryLayer\n   *\n   * @param {string} id - The id of the layer, that should be unique. It is\n   * not mandatory, but an error will be emitted if this layer is added a\n   * {@link View} that already has a layer going by that id.\n   * @param {Extent} extent - The extent to define the layer within.\n   * @param {THREE.Object3d} [object3d=THREE.Group] - The object3d used to\n   * contain the geometry of the TiledGeometryLayer. It is usually a\n   * `THREE.Group`, but it can be anything inheriting from a `THREE.Object3d`.\n   * @param {Object} [config] - Optional configuration, all elements in it\n   * will be merged as is in the layer. For example, if the configuration\n   * contains three elements `name, protocol, extent`, these elements will be\n   * available using `layer.name` or something else depending on the property\n   * name.\n   * @param {number} [config.maxSubdivisionLevel=5] - Maximum subdivision\n   * level for this tiled layer.\n   * @param {number} [config.maxDeltaElevationLevel=4] - Maximum delta between\n   * two elevations tile.\n   *\n   * @throws {Error} `object3d` must be a valid `THREE.Object3d`.\n   */\n  function PlanarLayer(id, extent, object3d) {\n    var _this;\n\n    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    (0, _classCallCheck2[\"default\"])(this, PlanarLayer);\n    var tileMatrixSets = [];\n\n    var tms = _Crs[\"default\"].formatToTms(extent.crs);\n\n    tileMatrixSets.push(tms);\n\n    if (tms.includes(':TMS')) {\n      // Add new global extent for this new projection.\n      _Extent.globalExtentTMS.set(extent.crs, extent);\n    }\n\n    config.tileMatrixSets = tileMatrixSets;\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(PlanarLayer).call(this, id, object3d || new THREE.Group(), [extent], new _PlanarTileBuilder[\"default\"]({\n      projection: extent.crs\n    }), config));\n    _this.isPlanarLayer = true;\n    _this.extent = extent;\n    _this.minSubdivisionLevel = _this.minSubdivisionLevel || 0;\n    _this.maxSubdivisionLevel = _this.maxSubdivisionLevel || 5.0;\n    _this.maxDeltaElevation = _this.maxDeltaElevation || 4.0;\n    return _this;\n  }\n\n  return PlanarLayer;\n}(_TiledGeometryLayer2[\"default\"]);\n\nvar _default = PlanarLayer;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/Planar/PlanarLayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/Planar/PlanarTileBuilder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/Planar/PlanarTileBuilder.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _OBB2 = _interopRequireDefault(__webpack_require__(/*! ../../../Renderer/OBB */ \"./node_modules/itowns/lib/Renderer/OBB.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../../Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../../Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar quaternion = new THREE.Quaternion();\n\nvar _center = new THREE.Vector3();\n\nvar PlanarTileBuilder =\n/*#__PURE__*/\nfunction () {\n  function PlanarTileBuilder() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2[\"default\"])(this, PlanarTileBuilder);\n\n    if (options.projection) {\n      this.projection = options.projection;\n    } else {\n      throw new Error('options.projection is mandatory for PlanarTileBuilder');\n    }\n\n    this.tmp = {\n      coords: new _Coordinates[\"default\"]('EPSG:4326', 0, 0),\n      position: new THREE.Vector3(),\n      normal: new THREE.Vector3(0, 0, 1)\n    };\n    this.uvCount = options.uvCount || 1;\n  } // prepare params\n  // init projected object -> params.projected\n\n\n  (0, _createClass2[\"default\"])(PlanarTileBuilder, [{\n    key: \"prepare\",\n    value: function prepare(params) {\n      params.nbRow = Math.pow(2, params.zoom + 1.0);\n      params.projected = new THREE.Vector3();\n    } // get center tile in cartesian 3D\n\n  }, {\n    key: \"center\",\n    value: function center(extent) {\n      extent.center(this.tmp.coords);\n\n      _center.set(this.tmp.coords.x, this.tmp.coords.y, 0);\n\n      return _center;\n    } // get position 3D cartesian\n\n  }, {\n    key: \"vertexPosition\",\n    value: function vertexPosition(params) {\n      this.tmp.position.set(params.projected.x, params.projected.y, 0);\n      return this.tmp.position;\n    } // get normal for last vertex\n\n  }, {\n    key: \"vertexNormal\",\n    value: function vertexNormal() {\n      return this.tmp.normal;\n    } // coord u tile to projected\n\n  }, {\n    key: \"uProjecte\",\n    value: function uProjecte(u, params) {\n      params.projected.x = params.extent.west + u * (params.extent.east - params.extent.west);\n    } // coord v tile to projected\n\n  }, {\n    key: \"vProjecte\",\n    value: function vProjecte(v, params) {\n      params.projected.y = params.extent.south + v * (params.extent.north - params.extent.south);\n    } // get oriented bounding box of tile\n\n  }, {\n    key: \"OBB\",\n    value: function OBB(boundingBox) {\n      return new _OBB2[\"default\"](boundingBox.min, boundingBox.max);\n    }\n  }, {\n    key: \"computeSharableExtent\",\n    value: function computeSharableExtent(extent) {\n      // compute sharable extent to pool the geometries\n      // the geometry in common extent is identical to the existing input\n      // with a translation\n      var sharableExtent = new _Extent[\"default\"](extent.crs, 0, Math.abs(extent.west - extent.east), 0, Math.abs(extent.north - extent.south));\n      return {\n        sharableExtent: sharableExtent,\n        quaternion: quaternion,\n        position: this.center(extent).clone()\n      };\n    }\n  }]);\n  return PlanarTileBuilder;\n}();\n\nvar _default = PlanarTileBuilder;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/Planar/PlanarTileBuilder.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/PlanarView.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/PlanarView.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ \"./node_modules/@babel/runtime/helpers/get.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _View2 = _interopRequireDefault(__webpack_require__(/*! ../View */ \"./node_modules/itowns/lib/Core/View.js\"));\n\nvar _CameraUtils = _interopRequireDefault(__webpack_require__(/*! ../../Utils/CameraUtils */ \"./node_modules/itowns/lib/Utils/CameraUtils.js\"));\n\nvar _PlanarLayer = _interopRequireDefault(__webpack_require__(/*! ./Planar/PlanarLayer */ \"./node_modules/itowns/lib/Core/Prefab/Planar/PlanarLayer.js\"));\n\nvar PlanarView =\n/*#__PURE__*/\nfunction (_View) {\n  (0, _inherits2[\"default\"])(PlanarView, _View);\n\n  function PlanarView(viewerDiv, extent) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2[\"default\"])(this, PlanarView);\n    THREE.Object3D.DefaultUp.set(0, 0, 1); // Setup View\n\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(PlanarView).call(this, extent.crs, viewerDiv, options));\n    _this.isPlanarView = true; // Configure camera\n\n    var dim = extent.dimensions();\n    var max = Math.max(dim.x, dim.y);\n    var camera3D = _this.camera.camera3D;\n    camera3D.near = 0.1;\n    camera3D.far = 2 * max;\n\n    _this.camera.camera3D.updateProjectionMatrix();\n\n    var tileLayer = new _PlanarLayer[\"default\"]('planar', extent, options.object3d, options);\n\n    _this.addLayer(tileLayer);\n\n    var placement = options.placement || {};\n    placement.coord = placement.coord || extent.center();\n    placement.tilt = placement.tilt || 90;\n    placement.heading = placement.heading || 0;\n    placement.range = placement.range || max;\n\n    _CameraUtils[\"default\"].transformCameraToLookAtTarget((0, _assertThisInitialized2[\"default\"])(_this), camera3D, placement);\n\n    _this.tileLayer = tileLayer;\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(PlanarView, [{\n    key: \"addLayer\",\n    value: function addLayer(layer) {\n      return (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PlanarView.prototype), \"addLayer\", this).call(this, layer, this.tileLayer);\n    }\n  }]);\n  return PlanarView;\n}(_View2[\"default\"]);\n\nvar _default = PlanarView;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/PlanarView.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/TileBuilder.js":
/*!************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/TileBuilder.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = newTileGeometry;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _TileGeometry = _interopRequireDefault(__webpack_require__(/*! ../TileGeometry */ \"./node_modules/itowns/lib/Core/TileGeometry.js\"));\n\nvar _Cache = _interopRequireDefault(__webpack_require__(/*! ../Scheduler/Cache */ \"./node_modules/itowns/lib/Core/Scheduler/Cache.js\"));\n\nvar _computeBufferTileGeometry = _interopRequireDefault(__webpack_require__(/*! ./computeBufferTileGeometry */ \"./node_modules/itowns/lib/Core/Prefab/computeBufferTileGeometry.js\"));\n\nvar cacheBuffer = new Map();\n\nfunction newTileGeometry(builder, params) {\n  var _builder$computeShara = builder.computeSharableExtent(params.extent),\n      sharableExtent = _builder$computeShara.sharableExtent,\n      quaternion = _builder$computeShara.quaternion,\n      position = _builder$computeShara.position;\n\n  var south = sharableExtent.south.toFixed(6);\n  var bufferKey = \"\".concat(builder.projection, \"_\").concat(params.disableSkirt ? 0 : 1, \"_\").concat(params.segment);\n\n  var promiseGeometry = _Cache[\"default\"].get(bufferKey, params.level, south); // build geometry if doesn't exist\n\n\n  if (!promiseGeometry) {\n    var resolve;\n    promiseGeometry = new Promise(function (r) {\n      resolve = r;\n    });\n\n    _Cache[\"default\"].set(promiseGeometry, _Cache[\"default\"].POLICIES.INFINITE, bufferKey, params.level, south);\n\n    params.extent = sharableExtent;\n    params.center = builder.center(params.extent).clone(); // Read previously cached values (index and uv.wgs84 only depend on the # of triangles)\n\n    var cachedBuffers = cacheBuffer.get(bufferKey);\n    params.buildIndexAndUv_0 = !cachedBuffers;\n    params.builder = builder;\n    return Promise.resolve((0, _computeBufferTileGeometry[\"default\"])(params)).then(function (buffers) {\n      if (!cachedBuffers) {\n        cachedBuffers = {};\n        cachedBuffers.index = new THREE.BufferAttribute(buffers.index, 1);\n        cachedBuffers.uv = new THREE.BufferAttribute(buffers.uvs[0], 2); // Update cacheBuffer\n\n        cacheBuffer.set(bufferKey, cachedBuffers);\n      }\n\n      buffers.index = cachedBuffers.index;\n      buffers.uvs[0] = cachedBuffers.uv;\n      buffers.position = new THREE.BufferAttribute(buffers.position, 3);\n      buffers.normal = new THREE.BufferAttribute(buffers.normal, 3);\n\n      if (params.builder.uvCount > 1) {\n        buffers.uvs[1] = new THREE.BufferAttribute(buffers.uvs[1], 1);\n      }\n\n      var geometry = new _TileGeometry[\"default\"](params, buffers);\n      geometry.OBB = builder.OBB(geometry.boundingBox);\n      geometry._count = 0;\n\n      geometry.dispose = function () {\n        geometry._count--;\n\n        if (geometry._count == 0) {\n          THREE.BufferGeometry.prototype.dispose.call(geometry);\n\n          _Cache[\"default\"][\"delete\"](bufferKey, params.level, south);\n        }\n      };\n\n      resolve(geometry);\n      return {\n        geometry: geometry,\n        quaternion: quaternion,\n        position: position\n      };\n    });\n  }\n\n  return promiseGeometry.then(function (geometry) {\n    return {\n      geometry: geometry,\n      quaternion: quaternion,\n      position: position\n    };\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/TileBuilder.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Prefab/computeBufferTileGeometry.js":
/*!**************************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Prefab/computeBufferTileGeometry.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = computeBuffers;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nfunction computeBuffers(params) {\n  // Create output buffers.\n  var outBuffers = {\n    index: null,\n    position: null,\n    normal: null,\n    // 2 UV set per tile: wgs84 (uv_0) and pm (uv_1)\n    //    - wgs84: 1 texture per tile because tiles are using wgs84 projection\n    //    - pm: use multiple textures per tile.\n    //      +-------------------------+\n    //      |                         |\n    //      |     Texture 0           |\n    //      +-------------------------+\n    //      |                         |\n    //      |     Texture 1           |\n    //      +-------------------------+\n    //      |                         |\n    //      |     Texture 2           |\n    //      +-------------------------+\n    //        * u = wgs84.u\n    //        * v = textureid + v in builder texture\n    uvs: []\n  };\n  var computeUvs = [];\n  var builder = params.builder;\n  var nSeg = params.segment; // segments count :\n  // Tile : (nSeg + 1) * (nSeg + 1)\n  // Skirt : 8 * (nSeg - 1)\n\n  var nVertex = (nSeg + 1) * (nSeg + 1) + (params.disableSkirt ? 0 : 4 * nSeg);\n  var triangles = nSeg * nSeg * 2 + (params.disableSkirt ? 0 : 4 * nSeg * 2);\n  outBuffers.position = new Float32Array(nVertex * 3);\n  outBuffers.normal = new Float32Array(nVertex * 3);\n  var uvCount = params.builder.uvCount;\n\n  if (uvCount > 1) {\n    outBuffers.uvs[1] = new Float32Array(nVertex);\n  }\n\n  computeUvs[0] = function () {};\n\n  if (params.buildIndexAndUv_0) {\n    outBuffers.index = new Uint32Array(triangles * 3);\n    outBuffers.uvs[0] = new Float32Array(nVertex * 2);\n\n    computeUvs[0] = function (id, u, v) {\n      outBuffers.uvs[0][id * 2 + 0] = u;\n      outBuffers.uvs[0][id * 2 + 1] = v;\n    };\n  }\n\n  var widthSegments = Math.max(2, Math.floor(nSeg) || 2);\n  var heightSegments = Math.max(2, Math.floor(nSeg) || 2);\n  var idVertex = 0;\n  var vertices = [];\n  var skirt = [];\n  var skirtEnd = [];\n  builder.prepare(params);\n\n  for (var y = 0; y <= heightSegments; y++) {\n    var verticesRow = [];\n    var v = y / heightSegments;\n    builder.vProjecte(v, params);\n\n    if (uvCount > 1) {\n      (function () {\n        var u = builder.computeUvs[1](params);\n\n        computeUvs[1] = function (id) {\n          outBuffers.uvs[1][id] = u;\n        };\n      })();\n    }\n\n    for (var x = 0; x <= widthSegments; x++) {\n      var u = x / widthSegments;\n      var id_m3 = idVertex * 3;\n      builder.uProjecte(u, params);\n      var vertex = builder.vertexPosition(params, params.projected);\n      var normal = builder.vertexNormal(params); // move geometry to center world\n\n      vertex.sub(params.center); // align normal to z axis\n\n      if (params.quatNormalToZ) {\n        vertex.applyQuaternion(params.quatNormalToZ);\n        normal.applyQuaternion(params.quatNormalToZ);\n      }\n\n      vertex.toArray(outBuffers.position, id_m3);\n      normal.toArray(outBuffers.normal, id_m3);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = computeUvs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var computeUv = _step.value;\n          computeUv(idVertex, u, v);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!params.disableSkirt) {\n        if (y !== 0 && y !== heightSegments) {\n          if (x === widthSegments) {\n            skirt.push(idVertex);\n          } else if (x === 0) {\n            skirtEnd.push(idVertex);\n          }\n        }\n      }\n\n      verticesRow.push(idVertex);\n      idVertex++;\n    }\n\n    vertices.push(verticesRow);\n\n    if (y === 0) {\n      skirt = skirt.concat(verticesRow);\n    } else if (y === heightSegments) {\n      skirt = skirt.concat(verticesRow.slice().reverse());\n    }\n  }\n\n  if (!params.disableSkirt) {\n    skirt = skirt.concat(skirtEnd.reverse());\n  }\n\n  function bufferize(va, vb, vc, idVertex) {\n    outBuffers.index[idVertex + 0] = va;\n    outBuffers.index[idVertex + 1] = vb;\n    outBuffers.index[idVertex + 2] = vc;\n    return idVertex + 3;\n  }\n\n  var idVertex2 = 0;\n\n  if (params.buildIndexAndUv_0) {\n    for (var _y = 0; _y < heightSegments; _y++) {\n      for (var _x = 0; _x < widthSegments; _x++) {\n        var v1 = vertices[_y][_x + 1];\n        var v2 = vertices[_y][_x];\n        var v3 = vertices[_y + 1][_x];\n        var v4 = vertices[_y + 1][_x + 1];\n        idVertex2 = bufferize(v4, v2, v1, idVertex2);\n        idVertex2 = bufferize(v4, v3, v2, idVertex2);\n      }\n    }\n  }\n\n  var iStart = idVertex; // TODO: WARNING beware skirt's size influences performance\n  // The size of the skirt is now a ratio of the size of the tile.\n  // To be perfect it should depend on the real elevation delta but too heavy to compute\n\n  if (!params.disableSkirt) {\n    // We compute the actual size of tile segment to use later for the skirt.\n    var segmentSize = new THREE.Vector3().fromArray(outBuffers.position).distanceTo(new THREE.Vector3().fromArray(outBuffers.position, 3));\n\n    var buildIndexSkirt = function () {};\n\n    var buildUVSkirt = function () {};\n\n    if (params.buildIndexAndUv_0) {\n      buildIndexSkirt = function (id, v1, v2, v3, v4) {\n        id = bufferize(v1, v2, v3, id);\n        id = bufferize(v1, v3, v4, id);\n        return id;\n      };\n\n      buildUVSkirt = function (id) {\n        outBuffers.uvs[0][idVertex * 2 + 0] = outBuffers.uvs[0][id * 2 + 0];\n        outBuffers.uvs[0][idVertex * 2 + 1] = outBuffers.uvs[0][id * 2 + 1];\n      };\n    }\n\n    for (var i = 0; i < skirt.length; i++) {\n      var id = skirt[i];\n\n      var _id_m = idVertex * 3;\n\n      var id2_m3 = id * 3;\n      outBuffers.position[_id_m + 0] = outBuffers.position[id2_m3 + 0] - outBuffers.normal[id2_m3 + 0] * segmentSize;\n      outBuffers.position[_id_m + 1] = outBuffers.position[id2_m3 + 1] - outBuffers.normal[id2_m3 + 1] * segmentSize;\n      outBuffers.position[_id_m + 2] = outBuffers.position[id2_m3 + 2] - outBuffers.normal[id2_m3 + 2] * segmentSize;\n      outBuffers.normal[_id_m + 0] = outBuffers.normal[id2_m3 + 0];\n      outBuffers.normal[_id_m + 1] = outBuffers.normal[id2_m3 + 1];\n      outBuffers.normal[_id_m + 2] = outBuffers.normal[id2_m3 + 2];\n      buildUVSkirt(id);\n\n      if (uvCount > 1) {\n        outBuffers.uvs[1][idVertex] = outBuffers.uvs[1][id];\n      }\n\n      var idf = (i + 1) % skirt.length;\n      var _v2 = idVertex;\n\n      var _v3 = idf === 0 ? iStart : idVertex + 1;\n\n      var _v4 = skirt[idf];\n      idVertex2 = buildIndexSkirt(idVertex2, id, _v2, _v3, _v4);\n      idVertex++;\n    }\n  }\n\n  return outBuffers;\n}\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Prefab/computeBufferTileGeometry.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Scheduler/Cache.js":
/*!*********************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Scheduler/Cache.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar data = {};\nvar entry;\n/**\n * This is a copy of the Map object, except that it also store a value for last\n * time used. This value is used for cache expiration mechanism.\n * <br><br>\n * This module can be imported anywhere, its data will be shared, as it is a\n * single instance.\n *\n * @module Cache\n *\n * @example\n * import Cache from './Cache';\n *\n * Cache.set({ bar: 1 }, Cache.POLICIES.TEXTURE, 'foo');\n * Cache.set({ bar: 32 }, Cache.POLICIES.INFINITE, 'foo', 'toto');\n *\n * Cache.get('foo');\n *\n * Cache.delete('foo');\n *\n * Cache.clear();\n *\n * Cache.flush();\n */\n\nvar Cache = {\n  /**\n   * Cache policies for flushing. Those policies can be used when something is\n   * [set]{@link Cache.set} into the Cache, as the lifetime property.\n   *\n   * @typedef {Object} POLICIES\n   *\n   * @property {number} INFINITE - The entry is never flushed, except when the\n   * `all` flag is set to `true` when calling {@link Cache.flush}.\n   * @property {number} TEXTURE - Shortcut for texture resources. Time is 15 minutes.\n   * @property {number} ELEVATION - Shortcut for elevation resources. Time is 15\n   * minutes.\n   */\n  POLICIES: {\n    INFINITE: Infinity,\n    TEXTURE: 900000,\n    ELEVATION: 900000\n  },\n\n  /**\n   * Returns the entry related to the specified key from the cache. The last\n   * time used property of the entry is updated to extend the longevity of the\n   * entry.\n   *\n   * @name module:Cache.get\n   * @function\n   *\n   * @param {string} key1\n   * @param {string} [key2]\n   * @param {string} [key3]\n   *\n   * @return {Object}\n   */\n  get: function get(key1, key2, key3) {\n    if (data[key1] == undefined) {\n      // eslint-disable-next-line\n      return;\n    } else if (data[key1][key2] == undefined) {\n      entry = data[key1];\n    } else if (data[key1][key2][key3] == undefined) {\n      entry = data[key1][key2];\n    } else {\n      entry = data[key1][key2][key3];\n    }\n\n    if (entry.value) {\n      entry.lastTimeUsed = Date.now();\n      return entry.value;\n    }\n  },\n\n  /**\n   * Adds or updates an entry with specified keys (up to 3). A lifetime can be\n   * added, by specifying a numerical value or using the {@link\n   * Cache.POLICIES} values. By default an entry has an infinite lifetime.\n   * Caution: it overrides any existing entry already set at this/those key/s.\n   *\n   * @name module:Cache.set\n   * @function\n   *\n   * @param {Object} value\n   * @param {number} lifetime\n   * @param {string} key1\n   * @param {string} [key2]\n   * @param {string} [key3]\n   *\n   * @return {Object} the added value\n   */\n  set: function set(value, lifetime, key1, key2, key3) {\n    entry = {\n      value: value,\n      lastTimeUsed: Date.now(),\n      lifetime: lifetime\n    };\n\n    if (key2 == undefined) {\n      data[key1] = entry;\n      return value;\n    }\n\n    if (!data[key1]) {\n      data[key1] = {};\n    }\n\n    if (key3 == undefined) {\n      data[key1][key2] = entry;\n      return value;\n    }\n\n    if (!data[key1][key2]) {\n      data[key1][key2] = {};\n    }\n\n    data[key1][key2][key3] = entry;\n    return value;\n  },\n\n  /**\n   * Deletes the specified entry from the cache.\n   *\n   * @name module:Cache.delete\n   * @function\n   *\n   * @param {string} key1\n   * @param {string} [key2]\n   * @param {string} [key3]\n   */\n  \"delete\": function _delete(key1, key2, key3) {\n    if (data[key1] == undefined) {\n      throw Error('Please specify at least a key of something to delete');\n    } else if (data[key1][key2] == undefined) {\n      delete data[key1];\n    } else if (data[key1][key2][key3] == undefined) {\n      delete data[key1][key2];\n    } else {\n      delete data[key1][key2][key3];\n    }\n  },\n\n  /**\n   * Removes all entries of the cache.\n   *\n   * @name module:Cache.clear\n   * @function\n   */\n  clear: function clear() {\n    data = {};\n  },\n\n  /**\n   * Flush the cache: entries that have been present for too long since the\n   * last time they were used, are removed from the cache. By default, the\n   * time is the current time, but the interval can be reduced by doing\n   * something like `Cache.flush(Date.now() - reductionTime)`. If you want to\n   * clear the whole cache, use {@link Cache.clear} instead.\n   *\n   * @name module:Cache.flush\n   * @function\n   *\n   * @param {number} [time=Date.now()]\n   */\n  flush: function flush() {\n    var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n\n    for (var i in data) {\n      if (data[i].lifetime < time - data[i].lastTimeUsed) {\n        delete data[i];\n      } else {\n        for (var j in data[i]) {\n          if (data[i][j].lifetime < time - data[i][j].lastTimeUsed) {\n            delete data[i][j];\n          } else {\n            for (var k in data[i][j]) {\n              if (data[i][j][k].lifetime < time - data[i][j][k].lastTimeUsed) {\n                delete data[i][j][k];\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\nObject.freeze(Cache);\nvar _default = Cache;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Scheduler/Cache.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Scheduler/CancelledCommandException.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Scheduler/CancelledCommandException.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\n/**\n * Custom error thrown when cancelling commands. Allows the caller to act differently if needed.\n * @class\n * @param {Command} command\n */\nvar CancelledCommandException =\n/*#__PURE__*/\nfunction () {\n  function CancelledCommandException(command) {\n    (0, _classCallCheck2[\"default\"])(this, CancelledCommandException);\n    this.command = command;\n    this.isCancelledCommandException = true;\n  }\n\n  (0, _createClass2[\"default\"])(CancelledCommandException, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"Cancelled command \".concat(this.command.requester.id, \"/\").concat(this.command.layer.id);\n    }\n  }]);\n  return CancelledCommandException;\n}();\n\nvar _default = CancelledCommandException;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Scheduler/CancelledCommandException.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Scheduler/Scheduler.js":
/*!*************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/Scheduler/Scheduler.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _jsPriorityQueue = _interopRequireDefault(__webpack_require__(/*! js-priority-queue */ \"./node_modules/js-priority-queue/priority-queue.js\"));\n\nvar _DataSourceProvider = _interopRequireDefault(__webpack_require__(/*! ../../Provider/DataSourceProvider */ \"./node_modules/itowns/lib/Provider/DataSourceProvider.js\"));\n\nvar _TileProvider = _interopRequireDefault(__webpack_require__(/*! ../../Provider/TileProvider */ \"./node_modules/itowns/lib/Provider/TileProvider.js\"));\n\nvar _dTilesProvider = _interopRequireDefault(__webpack_require__(/*! ../../Provider/3dTilesProvider */ \"./node_modules/itowns/lib/Provider/3dTilesProvider.js\"));\n\nvar _PointCloudProvider = _interopRequireDefault(__webpack_require__(/*! ../../Provider/PointCloudProvider */ \"./node_modules/itowns/lib/Provider/PointCloudProvider.js\"));\n\nvar _CancelledCommandException = _interopRequireDefault(__webpack_require__(/*! ./CancelledCommandException */ \"./node_modules/itowns/lib/Core/Scheduler/CancelledCommandException.js\"));\n\n/**\n * Generated On: 2015-10-5\n * Class: Scheduler\n * Description: Cette classe singleton gère les requetes/Commandes  de la scène. Ces commandes peuvent etre synchrone ou asynchrone. Elle permet d'executer, de prioriser  et d'annuler les commandes de la pile. Les commandes executées sont placées dans une autre file d'attente.\n */\nfunction queueOrdering(a, b) {\n  var cmp = b.priority - a.priority; // Prioritize recent commands\n\n  if (cmp === 0) {\n    return b.timestamp - a.timestamp;\n  }\n\n  return cmp;\n}\n\nfunction drawNextLayer(storages) {\n  // Dithering algorithm to select the next layer\n  // see https://gamedev.stackexchange.com/a/95696 for more details\n  var sum = 0;\n  var selected;\n  var max;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = storages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var item = _step.value;\n      var st = item[1];\n\n      if (st.q.length > 0) {\n        sum += st.priority;\n        st.accumulator += st.priority; // Select the biggest accumulator\n\n        if (!selected || st.accumulator > max) {\n          selected = st;\n          max = st.accumulator;\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (selected) {\n    selected.accumulator -= sum;\n    return selected.q;\n  }\n}\n\nfunction _instanciateQueue() {\n  return {\n    queue: function queue(command) {\n      var layer = command.layer;\n      var st = this.storages.get(layer.id);\n\n      if (!st) {\n        st = {\n          q: new _jsPriorityQueue[\"default\"]({\n            comparator: queueOrdering\n          }),\n          priority: 1,\n          accumulator: 0\n        };\n        this.storages.set(layer.id, st);\n      } // update priority (layer.priority may have changed)\n\n\n      st.priority = layer.priority || 1;\n      st.q.queue(command);\n      this.counters.pending++;\n    },\n    storages: new Map(),\n    counters: {\n      // commands in progress\n      executing: 0,\n      // commands successfully executed\n      executed: 0,\n      // commands failed\n      failed: 0,\n      // commands cancelled\n      cancelled: 0,\n      // commands pending\n      pending: 0\n    },\n    execute: function execute(cmd, provider) {\n      var _this = this;\n\n      this.counters.pending--;\n      this.counters.executing++;\n      return provider.executeCommand(cmd).then(function (result) {\n        _this.counters.executing--;\n        cmd.resolve(result); // only count successul commands\n\n        _this.counters.executed++;\n      }, function (err) {\n        _this.counters.executing--;\n        cmd.reject(err);\n        _this.counters.failed++;\n      });\n    }\n  };\n}\n/**\n * The Scheduler is in charge of managing the [Providers]{@link Provider} that\n * are used to gather resources needed to display the layers on a {@link View}.\n * There is only one instance of a Scheduler per webview, and it is instanciated\n * with the creation of the first view.\n *\n * @constructor\n */\n\n\nfunction Scheduler() {\n  // Constructor\n  this.defaultQueue = _instanciateQueue();\n  this.hostQueues = new Map();\n  this.providers = {};\n  this.maxCommandsPerHost = 6; // TODO: add an options to not instanciate default providers\n\n  this.initDefaultProviders();\n}\n\nScheduler.prototype.constructor = Scheduler;\n\nScheduler.prototype.initDefaultProviders = function () {\n  // Register all providers\n  this.addProtocolProvider('tile', _TileProvider[\"default\"]);\n  this.addProtocolProvider('3d-tiles', _dTilesProvider[\"default\"]);\n  this.addProtocolProvider('potreeconverter', _PointCloudProvider[\"default\"]);\n};\n\nScheduler.prototype.runCommand = function (command, queue, executingCounterUpToDate) {\n  var _this2 = this;\n\n  var protocol = command.layer.protocol || command.layer.source.protocol;\n  var provider = this.getProtocolProvider(protocol);\n\n  if (!provider) {\n    throw new Error(\"No known provider for layer \".concat(command.layer.id));\n  }\n\n  queue.execute(command, provider, executingCounterUpToDate).then(function () {\n    // notify view that one command ended.\n    command.view.notifyChange(command.requester, command.redraw); // try to execute next command\n\n    if (queue.counters.executing < _this2.maxCommandsPerHost) {\n      var cmd = _this2.deQueue(queue);\n\n      if (cmd) {\n        _this2.runCommand(cmd, queue);\n      }\n    }\n  });\n};\n\nScheduler.prototype.execute = function (command) {\n  var _this3 = this;\n\n  // TODO: check for mandatory commands fields\n  // parse host\n  var layer = command.layer;\n  var host = layer.source && layer.source.url ? new URL(layer.source.url, document.location).host : undefined;\n  command.promise = new Promise(function (resolve, reject) {\n    command.resolve = resolve;\n    command.reject = reject;\n  }); // init queue if needed\n\n  if (host && !this.hostQueues.has(host)) {\n    this.hostQueues.set(host, _instanciateQueue());\n  }\n\n  var q = host ? this.hostQueues.get(host) : this.defaultQueue;\n  command.timestamp = Date.now();\n  q.queue(command);\n\n  if (q.counters.executing < this.maxCommandsPerHost) {\n    // Defer the processing after the end of the current frame.\n    // Promise.resolve or setTimeout(..., 0) will do the job, the difference\n    // is:\n    //   - setTimeout is a new task, queued in the event-loop queues\n    //   - Promise is a micro-task, executed before other tasks\n    Promise.resolve().then(function () {\n      if (q.counters.executing < _this3.maxCommandsPerHost) {\n        var cmd = _this3.deQueue(q);\n\n        if (cmd) {\n          _this3.runCommand(cmd, q);\n        }\n      }\n    });\n  }\n\n  return command.promise;\n};\n/**\n * A Provider has the responsability to handle protocols and datablobs. Given a\n * data request (see {@link Provider#executeCommand} for details about this\n * request), it fetches serialized datasets, file content or even file chunks.\n *\n * @interface Provider\n */\n\n/**\n * When adding a layer to a view, some preprocessing can be done on it, before\n * fetching or creating resources attached to it. For example, in the WMTS and\n * WFS providers (included in iTowns), default options to the layer are added if\n * some are missing.\n *\n * @function\n * @name Provider#preprocessDataLayer\n *\n * @param {Layer} layer\n * @param {View} [view]\n * @param {Scheduler} [scheduler]\n * @param {Layer} [parentLayer]\n */\n\n/**\n * In the {@link Scheduler} loop, this function is called every time the layer\n * needs new information about itself. For tiled layers, it gets the necessary\n * tiles, given the current position of the camera on the map. For simple layers\n * like a GPX trace, it gets the data once.\n * <br><br>\n * It passes a `command` object as a parameter, with the `view` and the `layer`\n * always present. The other parameters are optional.\n *\n * @function\n * @name Provider#executeCommand\n *\n * @param {Object} command\n * @param {View} command.view\n * @param {Layer} command.layer\n * @param {TileMesh} [command.requester] - Every layer is attached to a tile.\n * @param {number} [command.targetLevel] - The target level is used when there\n * is a tiled layer, such as WMTS or TMS, but not in case like a GPX layer.\n *\n * @return {Promise} The {@link Scheduler} always expect a Promise as a result,\n * resolving to an object containing sufficient information for the associated\n * processing to the current layer. For example, see the\n * [LayeredMaterialNodeProcessing#updateLayeredMaterialNodeElevation]{@link\n * https://github.com/iTowns/itowns/blob/master/src/Process/LayeredMaterialNodeProcessing.js}\n * class or other processing class.\n */\n\n/**\n * Adds a provider for a specified protocol. The provider will be used when\n * executing the queue to provide resources. See {@link Provider} for more\n * informations.\n * By default, some protocols are already set in iTowns: WMTS, WMS, WFS, TMS,\n * XYZ, PotreeConverter, Rasterizer, 3D-Tiles and Static.\n * <br><br>\n * Warning: if the specified protocol has already a provider attached to it, the\n * current provider will be overwritten by the given provider.\n *\n * @param {string} protocol - The name of the protocol to add. This is the\n * `protocol` parameter put inside the configuration when adding a layer. The\n * capitalization of the name is not taken into account here.\n * @param {Provider} provider - The provider to link to the protocol, that must\n * respect the {@link Provider} interface description.\n *\n * @throws {Error} an error if any method of the {@link Provider} is not present\n * in the provider.\n */\n\n\nScheduler.prototype.addProtocolProvider = function (protocol, provider) {\n  if (typeof provider.executeCommand !== 'function') {\n    throw new Error(\"Can't add provider for \".concat(protocol, \": missing a executeCommand function.\"));\n  }\n\n  this.providers[protocol] = provider;\n};\n/**\n * Get a specific {@link Provider} given a particular protocol.\n *\n * @param {string} protocol\n *\n * @return {Provider}\n */\n\n\nScheduler.prototype.getProtocolProvider = function (protocol) {\n  return this.providers[protocol] || _DataSourceProvider[\"default\"];\n};\n\nScheduler.prototype.commandsWaitingExecutionCount = function () {\n  var sum = this.defaultQueue.counters.pending + this.defaultQueue.counters.executing;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = this.hostQueues[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var q = _step2.value;\n      sum += q[1].counters.pending + q[1].counters.executing;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return sum;\n};\n\nScheduler.prototype.commandsRunningCount = function () {\n  var sum = this.defaultQueue.counters.executing;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = this.hostQueues[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var q = _step3.value;\n      sum += q[1].counters.executing;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n        _iterator3[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return sum;\n};\n\nScheduler.prototype.resetCommandsCount = function (type) {\n  var sum = this.defaultQueue.counters[type];\n  this.defaultQueue.counters[type] = 0;\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = this.hostQueues[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var q = _step4.value;\n      sum += q[1].counters[type];\n      q[1].counters[type] = 0;\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n        _iterator4[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return sum;\n};\n\nScheduler.prototype.deQueue = function (queue) {\n  var st = drawNextLayer(queue.storages);\n\n  while (st && st.length > 0) {\n    var cmd = st.dequeue();\n\n    if (cmd.earlyDropFunction && cmd.earlyDropFunction(cmd)) {\n      queue.counters.pending--;\n      queue.counters.cancelled++;\n      cmd.reject(new _CancelledCommandException[\"default\"](cmd));\n    } else {\n      return cmd;\n    }\n  }\n\n  return undefined;\n};\n\nvar _default = Scheduler;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Scheduler/Scheduler.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/Style.js":
/*!***********************************************!*\
  !*** ./node_modules/itowns/lib/Core/Style.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _Feature = __webpack_require__(/*! ./Feature */ \"./node_modules/itowns/lib/Core/Feature.js\");\n\nvar inv255 = 1 / 255;\nvar canvas = document.createElement('canvas');\n\nfunction rgba2rgb(orig) {\n  var result = orig.match(/(?:((hsl|rgb)a? *\\(([\\d.%]+(?:deg|g?rad|turn)?)[ ,]*([\\d.%]+)[ ,]*([\\d.%]+)[ ,/]*([\\d.%]*)\\))|(#((?:[\\d\\w]{3}){1,2})([\\d\\w]{1,2})?))/i);\n\n  if (!result) {\n    return {\n      color: orig,\n      opacity: 1.0\n    };\n  } else if (result[7]) {\n    var opacity = 1.0;\n\n    if (result[9]) {\n      opacity = parseInt(result[9].length == 1 ? \"\".concat(result[9]).concat(result[9]) : result[9], 16) * inv255;\n    }\n\n    return {\n      color: \"#\".concat(result[8]),\n      opacity: opacity\n    };\n  } else if (result[0]) {\n    return {\n      color: \"\".concat(result[2], \"(\").concat(result[3], \",\").concat(result[4], \",\").concat(result[5], \")\"),\n      opacity: Number(result[6]) || 1.0\n    };\n  }\n}\n\nfunction readVectorProperty(property, zoom) {\n  if (property == undefined) {//\n  } else if (property.stops) {\n    var p = property.stops.slice().reverse().find(function (stop) {\n      return zoom >= stop[0];\n    });\n    return p ? p[1] : property.stops[0][1];\n  } else {\n    return property.base || property;\n  }\n}\n/**\n * Style defines {@link Feature} style.\n * @property {object} fill fill style.\n * @property {string} fill.color fill color string css.\n * @property {Image|Canvas} fill.pattern fill with pattern image.\n * @property {number} fill.opacity fill opacity.\n * @property {object} stroke stroke style.\n * @property {string} stroke.color stroke color string css.\n * @property {number} stroke.opacity stroke opacity.\n * @property {number} stroke.width stroke line width.\n * @property {object} point point style.\n * @property {string} point.color point color string css.\n * @property {string} point.line point line color string css.\n * @property {number} point.width point line width.\n * @property {number} point.opacity point opacity.\n * @property {number} point.radius point line radius\n */\n\n\nvar Style =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructs the object.\n   * @param  {Object}  [params={}] An object that can contain all properties of a Style.\n   * @constructor\n   */\n  function Style() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2[\"default\"])(this, Style);\n    this.isStyle = true;\n    params.fill = params.fill || {};\n    params.stroke = params.stroke || {};\n    params.point = params.point || {};\n    this.fill = {\n      color: params.fill.color,\n      opacity: params.fill.opacity,\n      pattern: params.fill.pattern\n    };\n    this.stroke = {\n      color: params.stroke.color,\n      opacity: params.stroke.opacity,\n      width: params.stroke.width,\n      dasharray: params.stroke.dasharray || []\n    };\n    this.point = {\n      color: params.point.color,\n      line: params.point.line,\n      opacity: params.point.opacity,\n      radius: params.point.radius,\n      width: params.point.width\n    };\n  }\n  /**\n   * set Style from geojson properties.\n   * @param {object} properties geojson properties.\n   * @param {number} type\n   * @returns {Style}\n   */\n\n\n  (0, _createClass2[\"default\"])(Style, [{\n    key: \"setFromGeojsonProperties\",\n    value: function setFromGeojsonProperties(properties, type) {\n      if (type === _Feature.FEATURE_TYPES.POINT) {\n        this.point.color = properties.fill || 'white';\n        this.point.opacity = properties['fill-opacity'] || 1.0;\n        this.point.line = properties.stroke || 'gray';\n        this.point.radius = properties.radius || 2.0;\n      } else {\n        this.stroke.color = properties.stroke;\n        this.stroke.width = properties['stroke-width'];\n        this.stroke.opacity = properties['stroke-opacity'];\n\n        if (type !== _Feature.FEATURE_TYPES.LINE) {\n          this.fill.color = properties.fill;\n          this.fill.opacity = properties['fill-opacity'] || 1.0;\n        }\n      }\n\n      return this;\n    }\n    /**\n     * set Style from vector tile layer properties.\n     * @param {object} layer vector tile layer.\n     * @param {Number} zoom vector tile layer.\n     * @param {Object} sprites vector tile layer.\n     * @returns {Style}\n     */\n\n  }, {\n    key: \"setFromVectorTileLayer\",\n    value: function setFromVectorTileLayer(layer, zoom, sprites) {\n      if (layer.type === 'fill' && !this.fill.color) {\n        var _rgba2rgb = rgba2rgb(readVectorProperty(layer.paint['fill-color'] || layer.paint['fill-pattern'])),\n            color = _rgba2rgb.color,\n            opacity = _rgba2rgb.opacity;\n\n        this.fill.color = color;\n        this.fill.opacity = readVectorProperty(layer.paint['fill-opacity'], zoom) || opacity || 1.0;\n\n        if (layer.paint['fill-pattern'] && sprites) {\n          var sprite = sprites[layer.paint['fill-pattern']];\n          canvas.width = sprite.width;\n          canvas.height = sprite.height;\n          canvas.getContext('2d').drawImage(sprites.img, sprite.x, sprite.y, sprite.width, sprite.height, 0, 0, sprite.width, sprite.height);\n          this.fill.pattern = document.createElement('img');\n          this.fill.pattern.src = canvas.toDataURL('image/png');\n        }\n\n        if (layer.paint['fill-outline-color']) {\n          var _rgba2rgb2 = rgba2rgb(readVectorProperty(layer.paint['fill-outline-color'])),\n              _color = _rgba2rgb2.color,\n              _opacity = _rgba2rgb2.opacity;\n\n          this.stroke.color = _color;\n          this.stroke.opacity = _opacity;\n          this.stroke.width = 1.0;\n          this.stroke.dasharray = [];\n        }\n      }\n\n      if (layer.type === 'line' && !this.stroke.color) {\n        var prepare = readVectorProperty(layer.paint['line-color'], zoom);\n\n        var _rgba2rgb3 = rgba2rgb(prepare),\n            _color2 = _rgba2rgb3.color,\n            _opacity2 = _rgba2rgb3.opacity;\n\n        this.stroke.dasharray = readVectorProperty(layer.paint['line-dasharray'], zoom) || [];\n        this.stroke.color = _color2;\n        this.stroke.lineCap = layer.layout && layer.layout['line-cap'];\n        this.stroke.width = readVectorProperty(layer.paint['line-width'], zoom) || 3.0;\n        this.stroke.opacity = readVectorProperty(layer.paint['line-opacity'], zoom) || _opacity2 || 1.0;\n      }\n\n      if (layer.type === 'symbol') {\n        var _rgba2rgb4 = rgba2rgb(readVectorProperty(layer.paint['text-color'] || '#000000', zoom)),\n            _color3 = _rgba2rgb4.color,\n            _opacity3 = _rgba2rgb4.opacity;\n\n        this.point.color = _color3;\n        this.point.opacity = _opacity3;\n        this.point.radius = 1.5;\n      } else if (layer.type === 'circle') {\n        var _rgba2rgb5 = rgba2rgb(readVectorProperty(layer.paint['circle-color']), zoom),\n            _color4 = _rgba2rgb5.color,\n            _opacity4 = _rgba2rgb5.opacity;\n\n        this.point.color = _color4;\n        this.point.opacity = _opacity4;\n        this.point.radius = readVectorProperty(layer.paint['circle-radius'], zoom);\n      }\n\n      return this;\n    }\n  }]);\n  return Style;\n}();\n\nvar _default = Style;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/Style.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/System/Capabilities.js":
/*!*************************************************************!*\
  !*** ./node_modules/itowns/lib/Core/System/Capabilities.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\n/* babel-plugin-inline-import '../../Renderer/Shader/SampleTestFS.glsl' */\nvar SampleTestFS = \"uniform sampler2D uni[SAMPLE];\\nvoid main() {\\n    gl_FragColor += texture2D(uni[SAMPLE-1], vec2(0));\\n}\";\n\n/* babel-plugin-inline-import '../../Renderer/Shader/SampleTestVS.glsl' */\nvar SampleTestVS = \"void main() {\\n    gl_Position = vec4( 0.0, 0.0, 0.0, 1.0 );\\n}\"; // default values\n\nvar logDepthBufferSupported = false;\nvar maxTexturesUnits = 8;\nvar maxTextureSize = 4096;\n\nfunction _WebGLShader(renderer, type, string) {\n  var gl = renderer.getContext();\n  var shader = gl.createShader(type);\n  gl.shaderSource(shader, string);\n  gl.compileShader(shader);\n  return shader;\n}\n\nfunction isFirefox() {\n  return navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes('firefox');\n}\n\nvar _default = {\n  isLogDepthBufferSupported: function isLogDepthBufferSupported() {\n    return logDepthBufferSupported;\n  },\n  isFirefox: isFirefox,\n  isInternetExplorer: function isInternetExplorer() {\n    var internetExplorer =  false || !!document.documentMode;\n    return internetExplorer;\n  },\n  getMaxTextureUnitsCount: function getMaxTextureUnitsCount() {\n    return maxTexturesUnits;\n  },\n  getMaxTextureSize: function getMaxTextureSize() {\n    return maxTextureSize;\n  },\n  updateCapabilities: function updateCapabilities(renderer) {\n    var gl = renderer.getContext();\n    maxTexturesUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    var program = gl.createProgram();\n\n    var glVertexShader = _WebGLShader(renderer, gl.VERTEX_SHADER, SampleTestVS);\n\n    var fragmentShader = \"#define SAMPLE \".concat(maxTexturesUnits, \"\\n\");\n    fragmentShader += SampleTestFS;\n\n    var glFragmentShader = _WebGLShader(renderer, gl.FRAGMENT_SHADER, fragmentShader);\n\n    gl.attachShader(program, glVertexShader);\n    gl.attachShader(program, glFragmentShader);\n    gl.linkProgram(program);\n\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n      if (maxTexturesUnits > 16) {\n        var info = gl.getProgramInfoLog(program); // eslint-disable-next-line no-console\n\n        console.warn(\"\".concat(info, \": using a maximum of 16 texture units instead of the reported value (\").concat(maxTexturesUnits, \")\"));\n\n        if (isFirefox()) {\n          // eslint-disable-next-line no-console\n          console.warn(\"It can come from a Mesa/Firefox bug;\\n                        the shader compiles to an error when using more than 16 sampler uniforms,\\n                        see https://bugzilla.mozilla.org/show_bug.cgi?id=777028\");\n        }\n\n        maxTexturesUnits = 16;\n      } else {\n        throw new Error(\"The GPU capabilities could not be determined accurately.\\n                    Impossible to link a shader with the Maximum texture units \".concat(maxTexturesUnits));\n      }\n    }\n\n    gl.deleteProgram(program);\n    gl.deleteShader(glVertexShader);\n    gl.deleteShader(glFragmentShader);\n    logDepthBufferSupported = renderer.capabilities.logarithmicDepthBuffer;\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/System/Capabilities.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/TileGeometry.js":
/*!******************************************************!*\
  !*** ./node_modules/itowns/lib/Core/TileGeometry.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _computeBufferTileGeometry = _interopRequireDefault(__webpack_require__(/*! ./Prefab/computeBufferTileGeometry */ \"./node_modules/itowns/lib/Core/Prefab/computeBufferTileGeometry.js\"));\n\nfunction defaultBuffers(params) {\n  params.buildIndexAndUv_0 = true;\n  params.center = params.builder.center(params.extent).clone();\n  var buffers = (0, _computeBufferTileGeometry[\"default\"])(params);\n  buffers.index = new THREE.BufferAttribute(buffers.index, 1);\n  buffers.uvs[0] = new THREE.BufferAttribute(buffers.uvs[0], 2);\n  buffers.position = new THREE.BufferAttribute(buffers.position, 3);\n  buffers.normal = new THREE.BufferAttribute(buffers.normal, 3);\n\n  for (var i = 1; i < params.builder.uvCount; i++) {\n    buffers.uvs[1] = new THREE.BufferAttribute(buffers.uvs[1], 1);\n  }\n\n  return buffers;\n}\n\nvar TileGeometry =\n/*#__PURE__*/\nfunction (_THREE$BufferGeometry) {\n  (0, _inherits2[\"default\"])(TileGeometry, _THREE$BufferGeometry);\n\n  function TileGeometry(params) {\n    var _this;\n\n    var buffers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultBuffers(params);\n    (0, _classCallCheck2[\"default\"])(this, TileGeometry);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(TileGeometry).call(this));\n    _this.center = params.center;\n    _this.extent = params.extent;\n\n    _this.setIndex(buffers.index);\n\n    _this.setAttribute('position', buffers.position);\n\n    _this.setAttribute('normal', buffers.normal);\n\n    for (var i = 0; i < buffers.uvs.length; i++) {\n      _this.setAttribute(\"uv_\".concat(i), buffers.uvs[i]);\n    }\n\n    _this.computeBoundingBox();\n\n    _this.OBB = {};\n    return _this;\n  }\n\n  return TileGeometry;\n}(THREE.BufferGeometry);\n\nvar _default = TileGeometry;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/TileGeometry.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/TileMesh.js":
/*!**************************************************!*\
  !*** ./node_modules/itowns/lib/Core/TileMesh.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ./Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\n/**\n * A TileMesh is a THREE.Mesh with a geometricError and an OBB\n * The objectId property of the material is the with the id of the TileMesh\n * @constructor\n * @param {TileGeometry} geometry - the tile geometry\n * @param {THREE.Material} material - a THREE.Material compatible with THREE.Mesh\n * @param {Layer} layer - the layer the tile is added to\n * @param {Extent} extent - the tile extent\n * @param {?number} level - the tile level (default = 0)\n */\nvar TileMesh =\n/*#__PURE__*/\nfunction (_THREE$Mesh) {\n  (0, _inherits2[\"default\"])(TileMesh, _THREE$Mesh);\n\n  function TileMesh(geometry, material, layer, extent) {\n    var _this;\n\n    var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    (0, _classCallCheck2[\"default\"])(this, TileMesh);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(TileMesh).call(this, geometry, material));\n\n    if (!extent) {\n      throw new Error('extent is mandatory to build a TileMesh');\n    }\n\n    _this.layer = layer;\n    _this.extent = extent;\n    _this.extent.zoom = level;\n    _this.level = level;\n    _this.material.objectId = _this.id;\n    _this.obb = _this.geometry.OBB.clone();\n    _this.boundingSphere = new THREE.Sphere();\n\n    _this.obb.box3D.getBoundingSphere(_this.boundingSphere);\n\n    _this._tms = new Map();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = layer.tileMatrixSets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var tms = _step.value;\n\n        _this._tms.set(tms, _this.extent.tiledCovering(tms));\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    _this.frustumCulled = false;\n    _this.matrixAutoUpdate = false;\n    _this.rotationAutoUpdate = false;\n    _this.layerUpdateState = {};\n    _this.isTileMesh = true;\n    return _this;\n  }\n  /**\n   * If specified, update the min and max elevation of the OBB\n   * and updates accordingly the bounding sphere and the geometric error\n   *\n   * @param {?number} min\n   * @param {?number} max\n   * @param {?number} scale\n   */\n\n\n  (0, _createClass2[\"default\"])(TileMesh, [{\n    key: \"setBBoxZ\",\n    value: function setBBoxZ(min, max, scale) {\n      if (min == undefined && max == undefined) {\n        return;\n      } // FIXME: Why the floors ? This is not conservative : the obb may be too short by almost 1m !\n\n\n      if (Math.floor(min) !== Math.floor(this.obb.z.min) || Math.floor(max) !== Math.floor(this.obb.z.max)) {\n        this.obb.updateZ(min, max, scale);\n\n        if (this.horizonCullingPointElevationScaled) {\n          this.horizonCullingPointElevationScaled.setLength(this.obb.z.delta + this.horizonCullingPoint.length());\n        }\n\n        this.obb.box3D.getBoundingSphere(this.boundingSphere);\n      }\n    }\n  }, {\n    key: \"getExtentsByProjection\",\n    value: function getExtentsByProjection(projection) {\n      return this._tms.get(_Crs[\"default\"].formatToTms(projection));\n    }\n    /**\n     * Search for a common ancestor between this tile and another one. It goes\n     * through parents on each side until one is found.\n     *\n     * @param {TileMesh} tile\n     *\n     * @return {TileMesh} the resulting common ancestor\n     */\n\n  }, {\n    key: \"findCommonAncestor\",\n    value: function findCommonAncestor(tile) {\n      if (!tile) {\n        return undefined;\n      }\n\n      if (tile.level == this.level) {\n        if (tile.id == this.id) {\n          return tile;\n        } else if (tile.level != 0) {\n          return this.parent.findCommonAncestor(tile.parent);\n        } else {\n          return undefined;\n        }\n      } else if (tile.level < this.level) {\n        return this.parent.findCommonAncestor(tile);\n      } else {\n        return this.findCommonAncestor(tile.parent);\n      }\n    }\n  }, {\n    key: \"onBeforeRender\",\n    value: function onBeforeRender() {\n      if (this.material.layersNeedUpdate) {\n        this.material.updateLayersUniforms();\n      }\n    }\n  }]);\n  return TileMesh;\n}(THREE.Mesh);\n\nvar _default = TileMesh;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/TileMesh.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Core/View.js":
/*!**********************************************!*\
  !*** ./node_modules/itowns/lib/Core/View.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.VIEW_EVENTS = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Camera = _interopRequireDefault(__webpack_require__(/*! ../Renderer/Camera */ \"./node_modules/itowns/lib/Renderer/Camera.js\"));\n\nvar _MainLoop = _interopRequireWildcard(__webpack_require__(/*! ./MainLoop */ \"./node_modules/itowns/lib/Core/MainLoop.js\"));\n\nvar _ColorLayersOrdering = __webpack_require__(/*! ../Renderer/ColorLayersOrdering */ \"./node_modules/itowns/lib/Renderer/ColorLayersOrdering.js\");\n\nvar _c3DEngine = _interopRequireDefault(__webpack_require__(/*! ../Renderer/c3DEngine */ \"./node_modules/itowns/lib/Renderer/c3DEngine.js\"));\n\nvar _RenderMode = _interopRequireDefault(__webpack_require__(/*! ../Renderer/RenderMode */ \"./node_modules/itowns/lib/Renderer/RenderMode.js\"));\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ./Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ./Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _FeaturesUtils = _interopRequireDefault(__webpack_require__(/*! ../Utils/FeaturesUtils */ \"./node_modules/itowns/lib/Utils/FeaturesUtils.js\"));\n\nvar _LayeredMaterial = __webpack_require__(/*! ../Renderer/LayeredMaterial */ \"./node_modules/itowns/lib/Renderer/LayeredMaterial.js\");\n\nvar _Scheduler = _interopRequireDefault(__webpack_require__(/*! ./Scheduler/Scheduler */ \"./node_modules/itowns/lib/Core/Scheduler/Scheduler.js\"));\n\nvar _Picking = _interopRequireDefault(__webpack_require__(/*! ./Picking */ \"./node_modules/itowns/lib/Core/Picking.js\"));\n\nvar VIEW_EVENTS = {\n  /**\n   * Fires when all the layers of the view are considered initialized.\n   * Initialized in this context means: all layers are ready to be\n   * displayed (no pending network access, no visual improvement to be\n   * expected, ...).\n   * If you add new layers, the event will be fired again when all\n   * layers are ready.\n   * @event View#layers-initialized\n   * @property type {string} layers-initialized\n   */\n  LAYERS_INITIALIZED: 'layers-initialized',\n  LAYER_REMOVED: 'layer-removed',\n  LAYER_ADDED: 'layer-added',\n  INITIALIZED: 'initialized',\n  COLOR_LAYERS_ORDER_CHANGED: _ColorLayersOrdering.COLOR_LAYERS_ORDER_CHANGED\n};\nexports.VIEW_EVENTS = VIEW_EVENTS;\n\nvar _syncGeometryLayerVisibility = function (layer, view) {\n  if (layer.object3d) {\n    layer.object3d.visible = layer.visible;\n  }\n\n  if (layer.threejsLayer) {\n    if (layer.visible) {\n      view.camera.camera3D.layers.enable(layer.threejsLayer);\n    } else {\n      view.camera.camera3D.layers.disable(layer.threejsLayer);\n    }\n  }\n};\n\nfunction _preprocessLayer(view, layer, provider, parentLayer) {\n  var source = layer.source;\n\n  if (parentLayer && !layer.extent) {\n    layer.extent = parentLayer.extent;\n\n    if (source && !source.extent) {\n      source.extent = parentLayer.extent;\n    }\n  }\n\n  if (layer.isGeometryLayer) {\n    if (parentLayer) {\n      // layer.threejsLayer *must* be assigned before preprocessing,\n      // because TileProvider.preprocessDataLayer function uses it.\n      layer.threejsLayer = view.mainLoop.gfxEngine.getUniqueThreejsLayer();\n    }\n\n    layer.defineLayerProperty('visible', true, function () {\n      return _syncGeometryLayerVisibility(layer, view);\n    });\n\n    _syncGeometryLayerVisibility(layer, view); // Find projection layer, this is projection destination\n\n\n    layer.projection = view.referenceCrs;\n  } else if (parentLayer.tileMatrixSets.includes(_Crs[\"default\"].formatToTms(source.projection))) {\n    layer.projection = source.projection;\n  } else {\n    layer.projection = parentLayer.extent.crs;\n  }\n\n  if (!layer.whenReady) {\n    if (provider && provider.preprocessDataLayer) {\n      layer.whenReady = provider.preprocessDataLayer(layer, view, view.mainLoop.scheduler, parentLayer);\n    } else if (source && source.whenReady) {\n      layer.whenReady = source.whenReady;\n    } else {\n      layer.whenReady = Promise.resolve();\n    }\n  }\n\n  layer.whenReady = layer.whenReady.then(function () {\n    layer.ready = true;\n    return layer;\n  });\n  return layer;\n}\n\nvar _eventCoords = new THREE.Vector2();\n\nvar matrix = new THREE.Matrix4();\nvar screen = new THREE.Vector2();\nvar ray = new THREE.Ray();\nvar direction = new THREE.Vector3();\nvar positionVector = new THREE.Vector3();\nvar coordinates = new _Coordinates[\"default\"]('EPSG:4326');\n\nvar View =\n/*#__PURE__*/\nfunction (_THREE$EventDispatche) {\n  (0, _inherits2[\"default\"])(View, _THREE$EventDispatche);\n\n  /**\n   * Constructs an Itowns View instance\n   *\n   * @param {string} crs - The default CRS of Three.js coordinates. Should be a cartesian CRS.\n   * @param {HTMLElement} viewerDiv - Where to instanciate the Three.js scene in the DOM\n   * @param {Object=} options - Optional properties.\n   * @param {?MainLoop} options.mainLoop - {@link MainLoop} instance to use, otherwise a default one will be constructed\n   * @param {?(WebGLRenderer|object)} options.renderer - {@link WebGLRenderer} instance to use, otherwise\n   * a default one will be constructed. In this case, if options.renderer is an object, it will be used to\n   * configure the renderer (see {@link c3DEngine}.  If not present, a new &lt;canvas> will be created and\n   * added to viewerDiv (mutually exclusive with mainLoop)\n   * @param {?Scene} options.scene3D - {@link Scene} instance to use, otherwise a default one will be constructed\n   * @constructor\n   */\n  function View(crs, viewerDiv) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2[\"default\"])(this, View);\n\n    if (!viewerDiv) {\n      throw new Error('Invalid viewerDiv parameter (must non be null/undefined)');\n    }\n\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(View).call(this));\n    _this.referenceCrs = crs;\n    coordinates.crs = crs;\n    var engine; // options.renderer can be 2 separate things:\n    //   - an actual renderer (in this case we don't use viewerDiv)\n    //   - options for the renderer to be created\n\n    if (options.renderer && options.renderer.domElement) {\n      engine = new _c3DEngine[\"default\"](options.renderer);\n    } else {\n      engine = new _c3DEngine[\"default\"](viewerDiv, options.renderer);\n    }\n\n    _this.mainLoop = options.mainLoop || new _MainLoop[\"default\"](new _Scheduler[\"default\"](), engine);\n    _this.scene = options.scene3D || new THREE.Scene();\n\n    if (!options.scene3D) {\n      _this.scene.autoUpdate = false;\n    }\n\n    _this.camera = new _Camera[\"default\"](_this.referenceCrs, _this.mainLoop.gfxEngine.getWindowSize().x, _this.mainLoop.gfxEngine.getWindowSize().y, options);\n    _this._frameRequesters = {};\n    _this._layers = [];\n    window.addEventListener('resize', function () {\n      // If the user gave us a container (<div>) then itowns' size is\n      // the container's size. Otherwise we use window' size.\n      _this.mainLoop.gfxEngine.onWindowResize(viewerDiv.clientWidth, viewerDiv.clientHeight);\n\n      _this.camera.resize(viewerDiv.clientWidth, viewerDiv.clientHeight);\n\n      _this.notifyChange(_this.camera.camera3D);\n    }, false);\n    _this._changeSources = new Set();\n    _this._delayedFrameRequesterRemoval = [];\n\n    _this._allLayersAreReadyCallback = function () {\n      // all layers must be ready\n      var allReady = _this.getLayers().every(function (layer) {\n        return layer.ready;\n      });\n\n      if (allReady && _this.mainLoop.scheduler.commandsWaitingExecutionCount() == 0 && _this.mainLoop.renderingState == _MainLoop.RENDERING_PAUSED) {\n        _this.dispatchEvent({\n          type: VIEW_EVENTS.LAYERS_INITIALIZED\n        });\n\n        _this.removeFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.UPDATE_END, _this._allLayersAreReadyCallback);\n      }\n    };\n\n    _this.camera.resize(viewerDiv.clientWidth, viewerDiv.clientHeight);\n\n    var fn = function () {\n      _this.removeEventListener(VIEW_EVENTS.LAYERS_INITIALIZED, fn);\n\n      _this.dispatchEvent({\n        type: VIEW_EVENTS.INITIALIZED\n      });\n    };\n\n    _this.addEventListener(VIEW_EVENTS.LAYERS_INITIALIZED, fn);\n\n    _this._fullSizeDepthBuffer = null;\n\n    _this.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.BEFORE_RENDER, function () {\n      if (_this._fullSizeDepthBuffer != null && _this._fullSizeDepthBuffer.needsUpdate) {\n        // clean depth buffer\n        _this._fullSizeDepthBuffer = null;\n      }\n    }); // Focus needed to capture some key events.\n\n\n    viewerDiv.focus();\n    return _this;\n  }\n  /**\n   * Add layer in viewer.\n   * The layer id must be unique.\n   *\n   * This function calls `preprocessDataLayer` of the relevant provider with this\n   * layer and set `layer.whenReady` to a promise that resolves when\n   * the preprocessing operation is done. This promise is also returned by\n   * `addLayer` allowing to chain call.\n   *\n   * @param {LayerOptions|Layer|GeometryLayer} layer\n   * @param {Layer=} parentLayer\n   * @return {Promise} a promise resolved with the new layer object when it is fully initialized or rejected if any error occurred.\n   */\n\n\n  (0, _createClass2[\"default\"])(View, [{\n    key: \"addLayer\",\n    value: function addLayer(layer, parentLayer) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (!layer) {\n          reject(new Error('layer is undefined'));\n          return;\n        }\n\n        var duplicate = _this2.getLayerById(layer.id);\n\n        if (duplicate) {\n          reject(new Error(\"Invalid id '\".concat(layer.id, \"': id already used\")));\n          return;\n        }\n\n        var protocol = layer.source ? layer.source.protocol : layer.protocol;\n\n        var provider = _this2.mainLoop.scheduler.getProtocolProvider(protocol);\n\n        if (layer.protocol && !provider) {\n          reject(new Error(\"\".concat(layer.protocol, \" is not a recognized protocol name.\")));\n          return;\n        }\n\n        layer = _preprocessLayer(_this2, layer, provider, parentLayer);\n\n        if (parentLayer) {\n          if (layer.isColorLayer) {\n            var layerColors = _this2.getLayers(function (l) {\n              return l.isColorLayer;\n            });\n\n            var sumColorLayers = parentLayer.countColorLayersTextures.apply(parentLayer, (0, _toConsumableArray2[\"default\"])(layerColors).concat([layer]));\n\n            if (sumColorLayers <= (0, _LayeredMaterial.getMaxColorSamplerUnitsCount)()) {\n              parentLayer.attach(layer);\n            } else {\n              reject(new Error(\"Cant add color layer \".concat(layer.id, \": the maximum layer is reached\")));\n              return;\n            }\n          } else {\n            parentLayer.attach(layer);\n          }\n        } else {\n          if (typeof layer.update !== 'function') {\n            reject(new Error('Cant add GeometryLayer: missing a update function'));\n            return;\n          }\n\n          if (typeof layer.preUpdate !== 'function') {\n            reject(new Error('Cant add GeometryLayer: missing a preUpdate function'));\n            return;\n          }\n\n          _this2._layers.push(layer);\n        }\n\n        if (layer.object3d && !layer.object3d.parent && layer.object3d !== _this2.scene) {\n          _this2.scene.add(layer.object3d);\n        }\n\n        layer.whenReady.then(function (layer) {\n          _this2.notifyChange(parentLayer || layer, false);\n\n          if (!_this2._frameRequesters[_MainLoop.MAIN_LOOP_EVENTS.UPDATE_END] || !_this2._frameRequesters[_MainLoop.MAIN_LOOP_EVENTS.UPDATE_END].includes(_this2._allLayersAreReadyCallback)) {\n            _this2.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.UPDATE_END, _this2._allLayersAreReadyCallback);\n          }\n\n          resolve(layer);\n        });\n\n        _this2.dispatchEvent({\n          type: VIEW_EVENTS.LAYER_ADDED,\n          layerId: layer.id\n        });\n      });\n    }\n    /**\n     * Removes a specific imagery layer from the current layer list. This removes layers inserted with attach().\n     * @example\n     * view.removeLayer('layerId');\n     * @param      {string}   layerId      The identifier\n     * @return     {boolean}\n     */\n\n  }, {\n    key: \"removeLayer\",\n    value: function removeLayer(layerId) {\n      var layer = this.getLayerById(layerId);\n\n      if (layer) {\n        var parentLayer = layer.parent; // Remove and dispose all nodes\n\n        layer[\"delete\"](); // Detach layer if it's attached\n\n        if (parentLayer && !parentLayer.detach(layer)) {\n          throw new Error(\"Error to detach \".concat(layerId, \" from \").concat(parentLayer.id));\n        } else if (parentLayer == undefined) {\n          // Remove layer from viewer\n          this._layers.splice(this._layers.findIndex(function (l) {\n            return l.id == layerId;\n          }), 1);\n        }\n\n        if (layer.isColorLayer) {\n          // Update color layers sequence\n          var imageryLayers = this.getLayers(function (l) {\n            return l.isColorLayer;\n          });\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = imageryLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var color = _step.value;\n\n              if (color.sequence > layer.sequence) {\n                color.sequence--;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        this.notifyChange(this.camera);\n        this.dispatchEvent({\n          type: VIEW_EVENTS.LAYER_REMOVED,\n          layerId: layerId\n        });\n        return true;\n      } else {\n        throw new Error(\"\".concat(layerId, \" doesn't exist\"));\n      }\n    }\n    /**\n     * Notifies the scene it needs to be updated due to changes exterior to the\n     * scene itself (e.g. camera movement).\n     * non-interactive events (e.g: texture loaded)\n     * @param {*} changeSource\n     * @param {boolean} needsRedraw - indicates if notified change requires a full scene redraw.\n     */\n\n  }, {\n    key: \"notifyChange\",\n    value: function notifyChange() {\n      var changeSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var needsRedraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (changeSource) {\n        this._changeSources.add(changeSource);\n\n        if ((changeSource.isTileMesh || changeSource.isCamera) && this._fullSizeDepthBuffer) {\n          this._fullSizeDepthBuffer.needsUpdate = true;\n        }\n      }\n\n      this.mainLoop.scheduleViewUpdate(this, needsRedraw);\n    }\n    /**\n     * Get all layers, with an optionnal filter applied.\n     * The filter method will be called with 2 args:\n     *   - 1st: current layer\n     *   - 2nd: (optional) the geometry layer to which the current layer is attached\n     * @example\n     * // get all layers\n     * view.getLayers();\n     * // get all color layers\n     * view.getLayers(layer => layer.isColorLayer);\n     * // get all elevation layers\n     * view.getLayers(layer => layer.isElevationLayer);\n     * // get all geometry layers\n     * view.getLayers(layer => layer.isGeometryLayer);\n     * // get one layer with id\n     * view.getLayers(layer => layer.id === 'itt');\n     * @param {function(Layer):boolean} filter\n     * @returns {Array<Layer>}\n     */\n\n  }, {\n    key: \"getLayers\",\n    value: function getLayers(filter) {\n      var result = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var layer = _step2.value;\n\n          if (!filter || filter(layer)) {\n            result.push(layer);\n          }\n\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = layer.attachedLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var attached = _step3.value;\n\n              if (!filter || filter(attached, layer)) {\n                result.push(attached);\n              }\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n                _iterator3[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Gets the layer by identifier.\n     *\n     * @param {String}  layerId  The layer identifier\n     * @return {Layer}  The layer by identifier.\n     */\n\n  }, {\n    key: \"getLayerById\",\n    value: function getLayerById(layerId) {\n      var layers = this.getLayers(function (l) {\n        return l.id === layerId;\n      });\n\n      if (layers.length) {\n        return layers[0];\n      }\n    }\n    /**\n     * @param {Layer} layer\n     * @returns {GeometryLayer} the parent layer of the given layer or undefined.\n     */\n\n  }, {\n    key: \"getParentLayer\",\n    value: function getParentLayer(layer) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this._layers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var geometryLayer = _step4.value;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = geometryLayer.attachedLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var attached = _step5.value;\n\n              if (attached === layer) {\n                return geometryLayer;\n              }\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n                _iterator5[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n    /**\n     * @name FrameRequester\n     * @function\n     *\n     * @description\n     * Method that will be called each time the `MainLoop` updates. This function\n     * will be given as parameter the delta (in ms) between this update and the\n     * previous one, and whether or not we just started to render again. This update\n     * is considered as the \"next\" update if `view.notifyChange` was called during a\n     * precedent update. If `view.notifyChange` has been called by something else\n     * (other micro/macrotask, UI events etc...), then this update is considered as\n     * being the \"first\". It can also receive optional arguments, depending on the\n     * attach point of this function. Currently only `BEFORE_LAYER_UPDATE /\n     * AFTER_LAYER_UPDATE` attach points provide an additional argument: the layer\n     * being updated.\n     * <br><br>\n     *\n     * This means that if a `frameRequester` function wants to animate something, it\n     * should keep on calling `view.notifyChange` until its task is done.\n     * <br><br>\n     *\n     * Implementors of `frameRequester` should keep in mind that this function will\n     * be potentially called at each frame, thus care should be given about\n     * performance.\n     * <br><br>\n     *\n     * Typical frameRequesters are controls, module wanting to animate moves or UI\n     * elements etc... Basically anything that would want to call\n     * requestAnimationFrame.\n     *\n     * @param {number} dt\n     * @param {boolean} updateLoopRestarted\n     * @param {...*} args\n     */\n\n    /**\n     * Add a frame requester to this view.\n     *\n     * FrameRequesters can activate the MainLoop update by calling view.notifyChange.\n     *\n     * @param {String} when - decide when the frameRequester should be called during\n     * the update cycle. Can be any of {@link MAIN_LOOP_EVENTS}.\n     * @param {FrameRequester} frameRequester - this function will be called at each\n     * MainLoop update with the time delta between last update, or 0 if the MainLoop\n     * has just been relaunched.\n     */\n\n  }, {\n    key: \"addFrameRequester\",\n    value: function addFrameRequester(when, frameRequester) {\n      if (typeof frameRequester !== 'function') {\n        throw new Error('frameRequester must be a function');\n      }\n\n      if (!this._frameRequesters[when]) {\n        this._frameRequesters[when] = [frameRequester];\n      } else {\n        this._frameRequesters[when].push(frameRequester);\n      }\n    }\n    /**\n     * Remove a frameRequester.\n     * The effective removal will happen either later; at worst it'll be at\n     * the beginning of the next frame.\n     *\n     * @param {String} when - attach point of this requester. Can be any of\n     * {@link MAIN_LOOP_EVENTS}.\n     * @param {FrameRequester} frameRequester\n     */\n\n  }, {\n    key: \"removeFrameRequester\",\n    value: function removeFrameRequester(when, frameRequester) {\n      if (this._frameRequesters[when].includes(frameRequester)) {\n        this._delayedFrameRequesterRemoval.push({\n          when: when,\n          frameRequester: frameRequester\n        });\n      } else {\n        console.error('Invalid call to removeFrameRequester: frameRequester isn\\'t registered');\n      }\n    }\n  }, {\n    key: \"_executeFrameRequestersRemovals\",\n    value: function _executeFrameRequestersRemovals() {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this._delayedFrameRequesterRemoval[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var toDelete = _step6.value;\n\n          var index = this._frameRequesters[toDelete.when].indexOf(toDelete.frameRequester);\n\n          if (index >= 0) {\n            this._frameRequesters[toDelete.when].splice(index, 1);\n          } else {\n            console.warn('FrameReq has already been removed');\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n            _iterator6[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      this._delayedFrameRequesterRemoval.length = 0;\n    }\n    /**\n     * Execute a frameRequester.\n     *\n     * @param {String} when - attach point of this (these) requester(s). Can be any\n     * of {@link MAIN_LOOP_EVENTS}.\n     * @param {Number} dt - delta between this update and the previous one\n     * @param {boolean} updateLoopRestarted\n     * @param {...*} args - optional arguments\n     */\n\n  }, {\n    key: \"execFrameRequesters\",\n    value: function execFrameRequesters(when, dt, updateLoopRestarted) {\n      if (!this._frameRequesters[when]) {\n        return;\n      }\n\n      if (this._delayedFrameRequesterRemoval.length > 0) {\n        this._executeFrameRequestersRemovals();\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        args[_key - 3] = arguments[_key];\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this._frameRequesters[when][Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var frameRequester = _step7.value;\n\n          if (frameRequester.update) {\n            frameRequester.update(dt, updateLoopRestarted, args);\n          } else {\n            frameRequester(dt, updateLoopRestarted, args);\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n            _iterator7[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n    /**\n     * Extract view coordinates from a mouse-event / touch-event\n     * @param {event} event - event can be a MouseEvent or a TouchEvent\n     * @param {THREE.Vector2} target - the target to set the view coords in\n     * @param {number} [touchIdx=0] - finger index when using a TouchEvent\n     * @return {THREE.Vector2} - view coordinates (in pixels, 0-0 = top-left of the View)\n     */\n\n  }, {\n    key: \"eventToViewCoords\",\n    value: function eventToViewCoords(event) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _eventCoords;\n      var touchIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (event.touches === undefined || !event.touches.length) {\n        return target.set(event.offsetX, event.offsetY);\n      } else {\n        var br = this.mainLoop.gfxEngine.renderer.domElement.getBoundingClientRect();\n        return target.set(event.touches[touchIdx].clientX - br.x, event.touches[touchIdx].clientY - br.y);\n      }\n    }\n    /**\n     * Extract normalized coordinates (NDC) from a mouse-event / touch-event\n     * @param {event} event - event can be a MouseEvent or a TouchEvent\n     * @param {number} touchIdx - finger index when using a TouchEvent (default: 0)\n     * @return {THREE.Vector2} - NDC coordinates (x and y are [-1, 1])\n     */\n\n  }, {\n    key: \"eventToNormalizedCoords\",\n    value: function eventToNormalizedCoords(event) {\n      var touchIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.viewToNormalizedCoords(this.eventToViewCoords(event, _eventCoords, touchIdx));\n    }\n    /**\n     * Convert view coordinates to normalized coordinates (NDC)\n     * @param {THREE.Vector2} viewCoords (in pixels, 0-0 = top-left of the View)\n     * @return {THREE.Vector2} - NDC coordinates (x and y are [-1, 1])\n     */\n\n  }, {\n    key: \"viewToNormalizedCoords\",\n    value: function viewToNormalizedCoords(viewCoords) {\n      _eventCoords.x = 2 * (viewCoords.x / this.camera.width) - 1;\n      _eventCoords.y = -2 * (viewCoords.y / this.camera.height) + 1;\n      return _eventCoords;\n    }\n    /**\n     * Convert NDC coordinates to view coordinates\n     * @param {THREE.Vector2} ndcCoords\n     * @return {THREE.Vector2} - view coordinates (in pixels, 0-0 = top-left of the View)\n     */\n\n  }, {\n    key: \"normalizedToViewCoords\",\n    value: function normalizedToViewCoords(ndcCoords) {\n      _eventCoords.x = (ndcCoords.x + 1) * 0.5 * this.camera.width;\n      _eventCoords.y = (ndcCoords.y - 1) * -0.5 * this.camera.height;\n      return _eventCoords;\n    }\n    /**\n     * Return objects from some layers/objects3d under the mouse in this view.\n     *\n     * @param {Object} mouseOrEvt - mouse position in window coordinates (0, 0 = top-left)\n     * or MouseEvent or TouchEvent\n     * @param {number} radius - picking will happen in a circle centered on mouseOrEvt. Radius\n     * is the radius of this circle, in pixels\n     * @param {...*} where - where to look for objects. Can be either: empty (= look\n     * in all layers with type == 'geometry'), layer ids or layers or a mix of all\n     * the above.\n     * @return {Array} - an array of objects. Each element contains at least an object\n     * property which is the Object3D under the cursor. Then depending on the queried\n     * layer/source, there may be additionnal properties (coming from THREE.Raycaster\n     * for instance).\n     *\n     * @example\n     * view.pickObjectsAt({ x, y })\n     * view.pickObjectsAt({ x, y }, 1, 'wfsBuilding')\n     * view.pickObjectsAt({ x, y }, 3, 'wfsBuilding', myLayer)\n     */\n\n  }, {\n    key: \"pickObjectsAt\",\n    value: function pickObjectsAt(mouseOrEvt) {\n      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var results = [];\n\n      for (var _len2 = arguments.length, where = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        where[_key2 - 2] = arguments[_key2];\n      }\n\n      var sources = where.length == 0 ? this.getLayers(function (l) {\n        return l.isGeometryLayer;\n      }) : [].concat(where);\n      var mouse = mouseOrEvt instanceof Event ? this.eventToViewCoords(mouseOrEvt) : mouseOrEvt;\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = sources[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var source = _step8.value;\n\n          if (source.isLayer || typeof source === 'string') {\n            var layer = typeof source === 'string' ? this.getLayerById(source) : source;\n\n            if (!layer || !layer.ready) {\n              console.warn('view.pickObjectAt : layer is not ready : ', source);\n              continue;\n            }\n\n            var parentLayer = this.getParentLayer(layer);\n\n            if (!parentLayer) {\n              var sp = layer.pickObjectsAt(this, mouse, radius); // warning: sp might be very large, so we can't use '...sp' (we'll hit\n              // 'javascript maximum call stack size exceeded' error) nor\n              // Array.prototype.push.apply(result, sp)\n\n              for (var i = 0; i < sp.length; i++) {\n                results.push(sp[i]);\n              }\n            } else {\n              // raycast using parent layer object3d\n              var obj = _Picking[\"default\"].pickObjectsAt(this, mouse, radius, parentLayer.object3d); // then filter the results\n\n\n              var _iteratorNormalCompletion9 = true;\n              var _didIteratorError9 = false;\n              var _iteratorError9 = undefined;\n\n              try {\n                for (var _iterator9 = obj[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                  var o = _step9.value;\n\n                  if (o.layer === layer) {\n                    results.push(o);\n                  }\n                }\n              } catch (err) {\n                _didIteratorError9 = true;\n                _iteratorError9 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion9 && _iterator9[\"return\"] != null) {\n                    _iterator9[\"return\"]();\n                  }\n                } finally {\n                  if (_didIteratorError9) {\n                    throw _iteratorError9;\n                  }\n                }\n              }\n            }\n          } else if (source.isObject3D) {\n            _Picking[\"default\"].pickObjectsAt(this, mouse, radius, source, results);\n          } else {\n            throw new Error(\"Invalid where arg (value = \".concat(where, \"). Expected layers, layer ids or Object3Ds\"));\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8[\"return\"] != null) {\n            _iterator8[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      return results;\n    }\n    /**\n     * Return the current zoom scale at the central point of the view. This\n     * function compute the scale of a map.\n     *\n     * @param {number} pitch - Screen pitch, in millimeters ; 0.28 by default\n     *\n     * @return {number} The zoom scale.\n     */\n\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      var pitch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.28;\n      return this.getScaleFromDistance(pitch, this.getDistanceFromCamera());\n    }\n  }, {\n    key: \"getScaleFromDistance\",\n    value: function getScaleFromDistance() {\n      var pitch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.28;\n      var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      pitch /= 1000;\n      var fov = THREE.Math.degToRad(this.camera.camera3D.fov);\n      var unit = this.camera.height / (2 * distance * Math.tan(fov * 0.5));\n      return pitch * unit;\n    }\n    /**\n     * Given a screen coordinates, get the distance between the projected\n     * coordinates and the camera associated to this view.\n     *\n     * @param {THREE.Vector2} [screenCoord] - The screen coordinate to get the\n     * distance at. By default this is the middle of the screen.\n     *\n     * @return {number} The distance in meters.\n     */\n\n  }, {\n    key: \"getDistanceFromCamera\",\n    value: function getDistanceFromCamera(screenCoord) {\n      this.getPickingPositionFromDepth(screenCoord, positionVector);\n      return this.camera.camera3D.position.distanceTo(positionVector);\n    }\n    /**\n     * Get, for a specific screen coordinate, the projected distance on the\n     * surface of the main layer of the view.\n     *\n     * @param {number} [pixels=1] - The size, in pixels, to get in meters.\n     * @param {THREE.Vector2} [screenCoord] - The screen coordinate to get the\n     * projected distance at. By default, this is the middle of the screen.\n     *\n     * @return {number} The projected distance in meters.\n     */\n\n  }, {\n    key: \"getPixelsToMeters\",\n    value: function getPixelsToMeters() {\n      var pixels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var screenCoord = arguments.length > 1 ? arguments[1] : undefined;\n      return this.getPixelsToMetersFromDistance(pixels, this.getDistanceFromCamera(screenCoord));\n    }\n  }, {\n    key: \"getPixelsToMetersFromDistance\",\n    value: function getPixelsToMetersFromDistance() {\n      var pixels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return pixels * distance / this.camera._preSSE;\n    }\n    /**\n     * Get, for a specific screen coordinate, this size in pixels of a projected\n     * distance on the surface of the main layer of the view.\n     *\n     * @param {number} [meters=1] - The size, in meters, to get in pixels.\n     * @param {THREE.Vector2} [screenCoord] - The screen coordinate to get the\n     * projected distance at. By default, this is the middle of the screen.\n     *\n     * @return {number} The projected distance in meters.\n     */\n\n  }, {\n    key: \"getMetersToPixels\",\n    value: function getMetersToPixels() {\n      var meters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var screenCoord = arguments.length > 1 ? arguments[1] : undefined;\n      return this.getMetersToPixelsFromDistance(meters, this.getDistanceFromCamera(screenCoord));\n    }\n  }, {\n    key: \"getMetersToPixelsFromDistance\",\n    value: function getMetersToPixelsFromDistance() {\n      var meters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this.camera._preSSE * meters / distance;\n    }\n    /**\n     * Returns features under the mouse, for a set of specified layers.\n     *\n     * @param {MouseEvent|Object} mouseOrEvt - A MouseEvent, or a screen\n     * coordinates.\n     * @param {number} [radius=3] - The precision of the picking, in pixels.\n     * @param {Layer[]} [where] - The layers to look into. If not specified, all\n     * `GeometryLayer` and `ColorLayer` layers of this view will be looked in.\n     *\n     * @return {Object} - An object, with a property per layer. For example,\n     * looking for features on layers `wfsBuilding` and `wfsRoads` will give an\n     * object like `{ wfsBuilding: [...], wfsRoads: [] }`. Each property is made\n     * of an array, that can be empty or filled with found features.\n     *\n     * @example\n     * view.pickFeaturesAt({ x, y });\n     * view.pickFeaturesAt({ x, y }, 1, ['wfsBuilding']);\n     * view.pickFeaturesAt({ x, y }, 3, ['wfsBuilding', myLayer]);\n     */\n\n  }, {\n    key: \"pickFeaturesAt\",\n    value: function pickFeaturesAt(mouseOrEvt) {\n      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n      var where = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var result = {};\n      var layers = where.length == 0 ? this.getLayers(function (l) {\n        return l.isGeometryLayer || l.isColorLayer;\n      }) : where;\n      layers = layers.map(function (l) {\n        var id = l.isLayer ? l.id : l;\n        result[id] = [];\n        return id;\n      }); // Get the mouse coordinates to the correct system\n\n      var mouse = mouseOrEvt instanceof Event ? this.eventToViewCoords(mouseOrEvt, _eventCoords) : mouseOrEvt;\n      this.getPickingPositionFromDepth(mouse, positionVector);\n      var distance = this.camera.camera3D.position.distanceTo(positionVector);\n      coordinates.setFromVector3(positionVector); // Get the correct precision; the position variable will be set in this\n      // function.\n\n      var precision;\n      var precisions = {\n        M: this.getPixelsToMetersFromDistance(radius, distance),\n        D: 0.001 * radius\n      };\n\n      if (this.isPlanarView) {\n        precisions.D = precisions.M;\n      } else if (this.getPixelsToDegrees) {\n        precisions.D = this.getMetersToDegrees(precisions.M);\n      } // Get the tile corresponding to where the cursor is\n\n\n      var tiles = _Picking[\"default\"].pickTilesAt(this, mouse, radius, this.tileLayer);\n\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = tiles[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var tile = _step10.value;\n\n          if (!tile.object.material) {\n            continue;\n          }\n\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = tile.object.material.getLayers(layers)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var materialLayer = _step11.value;\n              var _iteratorNormalCompletion12 = true;\n              var _didIteratorError12 = false;\n              var _iteratorError12 = undefined;\n\n              try {\n                for (var _iterator12 = materialLayer.textures[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                  var texture = _step12.value;\n\n                  if (!texture.parsedData) {\n                    continue;\n                  }\n\n                  precision = _Crs[\"default\"].isMetricUnit(texture.parsedData.crs) ? precisions.M : precisions.D;\n                  result[materialLayer.id] = result[materialLayer.id].concat(_FeaturesUtils[\"default\"].filterFeaturesUnderCoordinate(coordinates, texture.parsedData, precision));\n                }\n              } catch (err) {\n                _didIteratorError12 = true;\n                _iteratorError12 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion12 && _iterator12[\"return\"] != null) {\n                    _iterator12[\"return\"]();\n                  }\n                } finally {\n                  if (_didIteratorError12) {\n                    throw _iteratorError12;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11[\"return\"] != null) {\n                _iterator11[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10[\"return\"] != null) {\n            _iterator10[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"readDepthBuffer\",\n    value: function readDepthBuffer(x, y, width, height) {\n      var g = this.mainLoop.gfxEngine;\n      var currentWireframe = this.tileLayer.wireframe;\n      var currentOpacity = this.tileLayer.opacity;\n      var currentVisibility = this.tileLayer.visible;\n\n      if (currentWireframe) {\n        this.tileLayer.wireframe = false;\n      }\n\n      if (currentOpacity < 1.0) {\n        this.tileLayer.opacity = 1.0;\n      }\n\n      if (!currentVisibility) {\n        this.tileLayer.visible = true;\n      }\n\n      var restore = this.tileLayer.level0Nodes.map(function (n) {\n        return _RenderMode[\"default\"].push(n, _RenderMode[\"default\"].MODES.DEPTH);\n      });\n      var buffer = g.renderViewToBuffer({\n        camera: this.camera,\n        scene: this.tileLayer.object3d\n      }, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n      restore.forEach(function (r) {\n        return r();\n      });\n\n      if (this.tileLayer.wireframe !== currentWireframe) {\n        this.tileLayer.wireframe = currentWireframe;\n      }\n\n      if (this.tileLayer.opacity !== currentOpacity) {\n        this.tileLayer.opacity = currentOpacity;\n      }\n\n      if (this.tileLayer.visible !== currentVisibility) {\n        this.tileLayer.visible = currentVisibility;\n      }\n\n      return buffer;\n    }\n    /**\n     * Returns the world position (view's crs: referenceCrs) under view coordinates.\n     * This position is computed with depth buffer.\n     *\n     * @param      {THREE.Vector2}  mouse  position in view coordinates (in pixel), if it's null so it's view's center.\n     * @param      {THREE.Vector3}  [target=THREE.Vector3()] target. the result will be copied into this Vector3. If not present a new one will be created.\n     * @return     {THREE.Vector3}  the world position in view's crs: referenceCrs.\n     */\n\n  }, {\n    key: \"getPickingPositionFromDepth\",\n    value: function getPickingPositionFromDepth(mouse) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();\n\n      if (!this.tileLayer || this.tileLayer.level0Nodes.length == 0 || !this.tileLayer.level0Nodes[0]) {\n        target = undefined;\n        return;\n      }\n\n      var l = this.mainLoop;\n\n      var viewPaused = l.scheduler.commandsWaitingExecutionCount() == 0 && l.renderingState == _MainLoop.RENDERING_PAUSED;\n\n      var g = l.gfxEngine;\n      var dim = g.getWindowSize();\n      var camera = this.camera.camera3D;\n      mouse = mouse || dim.clone().multiplyScalar(0.5);\n      mouse.x = Math.floor(mouse.x);\n      mouse.y = Math.floor(mouse.y); // Prepare state\n\n      var prev = camera.layers.mask;\n      camera.layers.mask = 1 << this.tileLayer.threejsLayer; // Render/Read to buffer\n\n      var buffer;\n\n      if (viewPaused) {\n        this._fullSizeDepthBuffer = this._fullSizeDepthBuffer || this.readDepthBuffer(0, 0, dim.x, dim.y);\n        var id = ((dim.y - mouse.y - 1) * dim.x + mouse.x) * 4;\n        buffer = this._fullSizeDepthBuffer.slice(id, id + 4);\n      } else {\n        buffer = this.readDepthBuffer(mouse.x, mouse.y, 1, 1);\n      }\n\n      screen.x = mouse.x / dim.x * 2 - 1;\n      screen.y = -(mouse.y / dim.y) * 2 + 1; // Origin\n\n      ray.origin.copy(camera.position); // Direction\n\n      ray.direction.set(screen.x, screen.y, 0.5); // Unproject\n\n      matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));\n      ray.direction.applyMatrix4(matrix);\n      ray.direction.sub(ray.origin);\n      direction.set(0, 0, 1.0);\n      direction.applyMatrix4(matrix);\n      direction.sub(ray.origin);\n      var angle = direction.angleTo(ray.direction);\n      var orthoZ = g.depthBufferRGBAValueToOrthoZ(buffer, camera);\n      var length = orthoZ / Math.cos(angle);\n      target.addVectors(camera.position, ray.direction.setLength(length));\n      camera.layers.mask = prev;\n\n      if (target.length() > 10000000) {\n        return undefined;\n      }\n\n      return target;\n    }\n  }]);\n  return View;\n}(THREE.EventDispatcher);\n\nvar _default = View;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Core/View.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Layer/ColorLayer.js":
/*!*****************************************************!*\
  !*** ./node_modules/itowns/lib/Layer/ColorLayer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _Layer2 = _interopRequireDefault(__webpack_require__(/*! ./Layer */ \"./node_modules/itowns/lib/Layer/Layer.js\"));\n\nvar _LayeredMaterialNodeProcessing = __webpack_require__(/*! ../Process/LayeredMaterialNodeProcessing */ \"./node_modules/itowns/lib/Process/LayeredMaterialNodeProcessing.js\");\n\nvar _textureConverter = _interopRequireDefault(__webpack_require__(/*! ../Converter/textureConverter */ \"./node_modules/itowns/lib/Converter/textureConverter.js\"));\n\nvar _Style = _interopRequireDefault(__webpack_require__(/*! ../Core/Style */ \"./node_modules/itowns/lib/Core/Style.js\"));\n\n/**\n * Fires when the visiblity of the layer has changed.\n * @event ColorLayer#visible-property-changed\n */\n\n/**\n * Fires when the opacity of the layer has changed.\n * @event ColorLayer#opacity-property-changed\n */\n\n/**\n * Fires when the sequence of the layer has changed, meaning that the order of\n * the layer changed in the view it is attached to.\n * @event ColorLayer#sequence-property-changed\n */\n\n/**\n * @property {boolean} isColorLayer - Used to checkout whether this layer is a\n * ColorLayer. Default is true. You should not change this, as it is used\n * internally for optimisation.\n */\nvar ColorLayer =\n/*#__PURE__*/\nfunction (_Layer) {\n  (0, _inherits2[\"default\"])(ColorLayer, _Layer);\n\n  /**\n   * A simple layer, usually managing a texture to display on a view. For example,\n   * it can be an aerial view of the ground or a simple transparent layer with the\n   * roads displayed.\n   *\n   * @constructor\n   * @extends Layer\n   *\n   * @param {string} id - The id of the layer, that should be unique. It is\n   * not mandatory, but an error will be emitted if this layer is added a\n   * {@link View} that already has a layer going by that id.\n   * @param {Object} [config] - Optional configuration, all elements in it\n   * will be merged as is in the layer. For example, if the configuration\n   * contains three elements `name, protocol, extent`, these elements will be\n   * available using `layer.name` or something else depending on the property\n   * name.\n   * @param {Source} [config.source] - Description and options of the source.\n   *\n   * @example\n   * // Create a ColorLayer\n   * const color = new ColorLayer('roads', {\n   *     source: {\n   *          protocol: 'wmts',\n   *          url: 'http://server.geo/wmts/SERVICE=WMTS&TILEMATRIX=%TILEMATRIX&TILEROW=%ROW&TILECOL=%COL',\n   *          format: 'image/png',\n   *     }\n   *     transparent: true\n   * });\n   *\n   * // Add the layer\n   * view.addLayer(color);\n   */\n  function ColorLayer(id) {\n    var _this;\n\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, ColorLayer);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(ColorLayer).call(this, id, config));\n    _this.isColorLayer = true;\n    _this.style = config.style ? new _Style[\"default\"](config.style) : {};\n\n    _this.defineLayerProperty('visible', true);\n\n    _this.defineLayerProperty('opacity', 1.0);\n\n    _this.defineLayerProperty('sequence', 0);\n\n    _this.transparent = config.transparent || _this.opacity < 1.0;\n    _this.noTextureParentOutsideLimit = config.source ? config.source.isFileSource : false;\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(ColorLayer, [{\n    key: \"update\",\n    value: function update(context, layer, node, parent) {\n      return (0, _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeImagery)(context, this, node, parent);\n    }\n  }, {\n    key: \"convert\",\n    value: function convert(data, extentDestination) {\n      return _textureConverter[\"default\"].convert(data, extentDestination, this);\n    }\n    /**\n    * All layer's textures are removed from scene and disposed from video device.\n    */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.parent.level0Nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var root = _step.value;\n          root.traverse((0, _LayeredMaterialNodeProcessing.removeLayeredMaterialNodeLayer)(this.id));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n  return ColorLayer;\n}(_Layer2[\"default\"]);\n\nvar _default = ColorLayer;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Layer/ColorLayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Layer/ElevationLayer.js":
/*!*********************************************************!*\
  !*** ./node_modules/itowns/lib/Layer/ElevationLayer.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _Layer2 = _interopRequireDefault(__webpack_require__(/*! ./Layer */ \"./node_modules/itowns/lib/Layer/Layer.js\"));\n\nvar _LayeredMaterialNodeProcessing = __webpack_require__(/*! ../Process/LayeredMaterialNodeProcessing */ \"./node_modules/itowns/lib/Process/LayeredMaterialNodeProcessing.js\");\n\nvar _textureConverter = _interopRequireDefault(__webpack_require__(/*! ../Converter/textureConverter */ \"./node_modules/itowns/lib/Converter/textureConverter.js\"));\n\n/**\n * @property {boolean} isElevationLayer - Used to checkout whether this layer is\n * an ElevationLayer. Default is true. You should not change this, as it is used\n * internally for optimisation.\n * @property {number} scale - Used to apply a scale on the elevation value. It\n * can be used for exageration of the elevation, like in [this\n * example](https://www.itowns-project.org/itowns/examples/#plugins_pyramidal_tiff).\n */\nvar ElevationLayer =\n/*#__PURE__*/\nfunction (_Layer) {\n  (0, _inherits2[\"default\"])(ElevationLayer, _Layer);\n\n  /**\n   * A simple layer, managing an elevation texture to add some reliefs on the\n   * plane or globe view for example.\n   *\n   * @constructor\n   * @extends Layer\n   *\n   * @param {string} id - The id of the layer, that should be unique. It is\n   * not mandatory, but an error will be emitted if this layer is added a\n   * {@link View} that already has a layer going by that id.\n   * @param {Object} [config] - Optional configuration, all elements in it\n   * will be merged as is in the layer. For example, if the configuration\n   * contains three elements `name, protocol, extent`, these elements will be\n   * available using `layer.name` or something else depending on the property\n   * name.\n   * @param {Source} [config.source] - Description and options of the source.\n   *\n   * @example\n   * // Create an ElevationLayer\n   * const elevation = new ElevationLayer('IGN_MNT', {\n   *      source: {\n   *          url: 'http://server.geo/wmts/SERVICE=WMTS&TILEMATRIX=%TILEMATRIX&TILEROW=%ROW&TILECOL=%COL',\n   *          protocol: 'wmts',\n   *          format: 'image/x-bil;bits=32',\n   *      },\n   * });\n   *\n   * // Add the layer\n   * view.addLayer(elevation);\n   */\n  function ElevationLayer(id) {\n    var _this;\n\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, ElevationLayer);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(ElevationLayer).call(this, id, config));\n    _this.isElevationLayer = true; // This is used to add a factor needed to color texture\n\n    var baseScale = 1.0;\n\n    if (_this.useColorTextureElevation) {\n      baseScale = _this.colorTextureElevationMaxZ - _this.colorTextureElevationMinZ;\n    }\n\n    _this.defineLayerProperty('scale', _this.scale || 1.0, function (self) {\n      self.parent.object3d.traverse(function (obj) {\n        if (obj.layer == self.parent && obj.material) {\n          obj.material.setElevationScale(self.scale * baseScale);\n          obj.obb.updateScaleZ(self.scale);\n        }\n      });\n    });\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(ElevationLayer, [{\n    key: \"update\",\n    value: function update(context, layer, node, parent) {\n      return (0, _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeElevation)(context, this, node, parent);\n    }\n  }, {\n    key: \"convert\",\n    value: function convert(data, extentDestination) {\n      return _textureConverter[\"default\"].convert(data, extentDestination, this);\n    }\n    /**\n    * All layer's textures are removed from scene and disposed from video device.\n    */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.parent.level0Nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var root = _step.value;\n          root.traverse((0, _LayeredMaterialNodeProcessing.removeLayeredMaterialNodeLayer)(this.id));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n  return ElevationLayer;\n}(_Layer2[\"default\"]);\n\nvar _default = ElevationLayer;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Layer/ElevationLayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Layer/GeometryLayer.js":
/*!********************************************************!*\
  !*** ./node_modules/itowns/lib/Layer/GeometryLayer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _Layer2 = _interopRequireDefault(__webpack_require__(/*! ./Layer */ \"./node_modules/itowns/lib/Layer/Layer.js\"));\n\nvar _Picking = _interopRequireDefault(__webpack_require__(/*! ../Core/Picking */ \"./node_modules/itowns/lib/Core/Picking.js\"));\n\nfunction disposeMesh(obj) {\n  if (obj.dispose) {\n    obj.dispose();\n  } else {\n    if (obj.geometry) {\n      obj.geometry.dispose();\n    }\n\n    if (obj.material) {\n      if (Array.isArray(obj.material)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = obj.material[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var material = _step.value;\n            material.dispose();\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        obj.material.dispose();\n      }\n    }\n  }\n}\n\nfunction traverse(obj, callback) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = obj.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var child = _step2.value;\n      traverse(child, callback);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  callback(obj);\n}\n/**\n * Fires when the opacity of the layer has changed.\n * @event GeometryLayer#opacity-property-changed\n */\n\n/**\n * @property {boolean} isGeometryLayer - Used to checkout whether this layer is\n * a GeometryLayer. Default is true. You should not change this, as it is used\n * internally for optimisation.\n */\n\n\nvar GeometryLayer =\n/*#__PURE__*/\nfunction (_Layer) {\n  (0, _inherits2[\"default\"])(GeometryLayer, _Layer);\n\n  /**\n   * A layer usually managing a geometry to display on a view. For example, it\n   * can be a layer of buildings extruded from a a WFS stream.\n   *\n   * @constructor\n   * @extends Layer\n   *\n   * @param {string} id - The id of the layer, that should be unique. It is\n   * not mandatory, but an error will be emitted if this layer is added a\n   * {@link View} that already has a layer going by that id.\n   * @param {THREE.Object3d} object3d - The object3d used to contain the\n   * geometry of the GeometryLayer. It is usually a `THREE.Group`, but it can\n   * be anything inheriting from a `THREE.Object3d`.\n   * @param {Object} [config] - Optional configuration, all elements in it\n   * will be merged as is in the layer. For example, if the configuration\n   * contains three elements `name, protocol, extent`, these elements will be\n   * available using `layer.name` or something else depending on the property\n   * name.\n   * @param {Source} [config.source] - Description and options of the source.\n   *\n   * @throws {Error} `object3d` must be a valid `THREE.Object3d`.\n   *\n   * @example\n   * // Create a GeometryLayer\n   * const geometry = new GeometryLayer('buildings', {\n   *      source: {\n   *          url: 'http://server.geo/wfs?',\n   *          protocol: 'wfs',\n   *          format: 'application/json'\n   *      },\n   * });\n   *\n   * // Add the layer\n   * view.addLayer(geometry);\n   */\n  function GeometryLayer(id, object3d) {\n    var _this;\n\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2[\"default\"])(this, GeometryLayer);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(GeometryLayer).call(this, id, config));\n    _this.isGeometryLayer = true;\n\n    if (!object3d || !object3d.isObject3D) {\n      throw new Error(\"Missing/Invalid object3d parameter (must be a\\n                three.js Object3D instance)\");\n    }\n\n    if (object3d.type === 'Group' && object3d.name === '') {\n      object3d.name = id;\n    }\n\n    Object.defineProperty((0, _assertThisInitialized2[\"default\"])(_this), 'object3d', {\n      value: object3d,\n      writable: false,\n      configurable: true\n    });\n\n    _this.defineLayerProperty('opacity', 1.0, function () {\n      var root = _this.parent ? _this.parent.object3d : _this.object3d;\n      root.traverse(function (object) {\n        if (object.layer == (0, _assertThisInitialized2[\"default\"])(_this)) {\n          _this.changeOpacity(object);\n        } else if (object.content && object.content.layer == (0, _assertThisInitialized2[\"default\"])(_this)) {\n          object.content.traverse(_this.changeOpacity);\n        }\n      });\n    });\n\n    _this.defineLayerProperty('wireframe', false, function () {\n      var root = _this.parent ? _this.parent.object3d : _this.object3d;\n      root.traverse(function (object) {\n        if (object.layer == (0, _assertThisInitialized2[\"default\"])(_this) && object.material) {\n          object.material.wireframe = _this.wireframe;\n        } else if (object.content && object.content.layer == (0, _assertThisInitialized2[\"default\"])(_this)) {\n          object.content.traverse(function (o) {\n            if (o.material && o.layer == (0, _assertThisInitialized2[\"default\"])(_this)) {\n              o.material.wireframe = _this.wireframe;\n            }\n          });\n        }\n      });\n    });\n\n    _this.attachedLayers = [];\n    _this.visible = config.visible == undefined ? true : config.visible; // Attached layers expect to receive the visual representation of a\n    // layer (= THREE object with a material).  So if a layer's update\n    // function don't process this kind of object, the layer must provide a\n    // getObjectToUpdateForAttachedLayers function that returns the correct\n    // object to update for attached layer.\n    // See 3dtilesProvider or PointCloudProvider for examples.\n    // eslint-disable-next-line arrow-body-style\n\n    _this.getObjectToUpdateForAttachedLayers = function (obj) {\n      if (obj.parent && obj.material) {\n        return {\n          element: obj,\n          parent: obj.parent\n        };\n      }\n    };\n\n    return _this;\n  } // Placeholder\n  // eslint-disable-next-line\n\n\n  (0, _createClass2[\"default\"])(GeometryLayer, [{\n    key: \"postUpdate\",\n    value: function postUpdate() {} // Placeholder\n    // eslint-disable-next-line\n\n  }, {\n    key: \"culling\",\n    value: function culling() {\n      return true;\n    }\n    /**\n     * Attach another layer to this one. Layers attached to a GeometryLayer will\n     * be available in `geometryLayer.attachedLayers`.\n     *\n     * @param {Layer} layer - The layer to attach, that must have an `update`\n     * method.\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(layer) {\n      if (!layer.update) {\n        throw new Error(\"Missing 'update' function -> can't attach layer\\n                \".concat(layer.id));\n      }\n\n      this.attachedLayers.push(layer); // To traverse GeometryLayer object3d attached\n\n      layer.parent = this;\n    }\n    /**\n     * Detach a layer attached to this one. See {@link attach} to learn how to\n     * attach a layer.\n     *\n     * @param {Layer} layer - The layer to detach.\n     *\n     * @return {boolean} Confirmation of the detachment of the layer.\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach(layer) {\n      var count = this.attachedLayers.length;\n      this.attachedLayers = this.attachedLayers.filter(function (attached) {\n        return attached.id != layer.id;\n      });\n      layer.parent = undefined;\n      return this.attachedLayers.length < count;\n    }\n    /**\n     * All layer's meshs are removed from scene and disposed from video device.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _this2 = this;\n\n      // if Layer is attached\n      if (this.parent) {\n        traverse(this.parent.object3d, function (obj) {\n          if (obj.layer && obj.layer.id == _this2.id) {\n            obj.parent.remove(obj);\n            disposeMesh(obj);\n          }\n        });\n      } else {\n        if (this.object3d.parent) {\n          this.object3d.parent.remove(this.object3d);\n        }\n\n        this.object3d.traverse(disposeMesh);\n      }\n    }\n    /**\n     * Picking method for this layer. It uses the {@link Picking#pickObjectsAt}\n     * method.\n     *\n     * @param {View} view - The view instance.\n     * @param {Object} coordinates - The coordinates to pick in the view. It\n     * should have at least `x` and `y` properties.\n     * @param {number} radius - Radius of the picking circle.\n     *\n     * @return {Array} An array containing all targets picked under the\n     * specified coordinates.\n     */\n\n  }, {\n    key: \"pickObjectsAt\",\n    value: function pickObjectsAt(view, coordinates) {\n      var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.options.defaultPickingRadius;\n      return _Picking[\"default\"].pickObjectsAt(view, coordinates, radius, this.object3d);\n    }\n    /**\n     * Change the opacity of an object, according to the value of the `opacity`\n     * property of this layer.\n     *\n     * @param {Object} object - The object to change the opacity from. It is\n     * usually a `THREE.Object3d` or an implementation of it.\n     */\n\n  }, {\n    key: \"changeOpacity\",\n    value: function changeOpacity(object) {\n      if (object.material) {\n        // != undefined: we want the test to pass if opacity is 0\n        if (object.material.opacity != undefined) {\n          object.material.transparent = this.opacity < 1.0;\n          object.material.opacity = this.opacity;\n        }\n\n        if (object.material.uniforms && object.material.uniforms.opacity != undefined) {\n          object.material.transparent = this.opacity < 1.0;\n          object.material.uniforms.opacity.value = this.opacity;\n        }\n      }\n    }\n  }]);\n  return GeometryLayer;\n}(_Layer2[\"default\"]);\n\nvar _default = GeometryLayer;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Layer/GeometryLayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Layer/InfoLayer.js":
/*!****************************************************!*\
  !*** ./node_modules/itowns/lib/Layer/InfoLayer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InfoTiledGeometryLayer = exports[\"default\"] = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar InfoLayer =\n/*#__PURE__*/\nfunction () {\n  function InfoLayer(layer) {\n    (0, _classCallCheck2[\"default\"])(this, InfoLayer);\n    this.layer = layer;\n  } // eslint-disable-next-line\n\n\n  (0, _createClass2[\"default\"])(InfoLayer, [{\n    key: \"clear\",\n    value: function clear() {} // eslint-disable-next-line\n\n  }, {\n    key: \"update\",\n    value: function update() {}\n  }]);\n  return InfoLayer;\n}();\n/**\n * InfoTiledGeometryLayer that provides some states layer informations. These\n * informations are displayed tiles, displayed {@link ColorLayer} and {@link\n * ElevationLayer} and extent of displayed tiles.\n *\n * @class InfoTiledGeometryLayer\n *\n * @property {object} displayed\n * @property {Layer[]} displayed.layers - Displayed {@link ColorLayer} and {@link ElevationLayer}.\n * @property {Extent} displayed.extent - {@link Extent} of displayed tiles.\n * @property {Set} displayed.tiles - Set of displayed tiles.\n */\n\n\nexports[\"default\"] = InfoLayer;\n\nvar InfoTiledGeometryLayer =\n/*#__PURE__*/\nfunction (_InfoLayer) {\n  (0, _inherits2[\"default\"])(InfoTiledGeometryLayer, _InfoLayer);\n\n  function InfoTiledGeometryLayer(tiledGeometryLayer) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, InfoTiledGeometryLayer);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(InfoTiledGeometryLayer).call(this, tiledGeometryLayer));\n    _this.displayed = {\n      tiles: new Set()\n    };\n    Object.defineProperty(_this.displayed, 'layers', {\n      get: function get() {\n        var layers = [];\n\n        _this.displayed.tiles.forEach(function (tile) {\n          var m = tile.material;\n          layers = (0, _toConsumableArray2[\"default\"])(new Set([].concat((0, _toConsumableArray2[\"default\"])(layers), (0, _toConsumableArray2[\"default\"])(m.colorLayerIds.filter(function (id) {\n            return m.getLayer(id);\n          })), (0, _toConsumableArray2[\"default\"])(m.elevationLayerIds))));\n        });\n\n        return _this.layer.attachedLayers.filter(function (l) {\n          return layers.includes(l.id);\n        });\n      }\n    });\n    Object.defineProperty(_this.displayed, 'extent', {\n      get: function get() {\n        var extent = new _Extent[\"default\"](_this.layer.extent.crs, Infinity, -Infinity, Infinity, -Infinity);\n        extent.min = +Infinity;\n        extent.max = -Infinity;\n\n        _this.displayed.tiles.forEach(function (tile) {\n          extent.union(tile.extent);\n          extent.min = Math.min(tile.obb.z.min, extent.min);\n          extent.max = Math.max(tile.obb.z.max, extent.max);\n        });\n\n        return extent;\n      }\n    });\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(InfoTiledGeometryLayer, [{\n    key: \"clear\",\n    value: function clear() {\n      this.displayed.tiles.clear();\n    }\n  }, {\n    key: \"update\",\n    value: function update(tile) {\n      if (tile.material.visible) {\n        this.displayed.tiles.add(tile);\n      } else {\n        this.displayed.tiles[\"delete\"](tile);\n      }\n    }\n  }]);\n  return InfoTiledGeometryLayer;\n}(InfoLayer);\n\nexports.InfoTiledGeometryLayer = InfoTiledGeometryLayer;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Layer/InfoLayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Layer/Layer.js":
/*!************************************************!*\
  !*** ./node_modules/itowns/lib/Layer/Layer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ImageryLayers = exports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _LayerUpdateStrategy = __webpack_require__(/*! ./LayerUpdateStrategy */ \"./node_modules/itowns/lib/Layer/LayerUpdateStrategy.js\");\n\nvar _InfoLayer = _interopRequireDefault(__webpack_require__(/*! ./InfoLayer */ \"./node_modules/itowns/lib/Layer/InfoLayer.js\"));\n\n/**\n * @property {boolean} isLayer - Used to checkout whether this layer is a Layer.\n * Default is true. You should not change this, as it is used internally for\n * optimisation.\n */\nvar Layer =\n/*#__PURE__*/\nfunction (_THREE$EventDispatche) {\n  (0, _inherits2[\"default\"])(Layer, _THREE$EventDispatche);\n\n  /**\n   * Don't use directly constructor to instance a new Layer. Instead, use\n   * another available type of Layer, implement a new one inheriting from this\n   * one or use {@link View#addLayer}.\n   *\n   * @constructor\n   * @protected\n   *\n   * @param {string} id - The id of the layer, that should be unique. It is\n   * not mandatory, but an error will be emitted if this layer is added a\n   * {@link View} that already has a layer going by that id.\n   * @param {Object} [config] - Optional configuration, all elements in it\n   * will be merged as is in the layer. For example, if the configuration\n   * contains three elements `name, protocol, extent`, these elements will be\n   * available using `layer.name` or something else depending on the property\n   * name.\n   *\n   * @example\n   * // Add and create a new Layer\n   * const newLayer = new Layer('id', options);\n   * view.addLayer(newLayer);\n   *\n   * // Change layer's visibility\n   * const layerToChange = view.getLayerById('idLayerToChange');\n   * layerToChange.visible = false;\n   * view.notifyChange(); // update viewer\n   *\n   * // Change layer's opacity\n   * const layerToChange = view.getLayerById('idLayerToChange');\n   * layerToChange.opacity = 0.5;\n   * view.notifyChange(); // update viewer\n   *\n   * // Listen properties\n   * const layerToListen = view.getLayerById('idLayerToListen');\n   * layerToListen.addEventListener('visible-property-changed', (event) => console.log(event));\n   * layerToListen.addEventListener('opacity-property-changed', (event) => console.log(event));\n   */\n  function Layer(id) {\n    var _this;\n\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, Layer);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Layer).call(this));\n    _this.isLayer = true;\n    Object.assign((0, _assertThisInitialized2[\"default\"])(_this), config);\n    Object.defineProperty((0, _assertThisInitialized2[\"default\"])(_this), 'id', {\n      value: id,\n      writable: false\n    }); // Default properties\n\n    _this.options = config.options || {};\n\n    if (!_this.updateStrategy) {\n      _this.updateStrategy = {\n        type: _LayerUpdateStrategy.STRATEGY_MIN_NETWORK_TRAFFIC,\n        options: {}\n      };\n    }\n\n    _this.defineLayerProperty('frozen', false);\n\n    _this.info = new _InfoLayer[\"default\"]((0, _assertThisInitialized2[\"default\"])(_this));\n    return _this;\n  }\n  /**\n   * Defines a property for this layer, with a default value and a callback\n   * executed when the property changes.\n   * <br><br>\n   * When changing the property, it also emits an event, named following this\n   * convention: `${propertyName}-property-changed`, with `${propertyName}`\n   * being replaced by the name of the property.  For example, if the added\n   * property name is `frozen`, it will emit a `frozen-property-changed`.\n   * <br><br>\n   * @example <caption>The emitted event has some properties assigned to it</caption>\n   * event = {\n   *     new: {\n   *         ${propertyName}: * // the new value of the property\n   *     },\n   *     previous: {\n   *         ${propertyName}: * // the previous value of the property\n   *     },\n   *     target: Layer // the layer it has been dispatched from\n   *     type: string // the name of the emitted event\n   * }\n   *\n   * @param {string} propertyName - The name of the property, also used in\n   * the emitted event name.\n   * @param {*} defaultValue - The default set value.\n   * @param {function} [onChange] - The function executed when the property is\n   * changed. Parameters are the layer the property is defined on, and the\n   * name of the property.\n   */\n\n\n  (0, _createClass2[\"default\"])(Layer, [{\n    key: \"defineLayerProperty\",\n    value: function defineLayerProperty(propertyName, defaultValue, onChange) {\n      var _this2 = this;\n\n      var existing = Object.getOwnPropertyDescriptor(this, propertyName);\n\n      if (!existing || !existing.set) {\n        var property = this[propertyName] == undefined ? defaultValue : this[propertyName];\n        Object.defineProperty(this, propertyName, {\n          get: function get() {\n            return property;\n          },\n          set: function set(newValue) {\n            if (property !== newValue) {\n              var event = {\n                type: \"\".concat(propertyName, \"-property-changed\"),\n                previous: {},\n                \"new\": {}\n              };\n              event.previous[propertyName] = property;\n              event[\"new\"][propertyName] = newValue;\n              property = newValue;\n\n              if (onChange) {\n                onChange(_this2, propertyName);\n              }\n\n              _this2.dispatchEvent(event);\n            }\n          }\n        });\n      }\n    } // Placeholder\n    // eslint-disable-next-line\n\n  }, {\n    key: \"convert\",\n    value: function convert(data) {\n      return data;\n    }\n    /**\n     * Remove and dispose all objects from layer.\n     */\n    // eslint-disable-next-line\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      console.warn('Function delete doesn\\'t exist for this layer');\n    }\n  }]);\n  return Layer;\n}(THREE.EventDispatcher);\n\nvar _default = Layer;\nexports[\"default\"] = _default;\nvar ImageryLayers = {\n  // move this to new index\n  // After the modification :\n  //      * the minimum sequence will always be 0\n  //      * the maximum sequence will always be layers.lenght - 1\n  // the ordering of all layers (Except that specified) doesn't change\n  moveLayerToIndex: function (layer, newIndex, imageryLayers) {\n    newIndex = Math.min(newIndex, imageryLayers.length - 1);\n    newIndex = Math.max(newIndex, 0);\n    var oldIndex = layer.sequence;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = imageryLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var imagery = _step.value;\n\n        if (imagery.id === layer.id) {\n          // change index of specified layer\n          imagery.sequence = newIndex;\n        } else if (imagery.sequence > oldIndex && imagery.sequence <= newIndex) {\n          // down all layers between the old index and new index (to compensate the deletion of the old index)\n          imagery.sequence--;\n        } else if (imagery.sequence >= newIndex && imagery.sequence < oldIndex) {\n          // up all layers between the new index and old index (to compensate the insertion of the new index)\n          imagery.sequence++;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  },\n  moveLayerDown: function (layer, imageryLayers) {\n    if (layer.sequence > 0) {\n      this.moveLayerToIndex(layer, layer.sequence - 1, imageryLayers);\n    }\n  },\n  moveLayerUp: function (layer, imageryLayers) {\n    var m = imageryLayers.length - 1;\n\n    if (layer.sequence < m) {\n      this.moveLayerToIndex(layer, layer.sequence + 1, imageryLayers);\n    }\n  },\n  getColorLayersIdOrderedBySequence: function (imageryLayers) {\n    var copy = Array.from(imageryLayers);\n    copy.sort(function (a, b) {\n      return a.sequence - b.sequence;\n    });\n    return copy.map(function (l) {\n      return l.id;\n    });\n  }\n};\nexports.ImageryLayers = ImageryLayers;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Layer/Layer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Layer/LayerUpdateState.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Layer/LayerUpdateState.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar UPDATE_STATE = {\n  IDLE: 0,\n  PENDING: 1,\n  ERROR: 2,\n  DEFINITIVE_ERROR: 3,\n  FINISHED: 4\n};\nvar PAUSE_BETWEEN_ERRORS = [1.0, 3.0, 7.0, 60.0];\n/**\n * LayerUpdateState is the update state of a layer, for a given object (e.g tile).\n * It stores information to allow smart update decisions, and especially network\n * error handling.\n * @constructor\n */\n\nfunction LayerUpdateState() {\n  this.state = UPDATE_STATE.IDLE;\n  this.lastErrorTimestamp = 0;\n  this.errorCount = 0;\n}\n\nLayerUpdateState.prototype.canTryUpdate = function () {\n  var timestamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n\n  switch (this.state) {\n    case UPDATE_STATE.IDLE:\n      {\n        return true;\n      }\n\n    case UPDATE_STATE.DEFINITIVE_ERROR:\n    case UPDATE_STATE.PENDING:\n    case UPDATE_STATE.FINISHED:\n      {\n        return false;\n      }\n\n    case UPDATE_STATE.ERROR:\n    default:\n      {\n        var errorDuration = this.secondsUntilNextTry() * 1000;\n        return errorDuration <= timestamp - this.lastErrorTimestamp;\n      }\n  }\n};\n\nLayerUpdateState.prototype.secondsUntilNextTry = function () {\n  if (this.state !== UPDATE_STATE.ERROR) {\n    return 0;\n  }\n\n  var idx = Math.max(0, Math.min(this.errorCount, PAUSE_BETWEEN_ERRORS.length) - 1);\n  return PAUSE_BETWEEN_ERRORS[idx];\n};\n\nLayerUpdateState.prototype.newTry = function () {\n  this.state = UPDATE_STATE.PENDING;\n};\n\nLayerUpdateState.prototype.success = function () {\n  this.failureParams = undefined;\n  this.lastErrorTimestamp = 0;\n  this.state = UPDATE_STATE.IDLE;\n};\n\nLayerUpdateState.prototype.noMoreUpdatePossible = function () {\n  this.failureParams = undefined;\n  this.state = UPDATE_STATE.FINISHED;\n};\n\nLayerUpdateState.prototype.failure = function (timestamp, definitive, failureParams) {\n  this.failureParams = failureParams;\n  this.lastErrorTimestamp = timestamp;\n  this.state = definitive ? UPDATE_STATE.DEFINITIVE_ERROR : UPDATE_STATE.ERROR;\n  this.errorCount++;\n};\n\nLayerUpdateState.prototype.inError = function () {\n  return this.state == UPDATE_STATE.DEFINITIVE_ERROR || this.state == UPDATE_STATE.ERROR;\n};\n\nvar _default = LayerUpdateState;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Layer/LayerUpdateState.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Layer/LayerUpdateStrategy.js":
/*!**************************************************************!*\
  !*** ./node_modules/itowns/lib/Layer/LayerUpdateStrategy.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chooseNextLevelToFetch = chooseNextLevelToFetch;\nexports.STRATEGY_DICHOTOMY = exports.STRATEGY_PROGRESSIVE = exports.STRATEGY_GROUP = exports.STRATEGY_MIN_NETWORK_TRAFFIC = void 0;\n\nvar _MaterialLayer = __webpack_require__(/*! ../Renderer/MaterialLayer */ \"./node_modules/itowns/lib/Renderer/MaterialLayer.js\");\n\n/**\n * This modules implements various layer update strategies.\n *\n * Default strategy is STRATEGY_MIN_NETWORK_TRAFFIC which aims\n * to reduce the amount of network traffic.\n */\nvar STRATEGY_MIN_NETWORK_TRAFFIC = 0;\nexports.STRATEGY_MIN_NETWORK_TRAFFIC = STRATEGY_MIN_NETWORK_TRAFFIC;\nvar STRATEGY_GROUP = 1;\nexports.STRATEGY_GROUP = STRATEGY_GROUP;\nvar STRATEGY_PROGRESSIVE = 2;\nexports.STRATEGY_PROGRESSIVE = STRATEGY_PROGRESSIVE;\nvar STRATEGY_DICHOTOMY = 3;\nexports.STRATEGY_DICHOTOMY = STRATEGY_DICHOTOMY;\n\nfunction _minimizeNetworkTraffic(node, nodeLevel, currentLevel) {\n  if (node.pendingSubdivision) {\n    return currentLevel;\n  }\n\n  return nodeLevel;\n} // Maps nodeLevel to groups defined in layer's options\n// eg with groups = [3, 7, 12]:\n//     * nodeLevel = 2 -> 3\n//     * nodeLevel = 4 -> 3\n//     * nodeLevel = 7 -> 7\n//     * nodeLevel = 15 -> 12\n\n\nfunction _group(nodeLevel, currentLevel, options) {\n  var f = options.groups.filter(function (val) {\n    return val <= nodeLevel;\n  });\n  return f.length ? f[f.length - 1] : options.groups[0];\n}\n\nfunction _progressive(nodeLevel, currentLevel, options) {\n  return Math.min(nodeLevel, currentLevel + (options.increment || 1));\n} // Load textures at mid-point between current level and node's level.\n// This produces smoother transitions and a single fetch updates multiple\n// tiles thanks to caching.\n\n\nfunction _dichotomy(nodeLevel, currentLevel) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (currentLevel == _MaterialLayer.EMPTY_TEXTURE_ZOOM) {\n    return options.zoom ? options.zoom.min : 0;\n  }\n\n  return Math.min(nodeLevel, Math.ceil((currentLevel + nodeLevel) / 2));\n}\n\nfunction chooseNextLevelToFetch(strategy, node) {\n  var nodeLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.level;\n  var currentLevel = arguments.length > 3 ? arguments[3] : undefined;\n  var layer = arguments.length > 4 ? arguments[4] : undefined;\n  var failureParams = arguments.length > 5 ? arguments[5] : undefined;\n  var nextLevelToFetch;\n  var maxZoom = layer.source.zoom ? layer.source.zoom.max : Infinity;\n\n  if (failureParams) {\n    nextLevelToFetch = _dichotomy(failureParams.targetLevel, currentLevel, layer.source);\n  } else {\n    switch (strategy) {\n      case STRATEGY_GROUP:\n        nextLevelToFetch = _group(nodeLevel, currentLevel, layer.updateStrategy.options);\n        break;\n\n      case STRATEGY_PROGRESSIVE:\n        {\n          nextLevelToFetch = _progressive(nodeLevel, currentLevel, layer.updateStrategy.options);\n          break;\n        }\n\n      case STRATEGY_DICHOTOMY:\n        nextLevelToFetch = _dichotomy(nodeLevel, currentLevel, layer.source);\n        break;\n      // default strategy\n\n      case STRATEGY_MIN_NETWORK_TRAFFIC:\n      default:\n        nextLevelToFetch = _minimizeNetworkTraffic(node, nodeLevel, currentLevel);\n    }\n  }\n\n  return Math.min(nextLevelToFetch, maxZoom);\n}\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Layer/LayerUpdateStrategy.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Layer/OrientedImageLayer.js":
/*!*************************************************************!*\
  !*** ./node_modules/itowns/lib/Layer/OrientedImageLayer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ \"./node_modules/@babel/runtime/helpers/get.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _GeometryLayer2 = _interopRequireDefault(__webpack_require__(/*! ./GeometryLayer */ \"./node_modules/itowns/lib/Layer/GeometryLayer.js\"));\n\nvar _OrientedImageMaterial = _interopRequireDefault(__webpack_require__(/*! ../Renderer/OrientedImageMaterial */ \"./node_modules/itowns/lib/Renderer/OrientedImageMaterial.js\"));\n\nvar _GeoJsonParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/GeoJsonParser */ \"./node_modules/itowns/lib/Parser/GeoJsonParser.js\"));\n\nvar _CameraCalibrationParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/CameraCalibrationParser */ \"./node_modules/itowns/lib/Parser/CameraCalibrationParser.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _OrientationUtils = _interopRequireDefault(__webpack_require__(/*! ../Utils/OrientationUtils */ \"./node_modules/itowns/lib/Utils/OrientationUtils.js\"));\n\nvar coord = new _Coordinates[\"default\"]('EPSG:4978', 0, 0, 0);\n\nvar commandCancellation = function (cmd) {\n  return cmd.requester.id !== cmd.layer.currentPano.id;\n};\n\nfunction updatePano(context, camera, layer) {\n  var newPano = layer.mostNearPano(camera.position); // detection of oriented image change\n\n  var currentId = layer.currentPano ? layer.currentPano.id : undefined;\n\n  if (newPano && currentId != newPano.id) {\n    layer.currentPano = newPano; // callback to indicate current pano has changed\n\n    layer.onPanoChanged({\n      previousPanoPosition: layer.getPreviousPano() ? layer.getPreviousPano().position : undefined,\n      currentPanoPosition: layer.getCurrentPano().position,\n      nextPanoPosition: layer.getNextPano().position\n    }); // prepare informations about the needed textures\n\n    var panoCameras = newPano.geometry[0].properties.idSensors;\n    var imagesInfo = layer.cameras.map(function (cam) {\n      return {\n        cameraId: cam.name,\n        panoId: newPano.id,\n        as: function as() {},\n        toString: function toString() {\n          var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n          return \"\".concat(cam.name).concat(separator).concat(newPano.id);\n        }\n      };\n    }).filter(function (info) {\n      return !panoCameras || panoCameras.includes(info.cameraId);\n    });\n    var command = {\n      layer: layer,\n      // put informations about image URL as extent to be used by generic DataSourceProvider, OrientedImageSource will use that.\n      extentsSource: imagesInfo,\n      view: context.view,\n      threejsLayer: layer.threejsLayer,\n      requester: newPano,\n      earlyDropFunction: commandCancellation\n    }; // async call to scheduler to get textures\n\n    context.scheduler.execute(command).then(function (textures) {\n      if (newPano.id === layer.currentPano.id) {\n        layer.material.setTextures(textures, newPano, layer.getCamerasNameFromFeature(newPano));\n        layer.material.updateUniforms(context.camera.camera3D);\n        context.view.notifyChange(layer, true);\n      }\n    }, function () {});\n  }\n}\n\nfunction updateBackground(layer) {\n  if (layer.background && layer.currentPano) {\n    layer.background.position.copy(layer.currentPano.position);\n    layer.background.updateMatrixWorld();\n    layer.background.material = layer.material || layer.background.material;\n  }\n}\n\nfunction createBackground(radius) {\n  if (!radius || radius <= 0) {\n    return undefined;\n  }\n\n  var geometry = new THREE.SphereGeometry(radius, 32, 32);\n  var material = new THREE.MeshPhongMaterial({\n    color: 0x7777ff,\n    side: THREE.DoubleSide,\n    transparent: true,\n    opacity: 0.5,\n    wireframe: true\n  });\n  var sphere = new THREE.Mesh(geometry, material);\n  sphere.visible = true;\n  sphere.name = 'OrientedImageBackground';\n  return sphere;\n}\n/**\n * @classdesc OrientedImageLayer loads oriented images, and project these textures on the scene.\n * It is design to create an immersive view. </br>\n * It loads a set of panoramic position and orientation,\n * a set of camera calibration file (it's the same set of camera for each panoramic),\n * and a set of texture (each image for each camera for each panoramic), all organised in an {@link OrientedImageSource}. </br>\n * It creates an {@link OrientedImageMaterial} used to do projective texture mapping on the scene.\n * @extends GeometryLayer\n */\n\n\nvar OrientedImageLayer =\n/*#__PURE__*/\nfunction (_GeometryLayer) {\n  (0, _inherits2[\"default\"])(OrientedImageLayer, _GeometryLayer);\n\n  /**\n   * @constructor\n   * @param { string } id - The id of the layer, a unique name.\n   * @param { Object } config - configuration of the layer\n   * @param { number } config.backgroundDistance - Radius in meter of the sphere used as a background\n   * @param { function } config.onPanoChanged - callback fired when current panoramic changes\n   * @param { string } config.projection - projection of the view\n   * @param { string } config.orientation - Json object, using GeoJSon format to represent points,\n   * it's a set of panoramic position and orientation.\n   * @param { string } config.calibrations - Json object, representing a set of camera. see [CameraCalibrationParser]{@link module:CameraCalibrationParser}\n   * @param { OrientedImageSource } config.source - Source used to build url of texture for each oriented image,\n   * a tecture is need for each camera, for each panoramic.\n   */\n  function OrientedImageLayer(id) {\n    var _this;\n\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, OrientedImageLayer);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(OrientedImageLayer).call(this, id, new THREE.Group(), config));\n    _this.background = config.background || createBackground(config.backgroundDistance);\n    _this.isOrientedImageLayer = true;\n\n    if (_this.background) {\n      _this.object3d.add(_this.background);\n    } // currentPano is the current point, means it's the closest from the camera\n\n\n    _this.currentPano = undefined; // store a callback to fire event when current panoramic change\n\n    _this.onPanoChanged = config.onPanoChanged || function () {}; // function to get cameras name from panoramic feature\n\n\n    _this.getCamerasNameFromFeature = config.getCamerasNameFromFeature || function () {}; // panos is an array of feature point, representing many panoramics.\n    // for each point, there is a position and a quaternion attribute.\n\n\n    var p1 = _GeoJsonParser[\"default\"].parse(config.orientation, {\n      mergeFeatures: false,\n      crsOut: config.projection\n    }).then(function (res) {\n      _this.panos = res.features;\n      var crsIn = res.optionsFeature.crsIn;\n      var crsOut = config.projection;\n\n      var crs2crs = _OrientationUtils[\"default\"].quaternionFromCRSToCRS(crsIn, crsOut);\n\n      var quat = new THREE.Quaternion(); // add position and quaternion attributes from point feature\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _this.panos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var pano = _step.value;\n          // set position\n          coord.crs = pano.crs;\n          coord.setFromArray(pano.vertices);\n          pano.position = coord.toVector3(); // set quaternion\n\n          crs2crs(coord, quat);\n          pano.quaternion = _OrientationUtils[\"default\"].quaternionFromAttitude(pano.geometry[0].properties).premultiply(quat); // TODO clean DataSourceProvider, so that we don't have this hack to do\n\n          pano.material = {};\n          pano.id = pano.geometry[0].properties.id;\n          pano.index = i++;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }); // array of cameras, represent the projective texture configuration for each panoramic.\n\n\n    var p2 = _CameraCalibrationParser[\"default\"].parse(config.calibration, config).then(function (c) {\n      _this.cameras = c; // create the material\n\n      _this.material = new _OrientedImageMaterial[\"default\"](_this.cameras, config);\n    }); // wait for the twos promises to tell layer is ready.\n\n\n    _this.whenReady = Promise.all([p1, p2]).then(function () {\n      _this.ready = true;\n      return (0, _assertThisInitialized2[\"default\"])(_this);\n    });\n    return _this;\n  } // eslint-disable-next-line\n\n\n  (0, _createClass2[\"default\"])(OrientedImageLayer, [{\n    key: \"update\",\n    value: function update() {}\n  }, {\n    key: \"preUpdate\",\n    value: function preUpdate(context) {\n      updatePano(context, context.camera.camera3D, this);\n      this.material.updateUniforms(context.camera.camera3D);\n      updateBackground(this);\n    }\n  }, {\n    key: \"getNextPano\",\n    value: function getNextPano() {\n      var index = (this.currentPano.index + 1) % this.panos.length;\n      return this.panos[index];\n    }\n  }, {\n    key: \"getCurrentPano\",\n    value: function getCurrentPano() {\n      return this.currentPano;\n    }\n  }, {\n    key: \"getPreviousPano\",\n    value: function getPreviousPano() {\n      var index = (this.currentPano.index - 1) % this.panos.length;\n      return this.panos[index];\n    }\n    /**\n     * Delete background, but doesn't delete OrientedImageLayer.material. For the moment, this material visibility is set to false.\n     * You need to replace OrientedImageLayer.material applied on each object, if you want to continue displaying them.\n     * This issue (see #1018 {@link https://github.com/iTowns/itowns/issues/1018}) will be fixed when OrientedImageLayer will be a ColorLayer.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(OrientedImageLayer.prototype), \"delete\", this).call(this);\n      this.material.visible = false;\n      console.warn('You need to replace OrientedImageLayer.material applied on each object. This issue will be fixed when OrientedImageLayer will be a ColorLayer. the material visibility is set to false. To follow issue see https://github.com/iTowns/itowns/issues/1018');\n    }\n  }, {\n    key: \"mostNearPano\",\n    value: function mostNearPano(position) {\n      var minDistance = Infinity;\n      var nearPano;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.panos[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var pano = _step2.value;\n          var distance = position.distanceTo(pano.position);\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearPano = pano;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return nearPano;\n    }\n  }, {\n    key: \"boostLight\",\n    set: function set(value) {\n      this.material.uniforms.boostLight.value = value;\n    },\n    get: function get() {\n      return this.material.uniforms.boostLight.value;\n    }\n  }]);\n  return OrientedImageLayer;\n}(_GeometryLayer2[\"default\"]);\n\nvar _default = OrientedImageLayer;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Layer/OrientedImageLayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Layer/TiledGeometryLayer.js":
/*!*************************************************************!*\
  !*** ./node_modules/itowns/lib/Layer/TiledGeometryLayer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _GeometryLayer2 = _interopRequireDefault(__webpack_require__(/*! ./GeometryLayer */ \"./node_modules/itowns/lib/Layer/GeometryLayer.js\"));\n\nvar _InfoLayer = __webpack_require__(/*! ./InfoLayer */ \"./node_modules/itowns/lib/Layer/InfoLayer.js\");\n\nvar _Picking = _interopRequireDefault(__webpack_require__(/*! ../Core/Picking */ \"./node_modules/itowns/lib/Core/Picking.js\"));\n\nvar _convertToTile = _interopRequireDefault(__webpack_require__(/*! ../Converter/convertToTile */ \"./node_modules/itowns/lib/Converter/convertToTile.js\"));\n\nvar _CancelledCommandException = _interopRequireDefault(__webpack_require__(/*! ../Core/Scheduler/CancelledCommandException */ \"./node_modules/itowns/lib/Core/Scheduler/CancelledCommandException.js\"));\n\nvar _ObjectRemovalHelper = _interopRequireDefault(__webpack_require__(/*! ../Process/ObjectRemovalHelper */ \"./node_modules/itowns/lib/Process/ObjectRemovalHelper.js\"));\n\nvar _LayeredMaterialNodeProcessing = __webpack_require__(/*! ../Process/LayeredMaterialNodeProcessing */ \"./node_modules/itowns/lib/Process/LayeredMaterialNodeProcessing.js\");\n\nvar _Layer = __webpack_require__(/*! ./Layer */ \"./node_modules/itowns/lib/Layer/Layer.js\");\n\nvar subdivisionVector = new THREE.Vector3();\nvar boundingSphereCenter = new THREE.Vector3();\n/**\n * @property {InfoTiledGeometryLayer} info - Status information of layer\n * @property {boolean} isTiledGeometryLayer - Used to checkout whether this\n * layer is a TiledGeometryLayer. Default is true. You should not change this,\n * as it is used internally for optimisation.\n */\n\nvar TiledGeometryLayer =\n/*#__PURE__*/\nfunction (_GeometryLayer) {\n  (0, _inherits2[\"default\"])(TiledGeometryLayer, _GeometryLayer);\n\n  /**\n   * A layer extending the {@link GeometryLayer}, but with a tiling notion.\n   *\n   * @constructor\n   * @extends GeometryLayer\n   *\n   * @param {string} id - The id of the layer, that should be unique. It is\n   * not mandatory, but an error will be emitted if this layer is added a\n   * {@link View} that already has a layer going by that id.\n   * @param {THREE.Object3d} object3d - The object3d used to contain the\n   * geometry of the TiledGeometryLayer. It is usually a `THREE.Group`, but it\n   * can be anything inheriting from a `THREE.Object3d`.\n   * @param {Array} schemeTile - extents Array of root tiles\n   * @param {Object} builder - builder geometry object\n   * @param {Object} [config] - Optional configuration, all elements in it\n   * will be merged as is in the layer. For example, if the configuration\n   * contains three elements `name, protocol, extent`, these elements will be\n   * available using `layer.name` or something else depending on the property\n   * name.\n   * @param {Source} [config.source] - Description and options of the source.\n   *\n   * @throws {Error} `object3d` must be a valid `THREE.Object3d`.\n   */\n  function TiledGeometryLayer(id, object3d, schemeTile, builder, config) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, TiledGeometryLayer);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(TiledGeometryLayer).call(this, id, object3d, config));\n    _this.isTiledGeometryLayer = true;\n    _this.protocol = 'tile';\n    _this.sseSubdivisionThreshold = _this.sseSubdivisionThreshold || 1.0;\n    _this.schemeTile = schemeTile;\n    _this.builder = builder;\n    _this.info = new _InfoLayer.InfoTiledGeometryLayer((0, _assertThisInitialized2[\"default\"])(_this));\n\n    if (!_this.schemeTile) {\n      throw new Error(\"Cannot init tiled layer without schemeTile for layer \".concat(_this.id));\n    }\n\n    if (!_this.builder) {\n      throw new Error(\"Cannot init tiled layer without builder for layer \".concat(_this.id));\n    }\n\n    _this.level0Nodes = [];\n    var promises = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _this.schemeTile[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var root = _step.value;\n        promises.push(_this.convert(undefined, root));\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    Promise.all(promises).then(function (level0s) {\n      _this.level0Nodes = level0s;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = level0s[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var level0 = _step2.value;\n\n          _this.object3d.add(level0);\n\n          level0.updateMatrixWorld();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n    return _this;\n  }\n  /**\n   * Picking method for this layer. It uses the {@link Picking#pickTilesAt}\n   * method.\n   *\n   * @param {View} view - The view instance.\n   * @param {Object} coordinates - The coordinates to pick in the view. It\n   * should have at least `x` and `y` properties.\n   * @param {number} radius - Radius of the picking circle.\n   *\n   * @return {Array} An array containing all targets picked under the\n   * specified coordinates.\n   */\n\n\n  (0, _createClass2[\"default\"])(TiledGeometryLayer, [{\n    key: \"pickObjectsAt\",\n    value: function pickObjectsAt(view, coordinates) {\n      var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.options.defaultPickingRadius;\n      return _Picking[\"default\"].pickTilesAt(view, coordinates, radius, this);\n    }\n    /**\n     * Does pre-update work on the context:\n     * <ul>\n     *  <li>update the `colorLayers` and `elevationLayers`</li>\n     *  <li>update the `maxElevationLevel`</li>\n     * </ul>\n     *\n     * Once this work is done, it returns a list of nodes to update. Depending\n     * on the origin of `sources`, it can return a few things:\n     * <ul>\n     *  <li>if `sources` is empty, it returns the first node of the layer\n     *  (stored as `level0Nodes`), which will trigger the update of the whole\n     *  tree</li>\n     *  <li>if the update is triggered by a camera move, the whole tree is\n     *  returned too</li>\n     *  <li>if `source.layer` is this layer, it means that `source` is a node; a\n     *  common ancestor will be found if there are multiple sources, with the\n     *  default common ancestor being the first source itself</li>\n     *  <li>else it returns the whole tree</li>\n     * </ul>\n     *\n     * @param {Object} context - The context of the update; see the {@link\n     * MainLoop} for more informations.\n     * @param {Set<GeometryLayer|TileMesh>} sources - A list of sources to\n     * generate a list of nodes to update.\n     *\n     * @return {TileMesh[]} The array of nodes to update.\n     */\n\n  }, {\n    key: \"preUpdate\",\n    value: function preUpdate(context, sources) {\n      var _this2 = this;\n\n      if (sources.has(undefined) || sources.size == 0) {\n        return this.level0Nodes;\n      }\n\n      context.colorLayers = context.view.getLayers(function (l, a) {\n        return a && a.id == _this2.id && l.isColorLayer;\n      });\n      context.elevationLayers = context.view.getLayers(function (l, a) {\n        return a && a.id == _this2.id && l.isElevationLayer;\n      });\n      context.maxElevationLevel = -1;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = context.elevationLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var e = _step3.value;\n          context.maxElevationLevel = Math.max(e.source.zoom.max, context.maxElevationLevel);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      if (context.maxElevationLevel == -1) {\n        context.maxElevationLevel = Infinity;\n      } // Prepare ColorLayer sequence order\n      // In this moment, there is only one color layers sequence, because they are attached to tileLayer.\n      // In future, the sequence must be returned by parent geometry layer.\n\n\n      this.colorLayersOrder = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(context.colorLayers);\n      var commonAncestor;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = sources.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var source = _step4.value;\n\n          if (source.isCamera) {\n            // if the change is caused by a camera move, no need to bother\n            // to find common ancestor: we need to update the whole tree:\n            // some invisible tiles may now be visible\n            return this.level0Nodes;\n          }\n\n          if (source.layer === this) {\n            if (!commonAncestor) {\n              commonAncestor = source;\n            } else {\n              commonAncestor = source.findCommonAncestor(commonAncestor);\n\n              if (!commonAncestor) {\n                return this.level0Nodes;\n              }\n            }\n\n            if (commonAncestor.material == null) {\n              commonAncestor = undefined;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      if (commonAncestor) {\n        return [commonAncestor];\n      } else {\n        return this.level0Nodes;\n      }\n    }\n    /**\n     * Update a node of this layer. The node will not be updated if:\n     * <ul>\n     *  <li>it does not have a parent, then it is removed</li>\n     *  <li>its parent is being subdivided</li>\n     *  <li>is not visible in the camera</li>\n     * </ul>\n     *\n     * @param {Object} context - The context of the update; see the {@link\n     * MainLoop} for more informations.\n     * @param {Layer} layer - Parameter to be removed once all update methods\n     * have been aligned.\n     * @param {TileMesh} node - The node to update.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(context, layer, node) {\n      var _this3 = this;\n\n      if (!node.parent) {\n        return _ObjectRemovalHelper[\"default\"].removeChildrenAndCleanup(this, node);\n      } // early exit if parent' subdivision is in progress\n\n\n      if (node.parent.pendingSubdivision) {\n        node.visible = false;\n        node.material.visible = false;\n        this.info.update(node);\n        return undefined;\n      } // do proper culling\n\n\n      node.visible = !this.culling(node, context.camera);\n\n      if (node.visible) {\n        var requestChildrenUpdate = false;\n        node.material.visible = true;\n        this.info.update(node);\n\n        if (node.pendingSubdivision || TiledGeometryLayer.hasEnoughTexturesToSubdivide(context, node) && this.subdivision(context, this, node)) {\n          this.subdivideNode(context, node); // display iff children aren't ready\n\n          node.material.visible = node.pendingSubdivision;\n          this.info.update(node);\n          requestChildrenUpdate = true;\n        }\n\n        if (node.material.visible) {\n          if (!requestChildrenUpdate) {\n            return _ObjectRemovalHelper[\"default\"].removeChildren(this, node);\n          }\n        }\n\n        return requestChildrenUpdate ? node.children.filter(function (n) {\n          return n.layer == _this3;\n        }) : undefined;\n      }\n\n      node.material.visible = false;\n      this.info.update(node);\n      return _ObjectRemovalHelper[\"default\"].removeChildren(this, node);\n    }\n  }, {\n    key: \"convert\",\n    value: function convert(requester, extent) {\n      return _convertToTile[\"default\"].convert(requester, extent, this);\n    }\n  }, {\n    key: \"countColorLayersTextures\",\n    value: function countColorLayersTextures() {\n      return arguments.length;\n    } // eslint-disable-next-line\n\n  }, {\n    key: \"culling\",\n    value: function culling(node, camera) {\n      return !camera.isBox3Visible(node.obb.box3D, node.obb.matrixWorld);\n    }\n    /**\n     * Tell if a node has enough elevation or color textures to subdivide.\n     * Subdivision is prevented if:\n     * <ul>\n     *  <li>the node is covered by at least one elevation layer and if the node\n     *  doesn't have an elevation texture yet</li>\n     *  <li>a color texture is missing</li>\n     * </ul>\n     *\n     * @param {Object} context - The context of the update; see the {@link\n     * MainLoop} for more informations.\n     * @param {TileMesh} node - The node to subdivide.\n     *\n     * @returns {boolean} False if the node can not be subdivided, true\n     * otherwise.\n     */\n\n  }, {\n    key: \"subdivideNode\",\n\n    /**\n     * Subdivides a node of this layer. If the node is currently in the process\n     * of subdivision, it will not do anything here. The subdivision of a node\n     * will occur in four part, to create a quadtree. The extent of the node\n     * will be divided in four parts: north-west, north-east, south-west and\n     * south-east. Once all four nodes are created, they will be added to the\n     * current node and the view of the context will be notified of this change.\n     *\n     * @param {Object} context - The context of the update; see the {@link\n     * MainLoop} for more informations.\n     * @param {TileMesh} node - The node to subdivide.\n     * @return {Promise}  { description_of_the_return_value }\n     */\n    value: function subdivideNode(context, node) {\n      var _this4 = this;\n\n      if (!node.pendingSubdivision && !node.children.some(function (n) {\n        return n.layer == _this4;\n      })) {\n        var extents = node.extent.subdivision(); // TODO: pendingSubdivision mechanism is fragile, get rid of it\n\n        node.pendingSubdivision = true;\n        var command = {\n          /* mandatory */\n          view: context.view,\n          requester: node,\n          layer: this,\n          priority: 10000,\n\n          /* specific params */\n          extentsSource: extents,\n          redraw: false\n        };\n        return context.scheduler.execute(command).then(function (children) {\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var child = _step5.value;\n              node.add(child);\n              child.updateMatrixWorld(true);\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n                _iterator5[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n\n          node.pendingSubdivision = false;\n          context.view.notifyChange(node, false);\n        }, function (err) {\n          node.pendingSubdivision = false;\n\n          if (!(err instanceof _CancelledCommandException[\"default\"])) {\n            throw new Error(err);\n          }\n        });\n      }\n    }\n    /**\n     * Test the subdvision of a node, compared to this layer.\n     *\n     * @param {Object} context - The context of the update; see the {@link\n     * MainLoop} for more informations.\n     * @param {PlanarLayer} layer - This layer, parameter to be removed.\n     * @param {TileMesh} node - The node to test.\n     *\n     * @return {boolean} - True if the node is subdivisable, otherwise false.\n     */\n\n  }, {\n    key: \"subdivision\",\n    value: function subdivision(context, layer, node) {\n      if (node.level < this.minSubdivisionLevel) {\n        return true;\n      }\n\n      if (this.maxSubdivisionLevel <= node.level) {\n        return false;\n      } // Prevent to subdivise the node if the current elevation level\n      // we must avoid a tile, with level 20, inherits a level 3 elevation texture.\n      // The induced geometric error is much too large and distorts the SSE\n\n\n      var nodeLayer = node.material.getElevationLayer();\n\n      if (nodeLayer) {\n        var currentTexture = nodeLayer.textures[0];\n\n        if (currentTexture && currentTexture.extent) {\n          var offsetScale = nodeLayer.offsetScales[0];\n          var ratio = offsetScale.z; // ratio is node size / texture size\n\n          if (ratio < 1 / Math.pow(2, this.maxDeltaElevationLevel)) {\n            return false;\n          }\n        }\n      }\n\n      subdivisionVector.setFromMatrixScale(node.matrixWorld);\n      boundingSphereCenter.copy(node.boundingSphere.center).applyMatrix4(node.matrixWorld);\n      var distance = Math.max(0.0, context.camera.camera3D.position.distanceTo(boundingSphereCenter) - node.boundingSphere.radius * subdivisionVector.x); // Size projection on pixel of bounding\n\n      node.screenSize = context.camera._preSSE * (2 * node.boundingSphere.radius * subdivisionVector.x) / distance; // The screen space error is calculated to have a correct texture display.\n      // For the projection of a texture's texel to be less than or equal to one pixel\n\n      var sse = node.screenSize / (_LayeredMaterialNodeProcessing.SIZE_DIAGONAL_TEXTURE * 2);\n      return this.sseSubdivisionThreshold < sse;\n    }\n  }], [{\n    key: \"hasEnoughTexturesToSubdivide\",\n    value: function hasEnoughTexturesToSubdivide(context, node) {\n      var layerUpdateState = node.layerUpdateState || {};\n      var nodeLayer = node.material.getElevationLayer();\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = context.elevationLayers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var e = _step6.value;\n          var extents = node.getExtentsByProjection(e.projection);\n\n          if (!e.frozen && e.ready && e.source.extentsInsideLimit(extents) && (!nodeLayer || nodeLayer.level < 0)) {\n            // no stop subdivision in the case of a loading error\n            if (layerUpdateState[e.id] && layerUpdateState[e.id].inError()) {\n              continue;\n            }\n\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n            _iterator6[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = context.colorLayers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var c = _step7.value;\n\n          if (c.frozen || !c.visible || !c.ready) {\n            continue;\n          } // no stop subdivision in the case of a loading error\n\n\n          if (layerUpdateState[c.id] && layerUpdateState[c.id].inError()) {\n            continue;\n          }\n\n          var _extents = node.getExtentsByProjection(c.projection);\n\n          nodeLayer = node.material.getLayer(c.id);\n\n          if (c.source.extentsInsideLimit(_extents) && (!nodeLayer || nodeLayer.level < 0)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n            _iterator7[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return true;\n    }\n  }]);\n  return TiledGeometryLayer;\n}(_GeometryLayer2[\"default\"]);\n\nvar _default = TiledGeometryLayer;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Layer/TiledGeometryLayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Main.js":
/*!*****************************************!*\
  !*** ./node_modules/itowns/lib/Main.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Extent\", {\n  enumerable: true,\n  get: function get() {\n    return _Extent[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"Coordinates\", {\n  enumerable: true,\n  get: function get() {\n    return _Coordinates[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"CRS\", {\n  enumerable: true,\n  get: function get() {\n    return _Crs[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"Ellipsoid\", {\n  enumerable: true,\n  get: function get() {\n    return _Ellipsoid[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"ellipsoidSizes\", {\n  enumerable: true,\n  get: function get() {\n    return _Ellipsoid.ellipsoidSizes;\n  }\n});\nObject.defineProperty(exports, \"GlobeView\", {\n  enumerable: true,\n  get: function get() {\n    return _GlobeView[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"GLOBE_VIEW_EVENTS\", {\n  enumerable: true,\n  get: function get() {\n    return _GlobeView.GLOBE_VIEW_EVENTS;\n  }\n});\nObject.defineProperty(exports, \"PlanarView\", {\n  enumerable: true,\n  get: function get() {\n    return _PlanarView[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"Fetcher\", {\n  enumerable: true,\n  get: function get() {\n    return _Fetcher[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"MAIN_LOOP_EVENTS\", {\n  enumerable: true,\n  get: function get() {\n    return _MainLoop.MAIN_LOOP_EVENTS;\n  }\n});\nObject.defineProperty(exports, \"View\", {\n  enumerable: true,\n  get: function get() {\n    return _View[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"VIEW_EVENTS\", {\n  enumerable: true,\n  get: function get() {\n    return _View.VIEW_EVENTS;\n  }\n});\nObject.defineProperty(exports, \"Feature\", {\n  enumerable: true,\n  get: function get() {\n    return _Feature[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"FeatureCollection\", {\n  enumerable: true,\n  get: function get() {\n    return _Feature.FeatureCollection;\n  }\n});\nObject.defineProperty(exports, \"FeatureGeometry\", {\n  enumerable: true,\n  get: function get() {\n    return _Feature.FeatureGeometry;\n  }\n});\nObject.defineProperty(exports, \"FEATURE_TYPES\", {\n  enumerable: true,\n  get: function get() {\n    return _Feature.FEATURE_TYPES;\n  }\n});\nObject.defineProperty(exports, \"process3dTilesNode\", {\n  enumerable: true,\n  get: function get() {\n    return _dTilesProcessing.process3dTilesNode;\n  }\n});\nObject.defineProperty(exports, \"init3dTilesLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _dTilesProcessing.init3dTilesLayer;\n  }\n});\nObject.defineProperty(exports, \"$3dTilesCulling\", {\n  enumerable: true,\n  get: function get() {\n    return _dTilesProcessing.$3dTilesCulling;\n  }\n});\nObject.defineProperty(exports, \"$3dTilesSubdivisionControl\", {\n  enumerable: true,\n  get: function get() {\n    return _dTilesProcessing.$3dTilesSubdivisionControl;\n  }\n});\nObject.defineProperty(exports, \"pre3dTilesUpdate\", {\n  enumerable: true,\n  get: function get() {\n    return _dTilesProcessing.pre3dTilesUpdate;\n  }\n});\nObject.defineProperty(exports, \"$3dTilesExtensions\", {\n  enumerable: true,\n  get: function get() {\n    return _dTilesProvider.$3dTilesExtensions;\n  }\n});\nObject.defineProperty(exports, \"$3dTilesAbstractExtension\", {\n  enumerable: true,\n  get: function get() {\n    return _dTilesProvider.$3dTilesAbstractExtension;\n  }\n});\nObject.defineProperty(exports, \"FeatureProcessing\", {\n  enumerable: true,\n  get: function get() {\n    return _FeatureProcessing[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"updateLayeredMaterialNodeImagery\", {\n  enumerable: true,\n  get: function get() {\n    return _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeImagery;\n  }\n});\nObject.defineProperty(exports, \"updateLayeredMaterialNodeElevation\", {\n  enumerable: true,\n  get: function get() {\n    return _LayeredMaterialNodeProcessing.updateLayeredMaterialNodeElevation;\n  }\n});\nObject.defineProperty(exports, \"OrientedImageCamera\", {\n  enumerable: true,\n  get: function get() {\n    return _OrientedImageCamera[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"PointsMaterial\", {\n  enumerable: true,\n  get: function get() {\n    return _PointsMaterial[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"PointCloudProcessing\", {\n  enumerable: true,\n  get: function get() {\n    return _PointCloudProcessing[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"FlyControls\", {\n  enumerable: true,\n  get: function get() {\n    return _FlyControls[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"FirstPersonControls\", {\n  enumerable: true,\n  get: function get() {\n    return _FirstPersonControls[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"StreetControls\", {\n  enumerable: true,\n  get: function get() {\n    return _StreetControls[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"PlanarControls\", {\n  enumerable: true,\n  get: function get() {\n    return _PlanarControls[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"CONTROL_EVENTS\", {\n  enumerable: true,\n  get: function get() {\n    return _GlobeControls.CONTROL_EVENTS;\n  }\n});\nObject.defineProperty(exports, \"Feature2Mesh\", {\n  enumerable: true,\n  get: function get() {\n    return _Feature2Mesh[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"FeaturesUtils\", {\n  enumerable: true,\n  get: function get() {\n    return _FeaturesUtils[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"DEMUtils\", {\n  enumerable: true,\n  get: function get() {\n    return _DEMUtils[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"CameraUtils\", {\n  enumerable: true,\n  get: function get() {\n    return _CameraUtils[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"OrientationUtils\", {\n  enumerable: true,\n  get: function get() {\n    return _OrientationUtils[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"ShaderChunk\", {\n  enumerable: true,\n  get: function get() {\n    return _ShaderChunk[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"getMaxColorSamplerUnitsCount\", {\n  enumerable: true,\n  get: function get() {\n    return _LayeredMaterial.getMaxColorSamplerUnitsCount;\n  }\n});\nObject.defineProperty(exports, \"Capabilities\", {\n  enumerable: true,\n  get: function get() {\n    return _Capabilities[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"Layer\", {\n  enumerable: true,\n  get: function get() {\n    return _Layer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"ImageryLayers\", {\n  enumerable: true,\n  get: function get() {\n    return _Layer.ImageryLayers;\n  }\n});\nObject.defineProperty(exports, \"ColorLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _ColorLayer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"ElevationLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _ElevationLayer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"GeometryLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _GeometryLayer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"TiledGeometryLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _TiledGeometryLayer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"OrientedImageLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _OrientedImageLayer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"STRATEGY_MIN_NETWORK_TRAFFIC\", {\n  enumerable: true,\n  get: function get() {\n    return _LayerUpdateStrategy.STRATEGY_MIN_NETWORK_TRAFFIC;\n  }\n});\nObject.defineProperty(exports, \"STRATEGY_GROUP\", {\n  enumerable: true,\n  get: function get() {\n    return _LayerUpdateStrategy.STRATEGY_GROUP;\n  }\n});\nObject.defineProperty(exports, \"STRATEGY_PROGRESSIVE\", {\n  enumerable: true,\n  get: function get() {\n    return _LayerUpdateStrategy.STRATEGY_PROGRESSIVE;\n  }\n});\nObject.defineProperty(exports, \"STRATEGY_DICHOTOMY\", {\n  enumerable: true,\n  get: function get() {\n    return _LayerUpdateStrategy.STRATEGY_DICHOTOMY;\n  }\n});\nObject.defineProperty(exports, \"ColorLayersOrdering\", {\n  enumerable: true,\n  get: function get() {\n    return _ColorLayersOrdering[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"GlobeLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _GlobeLayer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"PlanarLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _PlanarLayer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"Source\", {\n  enumerable: true,\n  get: function get() {\n    return _Source[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"FileSource\", {\n  enumerable: true,\n  get: function get() {\n    return _FileSource[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"TMSSource\", {\n  enumerable: true,\n  get: function get() {\n    return _TMSSource[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"WFSSource\", {\n  enumerable: true,\n  get: function get() {\n    return _WFSSource[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"WMSSource\", {\n  enumerable: true,\n  get: function get() {\n    return _WMSSource[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"WMTSSource\", {\n  enumerable: true,\n  get: function get() {\n    return _WMTSSource[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"VectorTilesSource\", {\n  enumerable: true,\n  get: function get() {\n    return _VectorTilesSource[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"OrientedImageSource\", {\n  enumerable: true,\n  get: function get() {\n    return _OrientedImageSource[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"GpxParser\", {\n  enumerable: true,\n  get: function get() {\n    return _GpxParser[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"GeoJsonParser\", {\n  enumerable: true,\n  get: function get() {\n    return _GeoJsonParser[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"KMLParser\", {\n  enumerable: true,\n  get: function get() {\n    return _KMLParser[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"CameraCalibrationParser\", {\n  enumerable: true,\n  get: function get() {\n    return _CameraCalibrationParser[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"BatchTableHierarchyExtensionParser\", {\n  enumerable: true,\n  get: function get() {\n    return _BatchTableHierarchyExtensionParser[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"ShapefileParser\", {\n  enumerable: true,\n  get: function get() {\n    return _ShapefileParser[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"enableDracoLoader\", {\n  enumerable: true,\n  get: function get() {\n    return _B3dmParser.enableDracoLoader;\n  }\n});\nObject.defineProperty(exports, \"glTFLoader\", {\n  enumerable: true,\n  get: function get() {\n    return _B3dmParser.glTFLoader;\n  }\n});\nObject.defineProperty(exports, \"legacyGLTFLoader\", {\n  enumerable: true,\n  get: function get() {\n    return _B3dmParser.legacyGLTFLoader;\n  }\n});\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ./Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ./Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ./Core/Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\nvar _Ellipsoid = _interopRequireWildcard(__webpack_require__(/*! ./Core/Math/Ellipsoid */ \"./node_modules/itowns/lib/Core/Math/Ellipsoid.js\"));\n\nvar _GlobeView = _interopRequireWildcard(__webpack_require__(/*! ./Core/Prefab/GlobeView */ \"./node_modules/itowns/lib/Core/Prefab/GlobeView.js\"));\n\nvar _PlanarView = _interopRequireDefault(__webpack_require__(/*! ./Core/Prefab/PlanarView */ \"./node_modules/itowns/lib/Core/Prefab/PlanarView.js\"));\n\nvar _Fetcher = _interopRequireDefault(__webpack_require__(/*! ./Provider/Fetcher */ \"./node_modules/itowns/lib/Provider/Fetcher.js\"));\n\nvar _MainLoop = __webpack_require__(/*! ./Core/MainLoop */ \"./node_modules/itowns/lib/Core/MainLoop.js\");\n\nvar _View = _interopRequireWildcard(__webpack_require__(/*! ./Core/View */ \"./node_modules/itowns/lib/Core/View.js\"));\n\nvar _Feature = _interopRequireWildcard(__webpack_require__(/*! ./Core/Feature */ \"./node_modules/itowns/lib/Core/Feature.js\"));\n\nvar _dTilesProcessing = __webpack_require__(/*! ./Process/3dTilesProcessing */ \"./node_modules/itowns/lib/Process/3dTilesProcessing.js\");\n\nvar _dTilesProvider = __webpack_require__(/*! ./Provider/3dTilesProvider */ \"./node_modules/itowns/lib/Provider/3dTilesProvider.js\");\n\nvar _FeatureProcessing = _interopRequireDefault(__webpack_require__(/*! ./Process/FeatureProcessing */ \"./node_modules/itowns/lib/Process/FeatureProcessing.js\"));\n\nvar _LayeredMaterialNodeProcessing = __webpack_require__(/*! ./Process/LayeredMaterialNodeProcessing */ \"./node_modules/itowns/lib/Process/LayeredMaterialNodeProcessing.js\");\n\nvar _OrientedImageCamera = _interopRequireDefault(__webpack_require__(/*! ./Renderer/OrientedImageCamera */ \"./node_modules/itowns/lib/Renderer/OrientedImageCamera.js\"));\n\nvar _PointsMaterial = _interopRequireDefault(__webpack_require__(/*! ./Renderer/PointsMaterial */ \"./node_modules/itowns/lib/Renderer/PointsMaterial.js\"));\n\nvar _PointCloudProcessing = _interopRequireDefault(__webpack_require__(/*! ./Process/PointCloudProcessing */ \"./node_modules/itowns/lib/Process/PointCloudProcessing.js\"));\n\nvar _FlyControls = _interopRequireDefault(__webpack_require__(/*! ./Controls/FlyControls */ \"./node_modules/itowns/lib/Controls/FlyControls.js\"));\n\nvar _FirstPersonControls = _interopRequireDefault(__webpack_require__(/*! ./Controls/FirstPersonControls */ \"./node_modules/itowns/lib/Controls/FirstPersonControls.js\"));\n\nvar _StreetControls = _interopRequireDefault(__webpack_require__(/*! ./Controls/StreetControls */ \"./node_modules/itowns/lib/Controls/StreetControls.js\"));\n\nvar _PlanarControls = _interopRequireDefault(__webpack_require__(/*! ./Controls/PlanarControls */ \"./node_modules/itowns/lib/Controls/PlanarControls.js\"));\n\nvar _GlobeControls = __webpack_require__(/*! ./Controls/GlobeControls */ \"./node_modules/itowns/lib/Controls/GlobeControls.js\");\n\nvar _Feature2Mesh = _interopRequireDefault(__webpack_require__(/*! ./Converter/Feature2Mesh */ \"./node_modules/itowns/lib/Converter/Feature2Mesh.js\"));\n\nvar _FeaturesUtils = _interopRequireDefault(__webpack_require__(/*! ./Utils/FeaturesUtils */ \"./node_modules/itowns/lib/Utils/FeaturesUtils.js\"));\n\nvar _DEMUtils = _interopRequireDefault(__webpack_require__(/*! ./Utils/DEMUtils */ \"./node_modules/itowns/lib/Utils/DEMUtils.js\"));\n\nvar _CameraUtils = _interopRequireDefault(__webpack_require__(/*! ./Utils/CameraUtils */ \"./node_modules/itowns/lib/Utils/CameraUtils.js\"));\n\nvar _OrientationUtils = _interopRequireDefault(__webpack_require__(/*! ./Utils/OrientationUtils */ \"./node_modules/itowns/lib/Utils/OrientationUtils.js\"));\n\nvar _ShaderChunk = _interopRequireDefault(__webpack_require__(/*! ./Renderer/Shader/ShaderChunk */ \"./node_modules/itowns/lib/Renderer/Shader/ShaderChunk.js\"));\n\nvar _LayeredMaterial = __webpack_require__(/*! ./Renderer/LayeredMaterial */ \"./node_modules/itowns/lib/Renderer/LayeredMaterial.js\");\n\nvar _Capabilities = _interopRequireDefault(__webpack_require__(/*! ./Core/System/Capabilities */ \"./node_modules/itowns/lib/Core/System/Capabilities.js\"));\n\nvar _Layer = _interopRequireWildcard(__webpack_require__(/*! ./Layer/Layer */ \"./node_modules/itowns/lib/Layer/Layer.js\"));\n\nvar _ColorLayer = _interopRequireDefault(__webpack_require__(/*! ./Layer/ColorLayer */ \"./node_modules/itowns/lib/Layer/ColorLayer.js\"));\n\nvar _ElevationLayer = _interopRequireDefault(__webpack_require__(/*! ./Layer/ElevationLayer */ \"./node_modules/itowns/lib/Layer/ElevationLayer.js\"));\n\nvar _GeometryLayer = _interopRequireDefault(__webpack_require__(/*! ./Layer/GeometryLayer */ \"./node_modules/itowns/lib/Layer/GeometryLayer.js\"));\n\nvar _TiledGeometryLayer = _interopRequireDefault(__webpack_require__(/*! ./Layer/TiledGeometryLayer */ \"./node_modules/itowns/lib/Layer/TiledGeometryLayer.js\"));\n\nvar _OrientedImageLayer = _interopRequireDefault(__webpack_require__(/*! ./Layer/OrientedImageLayer */ \"./node_modules/itowns/lib/Layer/OrientedImageLayer.js\"));\n\nvar _LayerUpdateStrategy = __webpack_require__(/*! ./Layer/LayerUpdateStrategy */ \"./node_modules/itowns/lib/Layer/LayerUpdateStrategy.js\");\n\nvar _ColorLayersOrdering = _interopRequireDefault(__webpack_require__(/*! ./Renderer/ColorLayersOrdering */ \"./node_modules/itowns/lib/Renderer/ColorLayersOrdering.js\"));\n\nvar _GlobeLayer = _interopRequireDefault(__webpack_require__(/*! ./Core/Prefab/Globe/GlobeLayer */ \"./node_modules/itowns/lib/Core/Prefab/Globe/GlobeLayer.js\"));\n\nvar _PlanarLayer = _interopRequireDefault(__webpack_require__(/*! ./Core/Prefab/Planar/PlanarLayer */ \"./node_modules/itowns/lib/Core/Prefab/Planar/PlanarLayer.js\"));\n\nvar _Source = _interopRequireDefault(__webpack_require__(/*! ./Source/Source */ \"./node_modules/itowns/lib/Source/Source.js\"));\n\nvar _FileSource = _interopRequireDefault(__webpack_require__(/*! ./Source/FileSource */ \"./node_modules/itowns/lib/Source/FileSource.js\"));\n\nvar _TMSSource = _interopRequireDefault(__webpack_require__(/*! ./Source/TMSSource */ \"./node_modules/itowns/lib/Source/TMSSource.js\"));\n\nvar _WFSSource = _interopRequireDefault(__webpack_require__(/*! ./Source/WFSSource */ \"./node_modules/itowns/lib/Source/WFSSource.js\"));\n\nvar _WMSSource = _interopRequireDefault(__webpack_require__(/*! ./Source/WMSSource */ \"./node_modules/itowns/lib/Source/WMSSource.js\"));\n\nvar _WMTSSource = _interopRequireDefault(__webpack_require__(/*! ./Source/WMTSSource */ \"./node_modules/itowns/lib/Source/WMTSSource.js\"));\n\nvar _VectorTilesSource = _interopRequireDefault(__webpack_require__(/*! ./Source/VectorTilesSource */ \"./node_modules/itowns/lib/Source/VectorTilesSource.js\"));\n\nvar _OrientedImageSource = _interopRequireDefault(__webpack_require__(/*! ./Source/OrientedImageSource */ \"./node_modules/itowns/lib/Source/OrientedImageSource.js\"));\n\nvar _GpxParser = _interopRequireDefault(__webpack_require__(/*! ./Parser/GpxParser */ \"./node_modules/itowns/lib/Parser/GpxParser.js\"));\n\nvar _GeoJsonParser = _interopRequireDefault(__webpack_require__(/*! ./Parser/GeoJsonParser */ \"./node_modules/itowns/lib/Parser/GeoJsonParser.js\"));\n\nvar _KMLParser = _interopRequireDefault(__webpack_require__(/*! ./Parser/KMLParser */ \"./node_modules/itowns/lib/Parser/KMLParser.js\"));\n\nvar _CameraCalibrationParser = _interopRequireDefault(__webpack_require__(/*! ./Parser/CameraCalibrationParser */ \"./node_modules/itowns/lib/Parser/CameraCalibrationParser.js\"));\n\nvar _BatchTableHierarchyExtensionParser = _interopRequireDefault(__webpack_require__(/*! ./Parser/BatchTableHierarchyExtensionParser */ \"./node_modules/itowns/lib/Parser/BatchTableHierarchyExtensionParser.js\"));\n\nvar _ShapefileParser = _interopRequireDefault(__webpack_require__(/*! ./Parser/ShapefileParser */ \"./node_modules/itowns/lib/Parser/ShapefileParser.js\"));\n\nvar _B3dmParser = __webpack_require__(/*! ./Parser/B3dmParser */ \"./node_modules/itowns/lib/Parser/B3dmParser.js\");\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Main.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/B3dmParser.js":
/*!******************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/B3dmParser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableDracoLoader = enableDracoLoader;\nexports[\"default\"] = exports.legacyGLTFLoader = exports.glTFLoader = void 0;\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Capabilities = _interopRequireDefault(__webpack_require__(/*! ../Core/System/Capabilities */ \"./node_modules/itowns/lib/Core/System/Capabilities.js\"));\n\nvar _GLTFLoader = _interopRequireDefault(__webpack_require__(/*! ../ThreeExtended/loaders/GLTFLoader */ \"./node_modules/itowns/lib/ThreeExtended/loaders/GLTFLoader.js\"));\n\nvar _DRACOLoader = _interopRequireDefault(__webpack_require__(/*! ../ThreeExtended/loaders/DRACOLoader */ \"./node_modules/itowns/lib/ThreeExtended/loaders/DRACOLoader.js\"));\n\nvar _LegacyGLTFLoader = _interopRequireDefault(__webpack_require__(/*! ./deprecated/LegacyGLTFLoader */ \"./node_modules/itowns/lib/Parser/deprecated/LegacyGLTFLoader.js\"));\n\nvar _ShaderUtils = _interopRequireDefault(__webpack_require__(/*! ../Renderer/Shader/ShaderUtils */ \"./node_modules/itowns/lib/Renderer/Shader/ShaderUtils.js\"));\n\nvar _Utf8Decoder = _interopRequireDefault(__webpack_require__(/*! ../Utils/Utf8Decoder */ \"./node_modules/itowns/lib/Utils/Utf8Decoder.js\"));\n\nvar _BatchTableParser = _interopRequireDefault(__webpack_require__(/*! ./BatchTableParser */ \"./node_modules/itowns/lib/Parser/BatchTableParser.js\"));\n\nvar matrixChangeUpVectorZtoY = new THREE.Matrix4().makeRotationX(Math.PI / 2); // For gltf rotation\n\nvar matrixChangeUpVectorZtoX = new THREE.Matrix4().makeRotationZ(-Math.PI / 2);\nvar glTFLoader = new _GLTFLoader[\"default\"]();\nexports.glTFLoader = glTFLoader;\nvar legacyGLTFLoader = new _LegacyGLTFLoader[\"default\"]();\nexports.legacyGLTFLoader = legacyGLTFLoader;\n\nfunction filterUnsupportedSemantics(obj) {\n  // see GLTFLoader GLTFShader.prototype.update function\n  var supported = ['MODELVIEW', 'MODELVIEWINVERSETRANSPOSE', 'PROJECTION', 'JOINTMATRIX'];\n\n  if (obj.gltfShader) {\n    var names = []; // eslint-disable-next-line guard-for-in\n\n    for (var name in obj.gltfShader.boundUniforms) {\n      names.push(name);\n    }\n\n    for (var _i = 0, _names = names; _i < _names.length; _i++) {\n      var _name = _names[_i];\n      var semantic = obj.gltfShader.boundUniforms[_name].semantic;\n\n      if (!supported.includes(semantic)) {\n        delete obj.gltfShader.boundUniforms[_name];\n      }\n    }\n  }\n}\n/**\n * @module B3dmParser\n */\n\n/**\n * Enable Draco decoding for gltf.\n * @param {string} path to draco library folder.\n * This library is mandatory to load b3dm with Draco compression.\n * @param {object} config optional configuration for Draco compression.\n *\n * The Draco library files are in folder itowns/examples/libs/draco/.\n * You are obliged to indicate this path when you want enable the Draco Decoding.\n *\n * For more information on Draco, read file in /itowns/examples/libs/draco/README.md.\n *\n * @example <caption>Enable draco decoder</caption>\n * // if you copied the folder from /itowns/examples/libs/draco/ to your root project,\n * // You could set path with './'.\n * itowns.enableDracoLoader('./');\n */\n\n\nfunction enableDracoLoader(path, config) {\n  if (!path) {\n    throw new Error('Path to draco folder is mandatory');\n  }\n\n  _DRACOLoader[\"default\"].setDecoderPath(path);\n\n  if (config) {\n    _DRACOLoader[\"default\"].setDecoderConfig(config);\n  }\n\n  var dracoLoader = new _DRACOLoader[\"default\"]();\n  glTFLoader.setDRACOLoader(dracoLoader);\n\n  _DRACOLoader[\"default\"].getDecoderModule();\n}\n\nvar _default = {\n  /** Parse b3dm buffer and extract THREE.Scene and batch table\n   * @param {ArrayBuffer} buffer - the b3dm buffer.\n   * @param {Object} options - additional properties.\n   * @param {string=} [options.gltfUpAxis='Y'] - embedded glTF model up axis.\n   * @param {string} options.urlBase - the base url of the b3dm file (used to fetch textures for the embedded glTF model).\n   * @param {boolean=} [options.doNotPatchMaterial='false'] - disable patching material with logarithmic depth buffer support.\n   * @param {float} [options.opacity=1.0] - the b3dm opacity.\n   * @param {boolean|Material=} [options.overrideMaterials='false'] - override b3dm's embedded glTF materials. If overrideMaterials is a three.js material, it will be the material used to override.\n   * @return {Promise} - a promise that resolves with an object containig a THREE.Scene (gltf) and a batch table (batchTable).\n   *\n   */\n  parse: function parse(buffer, options) {\n    var gltfUpAxis = options.gltfUpAxis;\n    var urlBase = options.urlBase;\n\n    if (!buffer) {\n      throw new Error('No array buffer provided.');\n    }\n\n    var view = new DataView(buffer, 4); // starts after magic\n\n    var byteOffset = 0;\n    var b3dmHeader = {}; // Magic type is unsigned char [4]\n\n    var magicNumberByteLength = 4;\n    b3dmHeader.magic = _Utf8Decoder[\"default\"].decode(new Uint8Array(buffer, 0, magicNumberByteLength));\n\n    if (b3dmHeader.magic) {\n      // Version, byteLength, batchTableJSONByteLength, batchTableBinaryByteLength and batchTable types are uint32\n      b3dmHeader.version = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      b3dmHeader.byteLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      b3dmHeader.FTJSONLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      b3dmHeader.FTBinaryLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      b3dmHeader.BTJSONLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      b3dmHeader.BTBinaryLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      var headerByteLength = byteOffset + magicNumberByteLength;\n      var promises = [];\n      var FTJSON = {};\n      var FT_RTC = new THREE.Vector3();\n\n      if (b3dmHeader.FTJSONLength > 0) {\n        var sizeBegin = headerByteLength;\n        var jsonBuffer = buffer.slice(sizeBegin, b3dmHeader.FTJSONLength + sizeBegin);\n\n        var content = _Utf8Decoder[\"default\"].decode(new Uint8Array(jsonBuffer));\n\n        FTJSON = JSON.parse(content);\n\n        if (FTJSON.RTC_CENTER) {\n          FT_RTC.fromArray(FTJSON.RTC_CENTER);\n        } else {\n          FT_RTC.set(0, 0, 0);\n        }\n      }\n\n      if (b3dmHeader.FTBinaryLength > 0) {\n        console.warn('3D Tiles feature table binary not supported yet.');\n      } // Parse batch table\n\n\n      if (b3dmHeader.BTJSONLength > 0) {\n        // sizeBegin is an index to the beginning of the batch table\n        var _sizeBegin = headerByteLength + b3dmHeader.FTJSONLength + b3dmHeader.FTBinaryLength;\n\n        promises.push(_BatchTableParser[\"default\"].parse(buffer.slice(_sizeBegin, b3dmHeader.BTJSONLength + _sizeBegin), b3dmHeader.BTBinaryLength, FTJSON.BATCH_LENGTH));\n      } else {\n        promises.push(Promise.resolve({}));\n      }\n\n      var posGltf = headerByteLength + b3dmHeader.FTJSONLength + b3dmHeader.FTBinaryLength + b3dmHeader.BTJSONLength + b3dmHeader.BTBinaryLength;\n      var gltfBuffer = buffer.slice(posGltf);\n      var headerView = new DataView(gltfBuffer, 0, 20);\n      promises.push(new Promise(function (resolve\n      /* , reject */\n      ) {\n        var onload = function (gltf) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = gltf.scenes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var scene = _step.value;\n              scene.traverse(filterUnsupportedSemantics);\n            } // Rotation managed\n\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          if (gltfUpAxis === undefined || gltfUpAxis === 'Y') {\n            gltf.scene.applyMatrix(matrixChangeUpVectorZtoY);\n          } else if (gltfUpAxis === 'X') {\n            gltf.scene.applyMatrix(matrixChangeUpVectorZtoX);\n          } // Apply relative center from Feature table.\n\n\n          gltf.scene.position.copy(FT_RTC); // Apply relative center from gltf json.\n\n          var contentArray = new Uint8Array(gltfBuffer, 20, headerView.getUint32(12, true));\n\n          var content = _Utf8Decoder[\"default\"].decode(new Uint8Array(contentArray));\n\n          var json = JSON.parse(content);\n\n          if (json.extensions && json.extensions.CESIUM_RTC) {\n            gltf.scene.position.fromArray(json.extensions.CESIUM_RTC.center);\n            gltf.scene.updateMatrixWorld(true);\n          }\n\n          gltf.scene.traverse(function (mesh) {\n            mesh.frustumCulled = false;\n\n            if (mesh.material) {\n              if (options.overrideMaterials) {\n                if (Array.isArray(mesh.material)) {\n                  var _iteratorNormalCompletion2 = true;\n                  var _didIteratorError2 = false;\n                  var _iteratorError2 = undefined;\n\n                  try {\n                    for (var _iterator2 = mesh.material[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                      var material = _step2.value;\n                      material.dispose();\n                    }\n                  } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                        _iterator2[\"return\"]();\n                      }\n                    } finally {\n                      if (_didIteratorError2) {\n                        throw _iteratorError2;\n                      }\n                    }\n                  }\n                } else {\n                  mesh.material.dispose();\n                }\n\n                if ((0, _typeof2[\"default\"])(options.overrideMaterials) === 'object' && options.overrideMaterials.isMaterial) {\n                  mesh.material = options.overrideMaterials;\n                } else {\n                  mesh.material = new THREE.MeshLambertMaterial({\n                    color: 0xffffff\n                  });\n                }\n              } else if (_Capabilities[\"default\"].isLogDepthBufferSupported() && mesh.material.isRawShaderMaterial && !options.doNotPatchMaterial) {\n                _ShaderUtils[\"default\"].patchMaterialForLogDepthSupport(mesh.material);\n\n                console.warn('b3dm shader has been patched to add log depth buffer support');\n              }\n\n              mesh.material.transparent = options.opacity < 1.0;\n              mesh.material.opacity = options.opacity;\n            }\n          });\n          resolve(gltf);\n        };\n\n        var version = headerView.getUint32(4, true);\n\n        if (version === 1) {\n          legacyGLTFLoader.parse(gltfBuffer, urlBase, onload);\n        } else {\n          glTFLoader.parse(gltfBuffer, urlBase, onload);\n        }\n      }));\n      return Promise.all(promises).then(function (values) {\n        return {\n          gltf: values[1],\n          batchTable: values[0]\n        };\n      });\n    } else {\n      throw new Error('Invalid b3dm file.');\n    }\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/B3dmParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/BatchTableHierarchyExtensionParser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/BatchTableHierarchyExtensionParser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _dTilesProvider = __webpack_require__(/*! ../Provider/3dTilesProvider */ \"./node_modules/itowns/lib/Provider/3dTilesProvider.js\");\n\n/** @classdesc\n * Class for storing and accessing information relative to the\n *  [3DTILES_batch_table_hierarchy extension]{@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/extensions/3DTILES_batch_table_hierarchy}\n *  of 3D Tiles */\nvar BatchTableHierarchyExtension =\n/*#__PURE__*/\nfunction (_$3dTilesAbstractExte) {\n  (0, _inherits2[\"default\"])(BatchTableHierarchyExtension, _$3dTilesAbstractExte);\n\n  /**\n   * @param {Object} json - json holding the extension\n   */\n  function BatchTableHierarchyExtension(json) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, BatchTableHierarchyExtension);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(BatchTableHierarchyExtension).call(this, _dTilesProvider.$3dTilesAbstractExtension));\n    _this.classes = json.classes; // inverseHierarchy contains for each instance (i.e. georgraphic\n    // feature e.g. building, roof, etc.) an array of the indexes of its\n    // parents. For example, the parents of the instance 0 can be found\n    // using inverseHierarchy[0].\n\n    _this.inverseHierarchy = {}; // instancesIdxs contains for each instance of the extension, a\n    // javascript object with classId and instanceIdx. classId is the id of\n    // the class (from this.classes) of the instance. instanceIdx is the\n    // index of the instance in this class. Goal: Ease the retrieval\n    // of the properties of an instance\n\n    _this.instancesIdxs = []; // Counts the number of instances of a class\n\n    var classCounter = {};\n    var parentIdsCounter = 0; // if omitted, parentCounts is an array of length instancesLength,\n    // where all values are 1 (cf. spec)\n\n    var parentCounts = json.parentCounts;\n\n    if (parentCounts === undefined) {\n      parentCounts = new Array(json.instancesLength);\n      parentCounts.fill(1);\n    } // for each instance\n\n\n    for (var i = 0; i < json.instancesLength; i++) {\n      // for each parent of the current instance\n      for (var j = 0; j < parentCounts[i]; j++) {\n        // When an instance's parentId points to itself, then it has no\n        // parent\" (cf. spec)\n        if (i !== json.parentIds[parentIdsCounter]) {\n          if (_this.inverseHierarchy[i] === undefined) {\n            _this.inverseHierarchy[i] = [];\n          }\n\n          _this.inverseHierarchy[i].push(json.parentIds[parentIdsCounter]);\n\n          parentIdsCounter++;\n        }\n      }\n\n      var classId = json.classIds[i];\n\n      if (classCounter[classId] === undefined) {\n        classCounter[classId] = 0;\n      }\n\n      _this.instancesIdxs[i] = {\n        classId: classId,\n        instanceIdx: classCounter[classId]\n      };\n      classCounter[classId]++;\n    }\n\n    return _this;\n  }\n  /**\n   * Creates and returns a javascript object holding the displayable\n   * information relative to this extension and for a given feature and\n   * its parents\n   * @param {integer} featureId - id of the feature\n   * @returns {Object} - displayable information relative to this extension\n   * and for the feature with id=featureId and for its parents\n   */\n\n\n  (0, _createClass2[\"default\"])(BatchTableHierarchyExtension, [{\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(featureId) {\n      var _this2 = this;\n\n      var instanceProperties = {}; // get feature class name\n\n      var instanceClassId = this.instancesIdxs[featureId].classId;\n      var featureClass = this.classes[instanceClassId].name; // get feature properties and values\n\n      var instanceIdx = this.instancesIdxs[featureId].instanceIdx;\n      Object.keys(this.classes[instanceClassId].instances).forEach(function (property) {\n        instanceProperties[property] = _this2.classes[instanceClassId].instances[property][instanceIdx];\n      }); // create return object: className: {featureProperties and values}\n\n      var pickingInfo = {};\n      pickingInfo[featureClass] = instanceProperties; // If this feature has parent(s), recurse on them\n\n      if (this.inverseHierarchy && this.inverseHierarchy[featureId]) {\n        this.inverseHierarchy[featureId].forEach(function (parentId) {\n          return Object.assign(pickingInfo, _this2.getPickingInfo(parentId));\n        });\n      }\n\n      return pickingInfo;\n    }\n  }]);\n  return BatchTableHierarchyExtension;\n}(_dTilesProvider.$3dTilesAbstractExtension);\n/**\n * @module BatchTableHierarchyExtensionParser\n */\n\n\nvar _default = {\n  /**\n   * Parses a\n   * [3DTILES_batch_table_hierarchy extension]{@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/extensions/3DTILES_batch_table_hierarchy}\n   * and returns a Promise that resolves with a BatchTableHierarchyExtension\n   * object.\n   * @param {Object} json - json holding the extension\n   * @return {Promise} - a promise that resolves with a\n   *     BatchTableHierarchyExtension object.\n   */\n  parse: function parse(json) {\n    return Promise.resolve(new BatchTableHierarchyExtension(json));\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/BatchTableHierarchyExtensionParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/BatchTableParser.js":
/*!************************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/BatchTableParser.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _Utf8Decoder = _interopRequireDefault(__webpack_require__(/*! ../Utils/Utf8Decoder */ \"./node_modules/itowns/lib/Utils/Utf8Decoder.js\"));\n\nvar _dTilesProvider = __webpack_require__(/*! ../Provider/3dTilesProvider */ \"./node_modules/itowns/lib/Provider/3dTilesProvider.js\");\n\n/** @classdesc\n * Class representing a 3D Tiles batch table\n */\nvar BatchTable =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Object} json - batch table json part\n   * @param {ArrayBuffer} binary - buffer representing the batch table\n   * @param {number} batchLength the length of the batch.\n   * binary part (not supported yet)\n   */\n  function BatchTable(json, binary, batchLength) {\n    (0, _classCallCheck2[\"default\"])(this, BatchTable);\n\n    if (binary !== undefined) {\n      console.warn('Binary batch table content not supported yet.');\n    } // Store batch table content\n\n\n    this.content = json; // Compute the length of the batch (i.e. the number of features)\n    // Note: The batchLength could also be retrieved from the feature table\n    // which is currently not supported\n\n    if (batchLength != undefined) {\n      this.batchLength = batchLength;\n    } else if (Object.keys(this.content).length === 0) {\n      console.warn('Batch table is empty.');\n      this.batchLength = 0;\n    } else {\n      this.batchLength = this.content[Object.keys(this.content)[0]].length;\n    } // Array storing extensions of the batch table. Key is\n    // extension name (registered in $3dTilesExtensions global object).\n    // Value is the object returned by the parser associated with the\n    // extensions (mapping is done in $3dTilesExtensions global object)\n\n\n    this.extensions = {};\n  }\n  /**\n   * Creates and returns a javascript object holding the displayable\n   * information from the batch table and from extensions of the batch table\n   * for a given feature\n   * @param {integer} featureId - id of the feature\n   * @returns {Object} - displayable information relative to the batch table\n   * and its extensions for the feature with id=featureId. Object is\n   * formatted as follow: {BatchTable: {BatchTableFeatureProperties},\n   * ExtensionName: {ExtensionDisplayableInfo}}\n   */\n\n\n  (0, _createClass2[\"default\"])(BatchTable, [{\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(featureId) {\n      var _this = this;\n\n      var featureDisplayableInfo = {};\n\n      if (this.batchLength === 0) {\n        return;\n      }\n\n      if (featureId < 0) {\n        throw new Error(\"Batch Id (\".concat(featureId, \") must be positive to access\\n            feature properties from the batch table.\"));\n      }\n\n      if (featureId < this.batchLength) {\n        // Get properties from batch table content\n        Object.keys(this.content).forEach(function (property) {\n          featureDisplayableInfo[property] = _this.content[property][featureId];\n        });\n      } else {\n        throw new Error(\"Batch Id (\".concat(featureId, \") must be inferior to batch length \\n                (\").concat(this.batchLength, \") to access feature properties in batch \\n                table.\"));\n      }\n\n      var BTDisplayableInfo = {\n        BatchTable: featureDisplayableInfo\n      }; // loop through extensions and append their displayable\n      // information to featureDisplayableInfo\n\n      if (this.extensions) {\n        Object.keys(this.extensions).forEach(function (extName) {\n          var extDisplayableInfo = (0, _defineProperty2[\"default\"])({}, extName, _this.extensions[extName].getPickingInfo(featureId));\n          Object.assign(BTDisplayableInfo, extDisplayableInfo);\n        });\n      }\n\n      return BTDisplayableInfo;\n    }\n    /**\n     * Remove an extension from this.content. Must be called when an extension\n     * has been parsed and added to this.extensions\n     * @param {string} extensionName - the name of the extension to remove\n     */\n\n  }, {\n    key: \"removeExtensionFromContent\",\n    value: function removeExtensionFromContent(extensionName) {\n      // Delete extension from content\n      if (this.content.extensions[extensionName]) {\n        delete this.content.extensions[extensionName];\n      } // Delete extensions from content if empty\n\n\n      if (Object.keys(this.content.extensions).length === 0) {\n        delete this.content.extensions;\n      }\n    }\n  }]);\n  return BatchTable;\n}();\n/**\n * @module BatchTableParser\n */\n\n\nvar _default = {\n  /** Parse a batch table buffer and returns a promise that resolves with a\n   *  BatchTable object.\n   * @param {ArrayBuffer} buffer - the batch table buffer.\n   * @param {integer} BTBinaryLength - length of the binary part of the\n   * batch table\n   * @param {number} BATCH_LENGTH the length of the batch.\n   * @return {Promise} - a promise that resolves with a BatchTable object.\n   *\n   */\n  parse: function parse(buffer, BTBinaryLength, BATCH_LENGTH) {\n    // Batch table has a json part and can have a binary part (not\n    // supported yet)\n    var binary;\n    var jsonBuffer = buffer;\n\n    if (BTBinaryLength > 0) {\n      binary = buffer.slice(buffer.byteLength - BTBinaryLength);\n      jsonBuffer = buffer.slice(0, buffer.byteLength - BTBinaryLength);\n    }\n\n    var content = _Utf8Decoder[\"default\"].decode(new Uint8Array(jsonBuffer));\n\n    var json = JSON.parse(content);\n    var batchTable = new BatchTable(json, binary, BATCH_LENGTH);\n    var promises = []; // When an extension is found, we call its parser and append the\n    // returned object to batchTable.extensions\n    // Extensions must be registered in $3dTilesExtensions global object\n    // where an extension name is mapped to a parser.\n\n    if (json.extensions) {\n      Object.keys(json.extensions).forEach(function (extName) {\n        if (_dTilesProvider.$3dTilesExtensions.isExtensionRegistered(extName)) {\n          var extensionParser = _dTilesProvider.$3dTilesExtensions.getParser(extName);\n\n          promises.push(extensionParser(json.extensions[extName]).then(function (extObject) {\n            batchTable.extensions[extName] = extObject;\n            batchTable.removeExtensionFromContent(extName);\n          }));\n        }\n      });\n    } // values[0] is the results of the first promise pushed in promises,\n    // i.e. batchTable\n\n\n    return Promise.all(promises).then(function () {\n      return batchTable;\n    });\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/BatchTableParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/CameraCalibrationParser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/CameraCalibrationParser.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _OrientedImageCamera = _interopRequireDefault(__webpack_require__(/*! ../Renderer/OrientedImageCamera */ \"./node_modules/itowns/lib/Renderer/OrientedImageCamera.js\"));\n\n/**\n * The CameraCalibrationParser module provide a [parse]{@link module:CameraCalibrationParser.parse}\n * method that takes a JSON array of camera calibrations in and yields an array of {@link OrientedImageCamera}\n *\n * @module CameraCalibrationParser\n */\nTHREE.Matrix4.prototype.setMatrix3 = function (m) {\n  this.elements[0] = m.elements[0];\n  this.elements[1] = m.elements[1];\n  this.elements[2] = m.elements[2];\n  this.elements[4] = m.elements[3];\n  this.elements[5] = m.elements[4];\n  this.elements[6] = m.elements[5];\n  this.elements[8] = m.elements[6];\n  this.elements[9] = m.elements[7];\n  this.elements[10] = m.elements[8];\n  return this;\n};\n\nvar textureLoader = new THREE.TextureLoader();\nvar matrix3 = new THREE.Matrix3(); // the json format encodes the following transformation:\n// extrinsics: p_local = rotation * (p_world - position)\n// intrinsics: p_pixel = projection * p_local\n// distortion: p_raw = distortion(p_pixel)\n\nfunction parseCalibration(calibration) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var useMask = options.useMask == undefined ? true : options.useMask;\n  var imageYDown = options.imageYDown == undefined ? true : options.imageYDown; // parse intrinsics\n\n  var proj = calibration.projection;\n  var size = new THREE.Vector2().fromArray(calibration.size);\n  var focal = new THREE.Vector2(proj[0], proj[4]); // Center of image,  convention in digital image is Y dow\n  // To transform image space to webGl texture. It could inverse Y axis.\n\n  var center = new THREE.Vector2(proj[2], imageYDown ? size.y - proj[5] : proj[5]);\n  var skew = proj[1];\n  var camera = new _OrientedImageCamera[\"default\"](size, focal, center, options.near, options.far, skew); // parse extrinsics: Object3d.matrix is from local to world\n  // p_world = position + transpose(rotation) * p_local\n\n  camera.position.fromArray(calibration.position); // calibration.rotation is row-major but fromArray expects a column-major array, yielding the transposed matrix\n\n  var rotationInverse = matrix3.fromArray(calibration.rotation);\n  camera.matrix.setMatrix3(rotationInverse);\n  camera.quaternion.setFromRotationMatrix(camera.matrix); // local axes for cameras is (X right, Y up, Z back) rather than (X right, Y down, Z front)\n\n  camera.rotateX(Math.PI);\n\n  if (calibration.distortion) {\n    camera.distortion.setFromMicmacCalibration(calibration.distortion, imageYDown);\n  }\n\n  camera.maskPath = calibration.mask;\n  camera.name = calibration.id;\n  var resolve;\n  var deferred = new Promise(function (r) {\n    resolve = r;\n  });\n\n  if (useMask && camera.maskPath) {\n    textureLoader.load(camera.maskPath, function (mask) {\n      camera.maskTexture = mask;\n      resolve(camera);\n    });\n  } else {\n    resolve(camera);\n  }\n\n  return deferred;\n}\n\nvar _default = {\n  /**\n   * Description of a camera calibration in a JSON file.\n   *\n   * @typedef CameraCalibrationJson\n   * @type {Object}\n   *\n   * @property {number[]} projection - projection matrix,\n   * @property {number[]} size - image size in pixel.\n   * @property {number[]} position - position of the camera.\n   * @property {number[]} rotation - rotation matrix\n   * @property {Object} [distorsion={}] - distorsion\n   * @property {number[]} [distorsion.pps]\n   * @property {number[]} [distorsion.poly357]\n   * @property {number[]} [distorsion.limit]\n   * @property {number[]} [distorsion.l1l2]\n   * @property {number[]} [distorsion.etat]\n   */\n\n  /**\n   * Parser a JSON array of camera calibrations and return an array of {@link OrientedImageCamera}.\n   * @param {string|JSON} json - the json content of the calibration file.\n   * @param {Object} [options={}] - Options controlling the parsing.\n   * @param {string} [options.near=0.1] - Near of the created cameras. Default value comes from created {@link OrientedImageCamera}\n   * @param {string} [options.far=1000] - Far of the created cameras. Default value comes from created {@link OrientedImageCamera}\n   * @return {Promise} - A promise resolving with an array of {@link OrientedImageCamera}.\n   */\n  parse: function parse(json) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof json === 'string') {\n      json = JSON.parse(json);\n    }\n\n    return Promise.all(json.map(function (calibration) {\n      return parseCalibration(calibration, options);\n    }));\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/CameraCalibrationParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/GeoJsonParser.js":
/*!*********************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/GeoJsonParser.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Feature = _interopRequireWildcard(__webpack_require__(/*! ../Core/Feature */ \"./node_modules/itowns/lib/Core/Feature.js\"));\n\nvar _Style = _interopRequireDefault(__webpack_require__(/*! ../Core/Style */ \"./node_modules/itowns/lib/Core/Style.js\"));\n\nfunction readCRS(json) {\n  if (json.crs) {\n    if (json.crs.type.toLowerCase() == 'epsg') {\n      return \"EPSG:\".concat(json.crs.properties.code);\n    } else if (json.crs.type.toLowerCase() == 'name') {\n      var epsgIdx = json.crs.properties.name.toLowerCase().indexOf('epsg:');\n\n      if (epsgIdx >= 0) {\n        // authority:version:code => EPSG:[...]:code\n        var codeStart = json.crs.properties.name.indexOf(':', epsgIdx + 5);\n\n        if (codeStart > 0) {\n          return \"EPSG:\".concat(json.crs.properties.name.substr(codeStart + 1));\n        }\n      }\n    }\n\n    throw new Error(\"Unsupported CRS type '\".concat(json.crs, \"'\"));\n  } // assume default crs\n\n\n  return 'EPSG:4326';\n}\n\nvar coord = new _Coordinates[\"default\"]('EPSG:4978', 0, 0, 0); // filter with the first point\n\nvar firstPtIsOut = function (extent, aCoords, crs) {\n  coord.crs = crs;\n  coord.setFromArray(aCoords[0]);\n  return !extent.isPointInside(coord);\n};\n\nvar toFeature = {\n  populateGeometry: function populateGeometry(crsIn, coordinates, geometry) {\n    var setAltitude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    geometry.startSubGeometry(coordinates.length);\n    var useAlti = setAltitude && typeof coordinates[0][2] == 'number'; // coordinates is a list of pair [[x1, y1], [x2, y2], ..., [xn, yn]]\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = coordinates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var pair = _step.value;\n        coord.crs = crsIn;\n        coord.setFromValues(pair[0], pair[1], useAlti ? pair[2] : 0);\n        geometry.pushCoordinates(coord);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    geometry.updateExtent();\n  },\n  \"default\": function _default(feature, crsIn, coordsIn, filteringExtent, setAltitude, properties) {\n    if (filteringExtent && firstPtIsOut(filteringExtent, coordsIn, crsIn)) {\n      return;\n    }\n\n    var geometry = feature.bindNewGeometry();\n    geometry.properties = properties;\n    geometry.properties.style = new _Style[\"default\"]().setFromGeojsonProperties(properties, feature.type);\n    this.populateGeometry(crsIn, coordsIn, geometry, setAltitude);\n    feature.updateExtent(geometry);\n  },\n  polygon: function polygon(feature, crsIn, coordsIn, filteringExtent, setAltitude, properties) {\n    // filtering\n    if (filteringExtent && firstPtIsOut(filteringExtent, coordsIn[0], crsIn)) {\n      return;\n    }\n\n    var geometry = feature.bindNewGeometry();\n    geometry.properties = properties;\n    geometry.properties.style = new _Style[\"default\"]().setFromGeojsonProperties(properties, feature.type); // Then read contour and holes\n\n    for (var i = 0; i < coordsIn.length; i++) {\n      this.populateGeometry(crsIn, coordsIn[i], geometry, setAltitude);\n    }\n\n    feature.updateExtent(geometry);\n  },\n  multi: function multi(type, feature, crsIn, coordsIn, filteringExtent, setAltitude, properties) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = coordsIn[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var coords = _step2.value;\n        this[type](feature, crsIn, coords, filteringExtent, setAltitude, properties);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n};\n\nfunction coordinatesToFeature(type, feature, crsIn, coordinates, filteringExtent, setAltitude, properties) {\n  if (coordinates.length == 0) {\n    return;\n  }\n\n  switch (type) {\n    case 'point':\n    case 'linestring':\n      return toFeature[\"default\"](feature, crsIn, coordinates, filteringExtent, setAltitude, properties);\n\n    case 'multipoint':\n    case 'multilinestring':\n      return toFeature.multi('default', feature, crsIn, coordinates, filteringExtent, setAltitude, properties);\n\n    case 'polygon':\n      return toFeature.polygon(feature, crsIn, coordinates, filteringExtent, setAltitude, properties);\n\n    case 'multipolygon':\n      return toFeature.multi('polygon', feature, crsIn, coordinates, filteringExtent, setAltitude, properties);\n\n    case 'geometrycollection':\n    default:\n      throw new Error(\"Unhandled geojson type \".concat(feature.type));\n  }\n}\n\nfunction toFeatureType(jsonType) {\n  switch (jsonType) {\n    case 'point':\n    case 'multipoint':\n      return _Feature.FEATURE_TYPES.POINT;\n\n    case 'linestring':\n    case 'multilinestring':\n      return _Feature.FEATURE_TYPES.LINE;\n\n    case 'polygon':\n    case 'multipolygon':\n      return _Feature.FEATURE_TYPES.POLYGON;\n\n    case 'geometrycollection':\n    default:\n      throw new Error(\"Unhandled geometry type \".concat(jsonType));\n  }\n}\n\nvar keyProperties = ['type', 'geometry', 'properties'];\n\nfunction jsonFeatureToFeature(crsIn, crsOut, json, filteringExtent, options, featureCollection) {\n  if (options.filter && !options.filter(json.properties, json.geometry)) {\n    return;\n  }\n\n  var jsonType = json.geometry.type.toLowerCase();\n  var featureType = toFeatureType(jsonType);\n  var feature = options.mergeFeatures ? featureCollection.requestFeatureByType(featureType) : new _Feature[\"default\"](featureType, crsOut, options);\n  var geometryCount = feature.geometryCount;\n  var coordinates = jsonType != 'point' ? json.geometry.coordinates : [json.geometry.coordinates];\n  var setAltitude = !options.overrideAltitudeInToZero && options.withAltitude;\n  var properties = json.properties || {}; // copy other properties\n\n  for (var _i = 0, _Object$keys = Object.keys(json); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n\n    if (!keyProperties.includes(key.toLowerCase())) {\n      properties[key] = json[key];\n    }\n  }\n\n  coordinatesToFeature(jsonType, feature, crsIn, coordinates, filteringExtent, setAltitude, properties);\n\n  if (feature.geometryCount == geometryCount) {\n    return;\n  }\n\n  return feature;\n}\n\nfunction jsonFeaturesToFeatures(crsIn, crsOut, jsonFeatures, filteringExtent, options) {\n  var features = new _Feature.FeatureCollection(crsOut, options);\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = jsonFeatures[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var jsonFeature = _step3.value;\n      var feature = jsonFeatureToFeature(crsIn, crsOut, jsonFeature, filteringExtent, options, features);\n\n      if (feature && !options.mergeFeatures) {\n        features.pushFeature(feature);\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n        _iterator3[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  if (options.mergeFeatures) {\n    features.removeEmptyFeature();\n    features.updateExtent();\n  }\n\n  return features;\n}\n/**\n * The GeoJsonParser module provide a [parse]{@link module:GeoJsonParser.parse}\n * method that takes a GeoJSON in and gives an object formatted for iTowns\n * containing all necessary informations to display this GeoJSON.\n *\n * @module GeoJsonParser\n */\n\n\nvar _default = {\n  /**\n   * @typedef {Object} GeoJsonParserOptions\n   * @property {string} crsOut - The CRS to convert the input coordinates\n   * to.\n   * @property {string} crsIn - Override the data CRS.\n   * @property {Extent} [filteringExtent] - Optional filter to reject\n   * features outside of this extent.\n   * @property {boolean} [buildExtent=false] - If true the geometry will\n   * have an extent property containing the area covered by the geom\n   * @property {function} [filter] - Filter function to remove features\n   * @property {boolean} [mergeFeatures=true] - If true all geometries are merged by type and multi-type\n   * @property {boolean} [withNormal=true] - If true each coordinate normal is computed\n   * @property {boolean} [withAltitude=true] - If true each coordinate altitude is kept\n   * @property {boolean} [overrideAltitudeInToZero=false] - If true, the altitude of the source data isn't taken into account for 3D geometry convertions.\n   * the altitude will be override to 0. This can be useful if you don't have a DEM or provide a new one when converting (with Layer.convert).\n   */\n\n  /**\n   * Parse a GeoJSON file content and return a [FeatureCollection]{@link FeatureCollection}.\n   *\n   * @param {string} json - The GeoJSON file content to parse.\n   * @param {GeoJsonParser~GeoJsonParserOptions} options - Options controlling\n   * the parsing.\n   *\n   * @return {Promise} A promise resolving with a [FeatureCollection]{@link FeatureCollection}.\n   */\n  parse: function parse(json) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var crsOut = options.crsOut;\n    var filteringExtent = options.filteringExtent;\n\n    if (typeof json === 'string') {\n      json = JSON.parse(json);\n    }\n\n    options.crsIn = options.crsIn || readCRS(json);\n    options.mergeFeatures = options.mergeFeatures == undefined ? true : options.mergeFeatures;\n    options.withNormal = options.withNormal == undefined ? true : options.withNormal;\n    options.withAltitude = options.withAltitude == undefined ? true : options.withAltitude;\n\n    switch (json.type.toLowerCase()) {\n      case 'featurecollection':\n        return Promise.resolve(jsonFeaturesToFeatures(options.crsIn, crsOut, json.features, filteringExtent, options));\n\n      case 'feature':\n        return Promise.resolve(jsonFeaturesToFeatures(options.crsIn, crsOut, [json], filteringExtent, options));\n\n      default:\n        throw new Error(\"Unsupported GeoJSON type: '\".concat(json.type));\n    }\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/GeoJsonParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/GpxParser.js":
/*!*****************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/GpxParser.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _togeojson = _interopRequireDefault(__webpack_require__(/*! @mapbox/togeojson */ \"./node_modules/@mapbox/togeojson/togeojson.js\"));\n\nvar _GeoJsonParser = _interopRequireDefault(__webpack_require__(/*! ./GeoJsonParser */ \"./node_modules/itowns/lib/Parser/GeoJsonParser.js\"));\n\n/**\n * The GpxParser module provides a [parse]{@link module:GpxParser.parse}\n * method that takes a GPX in and gives an object formatted for iTowns\n * containing all necessary informations to display this GPX.\n *\n * @module GpxParser\n */\nvar _default = {\n  /**\n   * Parse a GPX file content and return a [FeatureCollection]{@link\n   * module:GeoJsonParser~FeatureCollection}.\n   *\n   * @param {XMLDocument} gpx - The GPX file content to parse.\n   * @param {GeoJsonParser~GeoJsonParserOptions} options - Options controlling the parsing.\n   *\n   * @return {Promise} A promise resolving with a [FeatureCollection]{@link\n   * module:GeoJsonParser~FeatureCollection}.\n   */\n  parse: function parse(gpx, options) {\n    return _GeoJsonParser[\"default\"].parse(_togeojson[\"default\"].gpx(gpx), options);\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/GpxParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/KMLParser.js":
/*!*****************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/KMLParser.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _togeojson = _interopRequireDefault(__webpack_require__(/*! @mapbox/togeojson */ \"./node_modules/@mapbox/togeojson/togeojson.js\"));\n\nvar _GeoJsonParser = _interopRequireDefault(__webpack_require__(/*! ./GeoJsonParser */ \"./node_modules/itowns/lib/Parser/GeoJsonParser.js\"));\n\n/**\n * The KMLParser module provides a [parse]{@link module:KMLParser.parse}\n * method that takes a KML in and gives an object formatted for iTowns\n * containing all necessary informations to display this KML.\n *\n * @module KMLParser\n */\nvar _default = {\n  /**\n   * Parse a KML file content and return a [FeatureCollection]{@link\n   * module:GeoJsonParser~FeatureCollection}.\n   *\n   * @param {XMLDocument} kml - The KML file content to parse.\n   * @param {GeoJsonParser~GeoJsonParserOptions} options - Options controlling the parsing.\n   *\n   * @return {Promise} A promise resolving with a [FeatureCollection]{@link\n   * module:GeoJsonParser~FeatureCollection}.\n   */\n  parse: function parse(kml, options) {\n    return _GeoJsonParser[\"default\"].parse(_togeojson[\"default\"].kml(kml), options);\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/KMLParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/PntsParser.js":
/*!******************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/PntsParser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Utf8Decoder = _interopRequireDefault(__webpack_require__(/*! ../Utils/Utf8Decoder */ \"./node_modules/itowns/lib/Utils/Utf8Decoder.js\"));\n\nvar _BatchTableParser = _interopRequireDefault(__webpack_require__(/*! ./BatchTableParser */ \"./node_modules/itowns/lib/Parser/BatchTableParser.js\"));\n\nvar _default = {\n  /** @module PntsParser */\n\n  /** Parse pnts buffer and extract THREE.Points and batch table\n   * @function parse\n   * @param {ArrayBuffer} buffer - the pnts buffer.\n   * @return {Promise} - a promise that resolves with an object containig a THREE.Points (point) and a batch table (batchTable).\n   *\n   */\n  parse: function (buffer) {\n    if (!buffer) {\n      throw new Error('No array buffer provided.');\n    }\n\n    var view = new DataView(buffer);\n    var byteOffset = 0;\n    var pntsHeader = {};\n    var batchTable = {};\n    var point = {}; // Magic type is unsigned char [4]\n\n    pntsHeader.magic = _Utf8Decoder[\"default\"].decode(new Uint8Array(buffer, byteOffset, 4));\n    byteOffset += 4;\n\n    if (pntsHeader.magic) {\n      // Version, byteLength, batchTableJSONByteLength, batchTableBinaryByteLength and batchTable types are uint32\n      pntsHeader.version = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      pntsHeader.byteLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      pntsHeader.FTJSONLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      pntsHeader.FTBinaryLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      pntsHeader.BTJSONLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n      pntsHeader.BTBinaryLength = view.getUint32(byteOffset, true);\n      byteOffset += Uint32Array.BYTES_PER_ELEMENT; // binary table\n\n      if (pntsHeader.FTBinaryLength > 0) {\n        point = parseFeatureBinary(buffer, byteOffset, pntsHeader.FTJSONLength);\n      } // batch table\n\n\n      if (pntsHeader.BTJSONLength > 0) {\n        var sizeBegin = 28 + pntsHeader.FTJSONLength + pntsHeader.FTBinaryLength;\n        batchTable = _BatchTableParser[\"default\"].parse(buffer.slice(sizeBegin, pntsHeader.BTJSONLength + sizeBegin));\n      }\n\n      var pnts = {\n        point: point,\n        batchTable: batchTable\n      };\n      return Promise.resolve(pnts);\n    } else {\n      throw new Error('Invalid pnts file.');\n    }\n  }\n};\nexports[\"default\"] = _default;\n\nfunction parseFeatureBinary(array, byteOffset, FTJSONLength) {\n  // Init geometry\n  var geometry = new THREE.BufferGeometry(); // init Array feature binary\n\n  var subArrayJson = _Utf8Decoder[\"default\"].decode(new Uint8Array(array, byteOffset, FTJSONLength));\n\n  var parseJSON = JSON.parse(subArrayJson);\n  var lengthFeature;\n\n  if (parseJSON.POINTS_LENGTH) {\n    lengthFeature = parseJSON.POINTS_LENGTH;\n  }\n\n  if (parseJSON.POSITION) {\n    var byteOffsetPos = parseJSON.POSITION.byteOffset + subArrayJson.length + byteOffset;\n    var positionArray = new Float32Array(array, byteOffsetPos, lengthFeature * 3);\n    geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));\n  }\n\n  if (parseJSON.RGB) {\n    var byteOffsetCol = parseJSON.RGB.byteOffset + subArrayJson.length + byteOffset;\n    var colorArray = new Uint8Array(array, byteOffsetCol, lengthFeature * 3);\n    geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3, true));\n  }\n\n  if (parseJSON.POSITION_QUANTIZED) {\n    throw new Error('For pnts loader, POSITION_QUANTIZED: not yet managed');\n  }\n\n  if (parseJSON.RGBA) {\n    throw new Error('For pnts loader, RGBA: not yet managed');\n  }\n\n  if (parseJSON.RGB565) {\n    throw new Error('For pnts loader, RGB565: not yet managed');\n  }\n\n  if (parseJSON.NORMAL) {\n    throw new Error('For pnts loader, NORMAL: not yet managed');\n  }\n\n  if (parseJSON.NORMAL_OCT16P) {\n    throw new Error('For pnts loader, NORMAL_OCT16P: not yet managed');\n  }\n\n  if (parseJSON.BATCH_ID) {\n    throw new Error('For pnts loader, BATCH_ID: not yet managed');\n  } // Add RTC feature\n\n\n  var offset = parseJSON.RTC_CENTER ? new THREE.Vector3().fromArray(parseJSON.RTC_CENTER) : undefined;\n  return {\n    geometry: geometry,\n    offset: offset\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/PntsParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/PotreeBinParser.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/PotreeBinParser.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\n// See the different constants holding ordinal, name, numElements, byteSize in PointAttributes.cpp in PotreeConverter\n// elementByteSize is byteSize / numElements\nvar POINT_ATTTRIBUTES = {\n  POSITION_CARTESIAN: {\n    numElements: 3,\n    arrayType: Float32Array,\n    attributeName: 'position'\n  },\n  COLOR_PACKED: {\n    numElements: 4,\n    arrayType: Uint8Array,\n    attributeName: 'color',\n    normalized: true\n  },\n  INTENSITY: {\n    numElements: 1,\n    numByte: 2,\n    // using Float32Array because Float16Array doesn't exist\n    arrayType: Float32Array,\n    attributeName: 'intensity',\n    normalized: true\n  },\n  CLASSIFICATION: {\n    numElements: 1,\n    arrayType: Uint8Array,\n    attributeName: 'classification'\n  },\n  // Note: at the time of writing, PotreeConverter will only generate normals in Oct16 format\n  // see PotreeConverter.cpp:121\n  // we keep all the historical value to still supports old conversion\n  NORMAL_SPHEREMAPPED: {\n    numElements: 2,\n    arrayType: Uint8Array,\n    attributeName: 'sphereMappedNormal'\n  },\n  // see https://web.archive.org/web/20150303053317/http://lgdv.cs.fau.de/get/1602\n  NORMAL_OCT16: {\n    numElements: 2,\n    arrayType: Uint8Array,\n    attributeName: 'oct16Normal'\n  },\n  NORMAL: {\n    numElements: 3,\n    arrayType: Float32Array,\n    attributeName: 'normal'\n  }\n};\n\nvar _loop = function () {\n  var potreeName = _Object$keys[_i];\n  var attr = POINT_ATTTRIBUTES[potreeName];\n  attr.potreeName = potreeName;\n  attr.numByte = attr.numByte || attr.arrayType.BYTES_PER_ELEMENT;\n  attr.byteSize = attr.numElements * attr.numByte;\n  attr.normalized = attr.normalized || false; // chrome is known to perform badly when we call a method without respecting its arity\n\n  var fnName = \"getUint\".concat(attr.numByte * 8);\n  attr.getValue = attr.numByte === 1 ? function (view, offset) {\n    return view[fnName](offset);\n  } : function (view, offset) {\n    return view[fnName](offset, true);\n  };\n};\n\nfor (var _i = 0, _Object$keys = Object.keys(POINT_ATTTRIBUTES); _i < _Object$keys.length; _i++) {\n  _loop();\n}\n\nvar _default = {\n  /** @module PotreeBinParser */\n\n  /** Parse .bin PotreeConverter format and convert to a THREE.BufferGeometry\n   * @function parse\n   * @param {ArrayBuffer} buffer - the bin buffer.\n   * @param {Object} pointAttributes - the point attributes information contained in layer.metadata coming from cloud.js\n   * @return {Promise} - a promise that resolves with a THREE.BufferGeometry.\n   *\n   */\n  parse: function (buffer, pointAttributes) {\n    if (!buffer) {\n      throw new Error('No array buffer provided.');\n    }\n\n    var view = new DataView(buffer); // Format: X1,Y1,Z1,R1,G1,B1,A1,[...],XN,YN,ZN,RN,GN,BN,AN\n\n    var pointByteSize = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = pointAttributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var potreeName = _step.value;\n        pointByteSize += POINT_ATTTRIBUTES[potreeName].byteSize;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var numPoints = Math.floor(buffer.byteLength / pointByteSize);\n    var geometry = new THREE.BufferGeometry();\n    var elemOffset = 0;\n    var attrOffset = 0;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = pointAttributes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _potreeName = _step2.value;\n        var attr = POINT_ATTTRIBUTES[_potreeName];\n        var arrayLength = attr.numElements * numPoints;\n        var array = new attr.arrayType(arrayLength);\n\n        for (var arrayOffset = 0; arrayOffset < arrayLength; arrayOffset += attr.numElements) {\n          for (var elemIdx = 0; elemIdx < attr.numElements; elemIdx++) {\n            array[arrayOffset + elemIdx] = attr.getValue(view, attrOffset + elemIdx * attr.numByte);\n          }\n\n          attrOffset += pointByteSize;\n        }\n\n        elemOffset += attr.byteSize;\n        attrOffset = elemOffset;\n        geometry.setAttribute(attr.attributeName, new THREE.BufferAttribute(array, attr.numElements, attr.normalized));\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    geometry.computeBoundingBox();\n    return Promise.resolve(geometry);\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/PotreeBinParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/PotreeCinParser.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/PotreeCinParser.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _default = {\n  /** @module PotreeCinParser */\n\n  /** Parse .cin PotreeConverter format (see {@link https://github.com/peppsac/PotreeConverter/tree/custom_bin}) and convert to a THREE.BufferGeometry\n   * @function parse\n   * @param {ArrayBuffer} buffer - the cin buffer.\n   * @return {Promise} - a promise that resolves with a THREE.BufferGeometry.\n   *\n   */\n  parse: function (buffer) {\n    if (!buffer) {\n      throw new Error('No array buffer provided.');\n    } // Format: MinX,MinY,MinZ,MaxX,MaxY,MaxZ,X1,Y1,Z1,[...],XN,YN,ZN,R1,G1,B1,A1,[...],RN,GN,BN,AN\n\n\n    var view = new DataView(buffer, 0, 6 * 4);\n    var min = new THREE.Vector3(view.getFloat32(0, true), view.getFloat32(4, true), view.getFloat32(8, true));\n    var max = new THREE.Vector3(view.getFloat32(12, true), view.getFloat32(16, true), view.getFloat32(20, true));\n    var box = new THREE.Box3(min, max);\n    var numPoints = Math.floor((buffer.byteLength - 24) / 16);\n    var positions = new Float32Array(buffer, 24, 3 * numPoints);\n    var colors = new Uint8Array(buffer, 24 + 3 * 4 * numPoints, 4 * numPoints);\n    var geometry = new THREE.BufferGeometry();\n    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 4, true));\n    geometry.boundingBox = box;\n    return Promise.resolve(geometry);\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/PotreeCinParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/ShapefileParser.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/ShapefileParser.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _proj = _interopRequireDefault(__webpack_require__(/*! proj4 */ \"./node_modules/proj4/lib/index.js\"));\n\nvar _shpjs = _interopRequireDefault(__webpack_require__(/*! shpjs */ \"./node_modules/shpjs/lib/index.js\"));\n\nvar _GeoJsonParser = _interopRequireDefault(__webpack_require__(/*! ./GeoJsonParser */ \"./node_modules/itowns/lib/Parser/GeoJsonParser.js\"));\n\n/**\n * The ShapefileParser module provides a [parse]{@link\n * module:ShapefileParser.parse} method that takes a bunch of files constituing\n * a shapefile in and gives an object formateted for iTowns, containing all\n * necessary informations to display this shapefile.\n *\n * It uses the [shpjs]{@link https://www.npmjs.com/package/shpjs} library to\n * parse all the files.\n *\n * @example\n * // Load all the necessary files for a shapefile, parse them and\n * // display them using a FileSource.\n * Promise.all([\n *     Fetcher.arrayBuffer('shapefile.shp'),\n *     Fetcher.arrayBuffer('shapefile.dbf'),\n *     Fetcher.arrayBuffer('shapefile.shx'),\n *     Fetcher.text('shapefile.prj'),\n * ]).then(function _(res) {\n *     return ShapefileParser.parse({\n *         shp: res[0],\n *         dbf: res[1],\n *         shx: res[2],\n *         prj: res[3],\n *     }, {\n *         buildExtent: true,\n *         crsIn: 'EPSG:4326',\n *         crsOut: view.tileLayer.extent.crs,\n *     });\n * }).then(function _(geojson) {\n *     var source = new FileSource({ parsedData: geojson });\n *     var layer = new ColorLayer('velib', { source  });\n *     view.addLayer(layer);\n * });\n *\n *\n * @module ShapefileParser\n */\nvar _default = {\n  /**\n   * Parse a bunch of Shapefile files and return a [FeatureCollection]{@link\n   * module:GeoJsonParser~FeatureCollection}.\n   *\n   * @param {Object} data - All the data that can be specified in a shapefile.\n   * @param {ArrayBuffer} data.shp - Data from the shapefile itself,\n   * containing the feature geometry itself.\n   * @param {ArrayBuffer} data.shx - A positional index of the feature\n   * geometry.\n   * @param {ArrayBuffer} data.dbf - Columnar attributes for each shape, in\n   * [dBase]{@link https://en.wikipedia.org/wiki/DBase} IV format.\n   * @param {string} [data.prj] - The coordinate system and projection\n   * information.\n   * @param {geojsonParserOptions} [options]\n   *\n   * @return {Promise} A promise resolving with a [FeatureCollection]{@link\n   * module:GeoJsonParser~FeatureCollection}.\n   */\n  parse: function parse(data) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var result; // If a zip is present, don't read anything else\n\n    if (data.zip) {\n      result = _shpjs[\"default\"].parseZip(data.zip);\n    } else if (data.shp && data.shx && data.dbf) {\n      result = Promise.all([_shpjs[\"default\"].parseShp(data.shp, data.prj), _shpjs[\"default\"].parseDbf(data.dbf)]).then(_shpjs[\"default\"].combine);\n    }\n\n    options.crsIn = data.prj ? (0, _proj[\"default\"])(data.prj).oProj.datumName : undefined;\n    return Promise.resolve(result).then(function (res) {\n      return _GeoJsonParser[\"default\"].parse(res, options);\n    });\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/ShapefileParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/VectorTileParser.js":
/*!************************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/VectorTileParser.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _three = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _pbf = _interopRequireDefault(__webpack_require__(/*! pbf */ \"./node_modules/pbf/index.js\"));\n\nvar _vectorTile = __webpack_require__(/*! @mapbox/vector-tile */ \"./node_modules/@mapbox/vector-tile/index.js\");\n\nvar _Extent = __webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\");\n\nvar _Feature = __webpack_require__(/*! ../Core/Feature */ \"./node_modules/itowns/lib/Core/Feature.js\");\n\nvar _mapboxGlStyleSpec = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec */ \"./node_modules/@mapbox/mapbox-gl-style-spec/dist/index.es.js\");\n\nvar _Style = _interopRequireDefault(__webpack_require__(/*! ../Core/Style */ \"./node_modules/itowns/lib/Core/Style.js\"));\n\nvar worldDimension3857 = _Extent.globalExtentTMS.get('EPSG:3857').dimensions();\n\nvar globalExtent = new _three.Vector3(worldDimension3857.x, worldDimension3857.y, 1);\nvar lastPoint = new _three.Vector2();\nvar firstPoint = new _three.Vector2();\nvar styleCache = new Map(); // Classify option, it allows to classify a full polygon and its holes.\n// Each polygon with its holes are in one FeatureGeometry.\n// A polygon is determined by its clockwise direction and the holes are in the opposite direction.\n// Clockwise direction is determined by Shoelace formula https://en.wikipedia.org/wiki/Shoelace_formula\n// Draw polygon with canvas doesn't need to classify however it is necessary for meshs.\n\nfunction vtFeatureToFeatureGeometry(vtFeature, feature) {\n  var classify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var geometry = feature.bindNewGeometry();\n  classify = classify && feature.type === _Feature.FEATURE_TYPES.POLYGON;\n  geometry.properties = vtFeature.properties;\n  var pbf = vtFeature._pbf;\n  pbf.pos = vtFeature._geometry;\n  var end = pbf.readVarint() + pbf.pos;\n  var cmd = 1;\n  var length = 0;\n  var x = 0;\n  var y = 0;\n  var count = 0;\n  var sum = 0;\n\n  while (pbf.pos < end) {\n    if (length <= 0) {\n      var cmdLen = pbf.readVarint();\n      cmd = cmdLen & 0x7;\n      length = cmdLen >> 3;\n    }\n\n    length--;\n\n    if (cmd === 1 || cmd === 2) {\n      x += pbf.readSVarint();\n      y += pbf.readSVarint();\n\n      if (cmd === 1) {\n        if (count) {\n          if (classify && sum > 0 && geometry.indices.length > 0) {\n            feature.updateExtent(geometry);\n            geometry = feature.bindNewGeometry();\n            geometry.properties = vtFeature.properties;\n          }\n\n          geometry.closeSubGeometry(count);\n          geometry.getLastSubGeometry().ccw = sum < 0;\n        }\n\n        count = 0;\n        sum = 0;\n      }\n\n      count++;\n      geometry.pushCoordinatesValues(x, y);\n\n      if (count == 1) {\n        firstPoint.set(x, y);\n        lastPoint.set(x, y);\n      } else if (classify && count > 1) {\n        sum += (lastPoint.x - x) * (lastPoint.y + y);\n        lastPoint.set(x, y);\n      }\n    } else if (cmd === 7) {\n      if (count) {\n        count++;\n        geometry.pushCoordinatesValues(firstPoint.x, firstPoint.y);\n\n        if (classify) {\n          sum += (lastPoint.x - firstPoint.x) * (lastPoint.y + firstPoint.y);\n        }\n      }\n    } else {\n      throw new Error(\"unknown command \".concat(cmd));\n    }\n  }\n\n  if (count) {\n    if (classify && sum > 0 && geometry.indices.length > 0) {\n      feature.updateExtent(geometry);\n      geometry = feature.bindNewGeometry();\n      geometry.properties = vtFeature.properties;\n    }\n\n    geometry.closeSubGeometry(count);\n    geometry.getLastSubGeometry().ccw = sum < 0;\n  }\n\n  feature.updateExtent(geometry);\n}\n\nvar defaultFilter = function () {\n  return true;\n};\n\nfunction readPBF(file, options) {\n  var vectorTile = new _vectorTile.VectorTile(new _pbf[\"default\"](file));\n  var extentSource = options.extentSource || file.extent;\n  var sourceLayers = Object.keys(vectorTile.layers);\n\n  if (sourceLayers.length < 1) {\n    return;\n  } // x,y,z tile coordinates\n\n\n  var x = extentSource.col;\n  var z = extentSource.zoom; // We need to move from TMS to Google/Bing/OSM coordinates\n  // https://alastaira.wordpress.com/2011/07/06/converting-tms-tile-coordinates-to-googlebingosm-tile-coordinates/\n  // Only if the layer.origin is top\n\n  var y = options.isInverted ? extentSource.row : (1 << z) - extentSource.row - 1;\n  options.buildExtent = true;\n  options.mergeFeatures = true;\n  options.withAltitude = false;\n  options.withNormal = false;\n  var features = new _Feature.FeatureCollection('EPSG:3857', options); // TODO remove defaultFilter;\n\n  features.filter = options.filter || defaultFilter;\n  var vFeature = vectorTile.layers[sourceLayers[0]]; // TODO: verify if size is correct because is computed with only one feature (vFeature).\n\n  var size = vFeature.extent * Math.pow(2, z);\n  var center = -0.5 * size;\n  features.scale.set(size, -size, 1).divide(globalExtent);\n  features.translation.set(-(vFeature.extent * x + center), -(vFeature.extent * y + center), 0).divide(features.scale);\n  var allLayers = features.filter;\n\n  if (!features.filter.loaded) {\n    allLayers.forEach(function (l) {\n      l.filterExpression = (0, _mapboxGlStyleSpec.featureFilter)(l.filter);\n    });\n    features.filter.loaded = true;\n  }\n\n  sourceLayers.forEach(function (layer_id) {\n    var sourceLayer = vectorTile.layers[layer_id];\n    var layersSource = allLayers.filter(function (l) {\n      return sourceLayer.name == l['source-layer'];\n    });\n\n    var _loop = function (i) {\n      var vtFeature = sourceLayer.feature(i);\n      var layers = layersSource.filter(function (l) {\n        return l.filterExpression({\n          zoom: z\n        }, vtFeature) && (!l.minzoom || l.minzoom <= z) && (!l.maxzoom || l.maxzoom >= z);\n      });\n      var feature = void 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop2 = function () {\n          var layer = _step.value;\n          var tag = \"\".concat(layer.id, \"_zoom_\").concat(z); // Fix doens't pass instance of properties\n\n          var style = styleCache.get(tag);\n\n          if (!style) {\n            style = new _Style[\"default\"]();\n            style.setFromVectorTileLayer(layer, extentSource.zoom, options.sprites);\n            styleCache.set(tag, style);\n          }\n\n          var order = allLayers.findIndex(function (l) {\n            return l.id == layer.id;\n          });\n\n          if (!feature) {\n            feature = features.requestFeatureById(layer.id, vtFeature.type - 1);\n            feature.id = layer.id;\n            feature.order = order;\n            feature.style = style;\n            vtFeatureToFeatureGeometry(vtFeature, feature);\n          } else if (!features.features.find(function (f) {\n            return f.id === layer.id;\n          })) {\n            feature = features.newFeatureByReference(feature);\n            feature.id = layer.id;\n            feature.order = order;\n            feature.style = style;\n          }\n        };\n\n        for (var _iterator = layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop2();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    };\n\n    for (var i = sourceLayer.length - 1; i >= 0; i--) {\n      _loop(i);\n    }\n  });\n  features.removeEmptyFeature(); // TODO verify if is needed to updateExtent for previous features.\n\n  features.updateExtent();\n  features.features.sort(function (a, b) {\n    return a.order - b.order;\n  });\n  features.extent = extentSource;\n  return Promise.resolve(features);\n}\n/**\n * @module VectorTileParser\n */\n\n\nvar _default = {\n  /**\n   * Parse a vector tile file and return a [Feature]{@link module:GeoJsonParser.Feature}\n   * or an array of Features. While multiple formats of vector tile are\n   * available, the only one supported for the moment is the\n   * [Mapbox Vector Tile]{@link https://www.mapbox.com/vector-tiles/specification/}.\n   *\n   * @param {ArrayBuffer} file - The vector tile file to parse.\n   * @param {Object} options - Options controlling the parsing.\n   * @param {Extent} options.extent - The Extent to convert the input coordinates to.\n   * @param {Extent=} options.filteringExtent - Optional filter to reject features\n   * outside of this extent.\n   * @param {boolean} [options.mergeFeatures=true] - If true all geometries are merged by type and multi-type\n   * @param {boolean} [options.withNormal=true] - If true each coordinate normal is computed\n   * @param {boolean} [options.withAltitude=true] - If true each coordinate altitude is kept\n   * @param {function=} options.filter - Filter function to remove features.\n   * @param {string=} options.isInverted - This option is to be set to the\n   * correct value, true or false (default being false), if the computation of\n   * the coordinates needs to be inverted to same scheme as OSM, Google Maps\n   * or other system. See [this link]{@link\n   * https://alastaira.wordpress.com/2011/07/06/converting-tms-tile-coordinates-to-googlebingosm-tile-coordinates}\n   * for more informations.\n   *\n   * @return {Promise} A Promise resolving with a Feature or an array a\n   * Features.\n   */\n  parse: function parse(file, options) {\n    return Promise.resolve(readPBF(file, options));\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/VectorTileParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/XbilParser.js":
/*!******************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/XbilParser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeMinMaxElevation = computeMinMaxElevation;\nexports.checkNodeElevationTextureValidity = checkNodeElevationTextureValidity;\nexports.insertSignificantValuesFromParent = insertSignificantValuesFromParent;\n\n/**\n  * Calculates the minimum maximum elevation of xbil buffer\n  *\n  * @param      {number}  buffer       The buffer to parse\n  * @param      {number}  width        The buffer's width\n  * @param      {number}  height       The buffer's height\n  * @param      {THREE.Vector4}  pitch  The pitch,  restrict zone to parse\n  * @return     {Object}  The minimum maximum elevation.\n  */\nfunction computeMinMaxElevation(buffer, width, height, pitch) {\n  var min = 1000000;\n  var max = -1000000;\n\n  if (!buffer) {\n    // Return null values means there's no elevation values.\n    // They can't be determined.\n    // Don't return 0 because the result will be wrong\n    return {\n      min: null,\n      max: null\n    };\n  }\n\n  var sizeX = pitch ? Math.floor(pitch.z * width) : buffer.length;\n  var sizeY = pitch ? Math.floor(pitch.z * height) : 1;\n  var xs = pitch ? Math.floor(pitch.x * width) : 0;\n  var ys = pitch ? Math.floor(pitch.y * height) : 0;\n  var inc = pitch ? Math.max(Math.floor(sizeX / 8), 2) : 16;\n\n  for (var y = ys; y < ys + sizeY; y += inc) {\n    var pit = y * (width || 0);\n\n    for (var x = xs; x < xs + sizeX; x += inc) {\n      var val = buffer[pit + x];\n\n      if (val > -10) {\n        max = Math.max(max, val);\n        min = Math.min(min, val);\n      }\n    }\n  }\n\n  if (max === -1000000 || min === 1000000) {\n    // Return null values means the elevation values are incoherent\n    // They can't be determined.\n    // Don't return 0, -1000000 or 1000000 because the result will be wrong\n    return {\n      min: null,\n      max: null\n    };\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n} // We check if the elevation texture has some significant values through corners\n\n\nfunction checkNodeElevationTextureValidity(data, noDataValue) {\n  var l = data.length;\n  return data[0] > noDataValue && data[l - 1] > noDataValue && data[Math.sqrt(l) - 1] > noDataValue && data[l - Math.sqrt(l)] > noDataValue;\n}\n\nfunction getIndiceWithPitch(i, pitch, w) {\n  // Return corresponding indice in parent tile using pitch\n  // normalized\n  var currentY = Math.floor(i / w) / w; // normalized\n\n  var newX = pitch.x + i % w / w * pitch.z;\n  var newY = pitch.y + currentY * pitch.w;\n  var newIndice = Math.floor(newY * w) * w + Math.floor(newX * w);\n  return newIndice;\n} // This function replaces noDataValue by significant values from parent texture\n\n\nfunction insertSignificantValuesFromParent(data, dataParent, noDataValue, pitch) {\n  for (var i = 0, l = data.length; i < l; ++i) {\n    if (data[i] === noDataValue) {\n      data[i] = dataParent[getIndiceWithPitch(i, pitch, 256)];\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/XbilParser.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Parser/deprecated/LegacyGLTFLoader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/itowns/lib/Parser/deprecated/LegacyGLTFLoader.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\n/* eslint-disable */\n// Copy LegacyGLTFLoader file from THREE v110 because it was removed in THREE v111\nvar threeExamples = {};\n/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n */\n\nthreeExamples.LegacyGLTFLoader = function () {\n  function LegacyGLTFLoader(manager) {\n    THREE.Loader.call(this, manager);\n  }\n\n  LegacyGLTFLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n    constructor: LegacyGLTFLoader,\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var resourcePath;\n\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = THREE.LoaderUtils.extractUrlBase(url);\n      }\n\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (data) {\n        scope.parse(data, resourcePath, onLoad);\n      }, onProgress, onError);\n    },\n    parse: function parse(data, path, callback) {\n      var content;\n      var extensions = {};\n      var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n      if (magic === BINARY_EXTENSION_HEADER_DEFAULTS.magic) {\n        extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n      } else {\n        content = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.extensionsUsed && json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_COMMON) >= 0) {\n        extensions[EXTENSIONS.KHR_MATERIALS_COMMON] = new GLTFMaterialsCommonExtension(json);\n      }\n\n      var parser = new GLTFParser(json, extensions, {\n        crossOrigin: this.crossOrigin,\n        manager: this.manager,\n        path: path || this.resourcePath || ''\n      });\n      parser.parse(function (scene, scenes, cameras, animations) {\n        callback({\n          \"scene\": scene,\n          \"scenes\": scenes,\n          \"cameras\": cameras,\n          \"animations\": animations\n        });\n      });\n    }\n  });\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    var objects = {};\n    return {\n      get: function get(key) {\n        return objects[key];\n      },\n      add: function add(key, object) {\n        objects[key] = object;\n      },\n      remove: function remove(key) {\n        delete objects[key];\n      },\n      removeAll: function removeAll() {\n        objects = {};\n      },\n      update: function update(scene, camera) {\n        for (var name in objects) {\n          var object = objects[name];\n\n          if (object.update) {\n            object.update(scene, camera);\n          }\n        }\n      }\n    };\n  }\n  /* GLTFSHADERS */\n\n\n  LegacyGLTFLoader.Shaders = {\n    update: function update() {\n      console.warn('threeExamples.LegacyGLTFLoader.Shaders has been deprecated, and now updates automatically.');\n    }\n  };\n  /* GLTFSHADER */\n\n  function GLTFShader(targetNode, allNodes) {\n    var boundUniforms = {}; // bind each uniform to its source node\n\n    var uniforms = targetNode.material.uniforms;\n\n    for (var uniformId in uniforms) {\n      var uniform = uniforms[uniformId];\n\n      if (uniform.semantic) {\n        var sourceNodeRef = uniform.node;\n        var sourceNode = targetNode;\n\n        if (sourceNodeRef) {\n          sourceNode = allNodes[sourceNodeRef];\n        }\n\n        boundUniforms[uniformId] = {\n          semantic: uniform.semantic,\n          sourceNode: sourceNode,\n          targetNode: targetNode,\n          uniform: uniform\n        };\n      }\n    }\n\n    this.boundUniforms = boundUniforms;\n    this._m4 = new THREE.Matrix4();\n  } // Update - update all the uniform values\n\n\n  GLTFShader.prototype.update = function (scene, camera) {\n    var boundUniforms = this.boundUniforms;\n\n    for (var name in boundUniforms) {\n      var boundUniform = boundUniforms[name];\n\n      switch (boundUniform.semantic) {\n        case \"MODELVIEW\":\n          var m4 = boundUniform.uniform.value;\n          m4.multiplyMatrices(camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld);\n          break;\n\n        case \"MODELVIEWINVERSETRANSPOSE\":\n          var m3 = boundUniform.uniform.value;\n\n          this._m4.multiplyMatrices(camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld);\n\n          m3.getNormalMatrix(this._m4);\n          break;\n\n        case \"PROJECTION\":\n          var m4 = boundUniform.uniform.value;\n          m4.copy(camera.projectionMatrix);\n          break;\n\n        case \"JOINTMATRIX\":\n          var m4v = boundUniform.uniform.value;\n\n          for (var mi = 0; mi < m4v.length; mi++) {\n            // So it goes like this:\n            // SkinnedMesh world matrix is already baked into MODELVIEW;\n            // transform joints to local space,\n            // then transform using joint's inverse\n            m4v[mi].getInverse(boundUniform.sourceNode.matrixWorld).multiply(boundUniform.targetNode.skeleton.bones[mi].matrixWorld).multiply(boundUniform.targetNode.skeleton.boneInverses[mi]).multiply(boundUniform.targetNode.bindMatrix);\n          }\n\n          break;\n\n        default:\n          console.warn(\"Unhandled shader semantic: \" + boundUniform.semantic);\n          break;\n      }\n    }\n  };\n  /* ANIMATION */\n\n\n  LegacyGLTFLoader.Animations = {\n    update: function update() {\n      console.warn('threeExamples.LegacyGLTFLoader.Animation has been deprecated. Use THREE.AnimationMixer instead.');\n    }\n  };\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n  var EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_MATERIALS_COMMON: 'KHR_materials_common'\n  };\n  /* MATERIALS COMMON EXTENSION */\n\n  function GLTFMaterialsCommonExtension(json) {\n    this.name = EXTENSIONS.KHR_MATERIALS_COMMON;\n    this.lights = {};\n    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_MATERIALS_COMMON] || {};\n    var lights = extension.lights || {};\n\n    for (var lightId in lights) {\n      var light = lights[lightId];\n      var lightNode;\n      var lightParams = light[light.type];\n      var color = new THREE.Color().fromArray(lightParams.color);\n\n      switch (light.type) {\n        case \"directional\":\n          lightNode = new THREE.DirectionalLight(color);\n          lightNode.position.set(0, 0, 1);\n          break;\n\n        case \"point\":\n          lightNode = new THREE.PointLight(color);\n          break;\n\n        case \"spot\":\n          lightNode = new THREE.SpotLight(color);\n          lightNode.position.set(0, 0, 1);\n          break;\n\n        case \"ambient\":\n          lightNode = new THREE.AmbientLight(color);\n          break;\n      }\n\n      if (lightNode) {\n        this.lights[lightId] = lightNode;\n      }\n    }\n  }\n  /* BINARY EXTENSION */\n\n\n  var BINARY_EXTENSION_HEADER_DEFAULTS = {\n    magic: 'glTF',\n    version: 1,\n    contentFormat: 0\n  };\n  var BINARY_EXTENSION_HEADER_LENGTH = 20;\n\n  function GLTFBinaryExtension(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    var header = {\n      magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n      contentLength: headerView.getUint32(12, true),\n      contentFormat: headerView.getUint32(16, true)\n    };\n\n    for (var key in BINARY_EXTENSION_HEADER_DEFAULTS) {\n      var value = BINARY_EXTENSION_HEADER_DEFAULTS[key];\n\n      if (header[key] !== value) {\n        throw new Error('Unsupported glTF-Binary header: Expected \"%s\" to be \"%s\".', key, value);\n      }\n    }\n\n    var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH, header.contentLength);\n    this.header = header;\n    this.content = THREE.LoaderUtils.decodeText(contentArray);\n    this.body = data.slice(BINARY_EXTENSION_HEADER_LENGTH + header.contentLength, header.length);\n  }\n\n  GLTFBinaryExtension.prototype.loadShader = function (shader, bufferViews) {\n    var bufferView = bufferViews[shader.extensions[EXTENSIONS.KHR_BINARY_GLTF].bufferView];\n    var array = new Uint8Array(bufferView);\n    return THREE.LoaderUtils.decodeText(array);\n  };\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n\n  var WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    TRIANGLES: 4,\n    LINES: 1,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123,\n    VERTEX_SHADER: 35633,\n    FRAGMENT_SHADER: 35632\n  };\n  var WEBGL_TYPE = {\n    5126: Number,\n    //35674: THREE.Matrix2,\n    35675: THREE.Matrix3,\n    35676: THREE.Matrix4,\n    35664: THREE.Vector2,\n    35665: THREE.Vector3,\n    35666: THREE.Vector4,\n    35678: THREE.Texture\n  };\n  var WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  var WEBGL_FILTERS = {\n    9728: THREE.NearestFilter,\n    9729: THREE.LinearFilter,\n    9984: THREE.NearestMipmapNearestFilter,\n    9985: THREE.LinearMipmapNearestFilter,\n    9986: THREE.NearestMipmapLinearFilter,\n    9987: THREE.LinearMipmapLinearFilter\n  };\n  var WEBGL_WRAPPINGS = {\n    33071: THREE.ClampToEdgeWrapping,\n    33648: THREE.MirroredRepeatWrapping,\n    10497: THREE.RepeatWrapping\n  };\n  var WEBGL_TEXTURE_FORMATS = {\n    6406: THREE.AlphaFormat,\n    6407: THREE.RGBFormat,\n    6408: THREE.RGBAFormat,\n    6409: THREE.LuminanceFormat,\n    6410: THREE.LuminanceAlphaFormat\n  };\n  var WEBGL_TEXTURE_DATATYPES = {\n    5121: THREE.UnsignedByteType,\n    32819: THREE.UnsignedShort4444Type,\n    32820: THREE.UnsignedShort5551Type,\n    33635: THREE.UnsignedShort565Type\n  };\n  var WEBGL_SIDES = {\n    1028: THREE.BackSide,\n    // Culling front\n    1029: THREE.FrontSide // Culling back\n    //1032: THREE.NoSide   // Culling front and back, what to do?\n\n  };\n  var WEBGL_DEPTH_FUNCS = {\n    512: THREE.NeverDepth,\n    513: THREE.LessDepth,\n    514: THREE.EqualDepth,\n    515: THREE.LessEqualDepth,\n    516: THREE.GreaterEqualDepth,\n    517: THREE.NotEqualDepth,\n    518: THREE.GreaterEqualDepth,\n    519: THREE.AlwaysDepth\n  };\n  var WEBGL_BLEND_EQUATIONS = {\n    32774: THREE.AddEquation,\n    32778: THREE.SubtractEquation,\n    32779: THREE.ReverseSubtractEquation\n  };\n  var WEBGL_BLEND_FUNCS = {\n    0: THREE.ZeroFactor,\n    1: THREE.OneFactor,\n    768: THREE.SrcColorFactor,\n    769: THREE.OneMinusSrcColorFactor,\n    770: THREE.SrcAlphaFactor,\n    771: THREE.OneMinusSrcAlphaFactor,\n    772: THREE.DstAlphaFactor,\n    773: THREE.OneMinusDstAlphaFactor,\n    774: THREE.DstColorFactor,\n    775: THREE.OneMinusDstColorFactor,\n    776: THREE.SrcAlphaSaturateFactor // The followings are not supported by Three.js yet\n    //32769: CONSTANT_COLOR,\n    //32770: ONE_MINUS_CONSTANT_COLOR,\n    //32771: CONSTANT_ALPHA,\n    //32772: ONE_MINUS_CONSTANT_COLOR\n\n  };\n  var WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n  };\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion'\n  };\n  var INTERPOLATION = {\n    LINEAR: THREE.InterpolateLinear,\n    STEP: THREE.InterpolateDiscrete\n  };\n  var STATES_ENABLES = {\n    2884: 'CULL_FACE',\n    2929: 'DEPTH_TEST',\n    3042: 'BLEND',\n    3089: 'SCISSOR_TEST',\n    32823: 'POLYGON_OFFSET_FILL',\n    32926: 'SAMPLE_ALPHA_TO_COVERAGE'\n  };\n  /* UTILITY FUNCTIONS */\n\n  function _each(object, callback, thisObj) {\n    if (!object) {\n      return Promise.resolve();\n    }\n\n    var results;\n    var fns = [];\n\n    if (Object.prototype.toString.call(object) === '[object Array]') {\n      results = [];\n      var length = object.length;\n\n      for (var idx = 0; idx < length; idx++) {\n        var value = callback.call(thisObj || this, object[idx], idx);\n\n        if (value) {\n          fns.push(value);\n\n          if (value instanceof Promise) {\n            value.then(function (key, value) {\n              results[key] = value;\n            }.bind(this, idx));\n          } else {\n            results[idx] = value;\n          }\n        }\n      }\n    } else {\n      results = {};\n\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          var value = callback.call(thisObj || this, object[key], key);\n\n          if (value) {\n            fns.push(value);\n\n            if (value instanceof Promise) {\n              value.then(function (key, value) {\n                results[key] = value;\n              }.bind(this, key));\n            } else {\n              results[key] = value;\n            }\n          }\n        }\n      }\n    }\n\n    return Promise.all(fns).then(function () {\n      return results;\n    });\n  }\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Absolute URL http://,https://,//\n\n    if (/^(https?:)?\\/\\//i.test(url)) {\n      return url;\n    } // Data URI\n\n\n    if (/^data:.*,.*$/i.test(url)) {\n      return url;\n    } // Blob URL\n\n\n    if (/^blob:.*$/i.test(url)) {\n      return url;\n    } // Relative URL\n\n\n    return (path || '') + url;\n  } // Three.js seems too dependent on attribute names so globally\n  // replace those in the shader code\n\n\n  function replaceTHREEShaderAttributes(shaderText, technique) {\n    // Expected technique attributes\n    var attributes = {};\n\n    for (var attributeId in technique.attributes) {\n      var pname = technique.attributes[attributeId];\n      var param = technique.parameters[pname];\n      var atype = param.type;\n      var semantic = param.semantic;\n      attributes[attributeId] = {\n        type: atype,\n        semantic: semantic\n      };\n    } // Figure out which attributes to change in technique\n\n\n    var shaderParams = technique.parameters;\n    var shaderAttributes = technique.attributes;\n    var params = {};\n\n    for (var attributeId in attributes) {\n      var pname = shaderAttributes[attributeId];\n      var shaderParam = shaderParams[pname];\n      var semantic = shaderParam.semantic;\n\n      if (semantic) {\n        params[attributeId] = shaderParam;\n      }\n    }\n\n    for (var pname in params) {\n      var param = params[pname];\n      var semantic = param.semantic;\n      var regEx = new RegExp(\"\\\\b\" + pname + \"\\\\b\", \"g\");\n\n      switch (semantic) {\n        case \"POSITION\":\n          shaderText = shaderText.replace(regEx, 'position');\n          break;\n\n        case \"NORMAL\":\n          shaderText = shaderText.replace(regEx, 'normal');\n          break;\n\n        case 'TEXCOORD_0':\n        case 'TEXCOORD0':\n        case 'TEXCOORD':\n          shaderText = shaderText.replace(regEx, 'uv');\n          break;\n\n        case 'TEXCOORD_1':\n          shaderText = shaderText.replace(regEx, 'uv2');\n          break;\n\n        case 'COLOR_0':\n        case 'COLOR0':\n        case 'COLOR':\n          shaderText = shaderText.replace(regEx, 'color');\n          break;\n\n        case \"WEIGHT\":\n          shaderText = shaderText.replace(regEx, 'skinWeight');\n          break;\n\n        case \"JOINT\":\n          shaderText = shaderText.replace(regEx, 'skinIndex');\n          break;\n      }\n    }\n\n    return shaderText;\n  }\n\n  function createDefaultMaterial() {\n    return new THREE.MeshPhongMaterial({\n      color: 0x00000,\n      emissive: 0x888888,\n      specular: 0x000000,\n      shininess: 0,\n      transparent: false,\n      depthTest: true,\n      side: THREE.FrontSide\n    });\n  } // Deferred constructor for RawShaderMaterial types\n\n\n  function DeferredShaderMaterial(params) {\n    this.isDeferredShaderMaterial = true;\n    this.params = params;\n  }\n\n  DeferredShaderMaterial.prototype.create = function () {\n    var uniforms = THREE.UniformsUtils.clone(this.params.uniforms);\n\n    for (var uniformId in this.params.uniforms) {\n      var originalUniform = this.params.uniforms[uniformId];\n\n      if (originalUniform.value instanceof THREE.Texture) {\n        uniforms[uniformId].value = originalUniform.value;\n        uniforms[uniformId].value.needsUpdate = true;\n      }\n\n      uniforms[uniformId].semantic = originalUniform.semantic;\n      uniforms[uniformId].node = originalUniform.node;\n    }\n\n    this.params.uniforms = uniforms;\n    return new THREE.RawShaderMaterial(this.params);\n  };\n  /* GLTF PARSER */\n\n\n  function GLTFParser(json, extensions, options) {\n    this.json = json || {};\n    this.extensions = extensions || {};\n    this.options = options || {}; // loader object cache\n\n    this.cache = new GLTFRegistry();\n  }\n\n  GLTFParser.prototype._withDependencies = function (dependencies) {\n    var _dependencies = {};\n\n    for (var i = 0; i < dependencies.length; i++) {\n      var dependency = dependencies[i];\n      var fnName = \"load\" + dependency.charAt(0).toUpperCase() + dependency.slice(1);\n      var cached = this.cache.get(dependency);\n\n      if (cached !== undefined) {\n        _dependencies[dependency] = cached;\n      } else if (this[fnName]) {\n        var fn = this[fnName]();\n        this.cache.add(dependency, fn);\n        _dependencies[dependency] = fn;\n      }\n    }\n\n    return _each(_dependencies, function (dependency) {\n      return dependency;\n    });\n  };\n\n  GLTFParser.prototype.parse = function (callback) {\n    var json = this.json; // Clear the loader cache\n\n    this.cache.removeAll(); // Fire the callback on complete\n\n    this._withDependencies([\"scenes\", \"cameras\", \"animations\"]).then(function (dependencies) {\n      var scenes = [];\n\n      for (var name in dependencies.scenes) {\n        scenes.push(dependencies.scenes[name]);\n      }\n\n      var scene = json.scene !== undefined ? dependencies.scenes[json.scene] : scenes[0];\n      var cameras = [];\n\n      for (var name in dependencies.cameras) {\n        var camera = dependencies.cameras[name];\n        cameras.push(camera);\n      }\n\n      var animations = [];\n\n      for (var name in dependencies.animations) {\n        animations.push(dependencies.animations[name]);\n      }\n\n      callback(scene, scenes, cameras, animations);\n    });\n  };\n\n  GLTFParser.prototype.loadShaders = function () {\n    var json = this.json;\n    var extensions = this.extensions;\n    var options = this.options;\n    return this._withDependencies([\"bufferViews\"]).then(function (dependencies) {\n      return _each(json.shaders, function (shader) {\n        if (shader.extensions && shader.extensions[EXTENSIONS.KHR_BINARY_GLTF]) {\n          return extensions[EXTENSIONS.KHR_BINARY_GLTF].loadShader(shader, dependencies.bufferViews);\n        }\n\n        return new Promise(function (resolve) {\n          var loader = new THREE.FileLoader(options.manager);\n          loader.setResponseType('text');\n          loader.load(resolveURL(shader.uri, options.path), function (shaderText) {\n            resolve(shaderText);\n          });\n        });\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadBuffers = function () {\n    var json = this.json;\n    var extensions = this.extensions;\n    var options = this.options;\n    return _each(json.buffers, function (buffer, name) {\n      if (name === 'binary_glTF') {\n        return extensions[EXTENSIONS.KHR_BINARY_GLTF].body;\n      }\n\n      if (buffer.type === 'arraybuffer' || buffer.type === undefined) {\n        return new Promise(function (resolve) {\n          var loader = new THREE.FileLoader(options.manager);\n          loader.setResponseType('arraybuffer');\n          loader.load(resolveURL(buffer.uri, options.path), function (buffer) {\n            resolve(buffer);\n          });\n        });\n      } else {\n        console.warn('threeExamples.LegacyGLTFLoader: ' + buffer.type + ' buffer type is not supported');\n      }\n    });\n  };\n\n  GLTFParser.prototype.loadBufferViews = function () {\n    var json = this.json;\n    return this._withDependencies([\"buffers\"]).then(function (dependencies) {\n      return _each(json.bufferViews, function (bufferView) {\n        var arraybuffer = dependencies.buffers[bufferView.buffer];\n        var byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;\n        return arraybuffer.slice(bufferView.byteOffset, bufferView.byteOffset + byteLength);\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadAccessors = function () {\n    var json = this.json;\n    return this._withDependencies([\"bufferViews\"]).then(function (dependencies) {\n      return _each(json.accessors, function (accessor) {\n        var arraybuffer = dependencies.bufferViews[accessor.bufferView];\n        var itemSize = WEBGL_TYPE_SIZES[accessor.type];\n        var TypedArray = WEBGL_COMPONENT_TYPES[accessor.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n        var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\n        // The buffer is not interleaved if the stride is the item size in bytes.\n        if (accessor.byteStride && accessor.byteStride !== elementBytes * itemSize) {\n          // Use the full buffer if it's interleaved.\n          var array = new TypedArray(arraybuffer); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          var ib = new THREE.InterleavedBuffer(array, accessor.byteStride / elementBytes);\n          return new THREE.InterleavedBufferAttribute(ib, itemSize, accessor.byteOffset / elementBytes);\n        } else {\n          array = new TypedArray(arraybuffer, accessor.byteOffset, accessor.count * itemSize);\n          return new THREE.BufferAttribute(array, itemSize);\n        }\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadTextures = function () {\n    var json = this.json;\n    var options = this.options;\n    return this._withDependencies([\"bufferViews\"]).then(function (dependencies) {\n      return _each(json.textures, function (texture) {\n        if (texture.source) {\n          return new Promise(function (resolve) {\n            var source = json.images[texture.source];\n            var sourceUri = source.uri;\n            var isObjectURL = false;\n\n            if (source.extensions && source.extensions[EXTENSIONS.KHR_BINARY_GLTF]) {\n              var metadata = source.extensions[EXTENSIONS.KHR_BINARY_GLTF];\n              var bufferView = dependencies.bufferViews[metadata.bufferView];\n              var blob = new Blob([bufferView], {\n                type: metadata.mimeType\n              });\n              sourceUri = URL.createObjectURL(blob);\n              isObjectURL = true;\n            }\n\n            var textureLoader = options.manager.getHandler(sourceUri);\n\n            if (textureLoader === null) {\n              textureLoader = new THREE.TextureLoader(options.manager);\n            }\n\n            textureLoader.setCrossOrigin(options.crossOrigin);\n            textureLoader.load(resolveURL(sourceUri, options.path), function (_texture) {\n              if (isObjectURL) URL.revokeObjectURL(sourceUri);\n              _texture.flipY = false;\n              if (texture.name !== undefined) _texture.name = texture.name;\n              _texture.format = texture.format !== undefined ? WEBGL_TEXTURE_FORMATS[texture.format] : THREE.RGBAFormat;\n\n              if (texture.internalFormat !== undefined && _texture.format !== WEBGL_TEXTURE_FORMATS[texture.internalFormat]) {\n                console.warn('threeExamples.LegacyGLTFLoader: Three.js doesn\\'t support texture internalFormat which is different from texture format. ' + 'internalFormat will be forced to be the same value as format.');\n              }\n\n              _texture.type = texture.type !== undefined ? WEBGL_TEXTURE_DATATYPES[texture.type] : THREE.UnsignedByteType;\n\n              if (texture.sampler) {\n                var sampler = json.samplers[texture.sampler];\n                _texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n                _texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.NearestMipmapLinearFilter;\n                _texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n                _texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n              }\n\n              resolve(_texture);\n            }, undefined, function () {\n              if (isObjectURL) URL.revokeObjectURL(sourceUri);\n              resolve();\n            });\n          });\n        }\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadMaterials = function () {\n    var json = this.json;\n    return this._withDependencies([\"shaders\", \"textures\"]).then(function (dependencies) {\n      return _each(json.materials, function (material) {\n        var materialType;\n        var materialValues = {};\n        var materialParams = {};\n        var khr_material;\n\n        if (material.extensions && material.extensions[EXTENSIONS.KHR_MATERIALS_COMMON]) {\n          khr_material = material.extensions[EXTENSIONS.KHR_MATERIALS_COMMON];\n        }\n\n        if (khr_material) {\n          // don't copy over unused values to avoid material warning spam\n          var keys = ['ambient', 'emission', 'transparent', 'transparency', 'doubleSided'];\n\n          switch (khr_material.technique) {\n            case 'BLINN':\n            case 'PHONG':\n              materialType = THREE.MeshPhongMaterial;\n              keys.push('diffuse', 'specular', 'shininess');\n              break;\n\n            case 'LAMBERT':\n              materialType = THREE.MeshLambertMaterial;\n              keys.push('diffuse');\n              break;\n\n            case 'CONSTANT':\n            default:\n              materialType = THREE.MeshBasicMaterial;\n              break;\n          }\n\n          keys.forEach(function (v) {\n            if (khr_material.values[v] !== undefined) materialValues[v] = khr_material.values[v];\n          });\n\n          if (khr_material.doubleSided || materialValues.doubleSided) {\n            materialParams.side = THREE.DoubleSide;\n          }\n\n          if (khr_material.transparent || materialValues.transparent) {\n            materialParams.transparent = true;\n            materialParams.opacity = materialValues.transparency !== undefined ? materialValues.transparency : 1;\n          }\n        } else if (material.technique === undefined) {\n          materialType = THREE.MeshPhongMaterial;\n          Object.assign(materialValues, material.values);\n        } else {\n          materialType = DeferredShaderMaterial;\n          var technique = json.techniques[material.technique];\n          materialParams.uniforms = {};\n          var program = json.programs[technique.program];\n\n          if (program) {\n            materialParams.fragmentShader = dependencies.shaders[program.fragmentShader];\n\n            if (!materialParams.fragmentShader) {\n              console.warn(\"ERROR: Missing fragment shader definition:\", program.fragmentShader);\n              materialType = THREE.MeshPhongMaterial;\n            }\n\n            var vertexShader = dependencies.shaders[program.vertexShader];\n\n            if (!vertexShader) {\n              console.warn(\"ERROR: Missing vertex shader definition:\", program.vertexShader);\n              materialType = THREE.MeshPhongMaterial;\n            } // IMPORTANT: FIX VERTEX SHADER ATTRIBUTE DEFINITIONS\n\n\n            materialParams.vertexShader = replaceTHREEShaderAttributes(vertexShader, technique);\n            var uniforms = technique.uniforms;\n\n            for (var uniformId in uniforms) {\n              var pname = uniforms[uniformId];\n              var shaderParam = technique.parameters[pname];\n              var ptype = shaderParam.type;\n\n              if (WEBGL_TYPE[ptype]) {\n                var pcount = shaderParam.count;\n                var value;\n                if (material.values !== undefined) value = material.values[pname];\n                var uvalue = new WEBGL_TYPE[ptype]();\n                var usemantic = shaderParam.semantic;\n                var unode = shaderParam.node;\n\n                switch (ptype) {\n                  case WEBGL_CONSTANTS.FLOAT:\n                    uvalue = shaderParam.value;\n\n                    if (pname == \"transparency\") {\n                      materialParams.transparent = true;\n                    }\n\n                    if (value !== undefined) {\n                      uvalue = value;\n                    }\n\n                    break;\n\n                  case WEBGL_CONSTANTS.FLOAT_VEC2:\n                  case WEBGL_CONSTANTS.FLOAT_VEC3:\n                  case WEBGL_CONSTANTS.FLOAT_VEC4:\n                  case WEBGL_CONSTANTS.FLOAT_MAT3:\n                    if (shaderParam && shaderParam.value) {\n                      uvalue.fromArray(shaderParam.value);\n                    }\n\n                    if (value) {\n                      uvalue.fromArray(value);\n                    }\n\n                    break;\n\n                  case WEBGL_CONSTANTS.FLOAT_MAT2:\n                    // what to do?\n                    console.warn(\"FLOAT_MAT2 is not a supported uniform type\");\n                    break;\n\n                  case WEBGL_CONSTANTS.FLOAT_MAT4:\n                    if (pcount) {\n                      uvalue = new Array(pcount);\n\n                      for (var mi = 0; mi < pcount; mi++) {\n                        uvalue[mi] = new WEBGL_TYPE[ptype]();\n                      }\n\n                      if (shaderParam && shaderParam.value) {\n                        var m4v = shaderParam.value;\n                        uvalue.fromArray(m4v);\n                      }\n\n                      if (value) {\n                        uvalue.fromArray(value);\n                      }\n                    } else {\n                      if (shaderParam && shaderParam.value) {\n                        var m4 = shaderParam.value;\n                        uvalue.fromArray(m4);\n                      }\n\n                      if (value) {\n                        uvalue.fromArray(value);\n                      }\n                    }\n\n                    break;\n\n                  case WEBGL_CONSTANTS.SAMPLER_2D:\n                    if (value !== undefined) {\n                      uvalue = dependencies.textures[value];\n                    } else if (shaderParam.value !== undefined) {\n                      uvalue = dependencies.textures[shaderParam.value];\n                    } else {\n                      uvalue = null;\n                    }\n\n                    break;\n                }\n\n                materialParams.uniforms[uniformId] = {\n                  value: uvalue,\n                  semantic: usemantic,\n                  node: unode\n                };\n              } else {\n                throw new Error(\"Unknown shader uniform param type: \" + ptype);\n              }\n            }\n\n            var states = technique.states || {};\n            var enables = states.enable || [];\n            var functions = states.functions || {};\n            var enableCullFace = false;\n            var enableDepthTest = false;\n            var enableBlend = false;\n\n            for (var i = 0, il = enables.length; i < il; i++) {\n              var enable = enables[i];\n\n              switch (STATES_ENABLES[enable]) {\n                case 'CULL_FACE':\n                  enableCullFace = true;\n                  break;\n\n                case 'DEPTH_TEST':\n                  enableDepthTest = true;\n                  break;\n\n                case 'BLEND':\n                  enableBlend = true;\n                  break;\n                // TODO: implement\n\n                case 'SCISSOR_TEST':\n                case 'POLYGON_OFFSET_FILL':\n                case 'SAMPLE_ALPHA_TO_COVERAGE':\n                  break;\n\n                default:\n                  throw new Error(\"Unknown technique.states.enable: \" + enable);\n              }\n            }\n\n            if (enableCullFace) {\n              materialParams.side = functions.cullFace !== undefined ? WEBGL_SIDES[functions.cullFace] : THREE.FrontSide;\n            } else {\n              materialParams.side = THREE.DoubleSide;\n            }\n\n            materialParams.depthTest = enableDepthTest;\n            materialParams.depthFunc = functions.depthFunc !== undefined ? WEBGL_DEPTH_FUNCS[functions.depthFunc] : THREE.LessDepth;\n            materialParams.depthWrite = functions.depthMask !== undefined ? functions.depthMask[0] : true;\n            materialParams.blending = enableBlend ? THREE.CustomBlending : THREE.NoBlending;\n            materialParams.transparent = enableBlend;\n            var blendEquationSeparate = functions.blendEquationSeparate;\n\n            if (blendEquationSeparate !== undefined) {\n              materialParams.blendEquation = WEBGL_BLEND_EQUATIONS[blendEquationSeparate[0]];\n              materialParams.blendEquationAlpha = WEBGL_BLEND_EQUATIONS[blendEquationSeparate[1]];\n            } else {\n              materialParams.blendEquation = THREE.AddEquation;\n              materialParams.blendEquationAlpha = THREE.AddEquation;\n            }\n\n            var blendFuncSeparate = functions.blendFuncSeparate;\n\n            if (blendFuncSeparate !== undefined) {\n              materialParams.blendSrc = WEBGL_BLEND_FUNCS[blendFuncSeparate[0]];\n              materialParams.blendDst = WEBGL_BLEND_FUNCS[blendFuncSeparate[1]];\n              materialParams.blendSrcAlpha = WEBGL_BLEND_FUNCS[blendFuncSeparate[2]];\n              materialParams.blendDstAlpha = WEBGL_BLEND_FUNCS[blendFuncSeparate[3]];\n            } else {\n              materialParams.blendSrc = THREE.OneFactor;\n              materialParams.blendDst = THREE.ZeroFactor;\n              materialParams.blendSrcAlpha = THREE.OneFactor;\n              materialParams.blendDstAlpha = THREE.ZeroFactor;\n            }\n          }\n        }\n\n        if (Array.isArray(materialValues.diffuse)) {\n          materialParams.color = new THREE.Color().fromArray(materialValues.diffuse);\n        } else if (typeof materialValues.diffuse === 'string') {\n          materialParams.map = dependencies.textures[materialValues.diffuse];\n        }\n\n        delete materialParams.diffuse;\n\n        if (typeof materialValues.reflective === 'string') {\n          materialParams.envMap = dependencies.textures[materialValues.reflective];\n        }\n\n        if (typeof materialValues.bump === 'string') {\n          materialParams.bumpMap = dependencies.textures[materialValues.bump];\n        }\n\n        if (Array.isArray(materialValues.emission)) {\n          if (materialType === THREE.MeshBasicMaterial) {\n            materialParams.color = new THREE.Color().fromArray(materialValues.emission);\n          } else {\n            materialParams.emissive = new THREE.Color().fromArray(materialValues.emission);\n          }\n        } else if (typeof materialValues.emission === 'string') {\n          if (materialType === THREE.MeshBasicMaterial) {\n            materialParams.map = dependencies.textures[materialValues.emission];\n          } else {\n            materialParams.emissiveMap = dependencies.textures[materialValues.emission];\n          }\n        }\n\n        if (Array.isArray(materialValues.specular)) {\n          materialParams.specular = new THREE.Color().fromArray(materialValues.specular);\n        } else if (typeof materialValues.specular === 'string') {\n          materialParams.specularMap = dependencies.textures[materialValues.specular];\n        }\n\n        if (materialValues.shininess !== undefined) {\n          materialParams.shininess = materialValues.shininess;\n        }\n\n        var _material = new materialType(materialParams);\n\n        if (material.name !== undefined) _material.name = material.name;\n        return _material;\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadMeshes = function () {\n    var json = this.json;\n    return this._withDependencies([\"accessors\", \"materials\"]).then(function (dependencies) {\n      return _each(json.meshes, function (mesh) {\n        var group = new THREE.Group();\n        if (mesh.name !== undefined) group.name = mesh.name;\n        if (mesh.extras) group.userData = mesh.extras;\n        var primitives = mesh.primitives || [];\n\n        for (var name in primitives) {\n          var primitive = primitives[name];\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === undefined) {\n            var geometry = new THREE.BufferGeometry();\n            var attributes = primitive.attributes;\n\n            for (var attributeId in attributes) {\n              var attributeEntry = attributes[attributeId];\n              if (!attributeEntry) return;\n              var bufferAttribute = dependencies.accessors[attributeEntry];\n\n              switch (attributeId) {\n                case 'POSITION':\n                  geometry.setAttribute('position', bufferAttribute);\n                  break;\n\n                case 'NORMAL':\n                  geometry.setAttribute('normal', bufferAttribute);\n                  break;\n\n                case 'TEXCOORD_0':\n                case 'TEXCOORD0':\n                case 'TEXCOORD':\n                  geometry.setAttribute('uv', bufferAttribute);\n                  break;\n\n                case 'TEXCOORD_1':\n                  geometry.setAttribute('uv2', bufferAttribute);\n                  break;\n\n                case 'COLOR_0':\n                case 'COLOR0':\n                case 'COLOR':\n                  geometry.setAttribute('color', bufferAttribute);\n                  break;\n\n                case 'WEIGHT':\n                  geometry.setAttribute('skinWeight', bufferAttribute);\n                  break;\n\n                case 'JOINT':\n                  geometry.setAttribute('skinIndex', bufferAttribute);\n                  break;\n\n                default:\n                  if (!primitive.material) break;\n                  var material = json.materials[primitive.material];\n                  if (!material.technique) break;\n                  var parameters = json.techniques[material.technique].parameters || {};\n\n                  for (var attributeName in parameters) {\n                    if (parameters[attributeName]['semantic'] === attributeId) {\n                      geometry.setAttribute(attributeName, bufferAttribute);\n                    }\n                  }\n\n              }\n            }\n\n            if (primitive.indices) {\n              geometry.setIndex(dependencies.accessors[primitive.indices]);\n            }\n\n            var material = dependencies.materials !== undefined ? dependencies.materials[primitive.material] : createDefaultMaterial();\n            var meshNode = new THREE.Mesh(geometry, material);\n            meshNode.castShadow = true;\n            meshNode.name = name === \"0\" ? group.name : group.name + name;\n            if (primitive.extras) meshNode.userData = primitive.extras;\n            group.add(meshNode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n            var geometry = new THREE.BufferGeometry();\n            var attributes = primitive.attributes;\n\n            for (var attributeId in attributes) {\n              var attributeEntry = attributes[attributeId];\n              if (!attributeEntry) return;\n              var bufferAttribute = dependencies.accessors[attributeEntry];\n\n              switch (attributeId) {\n                case 'POSITION':\n                  geometry.setAttribute('position', bufferAttribute);\n                  break;\n\n                case 'COLOR_0':\n                case 'COLOR0':\n                case 'COLOR':\n                  geometry.setAttribute('color', bufferAttribute);\n                  break;\n              }\n            }\n\n            var material = dependencies.materials[primitive.material];\n            var meshNode;\n\n            if (primitive.indices) {\n              geometry.setIndex(dependencies.accessors[primitive.indices]);\n              meshNode = new THREE.LineSegments(geometry, material);\n            } else {\n              meshNode = new THREE.Line(geometry, material);\n            }\n\n            meshNode.name = name === \"0\" ? group.name : group.name + name;\n            if (primitive.extras) meshNode.userData = primitive.extras;\n            group.add(meshNode);\n          } else {\n            console.warn(\"Only triangular and line primitives are supported\");\n          }\n        }\n\n        return group;\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadCameras = function () {\n    var json = this.json;\n    return _each(json.cameras, function (camera) {\n      if (camera.type == \"perspective\" && camera.perspective) {\n        var yfov = camera.perspective.yfov;\n        var aspectRatio = camera.perspective.aspectRatio !== undefined ? camera.perspective.aspectRatio : 1; // According to COLLADA spec...\n        // aspectRatio = xfov / yfov\n\n        var _camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(yfov * aspectRatio), aspectRatio, camera.perspective.znear || 1, camera.perspective.zfar || 2e6);\n\n        if (camera.name !== undefined) _camera.name = camera.name;\n        if (camera.extras) _camera.userData = camera.extras;\n        return _camera;\n      } else if (camera.type == \"orthographic\" && camera.orthographic) {\n        var _camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, camera.orthographic.znear, camera.orthographic.zfar);\n\n        if (camera.name !== undefined) _camera.name = camera.name;\n        if (camera.extras) _camera.userData = camera.extras;\n        return _camera;\n      }\n    });\n  };\n\n  GLTFParser.prototype.loadSkins = function () {\n    var json = this.json;\n    return this._withDependencies([\"accessors\"]).then(function (dependencies) {\n      return _each(json.skins, function (skin) {\n        var bindShapeMatrix = new THREE.Matrix4();\n        if (skin.bindShapeMatrix !== undefined) bindShapeMatrix.fromArray(skin.bindShapeMatrix);\n        var _skin = {\n          bindShapeMatrix: bindShapeMatrix,\n          jointNames: skin.jointNames,\n          inverseBindMatrices: dependencies.accessors[skin.inverseBindMatrices]\n        };\n        return _skin;\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadAnimations = function () {\n    var json = this.json;\n    return this._withDependencies([\"accessors\", \"nodes\"]).then(function (dependencies) {\n      return _each(json.animations, function (animation, animationId) {\n        var tracks = [];\n\n        for (var channelId in animation.channels) {\n          var channel = animation.channels[channelId];\n          var sampler = animation.samplers[channel.sampler];\n\n          if (sampler) {\n            var target = channel.target;\n            var name = target.id;\n            var input = animation.parameters !== undefined ? animation.parameters[sampler.input] : sampler.input;\n            var output = animation.parameters !== undefined ? animation.parameters[sampler.output] : sampler.output;\n            var inputAccessor = dependencies.accessors[input];\n            var outputAccessor = dependencies.accessors[output];\n            var node = dependencies.nodes[name];\n\n            if (node) {\n              node.updateMatrix();\n              node.matrixAutoUpdate = true;\n              var TypedKeyframeTrack = PATH_PROPERTIES[target.path] === PATH_PROPERTIES.rotation ? THREE.QuaternionKeyframeTrack : THREE.VectorKeyframeTrack;\n              var targetName = node.name ? node.name : node.uuid;\n              var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear; // KeyframeTrack.optimize() will modify given 'times' and 'values'\n              // buffers before creating a truncated copy to keep. Because buffers may\n              // be reused by other tracks, make copies here.\n\n              tracks.push(new TypedKeyframeTrack(targetName + '.' + PATH_PROPERTIES[target.path], THREE.AnimationUtils.arraySlice(inputAccessor.array, 0), THREE.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation));\n            }\n          }\n        }\n\n        var name = animation.name !== undefined ? animation.name : \"animation_\" + animationId;\n        return new THREE.AnimationClip(name, undefined, tracks);\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadNodes = function () {\n    var json = this.json;\n    var extensions = this.extensions;\n    var scope = this;\n    return _each(json.nodes, function (node) {\n      var matrix = new THREE.Matrix4();\n\n      var _node;\n\n      if (node.jointName) {\n        _node = new THREE.Bone();\n        _node.name = node.name !== undefined ? node.name : node.jointName;\n        _node.jointName = node.jointName;\n      } else {\n        _node = new THREE.Object3D();\n        if (node.name !== undefined) _node.name = node.name;\n      }\n\n      if (node.extras) _node.userData = node.extras;\n\n      if (node.matrix !== undefined) {\n        matrix.fromArray(node.matrix);\n\n        _node.applyMatrix(matrix);\n      } else {\n        if (node.translation !== undefined) {\n          _node.position.fromArray(node.translation);\n        }\n\n        if (node.rotation !== undefined) {\n          _node.quaternion.fromArray(node.rotation);\n        }\n\n        if (node.scale !== undefined) {\n          _node.scale.fromArray(node.scale);\n        }\n      }\n\n      return _node;\n    }).then(function (__nodes) {\n      return scope._withDependencies([\"meshes\", \"skins\", \"cameras\"]).then(function (dependencies) {\n        return _each(__nodes, function (_node, nodeId) {\n          var node = json.nodes[nodeId];\n\n          if (node.meshes !== undefined) {\n            for (var meshId in node.meshes) {\n              var mesh = node.meshes[meshId];\n              var group = dependencies.meshes[mesh];\n\n              if (group === undefined) {\n                console.warn('LegacyGLTFLoader: Couldn\\'t find node \"' + mesh + '\".');\n                continue;\n              }\n\n              for (var childrenId in group.children) {\n                var child = group.children[childrenId]; // clone Mesh to add to _node\n\n                var originalMaterial = child.material;\n                var originalGeometry = child.geometry;\n                var originalUserData = child.userData;\n                var originalName = child.name;\n                var material;\n\n                if (originalMaterial.isDeferredShaderMaterial) {\n                  originalMaterial = material = originalMaterial.create();\n                } else {\n                  material = originalMaterial;\n                }\n\n                switch (child.type) {\n                  case 'LineSegments':\n                    child = new THREE.LineSegments(originalGeometry, material);\n                    break;\n\n                  case 'LineLoop':\n                    child = new THREE.LineLoop(originalGeometry, material);\n                    break;\n\n                  case 'Line':\n                    child = new THREE.Line(originalGeometry, material);\n                    break;\n\n                  default:\n                    child = new THREE.Mesh(originalGeometry, material);\n                }\n\n                child.castShadow = true;\n                child.userData = originalUserData;\n                child.name = originalName;\n                var skinEntry;\n\n                if (node.skin) {\n                  skinEntry = dependencies.skins[node.skin];\n                } // Replace Mesh with SkinnedMesh in library\n\n\n                if (skinEntry) {\n                  var getJointNode = function (jointId) {\n                    var keys = Object.keys(__nodes);\n\n                    for (var i = 0, il = keys.length; i < il; i++) {\n                      var n = __nodes[keys[i]];\n                      if (n.jointName === jointId) return n;\n                    }\n\n                    return null;\n                  };\n\n                  var material = originalMaterial;\n                  material.skinning = true;\n                  child = new THREE.SkinnedMesh(originalGeometry, material);\n                  child.castShadow = true;\n                  child.userData = originalUserData;\n                  child.name = originalName;\n                  var bones = [];\n                  var boneInverses = [];\n\n                  for (var i = 0, l = skinEntry.jointNames.length; i < l; i++) {\n                    var jointId = skinEntry.jointNames[i];\n                    var jointNode = getJointNode(jointId);\n\n                    if (jointNode) {\n                      bones.push(jointNode);\n                      var m = skinEntry.inverseBindMatrices.array;\n                      var mat = new THREE.Matrix4().fromArray(m, i * 16);\n                      boneInverses.push(mat);\n                    } else {\n                      console.warn(\"WARNING: joint: '\" + jointId + \"' could not be found\");\n                    }\n                  }\n\n                  child.bind(new THREE.Skeleton(bones, boneInverses), skinEntry.bindShapeMatrix);\n\n                  var buildBoneGraph = function (parentJson, parentObject, property) {\n                    var children = parentJson[property];\n                    if (children === undefined) return;\n\n                    for (var i = 0, il = children.length; i < il; i++) {\n                      var nodeId = children[i];\n                      var bone = __nodes[nodeId];\n                      var boneJson = json.nodes[nodeId];\n\n                      if (bone !== undefined && bone.isBone === true && boneJson !== undefined) {\n                        parentObject.add(bone);\n                        buildBoneGraph(boneJson, bone, 'children');\n                      }\n                    }\n                  };\n\n                  buildBoneGraph(node, child, 'skeletons');\n                }\n\n                _node.add(child);\n              }\n            }\n          }\n\n          if (node.camera !== undefined) {\n            var camera = dependencies.cameras[node.camera];\n\n            _node.add(camera);\n          }\n\n          if (node.extensions && node.extensions[EXTENSIONS.KHR_MATERIALS_COMMON] && node.extensions[EXTENSIONS.KHR_MATERIALS_COMMON].light) {\n            var extensionLights = extensions[EXTENSIONS.KHR_MATERIALS_COMMON].lights;\n            var light = extensionLights[node.extensions[EXTENSIONS.KHR_MATERIALS_COMMON].light];\n\n            _node.add(light);\n          }\n\n          return _node;\n        });\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadScenes = function () {\n    var json = this.json; // scene node hierachy builder\n\n    function buildNodeHierachy(nodeId, parentObject, allNodes) {\n      var _node = allNodes[nodeId];\n      parentObject.add(_node);\n      var node = json.nodes[nodeId];\n\n      if (node.children) {\n        var children = node.children;\n\n        for (var i = 0, l = children.length; i < l; i++) {\n          var child = children[i];\n          buildNodeHierachy(child, _node, allNodes);\n        }\n      }\n    }\n\n    return this._withDependencies([\"nodes\"]).then(function (dependencies) {\n      return _each(json.scenes, function (scene) {\n        var _scene = new THREE.Scene();\n\n        if (scene.name !== undefined) _scene.name = scene.name;\n        if (scene.extras) _scene.userData = scene.extras;\n        var nodes = scene.nodes || [];\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          var nodeId = nodes[i];\n          buildNodeHierachy(nodeId, _scene, dependencies.nodes);\n        }\n\n        _scene.traverse(function (child) {\n          // Register raw material meshes with LegacyGLTFLoader.Shaders\n          if (child.material && child.material.isRawShaderMaterial) {\n            child.gltfShader = new GLTFShader(child, dependencies.nodes);\n\n            child.onBeforeRender = function (renderer, scene, camera) {\n              this.gltfShader.update(scene, camera);\n            };\n          }\n        });\n\n        return _scene;\n      });\n    });\n  };\n\n  return LegacyGLTFLoader;\n}();\n\nvar _default = threeExamples.LegacyGLTFLoader;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Parser/deprecated/LegacyGLTFLoader.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Process/3dTilesProcessing.js":
/*!**************************************************************!*\
  !*** ./node_modules/itowns/lib/Process/3dTilesProcessing.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$3dTilesCulling = $3dTilesCulling;\nexports.pre3dTilesUpdate = pre3dTilesUpdate;\nexports.computeNodeSSE = computeNodeSSE;\nexports.init3dTilesLayer = init3dTilesLayer;\nexports.process3dTilesNode = process3dTilesNode;\nexports.$3dTilesSubdivisionControl = $3dTilesSubdivisionControl;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nfunction requestNewTile(view, scheduler, geometryLayer, metadata, parent, redraw) {\n  var command = {\n    /* mandatory */\n    view: view,\n    requester: parent,\n    layer: geometryLayer,\n    priority: parent ? 1.0 / (parent.distance + 1) : 100,\n\n    /* specific params */\n    metadata: metadata,\n    redraw: redraw\n  };\n  return scheduler.execute(command);\n}\n\nfunction getChildTiles(tile) {\n  // only keep children that have the same layer and a valid tileId\n  return tile.children.filter(function (n) {\n    return n.layer == tile.layer && n.tileId;\n  });\n}\n\nfunction subdivideNode(context, layer, node, cullingTest) {\n  if (node.additiveRefinement) {\n    // Additive refinement can only fetch visible children.\n    _subdivideNodeAdditive(context, layer, node, cullingTest);\n  } else {\n    // Substractive refinement on the other hand requires to replace\n    // node with all of its children\n    _subdivideNodeSubstractive(context, layer, node);\n  }\n}\n\nvar tmpBox3 = new THREE.Box3();\nvar tmpSphere = new THREE.Sphere();\n\nfunction boundingVolumeToExtent(crs, volume, transform) {\n  if (volume.region) {\n    var box = tmpBox3.copy(volume.region.box3D).applyMatrix4(volume.region.matrixWorld);\n    return _Extent[\"default\"].fromBox3(crs, box);\n  } else if (volume.box) {\n    var _box = tmpBox3.copy(volume.box).applyMatrix4(transform);\n\n    return _Extent[\"default\"].fromBox3(crs, _box);\n  } else {\n    var sphere = tmpSphere.copy(volume.sphere).applyMatrix4(transform);\n    return new _Extent[\"default\"](crs, {\n      west: sphere.center.x - sphere.radius,\n      east: sphere.center.x + sphere.radius,\n      south: sphere.center.y - sphere.radius,\n      north: sphere.center.y + sphere.radius\n    });\n  }\n}\n\nvar tmpMatrix = new THREE.Matrix4();\n\nfunction _subdivideNodeAdditive(context, layer, node, cullingTest) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    var _loop = function () {\n      var child = _step.value;\n\n      // child being downloaded => skip\n      if (child.promise || child.loaded) {\n        return \"continue\";\n      } // 'child' is only metadata (it's *not* a THREE.Object3D). 'cullingTest' needs\n      // a matrixWorld, so we compute it: it's node's matrixWorld x child's transform\n\n\n      var overrideMatrixWorld = node.matrixWorld;\n\n      if (child.transform) {\n        overrideMatrixWorld = tmpMatrix.multiplyMatrices(node.matrixWorld, child.transform);\n      }\n\n      var isVisible = cullingTest ? !cullingTest(context.camera, child, overrideMatrixWorld) : true; // child is not visible => skip\n\n      if (!isVisible) {\n        return \"continue\";\n      }\n\n      child.promise = requestNewTile(context.view, context.scheduler, layer, child, node, true).then(function (tile) {\n        node.add(tile);\n        tile.updateMatrixWorld();\n        var extent = boundingVolumeToExtent(layer.extent.crs, tile.boundingVolume, tile.matrixWorld);\n        tile.traverse(function (obj) {\n          obj.extent = extent;\n        });\n        context.view.notifyChange(child);\n        child.loaded = true;\n        delete child.promise;\n      });\n    };\n\n    for (var _iterator = layer.tileIndex.index[node.tileId].children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nfunction _subdivideNodeSubstractive(context, layer, node) {\n  if (!node.pendingSubdivision && getChildTiles(node).length == 0) {\n    var _ret2 = function () {\n      var childrenTiles = layer.tileIndex.index[node.tileId].children;\n\n      if (childrenTiles === undefined || childrenTiles.length === 0) {\n        return {\n          v: void 0\n        };\n      }\n\n      node.pendingSubdivision = true;\n      var promises = [];\n\n      var _loop2 = function (i) {\n        promises.push(requestNewTile(context.view, context.scheduler, layer, childrenTiles[i], node, false).then(function (tile) {\n          childrenTiles[i].loaded = true;\n          node.add(tile);\n          tile.updateMatrixWorld();\n\n          if (node.additiveRefinement) {\n            context.view.notifyChange(node);\n          }\n\n          layer.tileIndex.index[tile.tileId].loaded = true;\n        }));\n      };\n\n      for (var i = 0; i < childrenTiles.length; i++) {\n        _loop2(i);\n      }\n\n      Promise.all(promises).then(function () {\n        node.pendingSubdivision = false;\n        context.view.notifyChange(node);\n      });\n    }();\n\n    if ((0, _typeof2[\"default\"])(_ret2) === \"object\") return _ret2.v;\n  }\n}\n\nfunction $3dTilesCulling(camera, node, tileMatrixWorld) {\n  // For viewer Request Volume https://github.com/AnalyticalGraphicsInc/3d-tiles-samples/tree/master/tilesets/TilesetWithRequestVolume\n  if (node.viewerRequestVolume) {\n    var nodeViewer = node.viewerRequestVolume;\n\n    if (nodeViewer.region) {\n      // TODO\n      return true;\n    }\n\n    if (nodeViewer.box) {\n      // TODO\n      return true;\n    }\n\n    if (nodeViewer.sphere) {\n      var worldCoordinateCenter = nodeViewer.sphere.center.clone();\n      worldCoordinateCenter.applyMatrix4(tileMatrixWorld); // To check the distance between the center sphere and the camera\n\n      if (!(camera.camera3D.position.distanceTo(worldCoordinateCenter) <= nodeViewer.sphere.radius)) {\n        return true;\n      }\n    }\n  } // For bounding volume\n\n\n  if (node.boundingVolume) {\n    var boundingVolume = node.boundingVolume;\n\n    if (boundingVolume.region) {\n      return !camera.isBox3Visible(boundingVolume.region.box3D, tileMatrixWorld.clone().multiply(boundingVolume.region.matrix));\n    }\n\n    if (boundingVolume.box) {\n      return !camera.isBox3Visible(boundingVolume.box, tileMatrixWorld);\n    }\n\n    if (boundingVolume.sphere) {\n      return !camera.isSphereVisible(boundingVolume.sphere, tileMatrixWorld);\n    }\n  }\n\n  return false;\n} // Cleanup all 3dtiles|three.js starting from a given node n.\n// n's children can be of 2 types:\n//   - have a 'content' attribute -> it's a tileset and must\n//     be cleaned with cleanup3dTileset()\n//   - doesn't have 'content' -> it's a raw Object3D object,\n//     and must be cleaned with _cleanupObject3D()\n\n\nfunction cleanup3dTileset(layer, n) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // If this layer is not using additive refinement, we can only\n  // clean a tile if all its neighbours are cleaned as well because\n  // a tile can only be in 2 states:\n  //   - displayed and no children displayed\n  //   - hidden and all of its children displayed\n  // So here we implement a conservative measure: if T is cleanable\n  // we actually only clean its children tiles.\n  var canCleanCompletely = n.additiveRefinement || depth > 0;\n\n  for (var i = 0; i < n.children.length; i++) {\n    // skip non-tiles elements\n    if (!n.children[i].content) {\n      if (canCleanCompletely) {\n        n.children[i].traverse(_cleanupObject3D);\n      }\n    } else {\n      cleanup3dTileset(layer, n.children[i], depth + 1);\n    }\n  }\n\n  if (canCleanCompletely) {\n    if (n.dispose) {\n      n.dispose();\n    }\n\n    delete n.content;\n    layer.tileIndex.index[n.tileId].loaded = false;\n    n.remove.apply(n, (0, _toConsumableArray2[\"default\"])(n.children)); // and finally remove from parent\n\n    if (depth == 0 && n.parent) {\n      n.parent.remove(n);\n    }\n  } else {\n    var tiles = getChildTiles(n);\n    n.remove.apply(n, (0, _toConsumableArray2[\"default\"])(tiles));\n  }\n} // This function is used to cleanup a Object3D hierarchy.\n// (no 3dtiles spectific code here because this is managed by cleanup3dTileset)\n\n\nfunction _cleanupObject3D(n) {\n  // all children of 'n' are raw Object3D\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = n.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var child = _step2.value;\n\n      _cleanupObject3D(child);\n    } // free resources\n\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  if (n.material) {\n    // material can be either a THREE.Material object, or an array of\n    // THREE.Material objects\n    if (Array.isArray(n.material)) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = n.material[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var material = _step3.value;\n          material.dispose();\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    } else {\n      n.material.dispose();\n    }\n  }\n\n  if (n.geometry) {\n    n.geometry.dispose();\n  }\n\n  n.remove.apply(n, (0, _toConsumableArray2[\"default\"])(n.children));\n} // this is a layer\n\n\nfunction pre3dTilesUpdate() {\n  if (!this.visible) {\n    return [];\n  } // Elements removed are added in the layer._cleanableTiles list.\n  // Since we simply push in this array, the first item is always\n  // the oldest one.\n\n\n  var now = Date.now();\n\n  if (this._cleanableTiles.length && now - this._cleanableTiles[0].cleanableSince > this.cleanupDelay) {\n    // Make sure we don't clean root tile\n    this.root.cleanableSince = undefined;\n    var i = 0;\n\n    for (; i < this._cleanableTiles.length; i++) {\n      var elt = this._cleanableTiles[i];\n\n      if (now - elt.cleanableSince > this.cleanupDelay) {\n        cleanup3dTileset(this, elt);\n      } else {\n        // later entries are younger\n        break;\n      }\n    } // remove deleted elements from _cleanableTiles\n\n\n    this._cleanableTiles.splice(0, i);\n  }\n\n  return [this.root];\n}\n\nvar boundingVolumeBox = new THREE.Box3();\nvar boundingVolumeSphere = new THREE.Sphere();\n\nfunction computeNodeSSE(camera, node) {\n  node.distance = 0;\n\n  if (node.boundingVolume.region) {\n    boundingVolumeBox.copy(node.boundingVolume.region.box3D);\n    boundingVolumeBox.applyMatrix4(node.boundingVolume.region.matrixWorld);\n    node.distance = boundingVolumeBox.distanceToPoint(camera.camera3D.position);\n  } else if (node.boundingVolume.box) {\n    // boundingVolume.box is affected by matrixWorld\n    boundingVolumeBox.copy(node.boundingVolume.box);\n    boundingVolumeBox.applyMatrix4(node.matrixWorld);\n    node.distance = boundingVolumeBox.distanceToPoint(camera.camera3D.position);\n  } else if (node.boundingVolume.sphere) {\n    // boundingVolume.sphere is affected by matrixWorld\n    boundingVolumeSphere.copy(node.boundingVolume.sphere);\n    boundingVolumeSphere.applyMatrix4(node.matrixWorld); // TODO: see https://github.com/iTowns/itowns/issues/800\n\n    node.distance = Math.max(0.0, boundingVolumeSphere.distanceToPoint(camera.camera3D.position));\n  } else {\n    return Infinity;\n  }\n\n  if (node.distance === 0) {\n    // This test is needed in case geometricError = distance = 0\n    return Infinity;\n  }\n\n  return camera._preSSE * (node.geometricError / node.distance);\n}\n\nfunction init3dTilesLayer(view, scheduler, layer) {\n  return requestNewTile(view, scheduler, layer, layer.tileset.root, undefined, true).then(function (tile) {\n    delete layer.tileset;\n    layer.object3d.add(tile);\n    tile.updateMatrixWorld();\n    layer.tileIndex.index[tile.tileId].loaded = true;\n    layer.root = tile;\n    layer.extent = boundingVolumeToExtent(layer.projection || view.referenceCrs, tile.boundingVolume, tile.matrixWorld);\n  });\n}\n\nfunction setDisplayed(node, display) {\n  // The geometry of the tile is not in node, but in node.content\n  // To change the display state, we change node.content.visible instead of\n  // node.material.visible\n  if (node.content) {\n    node.content.visible = display;\n  }\n}\n\nfunction markForDeletion(layer, elt) {\n  if (!elt.cleanableSince) {\n    elt.cleanableSince = Date.now();\n\n    layer._cleanableTiles.push(elt);\n  }\n}\n\nfunction process3dTilesNode() {\n  var cullingTest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $3dTilesCulling;\n  var subdivisionTest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $3dTilesSubdivisionControl;\n  return function (context, layer, node) {\n    // early exit if parent's subdivision is in progress\n    if (node.parent.pendingSubdivision && !node.parent.additiveRefinement) {\n      node.visible = false;\n      return undefined;\n    } // do proper culling\n\n\n    var isVisible = cullingTest ? !cullingTest(context.camera, node, node.matrixWorld) : true;\n    node.visible = isVisible;\n\n    if (isVisible) {\n      if (node.cleanableSince) {\n        layer._cleanableTiles.splice(layer._cleanableTiles.indexOf(node), 1);\n\n        node.cleanableSince = undefined;\n      }\n\n      var returnValue;\n\n      if (node.pendingSubdivision || subdivisionTest(context, layer, node)) {\n        subdivideNode(context, layer, node, cullingTest); // display iff children aren't ready\n\n        setDisplayed(node, node.pendingSubdivision || node.additiveRefinement);\n        returnValue = getChildTiles(node);\n      } else {\n        setDisplayed(node, true);\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = getChildTiles(node)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var n = _step4.value;\n            n.visible = false;\n            markForDeletion(layer, n);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n              _iterator4[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      return returnValue;\n    }\n\n    markForDeletion(layer, node);\n  };\n}\n\nfunction $3dTilesSubdivisionControl(context, layer, node) {\n  if (layer.tileIndex.index[node.tileId].children === undefined) {\n    return false;\n  }\n\n  if (layer.tileIndex.index[node.tileId].isTileset) {\n    return true;\n  }\n\n  var sse = computeNodeSSE(context.camera, node);\n  return sse > layer.sseThreshold;\n}\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Process/3dTilesProcessing.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Process/FeatureProcessing.js":
/*!**************************************************************!*\
  !*** ./node_modules/itowns/lib/Process/FeatureProcessing.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _LayerUpdateState = _interopRequireDefault(__webpack_require__(/*! ../Layer/LayerUpdateState */ \"./node_modules/itowns/lib/Layer/LayerUpdateState.js\"));\n\nvar _ObjectRemovalHelper = _interopRequireDefault(__webpack_require__(/*! ./ObjectRemovalHelper */ \"./node_modules/itowns/lib/Process/ObjectRemovalHelper.js\"));\n\nvar _handlerNodeError = _interopRequireDefault(__webpack_require__(/*! ./handlerNodeError */ \"./node_modules/itowns/lib/Process/handlerNodeError.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar _extent = new _Extent[\"default\"]('EPSG:4326', 0, 0, 0, 0);\n\nvar coord = new _Coordinates[\"default\"]('EPSG:4326', 0, 0, 0);\nvar vector = new THREE.Vector3();\nvar tmp = new THREE.Vector3();\n\nfunction applyOffset(obj, offset, quaternion) {\n  var offsetAltitude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (obj.geometry) {\n    if (obj.geometry.isBufferGeometry) {\n      var count = obj.geometry.attributes.position.count * 3;\n\n      for (var i = 0; i < count; i += 3) {\n        vector.fromArray(obj.geometry.attributes.position.array, i);\n        vector.add(offset).applyQuaternion(quaternion);\n        vector.z -= offsetAltitude;\n        vector.toArray(obj.geometry.attributes.position.array, i);\n      }\n\n      obj.geometry.attributes.position.needsUpdate = true;\n    } else {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = obj.geometry.vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var v = _step.value;\n          v.add(offset).applyQuaternion(quaternion);\n          v.z -= offsetAltitude;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      obj.geometry.verticesNeedUpdate = true;\n    }\n  }\n\n  obj.children.forEach(function (c) {\n    return applyOffset(c, offset, quaternion, offsetAltitude);\n  });\n}\n\nfunction assignLayer(object, layer) {\n  if (object) {\n    object.layer = layer;\n\n    if (object.material) {\n      object.material.transparent = layer.opacity < 1.0;\n      object.material.opacity = layer.opacity;\n      object.material.wireframe = layer.wireframe;\n\n      if (layer.size) {\n        object.material.size = layer.size;\n      }\n\n      if (layer.linewidth) {\n        object.material.linewidth = layer.linewidth;\n      }\n    }\n\n    object.layers.set(layer.threejsLayer);\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = object.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var c = _step2.value;\n        assignLayer(c, layer);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return object;\n  }\n}\n\nfunction extentInsideSource(extent, source) {\n  return !source.extentInsideLimit(extent) || source.parsedData && !source.parsedData.extent.isPointInside(extent.center(coord));\n}\n\nvar quaternion = new THREE.Quaternion();\nvar _default = {\n  update: function update(context, layer, node) {\n    if (!node.parent && node.children.length) {\n      // if node has been removed dispose three.js resource\n      _ObjectRemovalHelper[\"default\"].removeChildrenAndCleanupRecursively(layer, node);\n\n      return;\n    }\n\n    if (!node.visible) {\n      return;\n    }\n\n    if (node.layerUpdateState[layer.id] === undefined) {\n      node.layerUpdateState[layer.id] = new _LayerUpdateState[\"default\"]();\n    }\n\n    if (!node.layerUpdateState[layer.id].canTryUpdate()) {\n      return;\n    }\n\n    var features = node.children.filter(function (n) {\n      return n.layer == layer;\n    });\n\n    if (features.length > 0) {\n      return features;\n    }\n\n    var extentsDestination = node.getExtentsByProjection(layer.source.projection) || [node.extent];\n    extentsDestination.forEach(function (e) {\n      e.zoom = node.level;\n    });\n    var extentsSource = [];\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = extentsDestination[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var extentDest = _step3.value;\n        var ext = layer.source.projection == extentDest.crs ? extentDest : extentDest.as(layer.source.projection);\n        ext.zoom = extentDest.zoom;\n\n        if (extentInsideSource(ext, layer.source)) {\n          node.layerUpdateState[layer.id].noMoreUpdatePossible();\n          return;\n        }\n\n        extentsSource.push(extentDest);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n          _iterator3[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    node.layerUpdateState[layer.id].newTry();\n    var command = {\n      layer: layer,\n      extentsSource: extentsSource,\n      view: context.view,\n      threejsLayer: layer.threejsLayer,\n      requester: node\n    };\n    return context.scheduler.execute(command).then(function (result) {\n      // if request return empty json, WFSProvider.getFeatures return undefined\n      result = result[0];\n\n      if (result) {\n        // special case for FileSource, as it is not tiled and we need\n        // to attach it to the correct node\n        if (layer.source && layer.source.isFileSource) {\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = extentsSource[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var extentSrc = _step4.value;\n              var ext = extentSrc.crs == layer.source.projection ? extentSrc : extentSrc.as(layer.source.projection, _extent);\n              ext.zoom = extentSrc.zoom;\n\n              if (extentInsideSource(ext, layer.source)) {\n                node.layerUpdateState[layer.id].noMoreUpdatePossible();\n                return;\n              }\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n                _iterator4[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n\n        var isApplied = !result.layer;\n        result.minAltitude = isNaN(result.minAltitude) ? 0 : result.minAltitude;\n        assignLayer(result, layer); // call onMeshCreated callback if needed\n\n        if (layer.onMeshCreated) {\n          layer.onMeshCreated(result);\n        }\n\n        node.layerUpdateState[layer.id].success();\n\n        if (!node.parent) {\n          _ObjectRemovalHelper[\"default\"].removeChildrenAndCleanupRecursively(layer, result);\n\n          return;\n        } // We don't use node.matrixWorld here, because feature coordinates are\n        // expressed in crs coordinates (which may be different than world coordinates,\n        // if node's layer is attached to an Object with a non-identity transformation)\n\n\n        if (isApplied) {\n          // NOTE: now data source provider use cache on Mesh\n          // TODO move transform in feature2Mesh\n          node.extent.center(coord).as(context.view.referenceCrs, coord).toVector3(tmp).negate();\n          quaternion.setFromRotationMatrix(node.matrixWorld).inverse(); // const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), node.extent.center().geodesicNormal).inverse();\n\n          applyOffset(result, tmp, quaternion, result.minAltitude);\n        }\n\n        if (result.minAltitude) {\n          result.position.z = result.minAltitude;\n        }\n\n        result.layer = layer;\n        node.add(result);\n        node.updateMatrixWorld();\n      } else {\n        node.layerUpdateState[layer.id].failure(1, true);\n      }\n    }, function (err) {\n      return (0, _handlerNodeError[\"default\"])(err, node, layer, node.level, context.view);\n    });\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Process/FeatureProcessing.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Process/LayeredMaterialNodeProcessing.js":
/*!**************************************************************************!*\
  !*** ./node_modules/itowns/lib/Process/LayeredMaterialNodeProcessing.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateLayeredMaterialNodeImagery = updateLayeredMaterialNodeImagery;\nexports.updateLayeredMaterialNodeElevation = updateLayeredMaterialNodeElevation;\nexports.removeLayeredMaterialNodeLayer = removeLayeredMaterialNodeLayer;\nexports.SIZE_DIAGONAL_TEXTURE = exports.SIZE_TEXTURE_TILE = void 0;\n\nvar _LayerUpdateStrategy = __webpack_require__(/*! ../Layer/LayerUpdateStrategy */ \"./node_modules/itowns/lib/Layer/LayerUpdateStrategy.js\");\n\nvar _LayerUpdateState = _interopRequireDefault(__webpack_require__(/*! ../Layer/LayerUpdateState */ \"./node_modules/itowns/lib/Layer/LayerUpdateState.js\"));\n\nvar _XbilParser = __webpack_require__(/*! ../Parser/XbilParser */ \"./node_modules/itowns/lib/Parser/XbilParser.js\");\n\nvar _handlerNodeError = _interopRequireDefault(__webpack_require__(/*! ./handlerNodeError */ \"./node_modules/itowns/lib/Process/handlerNodeError.js\"));\n\nvar SIZE_TEXTURE_TILE = 256;\nexports.SIZE_TEXTURE_TILE = SIZE_TEXTURE_TILE;\nvar SIZE_DIAGONAL_TEXTURE = Math.pow(2 * (SIZE_TEXTURE_TILE * SIZE_TEXTURE_TILE), 0.5);\nexports.SIZE_DIAGONAL_TEXTURE = SIZE_DIAGONAL_TEXTURE;\n\nfunction materialCommandQueuePriorityFunction(material) {\n  // We know that 'node' is visible because commands can only be\n  // issued for visible nodes.\n  // TODO: need priorization of displayed nodes\n  // Then prefer displayed node over non-displayed one\n  return material.visible ? 100 : 10;\n}\n\nfunction refinementCommandCancellationFn(cmd) {\n  if (!cmd.requester.parent || !cmd.requester.material) {\n    return true;\n  } // Cancel the command if the tile already has a better texture.\n  // This is only needed for elevation layers, because we may have several\n  // concurrent layers but we can only use one texture.\n\n\n  if (cmd.layer.isElevationLayer && cmd.requester.material.getElevationLayer() && cmd.targetLevel <= cmd.requester.material.getElevationLayer().level) {\n    return true;\n  }\n\n  return !cmd.requester.material.visible;\n}\n\nfunction buildCommand(view, layer, extentsSource, extentsDestination, requester, parsedData) {\n  return {\n    view: view,\n    layer: layer,\n    extentsSource: extentsSource,\n    extentsDestination: extentsDestination,\n    requester: requester,\n    parsedData: parsedData,\n    priority: materialCommandQueuePriorityFunction(requester.material),\n    earlyDropFunction: refinementCommandCancellationFn\n  };\n}\n\nfunction updateLayeredMaterialNodeImagery(context, layer, node, parent) {\n  var material = node.material;\n\n  if (!parent || !material) {\n    return;\n  }\n\n  var extentsDestination = node.getExtentsByProjection(layer.projection);\n  var nodeLayer = material.getLayer(layer.id); // Initialisation\n\n  if (node.layerUpdateState[layer.id] === undefined) {\n    node.layerUpdateState[layer.id] = new _LayerUpdateState[\"default\"]();\n\n    if (!layer.source.extentsInsideLimit(extentsDestination)) {\n      // we also need to check that tile's parent doesn't have a texture for this layer,\n      // because even if this tile is outside of the layer, it could inherit it's\n      // parent texture\n      if (!(!layer.noTextureParentOutsideLimit && parent.material && parent.material.getLayer && parent.material.getLayer(layer.id))) {\n        node.layerUpdateState[layer.id].noMoreUpdatePossible();\n        return;\n      }\n    }\n\n    if (!nodeLayer) {\n      // Create new MaterialLayer\n      nodeLayer = material.addLayer(layer); // Init the new MaterialLayer by parent\n\n      var parentLayer = parent.material && parent.material.getLayer(layer.id);\n      nodeLayer.initFromParent(parentLayer, extentsDestination);\n    } // Proposed new process, two separate processes:\n    //      * FIRST PASS: initNodeXXXFromParent and get out of the function\n    //      * SECOND PASS: Fetch best texture\n    // The two-step allows you to filter out unnecessary requests\n    // Indeed in the second pass, their state (not visible or not displayed) can block them to fetch\n\n\n    if (nodeLayer.level >= layer.source.zoom.min) {\n      context.view.notifyChange(node, false);\n      return;\n    }\n  } // Node is hidden, no need to update it\n\n\n  if (!material.visible) {\n    return;\n  } // TODO: move this to defineLayerProperty() declaration\n  // to avoid mixing layer's network updates and layer's params\n  // Update material parameters\n\n\n  if (nodeLayer) {\n    nodeLayer.visible = layer.visible;\n    nodeLayer.opacity = layer.opacity;\n  } // An update is pending / or impossible -> abort\n\n\n  if (!layer.visible || !node.layerUpdateState[layer.id].canTryUpdate()) {\n    return;\n  }\n\n  if (nodeLayer.level >= extentsDestination[0].zoom) {\n    // default decision method\n    node.layerUpdateState[layer.id].noMoreUpdatePossible();\n    return;\n  } // is fetching data from this layer disabled?\n\n\n  if (layer.frozen) {\n    return;\n  }\n\n  var failureParams = node.layerUpdateState[layer.id].failureParams;\n  var destinationLevel = extentsDestination[0].zoom || node.level;\n  var targetLevel = (0, _LayerUpdateStrategy.chooseNextLevelToFetch)(layer.updateStrategy.type, node, destinationLevel, nodeLayer.level, layer, failureParams);\n\n  if (targetLevel <= nodeLayer.level || targetLevel > destinationLevel) {\n    return;\n  } // Get equivalent of extent destination in source\n\n\n  var extentsSource = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = extentsDestination[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var extentDestination = _step.value;\n      var extentSource = extentDestination.tiledExtentParent(targetLevel);\n\n      if (!layer.source.extentInsideLimit(extentSource)) {\n        // Retry extentInsideLimit because you must check with the targetLevel\n        // if the first test extentInsideLimit returns that it is out of limits\n        // and the node inherits from its parent, then it'll still make a command to fetch texture.\n        node.layerUpdateState[layer.id].noMoreUpdatePossible();\n        return;\n      }\n\n      extentsSource.push(extentSource);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  node.layerUpdateState[layer.id].newTry();\n  var parsedData = nodeLayer.textures.map(function (t) {\n    return t.parsedData;\n  });\n  var command = buildCommand(context.view, layer, extentsSource, extentsDestination, node, parsedData);\n  return context.scheduler.execute(command).then(function (result) {\n    // TODO: Handle error : result is undefined in provider. throw error\n    var pitchs = extentsDestination.map(function (ext, i) {\n      return ext.offsetToParent(result[i].extent, nodeLayer.offsetScales[i]);\n    });\n    nodeLayer.setTextures(result, pitchs);\n    node.layerUpdateState[layer.id].success();\n  }, function (err) {\n    return (0, _handlerNodeError[\"default\"])(err, node, layer, targetLevel, context.view);\n  });\n}\n\nfunction updateLayeredMaterialNodeElevation(context, layer, node, parent) {\n  var material = node.material;\n\n  if (!parent || !material) {\n    return;\n  } // TODO: we need either\n  //  - compound or exclusive layers\n  //  - support for multiple elevation layers\n  // Elevation is currently handled differently from color layers.\n  // This is caused by a LayeredMaterial limitation: only 1 elevation texture\n  // can be used (where a tile can have N textures x M layers)\n\n\n  var extentsDestination = node.getExtentsByProjection(layer.projection); // Init elevation layer, and inherit from parent if possible\n\n  var nodeLayer = material.getElevationLayer();\n\n  if (!nodeLayer) {\n    nodeLayer = material.addLayer(layer);\n  }\n\n  if (node.layerUpdateState[layer.id] === undefined) {\n    node.layerUpdateState[layer.id] = new _LayerUpdateState[\"default\"]();\n    var parentLayer = parent.material && parent.material.getLayer(layer.id);\n    nodeLayer.initFromParent(parentLayer, extentsDestination); // If the texture resolution has a poor precision for this node, we don't\n    // extract min-max from the texture (too few information), we instead chose\n    // to use parent's min-max.\n\n    var useMinMaxFromParent = extentsDestination[0].zoom - nodeLayer.zoom > 6;\n\n    if (nodeLayer.textures[0]) {\n      if (!useMinMaxFromParent) {\n        var _computeMinMaxElevati = (0, _XbilParser.computeMinMaxElevation)(nodeLayer.textures[0].image.data, SIZE_TEXTURE_TILE, SIZE_TEXTURE_TILE, nodeLayer.offsetScales[0]),\n            min = _computeMinMaxElevati.min,\n            max = _computeMinMaxElevati.max;\n\n        node.setBBoxZ(min, max, layer.scale);\n      }\n    }\n\n    if (nodeLayer.level >= layer.source.zoom.min) {\n      context.view.notifyChange(node, false);\n      return;\n    }\n  } // Possible conditions to *not* update the elevation texture\n\n\n  if (layer.frozen || !material.visible || !node.layerUpdateState[layer.id].canTryUpdate()) {\n    return;\n  }\n\n  var targetLevel = (0, _LayerUpdateStrategy.chooseNextLevelToFetch)(layer.updateStrategy.type, node, extentsDestination[0].zoom, nodeLayer.level, layer);\n\n  if (targetLevel <= nodeLayer.level || targetLevel > extentsDestination[0].zoom) {\n    node.layerUpdateState[layer.id].noMoreUpdatePossible();\n    return Promise.resolve();\n  }\n\n  var extentsSource = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = extentsDestination[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var nodeExtent = _step2.value;\n      var extentSource = nodeExtent.tiledExtentParent(targetLevel);\n\n      if (!layer.source.extentInsideLimit(extentSource)) {\n        node.layerUpdateState[layer.id].noMoreUpdatePossible();\n        return;\n      }\n\n      extentsSource.push(extentSource);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  node.layerUpdateState[layer.id].newTry();\n  var command = buildCommand(context.view, layer, extentsSource, extentsDestination, node);\n  return context.scheduler.execute(command).then(function (textures) {\n    // Do not apply the new texture if its level is < than the current\n    // one.  This is only needed for elevation layers, because we may\n    // have several concurrent layers but we can only use one texture.\n    if (targetLevel <= nodeLayer.level) {\n      node.layerUpdateState[layer.id].noMoreUpdatePossible();\n      return;\n    }\n\n    var elevation = {\n      texture: textures[0],\n      pitch: extentsDestination[0].offsetToParent(textures[0].extent, nodeLayer.offsetScales[0])\n    };\n    node.layerUpdateState[layer.id].success();\n\n    if (elevation.texture) {\n      if (layer.useColorTextureElevation) {\n        elevation.min = layer.colorTextureElevationMinZ;\n        elevation.max = layer.colorTextureElevationMaxZ;\n      } else {\n        var _computeMinMaxElevati2 = (0, _XbilParser.computeMinMaxElevation)(elevation.texture.image.data, SIZE_TEXTURE_TILE, SIZE_TEXTURE_TILE, elevation.pitch),\n            _min = _computeMinMaxElevati2.min,\n            _max = _computeMinMaxElevati2.max;\n\n        elevation.min = !_min ? 0 : _min;\n        elevation.max = !_max ? 0 : _max;\n      }\n    }\n\n    node.setBBoxZ(elevation.min, elevation.max, layer.scale);\n    nodeLayer.setTexture(0, elevation.texture, elevation.pitch);\n    var nodeParent = parent.material && parent.material.getElevationLayer();\n    nodeLayer.replaceNoDataValueFromParent(nodeParent, layer.noDataValue);\n  }, function (err) {\n    return (0, _handlerNodeError[\"default\"])(err, node, layer, targetLevel, context.view);\n  });\n}\n\nfunction removeLayeredMaterialNodeLayer(layerId) {\n  return function (node) {\n    if (node.material && node.material.removeLayer) {\n      node.material.removeLayer(layerId);\n\n      if (node.material.elevationLayerIds[0] == layerId) {\n        node.setBBoxZ(0, 0);\n      }\n    }\n\n    if (node.layerUpdateState && node.layerUpdateState[layerId]) {\n      delete node.layerUpdateState[layerId];\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Process/LayeredMaterialNodeProcessing.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Process/ObjectRemovalHelper.js":
/*!****************************************************************!*\
  !*** ./node_modules/itowns/lib/Process/ObjectRemovalHelper.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\n\nvar _default = {\n  /**\n   * Cleanup obj to release three.js allocated resources\n   * @param {Object3D} obj object to release\n   */\n  cleanup: function cleanup(obj) {\n    obj.layer = null;\n\n    if (typeof obj.dispose === 'function') {\n      obj.dispose();\n    } else {\n      if (obj.geometry) {\n        obj.geometry.dispose(); // the Object Removal Helper causes inconsistencies\n        // when it assigns null to a geometry present in the Cache.\n        // Actually, the cache can provide a mesh whose geometry is null.\n        // see https://github.com/iTowns/itowns/issues/869\n        // obj.geometry = null;\n      }\n\n      if (obj.material) {\n        if (Array.isArray(obj.material)) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = obj.material[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var material = _step.value;\n              material.dispose();\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        } else {\n          obj.material.dispose();\n        } // obj.material = null;\n\n      }\n    }\n  },\n\n  /**\n   * Remove obj's children belonging to a layer.\n   * Neither obj nor its children will be disposed!\n   * @param {Layer} layer The layer that objects must belong to. Other object are ignored\n   * @param {Object3D} obj The Object3D we want to clean\n   * @return {Array} an array of removed Object3D from obj (not including the recursive removals)\n   */\n  removeChildren: function removeChildren(layer, obj) {\n    var toRemove = obj.children.filter(function (c) {\n      return c.layer === layer;\n    });\n    obj.remove.apply(obj, (0, _toConsumableArray2[\"default\"])(toRemove));\n    return toRemove;\n  },\n\n  /**\n   * Remove obj's children belonging to a layer and cleanup objexts.\n   * obj will be disposed but its children **won't**!\n   * @param {Layer} layer The layer that objects must belong to. Other object are ignored\n   * @param {Object3D} obj The Object3D we want to clean\n   * @return {Array} an array of removed Object3D from obj (not including the recursive removals)\n   */\n  removeChildrenAndCleanup: function removeChildrenAndCleanup(layer, obj) {\n    var toRemove = obj.children.filter(function (c) {\n      return c.layer === layer;\n    });\n    obj.remove.apply(obj, (0, _toConsumableArray2[\"default\"])(toRemove));\n\n    if (obj.layer === layer) {\n      this.cleanup(obj);\n    }\n\n    return toRemove;\n  },\n\n  /**\n   * Recursively remove obj's children belonging to a layer.\n   * All removed obj will have their geometry/material disposed.\n   * @param {Layer} layer The layer that objects must belong to. Other object are ignored\n   * @param {Object3D} obj The Object3D we want to clean\n   * @return {Array} an array of removed Object3D from obj (not including the recursive removals)\n   */\n  removeChildrenAndCleanupRecursively: function removeChildrenAndCleanupRecursively(layer, obj) {\n    var toRemove = obj.children.filter(function (c) {\n      return c.layer === layer;\n    });\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = toRemove[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var c = _step2.value;\n        this.removeChildrenAndCleanupRecursively(layer, c);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    obj.remove.apply(obj, (0, _toConsumableArray2[\"default\"])(toRemove));\n\n    if (obj.layer === layer) {\n      this.cleanup(obj);\n    }\n\n    return toRemove;\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Process/ObjectRemovalHelper.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Process/PointCloudProcessing.js":
/*!*****************************************************************!*\
  !*** ./node_modules/itowns/lib/Process/PointCloudProcessing.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _CancelledCommandException = _interopRequireDefault(__webpack_require__(/*! ../Core/Scheduler/CancelledCommandException */ \"./node_modules/itowns/lib/Core/Scheduler/CancelledCommandException.js\"));\n\nvar point = new THREE.Vector3(); // Draw a cube with lines (12 lines).\n\nfunction cube(size) {\n  var h = size.clone().multiplyScalar(0.5);\n  var geometry = new THREE.Geometry();\n  var line = new THREE.Line(geometry);\n  geometry.vertices.push(new THREE.Vector3(-h.x, -h.y, -h.z), new THREE.Vector3(-h.x, h.y, -h.z), new THREE.Vector3(-h.x, h.y, -h.z), new THREE.Vector3(h.x, h.y, -h.z), new THREE.Vector3(h.x, h.y, -h.z), new THREE.Vector3(h.x, -h.y, -h.z), new THREE.Vector3(h.x, -h.y, -h.z), new THREE.Vector3(-h.x, -h.y, -h.z), new THREE.Vector3(-h.x, -h.y, h.z), new THREE.Vector3(-h.x, h.y, h.z), new THREE.Vector3(-h.x, h.y, h.z), new THREE.Vector3(h.x, h.y, h.z), new THREE.Vector3(h.x, h.y, h.z), new THREE.Vector3(h.x, -h.y, h.z), new THREE.Vector3(h.x, -h.y, h.z), new THREE.Vector3(-h.x, -h.y, h.z), new THREE.Vector3(-h.x, -h.y, -h.z), new THREE.Vector3(-h.x, -h.y, h.z), new THREE.Vector3(-h.x, h.y, -h.z), new THREE.Vector3(-h.x, h.y, h.z), new THREE.Vector3(h.x, h.y, -h.z), new THREE.Vector3(h.x, h.y, h.z), new THREE.Vector3(h.x, -h.y, -h.z), new THREE.Vector3(h.x, -h.y, h.z));\n  line.computeLineDistances();\n  return line.geometry;\n}\n\nfunction initBoundingBox(elt, layer) {\n  var size = new THREE.Vector3();\n  elt.tightbbox.getSize(size);\n  elt.obj.boxHelper = new THREE.LineSegments(cube(size), elt.childrenBitField ? new THREE.LineDashedMaterial({\n    color: 0,\n    dashSize: 0.25,\n    gapSize: 0.25\n  }) : new THREE.LineBasicMaterial({\n    color: 0\n  }));\n  elt.obj.boxHelper.frustumCulled = false;\n  elt.obj.boxHelper.position.copy(elt.tightbbox.min);\n  elt.obj.boxHelper.position.add(size.multiplyScalar(0.5));\n  elt.obj.boxHelper.updateMatrixWorld(true);\n  elt.obj.boxHelper.autoUpdateMatrix = false;\n  elt.obj.boxHelper.material.linewidth = 2;\n  elt.obj.boxHelper.layers.mask = layer.bboxes.layers.mask;\n  layer.bboxes.add(elt.obj.boxHelper);\n  elt.obj.boxHelper.updateMatrixWorld();\n}\n\nfunction computeScreenSpaceError(context, layer, elt, distance) {\n  if (distance <= 0) {\n    return Infinity;\n  }\n\n  var pointSpacing = layer.metadata.spacing / Math.pow(2, elt.name.length); // Estimate the onscreen distance between 2 points\n\n  var onScreenSpacing = context.camera.preSSE * pointSpacing / distance; // [  P1  ]--------------[   P2   ]\n  //     <--------------------->      = pointsSpacing (in world coordinates)\n  //                                  ~ onScreenSpacing (in pixels)\n  // <------>                         = layer.pointSize (in pixels)\n\n  return Math.max(0.0, onScreenSpacing - layer.pointSize);\n}\n\nfunction markForDeletion(elt) {\n  if (elt.obj) {\n    elt.obj.material.visible = false;\n  }\n\n  if (!elt.notVisibleSince) {\n    elt.notVisibleSince = Date.now(); // Set .sse to an invalid value\n\n    elt.sse = -1;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = elt.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var child = _step.value;\n      markForDeletion(child);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nvar _default = {\n  preUpdate: function preUpdate(context, changeSources) {\n    // Bail-out if not ready\n    if (!this.root) {\n      return [];\n    } // See https://cesiumjs.org/hosted-apps/massiveworlds/downloads/Ring/WorldScaleTerrainRendering.pptx\n    // slide 17\n\n\n    context.camera.preSSE = context.camera.height / (2 * Math.tan(THREE.Math.degToRad(context.camera.camera3D.fov) * 0.5));\n\n    if (this.material) {\n      this.material.visible = this.visible;\n      this.material.opacity = this.opacity;\n      this.material.transparent = this.opacity < 1;\n      this.material.size = this.pointSize;\n    } // lookup lowest common ancestor of changeSources\n\n\n    var commonAncestorName;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = changeSources.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var source = _step2.value;\n\n        if (source.isCamera || source == this) {\n          // if the change is caused by a camera move, no need to bother\n          // to find common ancestor: we need to update the whole tree:\n          // some invisible tiles may now be visible\n          return [this.root];\n        }\n\n        if (source.obj === undefined) {\n          continue;\n        } // filter sources that belong to our layer\n\n\n        if (source.obj.isPoints && source.obj.layer == this) {\n          if (!commonAncestorName) {\n            commonAncestorName = source.name;\n          } else {\n            var i = void 0;\n\n            for (i = 0; i < Math.min(source.name.length, commonAncestorName.length); i++) {\n              if (source.name[i] != commonAncestorName[i]) {\n                break;\n              }\n            }\n\n            commonAncestorName = commonAncestorName.substr(0, i);\n\n            if (commonAncestorName.length == 0) {\n              break;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    if (commonAncestorName) {\n      return [this.root.findChildrenByName(commonAncestorName)];\n    } // Start updating from hierarchy root\n\n\n    return [this.root];\n  },\n  update: function update(context, layer, elt) {\n    elt.visible = false;\n\n    if (layer.octreeDepthLimit >= 0 && layer.octreeDepthLimit < elt.name.length) {\n      markForDeletion(elt);\n      return;\n    } // pick the best bounding box\n\n\n    var bbox = elt.tightbbox ? elt.tightbbox : elt.bbox;\n    elt.visible = context.camera.isBox3Visible(bbox, layer.object3d.matrixWorld);\n\n    if (!elt.visible) {\n      markForDeletion(elt);\n      return;\n    }\n\n    elt.notVisibleSince = undefined;\n    point.copy(context.camera.camera3D.position).sub(layer.object3d.position); // only load geometry if this elements has points\n\n    if (elt.numPoints > 0) {\n      if (elt.obj) {\n        if (elt.obj.material.update) {\n          elt.obj.material.update(layer.material);\n        } else {\n          elt.obj.material.copy(layer.material);\n        }\n      } else if (!elt.promise) {\n        var distance = Math.max(0.001, bbox.distanceToPoint(point)); // Increase priority of nearest node\n\n        var priority = computeScreenSpaceError(context, layer, elt, distance) / distance;\n        elt.promise = context.scheduler.execute({\n          layer: layer,\n          requester: elt,\n          view: context.view,\n          priority: priority,\n          redraw: true,\n          isLeaf: elt.childrenBitField == 0,\n          earlyDropFunction: function earlyDropFunction(cmd) {\n            return !cmd.requester.visible || !layer.visible;\n          }\n        }).then(function (pts) {\n          if (layer.onPointsCreated) {\n            layer.onPointsCreated(layer, pts);\n          }\n\n          elt.obj = pts; // store tightbbox to avoid ping-pong (bbox = larger => visible, tight => invisible)\n\n          elt.tightbbox = pts.tightbbox; // make sure to add it here, otherwise it might never\n          // be added nor cleaned\n\n          layer.group.add(elt.obj);\n          elt.obj.updateMatrixWorld(true);\n          elt.promise = null;\n        }, function (err) {\n          if (err instanceof _CancelledCommandException[\"default\"]) {\n            elt.promise = null;\n          }\n        });\n      }\n    }\n\n    if (elt.children && elt.children.length) {\n      var _distance = bbox.distanceToPoint(point);\n\n      elt.sse = computeScreenSpaceError(context, layer, elt, _distance) / layer.sseThreshold;\n\n      if (elt.sse >= 1) {\n        return elt.children;\n      } else {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = elt.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var child = _step3.value;\n            markForDeletion(child);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    }\n  },\n  postUpdate: function postUpdate(context, layer) {\n    if (!layer.group) {\n      return;\n    }\n\n    layer.displayedCount = 0;\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = layer.group.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _pts2 = _step4.value;\n\n        if (_pts2.material.visible) {\n          var _count2 = _pts2.geometry.attributes.position.count;\n\n          _pts2.geometry.setDrawRange(0, _count2);\n\n          layer.displayedCount += _count2;\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n          _iterator4[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    if (layer.displayedCount > layer.pointBudget) {\n      // 2 different point count limit implementation, depending on the pointcloud source\n      if (layer.supportsProgressiveDisplay) {\n        // In this format, points are evenly distributed within a node,\n        // so we can draw a percentage of each node and still get a correct\n        // representation\n        var reduction = layer.pointBudget / layer.displayedCount;\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = layer.group.children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var pts = _step5.value;\n\n            if (pts.material.visible) {\n              var count = Math.floor(pts.geometry.drawRange.count * reduction);\n\n              if (count > 0) {\n                pts.geometry.setDrawRange(0, count);\n              } else {\n                pts.material.visible = false;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n              _iterator5[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        layer.displayedCount *= reduction;\n      } else {\n        // This format doesn't require points to be evenly distributed, so\n        // we're going to sort the nodes by \"importance\" (= on screen size)\n        // and display only the first N nodes\n        layer.group.children.sort(function (p1, p2) {\n          return p2.userData.metadata.sse - p1.userData.metadata.sse;\n        });\n        var limitHit = false;\n        layer.displayedCount = 0;\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = layer.group.children[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var _pts = _step6.value;\n            var _count = _pts.geometry.attributes.position.count;\n\n            if (limitHit || layer.displayedCount + _count > layer.pointBudget) {\n              _pts.material.visible = false;\n              limitHit = true;\n            } else {\n              layer.displayedCount += _count;\n            }\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n              _iterator6[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n      }\n    }\n\n    var now = Date.now();\n\n    for (var i = layer.group.children.length - 1; i >= 0; i--) {\n      var obj = layer.group.children[i];\n\n      if (!obj.material.visible && now - obj.userData.metadata.notVisibleSince > 10000) {\n        // remove from group\n        layer.group.children.splice(i, 1);\n\n        if (Array.isArray(obj.material)) {\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = obj.material[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var material = _step7.value;\n              material.dispose();\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n                _iterator7[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        } else {\n          obj.material.dispose();\n        }\n\n        obj.geometry.dispose();\n        obj.material = null;\n        obj.geometry = null;\n        obj.userData.metadata.obj = null;\n      }\n    }\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Process/PointCloudProcessing.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Process/handlerNodeError.js":
/*!*************************************************************!*\
  !*** ./node_modules/itowns/lib/Process/handlerNodeError.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = handlingError;\n\nvar _CancelledCommandException = _interopRequireDefault(__webpack_require__(/*! ../Core/Scheduler/CancelledCommandException */ \"./node_modules/itowns/lib/Core/Scheduler/CancelledCommandException.js\"));\n\n// max retry loading before changing the status to definitiveError\nvar MAX_RETRY = 4;\n\nfunction handlingError(err, node, layer, targetLevel, view) {\n  if (err instanceof _CancelledCommandException[\"default\"]) {\n    node.layerUpdateState[layer.id].success();\n  } else if (err instanceof SyntaxError) {\n    node.layerUpdateState[layer.id].failure(0, true);\n  } else {\n    var definitiveError = node.layerUpdateState[layer.id].errorCount > MAX_RETRY;\n    node.layerUpdateState[layer.id].failure(Date.now(), definitiveError, {\n      targetLevel: targetLevel\n    });\n\n    if (!definitiveError) {\n      window.setTimeout(function () {\n        view.notifyChange(node, false);\n      }, node.layerUpdateState[layer.id].secondsUntilNextTry() * 1000);\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Process/handlerNodeError.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Provider/3dTilesProvider.js":
/*!*************************************************************!*\
  !*** ./node_modules/itowns/lib/Provider/3dTilesProvider.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$3dTilesIndex = $3dTilesIndex;\nexports.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers;\nexports.configureTile = configureTile;\nexports[\"default\"] = exports.$3dtilesLayer = exports.$3dTilesAbstractExtension = exports.$3dTilesExtensions = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _B3dmParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/B3dmParser */ \"./node_modules/itowns/lib/Parser/B3dmParser.js\"));\n\nvar _PntsParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/PntsParser */ \"./node_modules/itowns/lib/Parser/PntsParser.js\"));\n\nvar _Fetcher = _interopRequireDefault(__webpack_require__(/*! ./Fetcher */ \"./node_modules/itowns/lib/Provider/Fetcher.js\"));\n\nvar _OBB = _interopRequireDefault(__webpack_require__(/*! ../Renderer/OBB */ \"./node_modules/itowns/lib/Renderer/OBB.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar _dTilesProcessing = __webpack_require__(/*! ../Process/3dTilesProcessing */ \"./node_modules/itowns/lib/Process/3dTilesProcessing.js\");\n\nvar _Utf8Decoder = _interopRequireDefault(__webpack_require__(/*! ../Utils/Utf8Decoder */ \"./node_modules/itowns/lib/Utils/Utf8Decoder.js\"));\n\n/** @classdesc\n * Class mapping 3D Tiles extensions names to their associated parsing methods.\n */\nvar $3DTilesExtensions =\n/*#__PURE__*/\nfunction () {\n  function $3DTilesExtensions() {\n    (0, _classCallCheck2[\"default\"])(this, $3DTilesExtensions);\n    this.extensionsMap = new Map();\n  }\n  /**\n   * Register a 3D Tiles extension: Maps an extension name to its parser\n   * @param {String} extensionName - Name of the extension\n   * @param {Function} parser - The function for parsing the extension\n   */\n\n\n  (0, _createClass2[\"default\"])($3DTilesExtensions, [{\n    key: \"registerExtension\",\n    value: function registerExtension(extensionName, parser) {\n      this.extensionsMap.set(extensionName, parser);\n    }\n    /**\n     * Get the parser of a given extension\n     * @param {String} extensionName - Name of the extension\n     * @returns {Function} - The function for parsing the extension\n     */\n\n  }, {\n    key: \"getParser\",\n    value: function getParser(extensionName) {\n      return this.extensionsMap.get(extensionName);\n    }\n    /**\n     * Test if an extension is registered\n     * @param {String} extensionName - Name of the extension\n     * @returns {boolean} - true if the extension is registered and false\n     * otherwise\n     */\n\n  }, {\n    key: \"isExtensionRegistered\",\n    value: function isExtensionRegistered(extensionName) {\n      return this.extensionsMap.has(extensionName);\n    }\n  }]);\n  return $3DTilesExtensions;\n}();\n/**\n * Global object holding 3D Tiles extensions. Extensions must be registered\n * with their parser by the client.\n * @type {$3DTilesExtensions}\n */\n\n\nvar $3dTilesExtensions = new $3DTilesExtensions();\n/** @classdesc\n * Abstract class for 3DTiles Extensions. Extensions implemented by the user\n * must inherit from this class. Example of extension extending this class:\n *  [BatchTableHierarchyExtension]{@link BatchTableHierarchyExtension}\n */\n\nexports.$3dTilesExtensions = $3dTilesExtensions;\n\nvar $3dTilesAbstractExtension =\n/*#__PURE__*/\nfunction () {\n  function $3dTilesAbstractExtension() {\n    (0, _classCallCheck2[\"default\"])(this, $3dTilesAbstractExtension);\n\n    if (this.constructor === $3dTilesAbstractExtension) {\n      throw new TypeError('Abstract class \"AbstractExtension\" ' + 'cannot be instantiated directly');\n    }\n  }\n  /**\n   * Method to get the displayable information related to a given feature\n   * from an extension. All extensions must implement it (event if it\n   * returns an empty object).\n   * @param {integer} featureId - id of the feature\n   */\n  // disable warning saying that we don't use 'this' in this method\n  // eslint-disable-next-line\n\n\n  (0, _createClass2[\"default\"])($3dTilesAbstractExtension, [{\n    key: \"getPickingInfo\",\n    value: function getPickingInfo() {\n      throw new Error('You must implement getPickingInfo function ' + 'in your extension');\n    }\n  }]);\n  return $3dTilesAbstractExtension;\n}();\n\nexports.$3dTilesAbstractExtension = $3dTilesAbstractExtension;\n\nfunction $3dTilesIndex(tileset, baseURL) {\n  var counter = 1;\n  this.index = {};\n  var inverseTileTransform = new THREE.Matrix4();\n\n  var recurse = function (node, baseURL, parent) {\n    // compute transform (will become Object3D.matrix when the object is downloaded)\n    node.transform = node.transform ? new THREE.Matrix4().fromArray(node.transform) : undefined; // The only reason to store _worldFromLocalTransform is because of extendTileset where we need the\n    // transform chain for one node.\n\n    node._worldFromLocalTransform = node.transform;\n\n    if (parent && parent._worldFromLocalTransform) {\n      if (node.transform) {\n        node._worldFromLocalTransform = new THREE.Matrix4().multiplyMatrices(parent._worldFromLocalTransform, node.transform);\n      } else {\n        node._worldFromLocalTransform = parent._worldFromLocalTransform;\n      }\n    } // getBox only use inverseTileTransform for volume.region so let's not\n    // compute the inverse matrix each time\n    // Assumes that node.boundingVolume is defined if node.viewerRequestVolume is undefined\n\n\n    if (node.viewerRequestVolume && node.viewerRequestVolume.region || node.boundingVolume.region) {\n      if (node._worldFromLocalTransform) {\n        inverseTileTransform.getInverse(node._worldFromLocalTransform);\n      } else {\n        inverseTileTransform.identity();\n      }\n    }\n\n    node.viewerRequestVolume = node.viewerRequestVolume ? getBox(node.viewerRequestVolume, inverseTileTransform) : undefined;\n    node.boundingVolume = getBox(node.boundingVolume, inverseTileTransform);\n    this.index[counter] = node;\n    node.tileId = counter;\n    node.baseURL = baseURL;\n    counter++;\n\n    if (node.children) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n          recurse(child, baseURL, node);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }.bind(this);\n\n  recurse(tileset.root, baseURL);\n\n  this.extendTileset = function (tileset, nodeId, baseURL) {\n    recurse(tileset.root, baseURL, this.index[nodeId]);\n    this.index[nodeId].children = [tileset.root];\n    this.index[nodeId].isTileset = true;\n  };\n}\n\nfunction getObjectToUpdateForAttachedLayers(meta) {\n  if (meta.content) {\n    var result = [];\n    meta.content.traverse(function (obj) {\n      if (obj.isObject3D && obj.material && obj.layer == meta.layer) {\n        result.push(obj);\n      }\n    });\n    var p = meta.parent;\n\n    if (p && p.content) {\n      return {\n        elements: result,\n        parent: p.content\n      };\n    } else {\n      return {\n        elements: result\n      };\n    }\n  }\n}\n/** @classdesc\n * Class for $3dtilesLayer.\n *\n * @example\n * var layer = new itowns.GeometryLayer('3dtiles-example');\n * layer.protocol = '3d-tiles'\n * layer.url = 'http://example/tileset.json';\n *\n * @property {string} url - tileset.json URL\n * @property {boolean|THREE.Material} [overrideMaterial=false] - override meshes material\n * embedded in the binary files and use a default one instead.\n * @property {THREE.Material} [material=THREE.PointsMaterial] - material cloned\n * and assigned each time a points mesh is created.\n * @property {number} [sseThreshold=16] - s(creen) s(pace) e(rror) threshold in pixels.\n * Define how many pixels the geometricError from a tile must cover to kick the\n * subdivision mechanism in.\n * @property {number} [cleanupDelay=1000] - delay in milliseconds after which an\n * undisplayed tiles will be removed from memory.\n * @property {Function} onTileContentLoaded - callback called when new content is added.\n */\n\n\nvar $3dtilesLayer = function $3dtilesLayer() {\n  (0, _classCallCheck2[\"default\"])(this, $3dtilesLayer);\n};\n\nexports.$3dtilesLayer = $3dtilesLayer;\n\nfunction preprocessDataLayer(layer, view, scheduler) {\n  layer.preUpdate = layer.preUpdate || _dTilesProcessing.pre3dTilesUpdate;\n  layer.update = layer.update || (0, _dTilesProcessing.process3dTilesNode)();\n  layer.sseThreshold = layer.sseThreshold || 16;\n  layer.cleanupDelay = layer.cleanupDelay || 1000;\n\n  layer.onTileContentLoaded = layer.onTileContentLoaded || function () {}; // override the default method, since updated objects are metadata in this case\n\n\n  layer.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers;\n  layer._cleanableTiles = [];\n  return _Fetcher[\"default\"].json(layer.url, layer.networkOptions).then(function (tileset) {\n    layer.tileset = tileset; // Verify that extensions of the tileset have been registered to\n    // $3dTilesExtensions\n\n    if (tileset.extensionsUsed) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = tileset.extensionsUsed[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var extensionUsed = _step2.value;\n\n          // if current extension is not registered\n          if (!$3dTilesExtensions.isExtensionRegistered(extensionUsed)) {\n            if (tileset.extensionsRequired && tileset.extensionsRequired.includes(extensionUsed)) {\n              console.error(\"3D Tiles tileset required extension \\\"\".concat(extensionUsed, \"\\\" must be registered to $3dTilesExtensions global object of iTowns to be parsed and used.\"));\n            } else {\n              console.warn(\"3D Tiles tileset used extension \\\"\".concat(extensionUsed, \"\\\" must be registered to $3dTilesExtensions global object of iTowns to be parsed and used.\"));\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    var urlPrefix = layer.url.slice(0, layer.url.lastIndexOf('/') + 1);\n    layer.tileIndex = new $3dTilesIndex(tileset, urlPrefix);\n    layer.asset = tileset.asset;\n    return (0, _dTilesProcessing.init3dTilesLayer)(view, scheduler, layer, tileset.root);\n  });\n}\n\nvar extent = new _Extent[\"default\"]('EPSG:4326', 0, 0, 0, 0);\n\nfunction getBox(volume, inverseTileTransform) {\n  if (volume.region) {\n    var region = volume.region;\n    extent.set(THREE.Math.radToDeg(region[0]), THREE.Math.radToDeg(region[2]), THREE.Math.radToDeg(region[1]), THREE.Math.radToDeg(region[3]));\n    var box = new _OBB[\"default\"]().setFromExtent(extent); // at this point box.matrix = box.epsg4978_from_local, so\n    // we transform it in parent_from_local by using parent's epsg4978_from_local\n    // which from our point of view is epsg4978_from_parent.\n    // box.matrix = (epsg4978_from_parent ^ -1) * epsg4978_from_local\n    //            =  parent_from_epsg4978 * epsg4978_from_local\n    //            =  parent_from_local\n\n    box.matrix.premultiply(inverseTileTransform); // update position, rotation and scale\n\n    box.matrix.decompose(box.position, box.quaternion, box.scale);\n    return {\n      region: box\n    };\n  } else if (volume.box) {\n    // TODO: only works for axis aligned boxes\n    var _box = volume.box; // box[0], box[1], box[2] = center of the box\n    // box[3], box[4], box[5] = x axis direction and half-length\n    // box[6], box[7], box[8] = y axis direction and half-length\n    // box[9], box[10], box[11] = z axis direction and half-length\n\n    var center = new THREE.Vector3(_box[0], _box[1], _box[2]);\n    var w = center.x - _box[3];\n    var e = center.x + _box[3];\n    var s = center.y - _box[7];\n    var n = center.y + _box[7];\n    var b = center.z - _box[11];\n    var t = center.z + _box[11];\n    return {\n      box: new THREE.Box3(new THREE.Vector3(w, s, b), new THREE.Vector3(e, n, t))\n    };\n  } else if (volume.sphere) {\n    var sphere = new THREE.Sphere(new THREE.Vector3(volume.sphere[0], volume.sphere[1], volume.sphere[2]), volume.sphere[3]);\n    return {\n      sphere: sphere\n    };\n  }\n}\n\nfunction b3dmToMesh(data, layer, url) {\n  var urlBase = THREE.LoaderUtils.extractUrlBase(url);\n  var options = {\n    gltfUpAxis: layer.asset.gltfUpAxis,\n    urlBase: urlBase,\n    overrideMaterials: layer.overrideMaterials,\n    doNotPatchMaterial: layer.doNotPatchMaterial,\n    opacity: layer.opacity\n  };\n  return _B3dmParser[\"default\"].parse(data, options).then(function (result) {\n    var batchTable = result.batchTable;\n    var object3d = result.gltf.scene;\n    return {\n      batchTable: batchTable,\n      object3d: object3d\n    };\n  });\n}\n\nfunction pntsParse(data, layer) {\n  return _PntsParser[\"default\"].parse(data).then(function (result) {\n    var material = layer.material ? layer.material.clone() : new THREE.PointsMaterial({\n      size: 0.05,\n      vertexColors: THREE.VertexColors\n    }); // creation points with geometry and material\n\n    var points = new THREE.Points(result.point.geometry, material);\n\n    if (result.point.offset) {\n      points.position.copy(result.point.offset);\n    }\n\n    return {\n      object3d: points\n    };\n  });\n}\n\nfunction configureTile(tile, layer, metadata, parent) {\n  tile.frustumCulled = false;\n  tile.layer = layer; // parse metadata\n\n  if (metadata.transform) {\n    tile.applyMatrix(metadata.transform);\n  }\n\n  tile.geometricError = metadata.geometricError;\n  tile.tileId = metadata.tileId;\n\n  if (metadata.refine) {\n    tile.additiveRefinement = metadata.refine.toUpperCase() === 'ADD';\n  } else {\n    tile.additiveRefinement = parent ? parent.additiveRefinement : false;\n  }\n\n  tile.viewerRequestVolume = metadata.viewerRequestVolume;\n  tile.boundingVolume = metadata.boundingVolume;\n\n  if (tile.boundingVolume.region) {\n    tile.add(tile.boundingVolume.region);\n  }\n\n  tile.updateMatrixWorld();\n}\n\nfunction executeCommand(command) {\n  var layer = command.layer;\n  var metadata = command.metadata;\n  var tile = new THREE.Object3D();\n  configureTile(tile, layer, metadata, command.requester); // Patch for supporting 3D Tiles pre 1.0 (metadata.content.url) and 1.0\n  // (metadata.content.uri)\n\n  var path = metadata.content && (metadata.content.url || metadata.content.uri);\n\n  var setLayer = function (obj) {\n    obj.layers.set(layer.threejsLayer);\n    obj.userData.metadata = metadata;\n    obj.layer = layer;\n\n    if (obj.material) {\n      obj.material.transparent = layer.opacity < 1.0;\n      obj.material.opacity = layer.opacity;\n      obj.material.wireframe = layer.wireframe;\n    }\n  };\n\n  if (path) {\n    // Check if we have relative or absolute url (with tileset's lopocs for example)\n    var url = path.startsWith('http') ? path : metadata.baseURL + path;\n    var supportedFormats = {\n      b3dm: b3dmToMesh,\n      pnts: pntsParse\n    };\n    return _Fetcher[\"default\"].arrayBuffer(url, layer.networkOptions).then(function (result) {\n      if (result !== undefined) {\n        var func;\n\n        var magic = _Utf8Decoder[\"default\"].decode(new Uint8Array(result, 0, 4));\n\n        if (magic[0] === '{') {\n          result = JSON.parse(_Utf8Decoder[\"default\"].decode(new Uint8Array(result)));\n          var newPrefix = url.slice(0, url.lastIndexOf('/') + 1);\n          layer.tileIndex.extendTileset(result, metadata.tileId, newPrefix);\n        } else if (magic == 'b3dm') {\n          func = supportedFormats.b3dm;\n        } else if (magic == 'pnts') {\n          func = supportedFormats.pnts;\n        } else {\n          return Promise.reject(\"Unsupported magic code \".concat(magic));\n        }\n\n        if (func) {\n          // TODO: request should be delayed if there is a viewerRequestVolume\n          return func(result, layer, url).then(function (content) {\n            layer.onTileContentLoaded(content);\n            tile.content = content.object3d;\n\n            if (content.batchTable) {\n              tile.batchTable = content.batchTable;\n            }\n\n            tile.add(content.object3d);\n            tile.traverse(setLayer);\n            return tile;\n          });\n        }\n      }\n\n      tile.traverse(setLayer);\n      return tile;\n    });\n  } else {\n    tile.traverse(setLayer);\n    return Promise.resolve(tile);\n  }\n}\n\nvar _default = {\n  preprocessDataLayer: preprocessDataLayer,\n  executeCommand: executeCommand\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Provider/3dTilesProvider.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Provider/DataSourceProvider.js":
/*!****************************************************************!*\
  !*** ./node_modules/itowns/lib/Provider/DataSourceProvider.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Cache = _interopRequireDefault(__webpack_require__(/*! ../Core/Scheduler/Cache */ \"./node_modules/itowns/lib/Core/Scheduler/Cache.js\"));\n\nfunction isValidData(data, extentDestination, validFn) {\n  if (data && (!validFn || validFn(data, extentDestination))) {\n    return data;\n  }\n}\n\nvar error = function (err, source) {\n  source.handlingError(err);\n  throw err;\n};\n\nfunction parseSourceData(data, extDest, layer) {\n  var source = layer.source;\n  var options = {\n    buildExtent: source.isFileSource || !layer.isGeometryLayer,\n    crsIn: source.projection,\n    crsOut: layer.projection,\n    sprites: layer.sprites || source.sprites,\n    // TODO FIXME: error in filtering vector tile\n    // filteringExtent: extentDestination.as(layer.projection),\n    filteringExtent: !source.isFileSource && layer.isGeometryLayer ? extDest.as(source.projection) : undefined,\n    overrideAltitudeInToZero: layer.overrideAltitudeInToZero,\n    filter: layer.filter || source.filter,\n    isInverted: source.isInverted,\n    mergeFeatures: layer.mergeFeatures === undefined ? true : layer.mergeFeatures,\n    withNormal: layer.isGeometryLayer,\n    withAltitude: layer.isGeometryLayer\n  };\n  return source.parser(data, options).then(function (parsedFile) {\n    return source.onParsedFile(parsedFile);\n  });\n}\n\nfunction fetchSourceData(extSrc, layer) {\n  var source = layer.source; // If source, we must fetch and convert data\n  // URL of the resource you want to fetch\n\n  var url = source.urlFromExtent(extSrc); // Fetch data\n\n  return source.fetcher(url, source.networkOptions).then(function (f) {\n    f.extent = extSrc;\n    return f;\n  });\n}\n\nvar _default = {\n  executeCommand: function executeCommand(command) {\n    var promises = [];\n    var layer = command.layer;\n    var source = layer.source;\n    var extentsSource = command.extentsSource;\n    var extentsDestination = command.extentsDestination || extentsSource;\n    var parsedData = command.parsedData || [];\n\n    for (var i = 0, max = extentsSource.length; i < max; i++) {\n      var extSource = extentsSource[i]; // Tag to Cache data\n\n      var exTag = source.isVectorSource ? extentsDestination[i] : extSource; // Get converted source data, in cache\n\n      var convertedSourceData = _Cache[\"default\"].get(source.uid, layer.id, exTag.toString('-')); // If data isn't in cache\n\n\n      if (!convertedSourceData) {\n        (function () {\n          var extDest = extentsDestination[i]; // Already fetched and parsed data that can be used\n\n          var validedParsedData = isValidData(parsedData[i], extDest, layer.isValidData) || source.parsedData;\n\n          if (validedParsedData) {\n            // Convert\n            convertedSourceData = layer.convert(validedParsedData, extDest, layer);\n          } else if (source.fetchedData) {\n            // Parse and convert\n            convertedSourceData = parseSourceData(source.fetchedData, extDest, layer).then(function (parsedData) {\n              return layer.convert(parsedData, extDest, layer);\n            }, function (err) {\n              return error(err, source);\n            });\n          } else {\n            // Fetch, parse and convert\n            convertedSourceData = fetchSourceData(extSource, layer).then(function (fetchedData) {\n              return parseSourceData(fetchedData, extDest, layer);\n            }, function (err) {\n              return error(err, source);\n            }).then(function (parsedData) {\n              return layer.convert(parsedData, extDest, layer);\n            }, function (err) {\n              return error(err, source);\n            });\n          } // Put converted data in cache\n\n\n          _Cache[\"default\"].set(convertedSourceData, _Cache[\"default\"].POLICIES.TEXTURE, source.uid, layer.id, exTag.toString('-'));\n        })();\n      } // Verify some command is resolved\n      // See old WFSProvider : command.resolve(result)\n\n\n      promises.push(convertedSourceData);\n    }\n\n    return Promise.all(promises);\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Provider/DataSourceProvider.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Provider/Fetcher.js":
/*!*****************************************************!*\
  !*** ./node_modules/itowns/lib/Provider/Fetcher.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _three = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar textureLoader = new _three.TextureLoader();\nvar SIZE_TEXTURE_TILE = 256;\n\nfunction checkResponse(response) {\n  if (!response.ok) {\n    var error = new Error(\"Error loading \".concat(response.url, \": status \").concat(response.status));\n    error.response = response;\n    throw error;\n  }\n}\n\nvar arrayBuffer = function (url) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return fetch(url, options).then(function (response) {\n    checkResponse(response);\n    return response.arrayBuffer();\n  });\n};\n\nvar getTextureFloat = function (buffer) {\n  return new _three.DataTexture(buffer, SIZE_TEXTURE_TILE, SIZE_TEXTURE_TILE, _three.AlphaFormat, _three.FloatType);\n};\n/**\n * Utilitary to fetch resources from a server using the [fetch API]{@link\n * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch}.\n *\n * @module Fetcher\n */\n\n\nvar _default = {\n  /**\n   * Wrapper over fetch to get some text.\n   *\n   * @param {string} url - The URL of the resources to fetch.\n   * @param {Object} options - Fetch options (passed directly to `fetch()`),\n   * see [the syntax for more information]{@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax}.\n   *\n   * @return {Promise<string>} Promise containing the text.\n   */\n  text: function text(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return fetch(url, options).then(function (response) {\n      checkResponse(response);\n      return response.text();\n    });\n  },\n\n  /**\n   * Little wrapper over fetch to get some JSON.\n   *\n   * @param {string} url - The URL of the resources to fetch.\n   * @param {Object} options - Fetch options (passed directly to `fetch()`),\n   * see [the syntax for more information]{@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax}.\n   *\n   * @return {Promise<Object>} Promise containing the JSON object.\n   */\n  json: function json(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return fetch(url, options).then(function (response) {\n      checkResponse(response);\n      return response.json();\n    });\n  },\n\n  /**\n   * Wrapper over fetch to get some XML.\n   *\n   * @param {string} url - The URL of the resources to fetch.\n   * @param {Object} options - Fetch options (passed directly to `fetch()`),\n   * see [the syntax for more information]{@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax}.\n   *\n   * @return {Promise<Document>} Promise containing the XML Document.\n   */\n  xml: function xml(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return fetch(url, options).then(function (response) {\n      checkResponse(response);\n      return response.text();\n    }).then(function (text) {\n      return new window.DOMParser().parseFromString(text, 'text/xml');\n    });\n  },\n\n  /**\n   * Wrapper around {@link THREE.TextureLoader}.\n   *\n   * @param {string} url - The URL of the resources to fetch.\n   * @param {Object} options - Fetch options (passed directly to `fetch()`),\n   * see [the syntax for more information]{@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax}.\n   * Note that THREE.js docs mentions `withCredentials`, but it is not\n   * actually used in {@link THREE.TextureLoader}.\n   *\n   * @return {Promise<THREE.Texture>} Promise containing the {@link\n   * THREE.Texture}.\n   */\n  texture: function texture(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var res;\n    var rej;\n    textureLoader.crossOrigin = options.crossOrigin;\n    var promise = new Promise(function (resolve, reject) {\n      res = resolve;\n      rej = reject;\n    });\n    textureLoader.load(url, res, function () {}, rej);\n    return promise;\n  },\n\n  /**\n   * Wrapper over fetch to get some ArrayBuffer.\n   *\n   * @param {string} url - The URL of the resources to fetch.\n   * @param {Object} options - Fetch options (passed directly to `fetch()`),\n   * see [the syntax for more information]{@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax}.\n   *\n   * @return {Promise<ArrayBuffer>} Promise containing the ArrayBuffer.\n   */\n  arrayBuffer: arrayBuffer,\n\n  /**\n   * Wrapper over fetch to get some {@link THREE.DataTexture}.\n   *\n   * @param {string} url - The URL of the resources to fetch.\n   * @param {Object} options - Fetch options (passed directly to `fetch()`),\n   * see [the syntax for more information]{@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax}.\n   *\n   * @return {Promise<THREE.DataTexture>} Promise containing the DataTexture.\n   */\n  textureFloat: function textureFloat(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return arrayBuffer(url, options).then(function (buffer) {\n      var floatArray = new Float32Array(buffer);\n      var texture = getTextureFloat(floatArray);\n      return texture;\n    });\n  },\n\n  /**\n   * Wrapper over fetch to get a bunch of files sharing the same name, but\n   * different extensions.\n   *\n   * @param {string} baseUrl - The shared URL of the resources to fetch.\n   * @param {Object} extensions - An object containing arrays. The keys of\n   * each of this array are available fetch type, such as `text`, `json` or\n   * even `arrayBuffer`. The arrays contains the extensions to append after\n   * the `baseUrl` (see example below).\n   * @param {Object} options - Fetch options (passed directly to `fetch()`),\n   * see [the syntax for more information]{@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax}.\n   *\n   * @return {Promise[]} An array of promises, containing all the files,\n   * organized by their extensions (see the example below).\n   *\n   * @example\n   * itowns.Fetcher.multiple('http://geo.server/shapefile', {\n   *     // will fetch:\n   *     // - http://geo.server/shapefile.shp\n   *     // - http://geo.server/shapefile.dbf\n   *     // - http://geo.server/shapefile.shx\n   *     // - http://geo.server/shapefile.prj\n   *     arrayBuffer: ['shp', 'dbf', 'shx'],\n   *     text: ['prj'],\n   * }).then(function _(result) {\n   *     // result looks like:\n   *     result = {\n   *         shp: ArrayBuffer\n   *         dbf: ArrayBuffer\n   *         shx: ArrayBuffer\n   *         prj: string\n   *     };\n   * });\n   */\n  multiple: function multiple(baseUrl, extensions) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var promises = [];\n    var url;\n\n    for (var fetchType in extensions) {\n      if (!this[fetchType]) {\n        throw new Error(\"\".concat(fetchType, \" is not a valid Fetcher method.\"));\n      } else {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          var _loop = function () {\n            var extension = _step.value;\n            url = \"\".concat(baseUrl, \".\").concat(extension);\n            promises.push(_this[fetchType](url, options).then(function (result) {\n              return {\n                type: extension,\n                result: result\n              };\n            }));\n          };\n\n          for (var _iterator = extensions[fetchType][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            _loop();\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n\n    return Promise.all(promises).then(function (result) {\n      var all = {};\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = result[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var res = _step2.value;\n          all[res.type] = res.result;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return Promise.resolve(all);\n    });\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Provider/Fetcher.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Provider/PointCloudProvider.js":
/*!****************************************************************!*\
  !*** ./node_modules/itowns/lib/Provider/PointCloudProvider.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers;\nexports._testing = exports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Fetcher = _interopRequireDefault(__webpack_require__(/*! ./Fetcher */ \"./node_modules/itowns/lib/Provider/Fetcher.js\"));\n\nvar _PointCloudProcessing = _interopRequireDefault(__webpack_require__(/*! ../Process/PointCloudProcessing */ \"./node_modules/itowns/lib/Process/PointCloudProcessing.js\"));\n\nvar _PotreeBinParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/PotreeBinParser */ \"./node_modules/itowns/lib/Parser/PotreeBinParser.js\"));\n\nvar _PotreeCinParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/PotreeCinParser */ \"./node_modules/itowns/lib/Parser/PotreeCinParser.js\"));\n\nvar _PointsMaterial = _interopRequireWildcard(__webpack_require__(/*! ../Renderer/PointsMaterial */ \"./node_modules/itowns/lib/Renderer/PointsMaterial.js\"));\n\nvar _Picking = _interopRequireDefault(__webpack_require__(/*! ../Core/Picking */ \"./node_modules/itowns/lib/Core/Picking.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\n// Create an A(xis)A(ligned)B(ounding)B(ox) for the child `childIndex` of one aabb.\n// (PotreeConverter protocol builds implicit octree hierarchy by applying the same\n// subdivision algo recursively)\nfunction createChildAABB(aabb, childIndex) {\n  // Code taken from potree\n  var min = aabb.min;\n  var max = aabb.max;\n  var dHalfLength = new THREE.Vector3().copy(max).sub(min).multiplyScalar(0.5);\n  var xHalfLength = new THREE.Vector3(dHalfLength.x, 0, 0);\n  var yHalfLength = new THREE.Vector3(0, dHalfLength.y, 0);\n  var zHalfLength = new THREE.Vector3(0, 0, dHalfLength.z);\n  var cmin = min;\n  var cmax = new THREE.Vector3().add(min).add(dHalfLength);\n\n  if (childIndex === 1) {\n    min = new THREE.Vector3().copy(cmin).add(zHalfLength);\n    max = new THREE.Vector3().copy(cmax).add(zHalfLength);\n  } else if (childIndex === 3) {\n    min = new THREE.Vector3().copy(cmin).add(zHalfLength).add(yHalfLength);\n    max = new THREE.Vector3().copy(cmax).add(zHalfLength).add(yHalfLength);\n  } else if (childIndex === 0) {\n    min = cmin;\n    max = cmax;\n  } else if (childIndex === 2) {\n    min = new THREE.Vector3().copy(cmin).add(yHalfLength);\n    max = new THREE.Vector3().copy(cmax).add(yHalfLength);\n  } else if (childIndex === 5) {\n    min = new THREE.Vector3().copy(cmin).add(zHalfLength).add(xHalfLength);\n    max = new THREE.Vector3().copy(cmax).add(zHalfLength).add(xHalfLength);\n  } else if (childIndex === 7) {\n    min = new THREE.Vector3().copy(cmin).add(dHalfLength);\n    max = new THREE.Vector3().copy(cmax).add(dHalfLength);\n  } else if (childIndex === 4) {\n    min = new THREE.Vector3().copy(cmin).add(xHalfLength);\n    max = new THREE.Vector3().copy(cmax).add(xHalfLength);\n  } else if (childIndex === 6) {\n    min = new THREE.Vector3().copy(cmin).add(xHalfLength).add(yHalfLength);\n    max = new THREE.Vector3().copy(cmax).add(xHalfLength).add(yHalfLength);\n  }\n\n  return new THREE.Box3(min, max);\n}\n\nfunction parseOctree(layer, hierarchyStepSize, root) {\n  return _Fetcher[\"default\"].arrayBuffer(\"\".concat(root.baseurl, \"/r\").concat(root.name, \".hrc\"), layer.fetchOptions).then(function (blob) {\n    var view = new DataView(blob);\n    var stack = [];\n    var offset = 0;\n    root.childrenBitField = view.getUint8(0);\n    offset += 1;\n    root.numPoints = view.getUint32(1, true);\n    offset += 4;\n    root.children = [];\n    stack.push(root);\n\n    while (stack.length && offset < blob.byteLength) {\n      var snode = stack.shift(); // look up 8 children\n\n      for (var i = 0; i < 8; i++) {\n        // does snode have a #i child ?\n        if (snode.childrenBitField & 1 << i && offset + 5 <= blob.byteLength) {\n          var c = view.getUint8(offset);\n          offset += 1;\n          var n = view.getUint32(offset, true);\n          offset += 4;\n\n          if (n == 0) {\n            n = root.numPoints;\n          }\n\n          var childname = snode.name + i;\n          var bounds = createChildAABB(snode.bbox, i);\n          var url = root.baseurl;\n\n          if (childname.length % hierarchyStepSize == 0) {\n            var myname = childname.substr(root.name.length);\n            url = \"\".concat(root.baseurl, \"/\").concat(myname);\n          }\n\n          var item = {\n            numPoints: n,\n            childrenBitField: c,\n            children: [],\n            name: childname,\n            baseurl: url,\n            bbox: bounds,\n            layer: layer,\n            parent: snode\n          };\n          snode.children.push(item);\n          stack.push(item);\n        }\n      }\n    }\n\n    return root;\n  });\n}\n\nfunction findChildrenByName(node, name) {\n  if (node.name === name) {\n    return node;\n  }\n\n  var charIndex = node.name.length;\n\n  for (var i = 0; i < node.children.length; i++) {\n    if (node.children[i].name[charIndex] == name[charIndex]) {\n      return findChildrenByName(node.children[i], name);\n    }\n  }\n\n  throw new Error(\"Cannot find node with name '\".concat(name, \"'\"));\n}\n\nvar nextuuid = 1;\n\nfunction addPickingAttribute(points) {\n  // generate unique id for picking\n  var numPoints = points.geometry.attributes.position.count;\n  var ids = new Uint8Array(4 * numPoints);\n  var baseId = nextuuid++;\n\n  if (numPoints > 0xffff || baseId > 0xffff) {\n    // TODO: fixme\n    console.warn('Currently picking is limited to Points with less than 65535 elements and less than 65535 Points instances');\n    return points;\n  }\n\n  for (var i = 0; i < numPoints; i++) {\n    // todo numpoints > 16bits\n    var v = baseId << 16 | i;\n    ids[4 * i + 0] = (v & 0xff000000) >> 24;\n    ids[4 * i + 1] = (v & 0x00ff0000) >> 16;\n    ids[4 * i + 2] = (v & 0x0000ff00) >> 8;\n    ids[4 * i + 3] = (v & 0x000000ff) >> 0;\n  }\n\n  points.baseId = baseId;\n  points.geometry.setAttribute('unique_id', new THREE.BufferAttribute(ids, 4, true));\n  return points;\n}\n\nfunction computeBbox(layer) {\n  var bbox;\n\n  if (layer.isFromPotreeConverter) {\n    bbox = new THREE.Box3(new THREE.Vector3(layer.metadata.boundingBox.lx, layer.metadata.boundingBox.ly, layer.metadata.boundingBox.lz), new THREE.Vector3(layer.metadata.boundingBox.ux, layer.metadata.boundingBox.uy, layer.metadata.boundingBox.uz));\n  } else {\n    // lopocs\n    var idx = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = layer.metadata[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var entry = _step.value;\n\n        if (entry.table == layer.table) {\n          break;\n        }\n\n        idx++;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    bbox = new THREE.Box3(new THREE.Vector3(layer.metadata[idx].bbox.xmin, layer.metadata[idx].bbox.ymin, layer.metadata[idx].bbox.zmin), new THREE.Vector3(layer.metadata[idx].bbox.xmax, layer.metadata[idx].bbox.ymax, layer.metadata[idx].bbox.zmax));\n  }\n\n  return bbox;\n}\n\nfunction parseMetadata(metadata, layer) {\n  layer.metadata = metadata;\n  var customBinFormat = true; // Lopocs pointcloud server can expose the same file structure as PotreeConverter output.\n  // The only difference is the metadata root file (cloud.js vs infos/sources), and we can\n  // check for the existence of a `scale` field.\n  // (if `scale` is defined => we're fetching files from PotreeConverter)\n\n  if (layer.metadata.scale != undefined) {\n    layer.isFromPotreeConverter = true; // PotreeConverter format\n\n    customBinFormat = layer.metadata.pointAttributes === 'CIN'; // do we have normal information\n\n    var normal = Array.isArray(layer.metadata.pointAttributes) && layer.metadata.pointAttributes.find(function (elem) {\n      return elem.startsWith('NORMAL');\n    });\n\n    if (normal) {\n      layer.material.defines[normal] = 1;\n    }\n  } else {\n    // Lopocs\n    layer.metadata.scale = 1;\n    layer.metadata.octreeDir = \"itowns/\".concat(layer.table, \".points\");\n    layer.metadata.hierarchyStepSize = 1000000; // ignore this with lopocs\n\n    customBinFormat = true;\n  }\n\n  layer.parse = customBinFormat ? _PotreeCinParser[\"default\"].parse : _PotreeBinParser[\"default\"].parse;\n  layer.extension = customBinFormat ? 'cin' : 'bin';\n  layer.supportsProgressiveDisplay = customBinFormat;\n}\n\nfunction getObjectToUpdateForAttachedLayers(meta) {\n  if (meta.obj) {\n    var p = meta.parent;\n\n    if (p && p.obj) {\n      return {\n        element: meta.obj,\n        parent: p.obj\n      };\n    } else {\n      return {\n        element: meta.obj\n      };\n    }\n  }\n}\n\nvar _default = {\n  preprocessDataLayer: function preprocessDataLayer(layer, view) {\n    if (!layer.file) {\n      layer.file = 'cloud.js';\n    }\n\n    if (!layer.group) {\n      layer.group = new THREE.Group();\n      layer.object3d.add(layer.group);\n      layer.group.updateMatrixWorld();\n    }\n\n    if (!layer.bboxes) {\n      layer.bboxes = new THREE.Group();\n      layer.object3d.add(layer.bboxes);\n      layer.bboxes.updateMatrixWorld();\n      layer.bboxes.visible = false;\n    } // default options\n\n\n    layer.fetchOptions = layer.fetchOptions || {};\n    layer.octreeDepthLimit = layer.octreeDepthLimit || -1;\n    layer.pointBudget = layer.pointBudget || 2000000;\n    layer.pointSize = layer.pointSize === 0 || !isNaN(layer.pointSize) ? layer.pointSize : 4;\n    layer.sseThreshold = layer.sseThreshold || 2;\n    layer.material = layer.material || {};\n    layer.material = layer.material.isMaterial ? layer.material : new _PointsMaterial[\"default\"](layer.material);\n    layer.material.defines = layer.material.defines || {};\n    layer.mode = _PointsMaterial.MODE.COLOR; // default update methods\n\n    layer.preUpdate = _PointCloudProcessing[\"default\"].preUpdate;\n    layer.update = _PointCloudProcessing[\"default\"].update;\n    layer.postUpdate = _PointCloudProcessing[\"default\"].postUpdate; // override the default method, since updated objects are metadata in this case\n\n    layer.getObjectToUpdateForAttachedLayers = getObjectToUpdateForAttachedLayers; // this probably needs to be moved to somewhere else\n\n    layer.pickObjectsAt = function (view, mouse, radius) {\n      return _Picking[\"default\"].pickPointsAt(view, mouse, radius, layer);\n    };\n\n    return _Fetcher[\"default\"].json(\"\".concat(layer.url, \"/\").concat(layer.file), layer.fetchOptions).then(function (metadata) {\n      parseMetadata(metadata, layer);\n      var bbox = computeBbox(layer);\n      return parseOctree(layer, layer.metadata.hierarchyStepSize, {\n        baseurl: \"\".concat(layer.url, \"/\").concat(layer.metadata.octreeDir, \"/r\"),\n        name: '',\n        bbox: bbox\n      });\n    }).then(function (root) {\n      layer.root = root;\n      root.findChildrenByName = findChildrenByName.bind(root, root);\n      layer.extent = _Extent[\"default\"].fromBox3(view.referenceCrs, root.bbox);\n      return layer;\n    });\n  },\n  executeCommand: function executeCommand(command) {\n    var layer = command.layer;\n    var metadata = command.requester; // Query HRC if we don't have children metadata yet.\n\n    if (metadata.childrenBitField && metadata.children.length === 0) {\n      parseOctree(layer, layer.metadata.hierarchyStepSize, metadata).then(function () {\n        return command.view.notifyChange(layer, false);\n      });\n    } // `isLeaf` is for lopocs and allows the pointcloud server to consider that the current\n    // node is the last one, even if we could subdivide even further.\n    // It's necessary because lopocs doens't know about the hierarchy (it generates it on the fly\n    // when we request .hrc files)\n\n\n    var url = \"\".concat(metadata.baseurl, \"/r\").concat(metadata.name, \".\").concat(layer.extension, \"?isleaf=\").concat(command.isLeaf ? 1 : 0);\n    return _Fetcher[\"default\"].arrayBuffer(url, layer.fetchOptions).then(function (buffer) {\n      return layer.parse(buffer, layer.metadata.pointAttributes);\n    }).then(function (geometry) {\n      var points = new THREE.Points(geometry, layer.material.clone());\n      addPickingAttribute(points);\n      points.frustumCulled = false;\n      points.matrixAutoUpdate = false;\n      points.position.copy(metadata.bbox.min);\n      points.scale.set(layer.metadata.scale, layer.metadata.scale, layer.metadata.scale);\n      points.updateMatrix();\n      points.tightbbox = geometry.boundingBox.applyMatrix4(points.matrix);\n      points.layers.set(layer.threejsLayer);\n      points.layer = layer;\n      points.extent = _Extent[\"default\"].fromBox3(command.view.referenceCrs, metadata.bbox);\n      points.userData.metadata = metadata;\n      return points;\n    });\n  }\n};\nexports[\"default\"] = _default;\nvar _testing = {\n  parseMetadata: parseMetadata\n};\nexports._testing = _testing;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Provider/PointCloudProvider.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Provider/TileProvider.js":
/*!**********************************************************!*\
  !*** ./node_modules/itowns/lib/Provider/TileProvider.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _CancelledCommandException = _interopRequireDefault(__webpack_require__(/*! ../Core/Scheduler/CancelledCommandException */ \"./node_modules/itowns/lib/Core/Scheduler/CancelledCommandException.js\"));\n\nvar _default = {\n  executeCommand: function executeCommand(command) {\n    var promises = [];\n    var layer = command.layer;\n    var requester = command.requester;\n    var extentsSource = command.extentsSource;\n\n    if (requester && !requester.material) {\n      return Promise.reject(new _CancelledCommandException[\"default\"](command));\n    }\n\n    for (var i = 0, size = extentsSource.length; i < size; i++) {\n      promises.push(layer.convert(requester, extentsSource[i]));\n    }\n\n    return Promise.all(promises);\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Provider/TileProvider.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Provider/URLBuilder.js":
/*!********************************************************!*\
  !*** ./node_modules/itowns/lib/Provider/URLBuilder.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar extent = new _Extent[\"default\"]('EPSG:4326', [0, 0, 0, 0]);\nvar subDomainsCount = 0;\n\nfunction subDomains(url) {\n  var subDomainsPtrn = /\\$\\{u:([\\w-_.|]+)\\}/.exec(url);\n\n  if (!subDomainsPtrn) {\n    return url;\n  }\n\n  var subDomainsList = subDomainsPtrn[1].split('|');\n  return url.replace(subDomainsPtrn[0], subDomainsList[subDomainsCount++ % subDomainsList.length]);\n}\n/**\n * This module performs basic operations around urls, to replace some elements\n * in it by coordinates or other things.\n *\n * In an url, it is also possible to specify subdomains alternatives using the\n * `${u:a|b|c}` pattern, by separating differents options using `|`. It will go\n * through the following alternative each time (no random). For example\n * `https://${u:xyz.org|yzx.org|zxy.org}/${z}/${x}/${y}.png` or\n * `https://${u:a|b|c}.tile.openstreetmap.org/${z}/${x}/${y}.png`.\n *\n * @module URLBuilder\n */\n\n\nvar _default = {\n  /**\n   * Builds an URL knowing the coordinates and the source to query.\n   * <br><br>\n   * The source object needs to have an url property, which should have some\n   * specific strings that will be replaced by coordinates.\n   * <ul>\n   * <li>`${x}` or `%COL` will be replaced by `coords.col`</li>\n   * <li>`${y}` or `%ROW` will be replaced by `coords.row`</li>\n   * <li>`${z}` or `%TILEMATRIX` will be replaced by `coords.zoom`</li>\n   * </ul>\n   *\n   * @example\n   * coords = new Coordinates('WMTS:WGS84', 12, 1410, 2072);\n   * source.url = 'http://server.geo/wmts/SERVICE=WMTS&TILEMATRIX=%TILEMATRIX&TILEROW=%ROW&TILECOL=%COL';\n   * url = URLBuilder.xyz(coords, source);\n   *\n   * // The resulting url is:\n   * // http://server.geo/wmts/SERVICE=WMTS&TILEMATRIX=12&TILEROW=1410&TILECOL=2072;\n   *\n   * @example\n   * coords = new Extent('TMS', 15, 2142, 3412);\n   * source.url = 'http://server.geo/tms/${z}/${y}/${x}.jpg';\n   * url = URLBuilder.xyz(coords, source);\n   *\n   * // The resulting url is:\n   * // http://server.geo/tms/15/2142/3412.jpg;\n   *\n   * @param {Extent} coords - the coordinates\n   * @param {Source} source\n   *\n   * @return {string} the formed url\n   */\n  xyz: function (coords, source) {\n    return subDomains(source.url.replace(/(\\$\\{z\\}|%TILEMATRIX)/, coords.zoom).replace(/(\\$\\{y\\}|%ROW)/, coords.row).replace(/(\\$\\{x\\}|%COL)/, coords.col));\n  },\n\n  /**\n   * Builds an URL knowing the bounding box and the source to query.\n   * <br><br>\n   * The source object needs to have an url property, which should have the\n   * string `%bbox` in it. This string will be replaced by the four cardinal\n   * points composing the bounding box.\n   * <br><br>\n   * Order of the points can be specified in the `axisOrder` property in\n   * source, using the letters `w, s, e, n` respectively for `WEST, SOUTH,\n   * EAST, NORTH`. The default order is `wsen`.\n   *\n   * @example\n   * extent = new Extent('EPSG:4326', 12, 14, 35, 46);\n   * source.projection = 'EPSG:4326';\n   * source.url = 'http://server.geo/wms/BBOX=%bbox&FORMAT=jpg&SERVICE=WMS';\n   * url = URLBuilder.bbox(extent, source);\n   *\n   * // The resulting url is:\n   * // http://server.geo/wms/BBOX=12,35,14,46&FORMAT=jpg&SERVICE=WMS\n   *\n   * @param {Extent} bbox - the bounding box\n   * @param {Source} source\n   *\n   * @return {string} the formed url\n   */\n  bbox: function bbox(bbox, source) {\n    var precision = source.projection == 'EPSG:4326' ? 9 : 2;\n    bbox.as(source.projection, extent);\n    var w = extent.west.toFixed(precision);\n    var s = extent.south.toFixed(precision);\n    var e = extent.east.toFixed(precision);\n    var n = extent.north.toFixed(precision);\n    var bboxInUnit = source.axisOrder || 'wsen';\n    bboxInUnit = bboxInUnit.replace('w', \"\".concat(w, \",\")).replace('s', \"\".concat(s, \",\")).replace('e', \"\".concat(e, \",\")).replace('n', \"\".concat(n, \",\")).slice(0, -1);\n    return subDomains(source.url.replace('%bbox', bboxInUnit));\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Provider/URLBuilder.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/Camera.js":
/*!****************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/Camera.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _DEMUtils = _interopRequireDefault(__webpack_require__(/*! ../Utils/DEMUtils */ \"./node_modules/itowns/lib/Utils/DEMUtils.js\"));\n\n/**\n * Wrapper around three.js camera to expose some geographic helpers.\n */\nfunction updatePreSse(camera, height, fov) {\n  // sse = projected geometric error on screen plane from distance\n  // We're using an approximation, assuming that the geometric error of all\n  // objects is perpendicular to the camera view vector (= we always compute\n  // for worst case).\n  //\n  //            screen plane             object\n  //               |                         __\n  //               |                        /  \\\n  //               |             geometric{|\n  //  < fov angle  . } sse          error {|    |\n  //               |                        \\__/\n  //               |\n  //               |<--------------------->\n  //               |        distance\n  //\n  //              geometric_error * screen_width      (resp. screen_height)\n  //     =  ---------------------------------------\n  //        2 * distance * tan (horizontal_fov / 2)   (resp. vertical_fov)\n  //\n  //\n  // We pre-compute the preSSE (= constant part of the screen space error formula) once here\n  var verticalFOV = THREE.Math.degToRad(fov);\n  var verticalPreSSE = height / (2.0 * Math.tan(verticalFOV * 0.5)); // Note: the preSSE for the horizontal FOV is the same value\n  // focale = (this.height * 0.5) / Math.tan(verticalFOV * 0.5);\n  // horizontalFOV = 2 * Math.atan(this.width * 0.5 / focale);\n  // horizontalPreSSE = this.width / (2.0 * Math.tan(horizontalFOV * 0.5)); (1)\n  // => replacing horizontalFOV in Math.tan(horizontalFOV * 0.5)\n  // Math.tan(horizontalFOV * 0.5) = Math.tan(2 * Math.atan(this.width * 0.5 / focale) * 0.5)\n  //                               = Math.tan(Math.atan(this.width * 0.5 / focale))\n  //                               = this.width * 0.5 / focale\n  // => now replacing focale\n  //                               = this.width * 0.5 / (this.height * 0.5) / Math.tan(verticalFOV * 0.5)\n  //                               = Math.tan(verticalFOV * 0.5) * this.width / this.height\n  // => back to (1)\n  // horizontalPreSSE = this.width / (2.0 * Math.tan(verticalFOV * 0.5) * this.width / this.height)\n  //                  = this.height / 2.0 * Math.tan(verticalFOV * 0.5)\n  //                  = verticalPreSSE\n\n  camera._preSSE = verticalPreSSE;\n}\n\nfunction Camera(crs, width, height) {\n  var _this = this;\n\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  Object.defineProperty(this, 'crs', {\n    get: function get() {\n      return crs;\n    }\n  });\n  this.camera3D = options.camera ? options.camera : new THREE.PerspectiveCamera(30, width / height);\n  this._viewMatrix = new THREE.Matrix4();\n  this.width = width;\n  this.height = height;\n  this._viewMatrixNeedsUpdate = true;\n  this.resize(width, height);\n  this._preSSE = Infinity;\n\n  if (this.camera3D.isPerspectiveCamera) {\n    var fov = this.camera3D.fov;\n    Object.defineProperty(this.camera3D, 'fov', {\n      get: function get() {\n        return fov;\n      },\n      set: function set(newFov) {\n        fov = newFov;\n        updatePreSse(_this, _this.height, fov);\n      }\n    });\n  }\n}\n\nCamera.prototype.resize = function (width, height) {\n  this.width = width;\n  this.height = height;\n  var ratio = width / height;\n  updatePreSse(this, this.height, this.camera3D.fov);\n\n  if (this.camera3D.aspect !== ratio) {\n    this.camera3D.aspect = ratio;\n\n    if (this.camera3D.isOrthographicCamera) {\n      var halfH = (this.camera3D.right - this.camera3D.left) * 0.5 / ratio;\n      var y = (this.camera3D.top + this.camera3D.bottom) * 0.5;\n      this.camera3D.top = y + halfH;\n      this.camera3D.bottom = y - halfH;\n    }\n  }\n\n  if (this.camera3D.updateProjectionMatrix) {\n    this.camera3D.updateProjectionMatrix();\n    this._viewMatrixNeedsUpdate = true;\n  }\n};\n\nCamera.prototype.update = function () {\n  // update matrix\n  this.camera3D.updateMatrixWorld();\n  this._viewMatrixNeedsUpdate = true;\n};\n/**\n * Return the position in the requested CRS, or in camera's CRS if undefined.\n * @param {string} crs if defined (e.g 'EPSG:4236') the camera position will be returned in this CRS\n * @return {Coordinates} Coordinates object holding camera's position\n */\n\n\nCamera.prototype.position = function (crs) {\n  return new _Coordinates[\"default\"](this.crs, this.camera3D.position).as(crs || this.crs);\n};\n/**\n * Set the position of the camera using a Coordinates object.\n * If you want to modify the position directly using x,y,z value then use camera.camera3D.position.set(x, y, z)\n * @param {Coordinates} position the new position of the camera\n */\n\n\nCamera.prototype.setPosition = function (position) {\n  this.camera3D.position.copy(position.as(this.crs));\n};\n\nvar tmp = {\n  frustum: new THREE.Frustum(),\n  matrix: new THREE.Matrix4(),\n  box3: new THREE.Box3()\n};\nvar points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n\nfunction projectBox3PointsInCameraSpace(camera, box3, matrixWorld) {\n  // Projects points in camera space\n  // We don't project directly on screen to avoid artifacts when projecting\n  // points behind the near plane.\n  var m = camera.camera3D.matrixWorldInverse;\n\n  if (matrixWorld) {\n    m = tmp.matrix.multiplyMatrices(camera.camera3D.matrixWorldInverse, matrixWorld);\n  }\n\n  points[0].set(box3.min.x, box3.min.y, box3.min.z).applyMatrix4(m);\n  points[1].set(box3.min.x, box3.min.y, box3.max.z).applyMatrix4(m);\n  points[2].set(box3.min.x, box3.max.y, box3.min.z).applyMatrix4(m);\n  points[3].set(box3.min.x, box3.max.y, box3.max.z).applyMatrix4(m);\n  points[4].set(box3.max.x, box3.min.y, box3.min.z).applyMatrix4(m);\n  points[5].set(box3.max.x, box3.min.y, box3.max.z).applyMatrix4(m);\n  points[6].set(box3.max.x, box3.max.y, box3.min.z).applyMatrix4(m);\n  points[7].set(box3.max.x, box3.max.y, box3.max.z).applyMatrix4(m); // In camera space objects are along the -Z axis\n  // So if min.z is > -near, the object is invisible\n\n  var atLeastOneInFrontOfNearPlane = false;\n\n  for (var i = 0; i < 8; i++) {\n    if (points[i].z <= -camera.camera3D.near) {\n      atLeastOneInFrontOfNearPlane = true;\n    } else {\n      // Clamp to near plane\n      points[i].z = -camera.camera3D.near;\n    }\n  }\n\n  return atLeastOneInFrontOfNearPlane ? points : undefined;\n}\n\nvar ndcBox3 = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));\n\nCamera.prototype.isBox3Visible = function (box3, matrixWorld) {\n  return this.box3SizeOnScreen(box3, matrixWorld).intersectsBox(ndcBox3);\n};\n\nCamera.prototype.isSphereVisible = function (sphere, matrixWorld) {\n  if (this._viewMatrixNeedsUpdate) {\n    // update visibility testing matrix\n    this._viewMatrix.multiplyMatrices(this.camera3D.projectionMatrix, this.camera3D.matrixWorldInverse);\n\n    this._viewMatrixNeedsUpdate = false;\n  }\n\n  if (matrixWorld) {\n    tmp.matrix.multiplyMatrices(this._viewMatrix, matrixWorld);\n    tmp.frustum.setFromMatrix(tmp.matrix);\n  } else {\n    tmp.frustum.setFromMatrix(this._viewMatrix);\n  }\n\n  return tmp.frustum.intersectsSphere(sphere);\n};\n\nCamera.prototype.box3SizeOnScreen = function (box3, matrixWorld) {\n  var pts = projectBox3PointsInCameraSpace(this, box3, matrixWorld); // All points are in front of the near plane -> box3 is invisible\n\n  if (!pts) {\n    return tmp.box3.makeEmpty();\n  } // Project points on screen\n\n\n  for (var i = 0; i < 8; i++) {\n    pts[i].applyMatrix4(this.camera3D.projectionMatrix);\n  }\n\n  return tmp.box3.setFromPoints(pts);\n};\n/**\n * Test for collision between camera and a geometry layer (DTM/DSM) to adjust camera position\n * It could be modified later to handle an array of geometry layers\n * TODO Improve Coordinates class to handle altitude for any coordinate system (even projected one)\n * @param {view} view where we test the collision between geometry layers and the camera\n * @param {elevationLayer} elevationLayer (DTM/DSM) used to test the collision with the camera. Could be another geometry layer\n * @param {minDistanceCollision} minDistanceCollision the minimum distance allowed between the camera and the surface\n */\n\n\nCamera.prototype.adjustAltitudeToAvoidCollisionWithLayer = function (view, elevationLayer, minDistanceCollision) {\n  // We put the camera location in geographic by default to easily handle altitude. (Should be improved in Coordinates class for all ref)\n  var camLocation = view.camera.position().as('EPSG:4326');\n\n  if (elevationLayer !== undefined) {\n    var elevationUnderCamera = _DEMUtils[\"default\"].getElevationValueAt(elevationLayer, camLocation);\n\n    if (elevationUnderCamera != undefined) {\n      var difElevation = camLocation.altitude - (elevationUnderCamera.z + minDistanceCollision); // We move the camera to avoid collisions if too close to terrain\n\n      if (difElevation < 0) {\n        camLocation.altitude = elevationUnderCamera.z + minDistanceCollision;\n        view.camera.camera3D.position.copy(camLocation.as(view.referenceCrs));\n        view.notifyChange(this.camera3D);\n      }\n    }\n  }\n};\n\nvar _default = Camera;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/Camera.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/ColorLayersOrdering.js":
/*!*****************************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/ColorLayersOrdering.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.COLOR_LAYERS_ORDER_CHANGED = void 0;\n\nvar _Layer = __webpack_require__(/*! ../Layer/Layer */ \"./node_modules/itowns/lib/Layer/Layer.js\");\n\nfunction updateLayersOrdering(geometryLayer, imageryLayers) {\n  var sequence = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);\n\n  var cO = function (object) {\n    if (object.material && object.material.setSequence) {\n      object.material.setSequence(sequence);\n    }\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = geometryLayer.level0Nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n      node.traverse(cO);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nvar COLOR_LAYERS_ORDER_CHANGED = 'layers-order-changed';\n/**\n * Utilitary to organize {@link ColorLayer} in a {@link View}.\n *\n * @module ColorLayersOrdering\n */\n\nexports.COLOR_LAYERS_ORDER_CHANGED = COLOR_LAYERS_ORDER_CHANGED;\nvar _default = {\n  /**\n   * Moves up in the layer list. This function has no effect if the layer is\n   * moved to its current index.\n   *\n   * @param {View} view - The view in which the layer is moved up.\n   * @param {string} layerId - The ID of the layer to move.\n   *\n   * @example\n   * itowns.ColorLayersOrdering.moveLayerUp(viewer, 'idLayerToUp');\n   */\n  moveLayerUp: function moveLayerUp(view, layerId) {\n    var imageryLayers = view.getLayers(function (l) {\n      return l.isColorLayer;\n    });\n    var layer = view.getLayerById(layerId);\n\n    if (layer) {\n      var previousSequence = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);\n\n      _Layer.ImageryLayers.moveLayerUp(layer, imageryLayers);\n\n      updateLayersOrdering(view.tileLayer, imageryLayers);\n      view.dispatchEvent({\n        type: COLOR_LAYERS_ORDER_CHANGED,\n        previous: {\n          sequence: previousSequence\n        },\n        \"new\": {\n          sequence: _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers)\n        }\n      });\n      view.notifyChange(view.tileLayer);\n    } else {\n      throw new Error(\"\".concat(layerId, \" isn't color layer\"));\n    }\n  },\n\n  /**\n   * Moves down in the layer list. This function has no effect if the layer is\n   * moved to its current index.\n   *\n   * @param {View} view - The view in which the layer is moved down.\n   * @param {string} layerId - The ID of the layer to move.\n   *\n   * @example\n   * itowns.ColorLayersOrdering.moveLayerDown(viewer, 'idLayerToDown');\n   */\n  moveLayerDown: function moveLayerDown(view, layerId) {\n    var imageryLayers = view.getLayers(function (l) {\n      return l.isColorLayer;\n    });\n    var layer = view.getLayerById(layerId);\n\n    if (layer) {\n      var previousSequence = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);\n\n      _Layer.ImageryLayers.moveLayerDown(layer, imageryLayers);\n\n      updateLayersOrdering(view.tileLayer, imageryLayers);\n      view.dispatchEvent({\n        type: COLOR_LAYERS_ORDER_CHANGED,\n        previous: {\n          sequence: previousSequence\n        },\n        \"new\": {\n          sequence: _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers)\n        }\n      });\n      view.notifyChange(view.tileLayer);\n    } else {\n      throw new Error(\"\".concat(layerId, \" isn't color layer\"));\n    }\n  },\n\n  /**\n   * Moves a specific layer to a specific index in the layer list. This\n   * function has no effect if the layer is moved to its current index.\n   *\n   * @param {View} view - The view in which the layer is moved.\n   * @param {string} layerId - The ID of the layer to move.\n   * @param {number} index - The index to move the layer to.\n   *\n   * @example\n   * itowns.ColorLayersOrdering.moveLayerToIndex(viewer, 'idLayerToChangeIndex', 2);\n   */\n  moveLayerToIndex: function moveLayerToIndex(view, layerId, index) {\n    var imageryLayers = view.getLayers(function (l) {\n      return l.isColorLayer;\n    });\n    var layer = view.getLayerById(layerId);\n\n    if (layer) {\n      var previousSequence = _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);\n\n      _Layer.ImageryLayers.moveLayerToIndex(layer, index, imageryLayers);\n\n      updateLayersOrdering(view.tileLayer, imageryLayers);\n      view.dispatchEvent({\n        type: COLOR_LAYERS_ORDER_CHANGED,\n        previous: {\n          sequence: previousSequence\n        },\n        \"new\": {\n          sequence: _Layer.ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers)\n        }\n      });\n      view.notifyChange(view.tileLayer);\n    } else {\n      throw new Error(\"\".concat(layerId, \" isn't color layer\"));\n    }\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/ColorLayersOrdering.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/LayeredMaterial.js":
/*!*************************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/LayeredMaterial.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unpack1K = unpack1K;\nexports.getMaxColorSamplerUnitsCount = getMaxColorSamplerUnitsCount;\nexports[\"default\"] = exports.ELEVATION_MODES = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _ShaderUtils = _interopRequireDefault(__webpack_require__(/*! ./Shader/ShaderUtils */ \"./node_modules/itowns/lib/Renderer/Shader/ShaderUtils.js\"));\n\nvar _Capabilities = _interopRequireDefault(__webpack_require__(/*! ../Core/System/Capabilities */ \"./node_modules/itowns/lib/Core/System/Capabilities.js\"));\n\nvar _RenderMode = _interopRequireDefault(__webpack_require__(/*! ./RenderMode */ \"./node_modules/itowns/lib/Renderer/RenderMode.js\"));\n\nvar _MaterialLayer = _interopRequireDefault(__webpack_require__(/*! ./MaterialLayer */ \"./node_modules/itowns/lib/Renderer/MaterialLayer.js\"));\n\n/* babel-plugin-inline-import './Shader/TileVS.glsl' */\nvar TileVS = \"#include <itowns/precision_qualifier>\\n#include <common>\\n#include <itowns/project_pars_vertex>\\n#include <itowns/elevation_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nattribute vec2      uv_0;\\n#if NUM_CRS > 1\\nattribute float     uv_1;\\n#endif\\nattribute vec3      normal;\\n\\nuniform mat4 modelMatrix;\\nuniform bool lightingEnabled;\\n\\n#if MODE == MODE_FINAL\\n#include <fog_pars_vertex>\\nvarying vec3        vUv;\\nvarying vec3        vNormal;\\n#endif\\nvoid main() {\\n        vec2 uv = vec2(uv_0.x, 1.0 - uv_0.y);\\n\\n        #include <begin_vertex>\\n        #include <itowns/elevation_vertex>\\n        #include <project_vertex>\\n        #include <logdepthbuf_vertex>\\n#if MODE == MODE_FINAL\\n        #include <fog_vertex>\\n        #if NUM_CRS > 1\\n        vUv = vec3(uv_0, (uv_1 > 0.) ? uv_1 : uv_0.y); // set uv_1 = uv_0 if uv_1 is undefined\\n        #else\\n        vUv = vec3(uv_0, 0.0);\\n        #endif\\n        vNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\\n#endif\\n}\\n\";\n\n/* babel-plugin-inline-import './Shader/TileFS.glsl' */\nvar TileFS = \"#include <itowns/precision_qualifier>\\n#include <logdepthbuf_pars_fragment>\\n#include <itowns/pitUV>\\n#include <itowns/color_layers_pars_fragment>\\n#if MODE == MODE_FINAL\\n#include <itowns/fog_pars_fragment>\\n#include <itowns/overlay_pars_fragment>\\n#include <itowns/lighting_pars_fragment>\\n#endif\\n#include <itowns/mode_pars_fragment>\\n\\nuniform vec3        diffuse;\\nuniform float       opacity;\\nvarying vec3        vUv; // uv_0.x/uv_1.x, uv_0.y, uv_1.y\\n\\nvoid main() {\\n    #include <logdepthbuf_fragment>\\n\\n#if MODE == MODE_ID\\n\\n    #include <itowns/mode_id_fragment>\\n\\n#elif MODE == MODE_DEPTH\\n\\n    #include <itowns/mode_depth_fragment>\\n\\n#else\\n\\n    gl_FragColor = vec4(diffuse, opacity);\\n\\n    uvs[0] = vec3(vUv.xy, 0.);\\n\\n#if NUM_CRS > 1\\n    uvs[1] = vec3(vUv.x, fract(vUv.z), floor(vUv.z));\\n#endif\\n\\n    vec4 color;\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_FS_TEXTURES; i ++ ) {\\n        color = getLayerColor( i , colorTextures[ i ], colorOffsetScales[ i ], colorLayers[ i ]);\\n        gl_FragColor.rgb = mix(gl_FragColor.rgb, color.rgb, color.a);\\n    }\\n\\n  #if defined(DEBUG)\\n    if (showOutline) {\\n        #pragma unroll_loop\\n        for ( int i = 0; i < NUM_CRS; i ++) {\\n            color = getOutlineColor( outlineColors[ i ], uvs[ i ].xy);\\n            gl_FragColor.rgb = mix(gl_FragColor.rgb, color.rgb, color.a);\\n        }\\n    }\\n  #endif\\n\\n    #include <itowns/fog_fragment>\\n    #include <itowns/lighting_fragment>\\n    #include <itowns/overlay_fragment>\\n\\n#endif\\n}\\n\";\nvar identityOffsetScale = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // from three.js packDepthToRGBA\n\nvar UnpackDownscale = 255 / 256; // 0..1 -> fraction (excluding 1)\n\nvar bitSh = new THREE.Vector4(UnpackDownscale / (256.0 * 256.0 * 256.0), UnpackDownscale / (256.0 * 256.0), UnpackDownscale / 256.0, UnpackDownscale);\n\nfunction unpack1K(color, factor) {\n  return factor ? bitSh.dot(color) * factor : bitSh.dot(color);\n} // Max sampler color count to LayeredMaterial\n// Because there's a statement limitation to unroll, in getColorAtIdUv method\n\n\nvar maxSamplersColorCount = 15;\nvar samplersElevationCount = 1;\n\nfunction getMaxColorSamplerUnitsCount() {\n  var maxSamplerUnitsCount = _Capabilities[\"default\"].getMaxTextureUnitsCount();\n\n  return Math.min(maxSamplerUnitsCount - samplersElevationCount, maxSamplersColorCount);\n}\n\nfunction _updateLayersUniforms(uniforms, olayers, max) {\n  // prepare convenient access to elevation or color uniforms\n  var layers = uniforms.layers.value;\n  var textures = uniforms.textures.value;\n  var offsetScales = uniforms.offsetScales.value;\n  var textureCount = uniforms.textureCount; // flatten the 2d array [i,j] -> layers[_layerIds[i]].textures[j]\n\n  var count = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = olayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var layer = _step.value;\n      layer.textureOffset = count;\n\n      for (var i = 0, il = layer.textures.length; i < il; ++i, ++count) {\n        if (count < max) {\n          offsetScales[count] = layer.offsetScales[i];\n          textures[count] = layer.textures[i];\n          layers[count] = layer;\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (count > max) {\n    console.warn(\"LayeredMaterial: Not enough texture units (\".concat(max, \" < \").concat(count, \"), excess textures have been discarded.\"));\n  }\n\n  textureCount.value = count;\n}\n\nfunction setDefineMapping(object, PROPERTY, mapping) {\n  Object.keys(mapping).forEach(function (key) {\n    object.defines[\"\".concat(PROPERTY, \"_\").concat(key)] = mapping[key];\n  });\n}\n\nfunction setDefineProperty(object, property, PROPERTY, initValue) {\n  object.defines[PROPERTY] = initValue;\n  Object.defineProperty(object, property, {\n    get: function get() {\n      return object.defines[PROPERTY];\n    },\n    set: function set(value) {\n      if (object.defines[PROPERTY] != value) {\n        object.defines[PROPERTY] = value;\n        object.needsUpdate = true;\n      }\n    }\n  });\n}\n\nfunction setUniformProperty(object, property, initValue) {\n  object.uniforms[property] = new THREE.Uniform(initValue);\n  Object.defineProperty(object, property, {\n    get: function get() {\n      return object.uniforms[property].value;\n    },\n    set: function set(value) {\n      if (object.uniforms[property].value != value) {\n        object.uniforms[property].value = value;\n      }\n    }\n  });\n}\n\nvar ELEVATION_MODES = {\n  RGBA: 0,\n  COLOR: 1,\n  DATA: 2\n};\nexports.ELEVATION_MODES = ELEVATION_MODES;\nvar nbSamplers;\nvar fragmentShader = [];\n\nvar LayeredMaterial =\n/*#__PURE__*/\nfunction (_THREE$RawShaderMater) {\n  (0, _inherits2[\"default\"])(LayeredMaterial, _THREE$RawShaderMater);\n\n  function LayeredMaterial() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var crsCount = arguments.length > 1 ? arguments[1] : undefined;\n    (0, _classCallCheck2[\"default\"])(this, LayeredMaterial);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(LayeredMaterial).call(this, options));\n    nbSamplers = nbSamplers || [samplersElevationCount, getMaxColorSamplerUnitsCount()];\n    _this.defines.NUM_VS_TEXTURES = nbSamplers[0];\n    _this.defines.NUM_FS_TEXTURES = nbSamplers[1];\n    _this.defines.USE_FOG = 1;\n    _this.defines.NUM_CRS = crsCount;\n    setDefineMapping((0, _assertThisInitialized2[\"default\"])(_this), 'ELEVATION', ELEVATION_MODES);\n    setDefineMapping((0, _assertThisInitialized2[\"default\"])(_this), 'MODE', _RenderMode[\"default\"].MODES);\n    setDefineProperty((0, _assertThisInitialized2[\"default\"])(_this), 'mode', 'MODE', _RenderMode[\"default\"].MODES.FINAL);\n\n    if (_Capabilities[\"default\"].isLogDepthBufferSupported()) {\n      _this.defines.USE_LOGDEPTHBUF = 1;\n      _this.defines.USE_LOGDEPTHBUF_EXT = 1;\n    }\n\n    _this.vertexShader = TileVS;\n    fragmentShader[crsCount] = fragmentShader[crsCount] || _ShaderUtils[\"default\"].unrollLoops(TileFS, _this.defines);\n    _this.fragmentShader = fragmentShader[crsCount]; // Color uniforms\n\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'diffuse', new THREE.Color(0.04, 0.23, 0.35));\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'opacity', _this.opacity); // Lighting uniforms\n\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'lightingEnabled', false);\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'lightPosition', new THREE.Vector3(-0.5, 0.0, 1.0)); // Misc properties\n\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'fogDistance', 1000000000.0);\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'fogColor', new THREE.Color(0.76, 0.85, 1.0));\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'overlayAlpha', 0);\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'overlayColor', new THREE.Color(1.0, 0.3, 0.0));\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'objectId', 0); // > 0 produces gaps,\n    // < 0 causes oversampling of textures\n    // = 0 causes sampling artefacts due to bad estimation of texture-uv gradients\n    // best is a small negative number\n\n    setUniformProperty((0, _assertThisInitialized2[\"default\"])(_this), 'minBorderDistance', -0.01); // LayeredMaterialLayers\n\n    _this.layers = [];\n    _this.elevationLayerIds = [];\n    _this.colorLayerIds = []; // elevation layer uniforms, to be updated using updateUniforms()\n\n    _this.uniforms.elevationLayers = new THREE.Uniform(new Array(nbSamplers[0]).fill({}));\n    _this.uniforms.elevationTextures = new THREE.Uniform(new Array(nbSamplers[0]).fill(null));\n    _this.uniforms.elevationOffsetScales = new THREE.Uniform(new Array(nbSamplers[0]).fill(identityOffsetScale));\n    _this.uniforms.elevationTextureCount = new THREE.Uniform(0); // color layer uniforms, to be updated using updateUniforms()\n\n    _this.uniforms.colorLayers = new THREE.Uniform(new Array(nbSamplers[1]).fill({}));\n    _this.uniforms.colorTextures = new THREE.Uniform(new Array(nbSamplers[1]).fill(null));\n    _this.uniforms.colorOffsetScales = new THREE.Uniform(new Array(nbSamplers[1]).fill(identityOffsetScale));\n    _this.uniforms.colorTextureCount = new THREE.Uniform(0);\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(LayeredMaterial, [{\n    key: \"getUniformByType\",\n    value: function getUniformByType(type) {\n      return {\n        layers: this.uniforms[\"\".concat(type, \"Layers\")],\n        textures: this.uniforms[\"\".concat(type, \"Textures\")],\n        offsetScales: this.uniforms[\"\".concat(type, \"OffsetScales\")],\n        textureCount: this.uniforms[\"\".concat(type, \"TextureCount\")]\n      };\n    }\n  }, {\n    key: \"updateLayersUniforms\",\n    value: function updateLayersUniforms() {\n      var _this2 = this;\n\n      var colorlayers = this.layers.filter(function (l) {\n        return _this2.colorLayerIds.includes(l.id) && l.visible && l.opacity > 0;\n      });\n      colorlayers.sort(function (a, b) {\n        return _this2.colorLayerIds.indexOf(a.id) - _this2.colorLayerIds.indexOf(b.id);\n      });\n\n      _updateLayersUniforms(this.getUniformByType('color'), colorlayers, this.defines.NUM_FS_TEXTURES);\n\n      if (this.elevationLayerIds.some(function (id) {\n        return _this2.getLayer(id);\n      }) || this.uniforms.elevationTextureCount.value && !this.elevationLayerIds.length) {\n        var elevationLayer = this.getElevationLayer() ? [this.getElevationLayer()] : [];\n\n        _updateLayersUniforms(this.getUniformByType('elevation'), elevationLayer, this.defines.NUM_VS_TEXTURES);\n      }\n\n      this.layersNeedUpdate = false;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: 'dispose'\n      });\n      this.layers.forEach(function (l) {\n        return l.dispose(false);\n      });\n      this.layers.length = 0;\n      this.layersNeedUpdate = true;\n    } // TODO: rename to setColorLayerIds and add setElevationLayerIds ?\n\n  }, {\n    key: \"setSequence\",\n    value: function setSequence(sequenceLayer) {\n      this.colorLayerIds = sequenceLayer;\n      this.layersNeedUpdate = true;\n    }\n  }, {\n    key: \"setSequenceElevation\",\n    value: function setSequenceElevation(layerId) {\n      this.elevationLayerIds[0] = layerId;\n      this.layersNeedUpdate = true;\n    }\n  }, {\n    key: \"removeLayer\",\n    value: function removeLayer(layerId) {\n      var index = this.layers.findIndex(function (l) {\n        return l.id === layerId;\n      });\n\n      if (index > -1) {\n        this.layers[index].dispose();\n        this.layers.splice(index, 1);\n        var idSeq = this.colorLayerIds.indexOf(layerId);\n\n        if (idSeq > -1) {\n          this.colorLayerIds.splice(idSeq, 1);\n        } else {\n          this.elevationLayerIds = [];\n        }\n      }\n    }\n  }, {\n    key: \"addLayer\",\n    value: function addLayer(layer) {\n      if (layer.id in this.layers) {\n        console.warn('The \"{layer.id}\" layer was already present in the material, overwritting.');\n      }\n\n      var lml = new _MaterialLayer[\"default\"](this, layer);\n      this.layers.push(lml);\n\n      if (layer.isColorLayer) {\n        this.setSequence(layer.parent.colorLayersOrder);\n      } else {\n        this.setSequenceElevation(layer.id);\n      }\n\n      return lml;\n    }\n  }, {\n    key: \"getLayer\",\n    value: function getLayer(id) {\n      return this.layers.find(function (l) {\n        return l.id === id;\n      });\n    }\n  }, {\n    key: \"getLayers\",\n    value: function getLayers(ids) {\n      return this.layers.filter(function (l) {\n        return ids.includes(l.id);\n      });\n    }\n  }, {\n    key: \"getElevationLayer\",\n    value: function getElevationLayer() {\n      var _this3 = this;\n\n      return this.layers.find(function (l) {\n        return l.id === _this3.elevationLayerIds[0];\n      });\n    }\n  }, {\n    key: \"setElevationScale\",\n    value: function setElevationScale(scale) {\n      if (this.elevationLayerIds.length) {\n        this.getElevationLayer().scale = scale;\n      }\n    }\n  }]);\n  return LayeredMaterial;\n}(THREE.RawShaderMaterial);\n\nvar _default = LayeredMaterial;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/LayeredMaterial.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/MaterialLayer.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/MaterialLayer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.EMPTY_TEXTURE_ZOOM = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _LayeredMaterial = __webpack_require__(/*! ./LayeredMaterial */ \"./node_modules/itowns/lib/Renderer/LayeredMaterial.js\");\n\nvar _XbilParser = __webpack_require__(/*! ../Parser/XbilParser */ \"./node_modules/itowns/lib/Parser/XbilParser.js\");\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\nvar EMPTY_TEXTURE_ZOOM = -1;\nexports.EMPTY_TEXTURE_ZOOM = EMPTY_TEXTURE_ZOOM;\nvar pitch = new THREE.Vector4();\n\nfunction defineLayerProperty(layer, property, initValue, defaultValue) {\n  var _value = initValue !== undefined ? initValue : defaultValue;\n\n  Object.defineProperty(layer, property, {\n    get: function get() {\n      return _value;\n    },\n    set: function set(value) {\n      if (_value !== value) {\n        _value = value;\n      }\n    }\n  });\n}\n\nvar MaterialLayer =\n/*#__PURE__*/\nfunction () {\n  function MaterialLayer(material, layer) {\n    var _this = this;\n\n    (0, _classCallCheck2[\"default\"])(this, MaterialLayer);\n    this.id = layer.id;\n    this.textureOffset = 0; // will be updated in updateUniforms()\n\n    this.crs = layer.parent.tileMatrixSets.indexOf(_Crs[\"default\"].formatToTms(layer.projection));\n\n    if (this.crs == -1) {\n      console.error('Unknown crs:', layer.projection);\n    } // Define color properties\n\n\n    var _valueOpacity = layer.opacity !== undefined ? layer.opacity : true;\n\n    Object.defineProperty(this, 'opacity', {\n      get: function get() {\n        return _valueOpacity;\n      },\n      set: function set(value) {\n        if (_valueOpacity !== value) {\n          if (value === 0 || _valueOpacity === 0) {\n            _this.material.layersNeedUpdate = true;\n          }\n\n          _valueOpacity = value;\n        }\n      }\n    });\n\n    var _valueVisibility = layer.visible !== undefined ? layer.visible : true;\n\n    Object.defineProperty(this, 'visible', {\n      get: function get() {\n        return _valueVisibility;\n      },\n      set: function set(value) {\n        if (_valueVisibility !== value) {\n          _this.material.layersNeedUpdate = true;\n          _valueVisibility = value;\n        }\n      }\n    });\n    defineLayerProperty(this, 'effect', layer.fx, 0);\n    var defaultEle = {\n      bias: 0,\n      scale: 1,\n      mode: _LayeredMaterial.ELEVATION_MODES.DATA,\n      zmin: 0,\n      zmax: Infinity\n    };\n    var scaleFactor = 1.0; // Define elevation properties\n\n    if (layer.useRgbaTextureElevation) {\n      defaultEle.mode = _LayeredMaterial.ELEVATION_MODES.RGBA;\n      defaultEle.zmax = 5000;\n      throw new Error('Restore this feature');\n    } else if (layer.useColorTextureElevation) {\n      scaleFactor = layer.colorTextureElevationMaxZ - layer.colorTextureElevationMinZ;\n      defaultEle.mode = _LayeredMaterial.ELEVATION_MODES.COLOR;\n      defaultEle.bias = layer.colorTextureElevationMinZ;\n    }\n\n    defineLayerProperty(this, 'bias', layer.bias, defaultEle.bias);\n    defineLayerProperty(this, 'scale', layer.scale * scaleFactor, defaultEle.scale * scaleFactor);\n    defineLayerProperty(this, 'mode', layer.mode, defaultEle.mode);\n    defineLayerProperty(this, 'zmin', layer.zmin, defaultEle.zmin);\n    defineLayerProperty(this, 'zmax', layer.zmax, defaultEle.zmax);\n    this.textures = [];\n    this.offsetScales = [];\n    this.level = EMPTY_TEXTURE_ZOOM;\n    this.material = material;\n  }\n\n  (0, _createClass2[\"default\"])(MaterialLayer, [{\n    key: \"initFromParent\",\n    value: function initFromParent(parent, extents) {\n      if (parent && parent.level > this.level) {\n        var index = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = extents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var c = _step.value;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = parent.textures[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var texture = _step2.value;\n\n                if (c.isInside(texture.extent)) {\n                  this.setTexture(index++, texture, c.offsetToParent(texture.extent));\n                  break;\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                  _iterator2[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"replaceNoDataValueFromParent\",\n    value: function replaceNoDataValueFromParent(parent, nodatavalue) {\n      var dataElevation = this.textures[0].image.data;\n      var parentTexture = parent && parent.textures[0];\n\n      if (dataElevation && parentTexture && !(0, _XbilParser.checkNodeElevationTextureValidity)(dataElevation, nodatavalue)) {\n        var extent = this.textures[0].extent;\n        extent.offsetToParent(parentTexture.extent, pitch);\n        (0, _XbilParser.insertSignificantValuesFromParent)(dataElevation, parentTexture.image.data, nodatavalue, pitch);\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      // TODO: WARNING  verify if textures to dispose aren't attached with ancestor\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.textures[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var texture = _step3.value;\n\n          if (texture.isTexture) {\n            texture.dispose();\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      this.level = EMPTY_TEXTURE_ZOOM;\n      this.textures = [];\n      this.offsetScales = [];\n      this.material.layersNeedUpdate = true;\n    }\n  }, {\n    key: \"setTexture\",\n    value: function setTexture(index, texture, offsetScale) {\n      this.level = texture && index == 0 ? texture.extent.zoom : this.level;\n      this.textures[index] = texture || null;\n      this.offsetScales[index] = offsetScale;\n      this.material.layersNeedUpdate = true;\n    }\n  }, {\n    key: \"setTextures\",\n    value: function setTextures(textures, pitchs) {\n      this.dispose(false);\n\n      for (var i = 0, il = textures.length; i < il; ++i) {\n        this.setTexture(i, textures[i], pitchs[i]);\n      }\n    }\n  }]);\n  return MaterialLayer;\n}();\n\nvar _default = MaterialLayer;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/MaterialLayer.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/OBB.js":
/*!*************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/OBB.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ \"./node_modules/@babel/runtime/helpers/get.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _TileGeometry = _interopRequireDefault(__webpack_require__(/*! ../Core/TileGeometry */ \"./node_modules/itowns/lib/Core/TileGeometry.js\"));\n\nvar _BuilderEllipsoidTile = _interopRequireDefault(__webpack_require__(/*! ../Core/Prefab/Globe/BuilderEllipsoidTile */ \"./node_modules/itowns/lib/Core/Prefab/Globe/BuilderEllipsoidTile.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\n// get oriented bounding box of tile\nvar builder = new _BuilderEllipsoidTile[\"default\"]({\n  projection: 'EPSG:4978',\n  uvCount: 1\n});\nvar size = new THREE.Vector3();\nvar dimension = new THREE.Vector2();\nvar center = new THREE.Vector3();\nvar coord = new _Coordinates[\"default\"]('EPSG:4326', 0, 0, 0);\n\nvar OBB =\n/*#__PURE__*/\nfunction (_THREE$Object3D) {\n  (0, _inherits2[\"default\"])(OBB, _THREE$Object3D);\n\n  /**\n   * Oriented bounding box\n   * @constructor\n   * @extends THREE.Object3D\n   * @param {THREE.Vector3}  min representing the lower (x, y, z) boundary of the box. Default is ( + Infinity, + Infinity, + Infinity ).\n   * @param {THREE.Vector3}  max representing the lower upper (x, y, z) boundary of the box. Default is ( - Infinity, - Infinity, - Infinity ).\n   */\n  function OBB() {\n    var _this;\n\n    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new THREE.Vector3(+Infinity, +Infinity, +Infinity);\n    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3(-Infinity, -Infinity, -Infinity);\n    (0, _classCallCheck2[\"default\"])(this, OBB);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(OBB).call(this));\n    _this.box3D = new THREE.Box3(min.clone(), max.clone());\n    _this.natBox = _this.box3D.clone();\n    _this.z = {\n      min: 0,\n      max: 0,\n      scale: 1.0\n    };\n    return (0, _possibleConstructorReturn2[\"default\"])(_this, (0, _assertThisInitialized2[\"default\"])(_this));\n  }\n  /**\n   * Creates a new instance of the object with same properties than original.\n   *\n   * @return     {OBB}  Copy of this object.\n   */\n\n\n  (0, _createClass2[\"default\"])(OBB, [{\n    key: \"clone\",\n    value: function clone() {\n      return new OBB().copy(this);\n    }\n    /**\n     * Copy the property of OBB\n     *\n     * @param      {OBB}  cOBB OBB to copy\n     * @return     {OBB}  the copy\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(cOBB) {\n      (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(OBB.prototype), \"copy\", this).call(this, cOBB);\n      this.box3D.copy(cOBB.box3D);\n      this.natBox.copy(cOBB.natBox);\n      this.z.min = cOBB.z.min;\n      this.z.max = cOBB.z.max;\n      this.z.scale = cOBB.z.scale;\n      return this;\n    }\n    /**\n     * Update the top point world\n     *\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.updateMatrixWorld(true);\n    }\n    /**\n     * Update z min and z max of oriented bounding box\n     *\n     * @param {number}  min The minimum of oriented bounding box\n     * @param {number}  max The maximum of oriented bounding box\n     * @param {number} scale\n     */\n\n  }, {\n    key: \"updateZ\",\n    value: function updateZ(min, max) {\n      var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.z.scale;\n      this.z = {\n        min: min,\n        max: max,\n        scale: scale,\n        delta: Math.abs(max - min) * scale\n      };\n      this.box3D.min.z = this.natBox.min.z + min * scale;\n      this.box3D.max.z = this.natBox.max.z + max * scale;\n    }\n  }, {\n    key: \"updateScaleZ\",\n    value: function updateScaleZ(scale) {\n      if (scale > 0) {\n        this.updateZ(this.z.min, this.z.max, scale);\n      }\n    }\n    /**\n     * Set bouding box value to points\n     *\n     * @param      {Array<THREE.Vector3>}  points  The points to set\n     * @return     {Array<THREE.Vector3>}  The points seted\n     */\n\n  }, {\n    key: \"toPoints\",\n    value: function toPoints(points) {\n      // top points of bounding box\n      points[0].set(this.box3D.max.x, this.box3D.max.y, this.box3D.max.z);\n      points[1].set(this.box3D.min.x, this.box3D.max.y, this.box3D.max.z);\n      points[2].set(this.box3D.min.x, this.box3D.min.y, this.box3D.max.z);\n      points[3].set(this.box3D.max.x, this.box3D.min.y, this.box3D.max.z);\n      points[4].set(this.box3D.max.x, this.box3D.max.y, this.box3D.min.z);\n      points[5].set(this.box3D.min.x, this.box3D.max.y, this.box3D.min.z);\n      points[6].set(this.box3D.min.x, this.box3D.min.y, this.box3D.min.z);\n      points[7].set(this.box3D.max.x, this.box3D.min.y, this.box3D.min.z);\n      return points;\n    }\n    /**\n     * Determines if the sphere is above the XY space of the box\n     *\n     * @param      {Sphere}   sphere  The sphere\n     * @return     {boolean}  True if sphere is above the XY space of the box, False otherwise.\n     */\n\n  }, {\n    key: \"isSphereAboveXYBox\",\n    value: function isSphereAboveXYBox(sphere) {\n      var localSpherePosition = this.worldToLocal(sphere.center); // get obb closest point to sphere center by clamping\n\n      var x = Math.max(this.box3D.min.x, Math.min(localSpherePosition.x, this.box3D.max.x));\n      var y = Math.max(this.box3D.min.y, Math.min(localSpherePosition.y, this.box3D.max.y)); // this is the same as isPointInsideSphere.position\n\n      var distance = Math.sqrt((x - localSpherePosition.x) * (x - localSpherePosition.x) + (y - localSpherePosition.y) * (y - localSpherePosition.y));\n      return distance < sphere.radius;\n    }\n    /**\n     * Compute OBB from extent.\n     * The OBB resulted can be only in the system 'EPSG:3946'.\n     *\n     * @param      {Extent}        extent     The extent (with crs 'EPSG:4326') to compute oriented bounding box\n     * @param      {number}        minHeight  The minimum height of OBB\n     * @param      {number}        maxHeight  The maximum height of OBB\n     * @return     {OBB}           return this object\n     */\n\n  }, {\n    key: \"setFromExtent\",\n    value: function setFromExtent(extent) {\n      var minHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : extent.min || 0;\n      var maxHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : extent.max || 0;\n\n      if (extent.crs == 'EPSG:4326') {\n        var _builder$computeShara = builder.computeSharableExtent(extent),\n            sharableExtent = _builder$computeShara.sharableExtent,\n            quaternion = _builder$computeShara.quaternion,\n            position = _builder$computeShara.position; // Compute the minimum count of segment to build tile\n\n\n        var segment = Math.max(Math.floor(sharableExtent.dimensions(dimension).x / 90 + 1), 2);\n        var geometry = new _TileGeometry[\"default\"]({\n          extent: sharableExtent,\n          level: 0,\n          segment: segment,\n          disableSkirt: true,\n          builder: builder\n        });\n        this.copy(builder.OBB(geometry.boundingBox));\n        this.updateZ(minHeight, maxHeight);\n        this.position.copy(position);\n        this.quaternion.copy(quaternion);\n        this.updateMatrixWorld(true);\n      } else if (!extent.isTiledCrs() && _Crs[\"default\"].isMetricUnit(extent.crs)) {\n        extent.center(coord).toVector3(this.position);\n        extent.dimensions(dimension);\n        size.set(dimension.x, dimension.y, Math.abs(maxHeight - minHeight));\n        this.box3D.setFromCenterAndSize(center, size);\n        this.updateMatrixWorld(true);\n      } else {\n        throw new Error('Unsupported extent crs');\n      }\n\n      return this;\n    }\n  }]);\n  return OBB;\n}(THREE.Object3D);\n\nvar _default = OBB;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/OBB.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/OrientedImageCamera.js":
/*!*****************************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/OrientedImageCamera.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ \"./node_modules/@babel/runtime/helpers/get.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar Distortion =\n/*#__PURE__*/\nfunction () {\n  function Distortion(size) {\n    (0, _classCallCheck2[\"default\"])(this, Distortion);\n    this.size = size;\n    this.pps = null;\n    this.polynom = null;\n    this.l1l2 = null;\n  }\n\n  (0, _createClass2[\"default\"])(Distortion, [{\n    key: \"setFromMicmacCalibration\",\n    value: function setFromMicmacCalibration(distortion) {\n      var imageYDown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.pps = new THREE.Vector2().fromArray(distortion.pps);\n      this.polynom = new THREE.Vector4().fromArray(distortion.poly357);\n      this.l1l2 = new THREE.Vector3(); // inverse Y pps convention image micmac\n\n      this.pps.y = imageYDown ? this.size.y - this.pps.y : this.pps.y;\n      this.polynom.w = Math.pow(distortion.limit, 2);\n\n      if (distortion.l1l2) {\n        this.l1l2.fromArray(distortion.l1l2);\n        this.l1l2.z = distortion.etats;\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var dest = new Distortion(this.size.clone());\n      dest.pps = this.pps.clone();\n      dest.polynom = this.polynom.clone();\n      dest.l1l2 = this.l1l2.clone();\n      return dest;\n    }\n  }]);\n  return Distortion;\n}();\n\nvar zoom = new THREE.Vector3();\n/**\n * @classdesc OrientedImageCamera is a ThreeJs camera adapted to photogrammetric description.\n * So we can build a ThreeJs perspective camera from size and focal information.\n */\n\nvar OrientedImageCamera =\n/*#__PURE__*/\nfunction (_THREE$PerspectiveCam) {\n  (0, _inherits2[\"default\"])(OrientedImageCamera, _THREE$PerspectiveCam);\n\n  /**\n   * @constructor\n   * @param {number|Vector2} size - image size in pixels (default: x=1024, y=x)\n   * @param {number|Vector2} focal - focal length in pixels (default: x=1024, y=x)\n   * @param {Vector2} center - principal point in pixels (default: size/2)\n   * @param {number} near - Camera frustum near plane (default: see THREE.PerspectiveCamera).\n   * @param {number} far - Camera frustum far plane (default: see THREE.PerspectiveCamera).\n   * @param {number} skew - shear transform parameter (default: 0)\n   * @param {number} aspect - aspect ratio of the camera (default: size.x/size.y).\n   */\n  function OrientedImageCamera() {\n    var _this;\n\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n    var focal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n    var center = arguments.length > 2 ? arguments[2] : undefined;\n    var near = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;\n    var far = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 10000;\n    var skew = arguments.length > 5 ? arguments[5] : undefined;\n    var aspect = arguments.length > 6 ? arguments[6] : undefined;\n    (0, _classCallCheck2[\"default\"])(this, OrientedImageCamera);\n    size = size.isVector2 ? size : new THREE.Vector2(size, size);\n    aspect = aspect || size.x / size.y;\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(OrientedImageCamera).call(this, undefined, aspect, near, far));\n    _this.size = size;\n    _this.focal = focal.isVector2 ? focal : new THREE.Vector2(focal, focal);\n    _this.center = center || size.clone().multiplyScalar(0.5);\n    _this.skew = skew || 0;\n    _this.textureMatrixWorldInverse = new THREE.Matrix4();\n    Object.defineProperty((0, _assertThisInitialized2[\"default\"])(_this), 'fov', {\n      get: function get() {\n        return 2 * THREE.Math.radToDeg(Math.atan2(_this.size.y, 2 * _this.focal.y));\n      },\n      // setting the fov overwrites focal.x and focal.y\n      set: function set(fov) {\n        var focal = 0.5 * _this.size.y / Math.tan(THREE.Math.degToRad(fov * 0.5));\n        _this.focal.x = focal;\n        _this.focal.y = focal;\n      }\n    });\n    _this.distortion = new Distortion(_this.size);\n    _this.maskPath = undefined;\n    _this.mask = undefined;\n\n    _this.updateProjectionMatrix();\n\n    return _this;\n  } // we override PerspectiveCamera.updateProjectionMatrix to\n  // update the projection matrix depending on other variables\n  // focal, center and size...\n\n\n  (0, _createClass2[\"default\"])(OrientedImageCamera, [{\n    key: \"updateProjectionMatrix\",\n    value: function updateProjectionMatrix() {\n      if (!this.focal) {\n        return;\n      }\n\n      var near = this.near;\n      var sx = near / this.focal.x;\n      var sy = near / this.focal.y;\n      var left = -sx * this.center.x;\n      var bottom = -sy * this.center.y;\n      var right = left + sx * this.size.x;\n      var top = bottom + sy * this.size.y;\n      this.projectionMatrix.makePerspective(left, right, top, bottom, near, this.far);\n      this.projectionMatrix.elements[4] = 2 * this.skew / this.size.x; // take zoom and aspect into account\n\n      var textureAspect = this.size.x / this.size.y;\n      var aspectRatio = this.aspect / textureAspect;\n      zoom.set(this.zoom, this.zoom, 1);\n\n      if (aspectRatio > 1) {\n        zoom.x /= aspectRatio;\n      } else {\n        zoom.y *= aspectRatio;\n      }\n\n      this.projectionMatrix.scale(zoom);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source, recursive) {\n      (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(OrientedImageCamera.prototype), \"copy\", this).call(this, source, recursive);\n      this.size = source.size.clone();\n      this.focal = source.focal.clone();\n      this.center = source.center.clone();\n      this.distortion = source.distortion.clone();\n      this.textureMatrixWorldInverse = source.textureMatrixWorldInverse.clone();\n      this.skew = source.skew;\n      this.maskPath = source.maskPath;\n      this.mask = source.mask;\n      return this;\n    }\n  }]);\n  return OrientedImageCamera;\n}(THREE.PerspectiveCamera);\n\nvar _default = OrientedImageCamera;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/OrientedImageCamera.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/OrientedImageMaterial.js":
/*!*******************************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/OrientedImageMaterial.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Capabilities = _interopRequireDefault(__webpack_require__(/*! ../Core/System/Capabilities */ \"./node_modules/itowns/lib/Core/System/Capabilities.js\"));\n\nvar _ShaderUtils = _interopRequireDefault(__webpack_require__(/*! ./Shader/ShaderUtils */ \"./node_modules/itowns/lib/Renderer/Shader/ShaderUtils.js\"));\n\n/* babel-plugin-inline-import './Shader/ProjectiveTextureVS.glsl' */\nvar textureVS = \"#include <itowns/precision_qualifier>\\n#include <itowns/project_pars_vertex>\\n#include <itowns/projective_texturing_pars_vertex>\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n\\nvarying vec3 vNormal;\\nattribute vec3 normal;\\n\\nvoid main() {\\n    #include <begin_vertex>\\n    #include <project_vertex>\\n    vNormal = normal;\\n    #include <itowns/projective_texturing_vertex>\\n    #include <logdepthbuf_vertex>\\n}\\n\";\n\n/* babel-plugin-inline-import './Shader/ProjectiveTextureFS.glsl' */\nvar textureFS = \"#include <itowns/precision_qualifier>\\n#include <logdepthbuf_pars_fragment>\\n#include <itowns/projective_texturing_pars_fragment>\\nvarying vec3 vNormal;\\n\\n#ifdef USE_BASE_MATERIAL\\nstruct noPT {\\n    vec3 lightDirection;\\n    vec3 ambient;\\n    float opacity;\\n};\\n\\nuniform noPT noProjectiveMaterial;\\n#endif\\n\\nvoid main(void)\\n{\\n    #include <logdepthbuf_fragment>\\n    #ifdef USE_BASE_MATERIAL\\n    float nDotVP = (max(0.1, dot(vNormal, normalize(noProjectiveMaterial.lightDirection))));\\n    vec4 color = vec4(noProjectiveMaterial.ambient + nDotVP, 0.0);\\n    #else\\n    vec4 color = vec4(0.0);\\n    #endif\\n\\n    #pragma unroll_loop\\n    for (int i = 0; i < ORIENTED_IMAGES_COUNT; i++) {\\n        color = projectiveTextureColor(projectiveTextureCoords[ ORIENTED_IMAGES_COUNT - 1 - i ], projectiveTextureDistortion[ ORIENTED_IMAGES_COUNT - 1 - i ], projectiveTexture[ ORIENTED_IMAGES_COUNT - 1 - i ], mask[ORIENTED_IMAGES_COUNT - 1 - i], color);\\n    }\\n\\n    #ifdef USE_BASE_MATERIAL\\n    color.a = color.a < 1.0 ? max(noProjectiveMaterial.opacity, color.a) : 1.0 ;\\n    gl_FragColor = vec4(color.rgb, color.a * opacity);\\n    #else\\n    gl_FragColor = vec4(color.rgb / color.a, opacity);\\n    #endif\\n\\n}\\n\";\nvar ndcToTextureMatrix = new THREE.Matrix4().set(1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 2, 0, 0, 0, 0, 2);\nvar noMask = new THREE.DataTexture(new Uint8Array([255, 255, 255]), 1, 1, THREE.RGBFormat, THREE.UnsignedByteType);\nvar noTexture = new THREE.Texture();\nvar rawShaderMaterial = new THREE.RawShaderMaterial();\n/**\n * @classdesc OrientedImageMaterial is a custom shader material used to do projective texture mapping.<br/>\n *\n * This Material is designed to project many textures simultaneously.\n * Each projected texture setting is stored as an {@link OrientedImageCamera}.<br/>\n * <br/>\n * All cameras settings, like distorsion, can be specified in a configuration file.\n * See [CameraCalibrationParser]{@link module:CameraCalibrationParser.parse}\n * used to parse a configuration file and create an array of camera.<br/>\n * <br/>\n * The current implementation supports the following distortion models : <br/>\n *  - no distortion (polynom==vec3(0),l1l2==vec2(0))<br/>\n *  - radial distortion (polynom!=vec3(0),l1l2==vec2(0)) (see <b>15.2.2 Radial Model</b> in [MicMac doc]{@link https://github.com/micmacIGN/Documentation/blob/master/DocMicMac.pdf}) </br>\n *  - equilinear fish eye distortion (polynom!=vec3(0),l1l2 != vec2(0)) (see <b>15.3.4 Fish eye models</b> in [MicMac doc]{@link https://github.com/micmacIGN/Documentation/blob/master/DocMicMac.pdf}) </br>\n * (Note: radial decentric parameters P1 are P2 not supported and assumed to be 0).<br/>\n * <br/>\n * To get a more comprehensive support of camera Micmac models, you can consider using [three-photogrammetric-camera]{@link https://github.com/mbredif/three-photogrammetric-camera} instead.\n */\n\nvar OrientedImageMaterial =\n/*#__PURE__*/\nfunction (_THREE$RawShaderMater) {\n  (0, _inherits2[\"default\"])(OrientedImageMaterial, _THREE$RawShaderMater);\n\n  /**\n   * @constructor\n   * @param { OrientedImageCamera[]} cameras - Array of {@link OrientedImageCamera}. Each camera will project a texture.\n   * [CameraCalibrationParser]{@link module:CameraCalibrationParser.parse} can used to create this array of camera from a configuration file.\n   * @param {Object} [options={}] - Object with one or more properties defining the material's appearance.\n   * Any property of the material (including any property inherited from\n   * [THREE.Material]{@link https://threejs.org/docs/#api/en/materials/Material} and\n   * [THREE.ShaderMaterial]{@link https://threejs.org/docs/#api/en/materials/ShaderMaterial}) can be passed in here.\n   * @param {Number} [options.side=THREE.DoubleSide] - We override default\n   * [THREE.Material.side]{@link https://threejs.org/docs/#api/en/materials/Material.side} from FrontSide to DoubleSide.\n   * @param {Boolean} [options.transparent=true] - We override default\n   * [THREE.Material.transparent]{@link https://threejs.org/docs/#api/en/materials/Material.transparent} from false to true.\n   * @param {Number} [options.opacity=0.1] - We override default\n   * [THREE.Material.opacity]{@link https://threejs.org/docs/#api/en/materials/Material.opacity} from 1 to 0.1.\n   * @param {Number} [options.alphaBorder=20] - Part of the texture that is blended, when texture crosses each other.\n   * For example, 10 means a border as large as 1 / 10 of the size of the texture is used to blend colors.\n   * @param {Number} [options.debugAlphaBorder=0] - Set this option to 1 to see influence of alphaBorder option.\n   */\n  function OrientedImageMaterial(cameras) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, OrientedImageMaterial);\n    options.side = options.side !== undefined ? options.side : THREE.DoubleSide;\n    options.transparent = options.transparent !== undefined ? options.transparent : true;\n    options.opacity = options.opacity !== undefined ? options.opacity : 1; // Filter the rawShaderMaterial options\n\n    var rawShaderMaterialOptions = {};\n\n    for (var key in options) {\n      if (Object.prototype.hasOwnProperty.call(options, key)) {\n        var currentValue = rawShaderMaterial[key];\n\n        if (currentValue !== undefined) {\n          rawShaderMaterialOptions[key] = options[key];\n        }\n      }\n    }\n\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(OrientedImageMaterial).call(this, rawShaderMaterialOptions));\n    _this.defines.ORIENTED_IMAGES_COUNT = options.OrientedImagesCount !== undefined ? options.OrientedImagesCount : cameras.length; // verify that number of textures doesn't exceed GPU capabilities\n\n    var maxTexturesUnits = _Capabilities[\"default\"].getMaxTextureUnitsCount();\n\n    if (_this.defines.ORIENTED_IMAGES_COUNT > maxTexturesUnits) {\n      console.warn(\"OrientedImageMaterial: Can't project \".concat(cameras.length, \" textures, because it's more than GPU capabilities maximum texture units (\").concat(maxTexturesUnits, \")\")); // Clamp number of textures used\n\n      _this.defines.ORIENTED_IMAGES_COUNT = maxTexturesUnits - 1;\n      console.warn(\"OrientedImageMaterial: We'll use only the first \".concat(_this.defines.ORIENTED_IMAGES_COUNT, \" cameras.\"));\n    }\n\n    if (options.useBaseMaterial) {\n      _this.defines.USE_BASE_MATERIAL = true;\n    }\n\n    _this.defines.USE_DISTORTION = Number(cameras.some(function (camera) {\n      return camera.distortion.pps !== null;\n    }));\n    _this.alphaBorder = options.alphaBorder | 20;\n    _this.defines.DEBUG_ALPHA_BORDER = options.debugAlphaBorder | 0;\n    _this.cameras = cameras;\n    var textureMatrix = [];\n    var texture = [];\n    var mask = [];\n    var distortion = [];\n    _this.group = new THREE.Group();\n\n    for (var i = 0; i < _this.defines.ORIENTED_IMAGES_COUNT; ++i) {\n      texture[i] = noTexture;\n      mask[i] = noMask;\n      textureMatrix[i] = new THREE.Matrix4();\n      cameras[i].needsUpdate = true;\n      distortion[i] = cameras[i].distortion;\n\n      _this.group.add(cameras[i]);\n    }\n\n    _this.uniforms.opacity = new THREE.Uniform(_this.opacity);\n    _this.uniforms.projectiveTextureAlphaBorder = new THREE.Uniform(_this.alphaBorder);\n    _this.uniforms.projectiveTextureDistortion = new THREE.Uniform(distortion);\n    _this.uniforms.projectiveTextureMatrix = new THREE.Uniform(textureMatrix);\n    _this.uniforms.projectiveTexture = new THREE.Uniform(texture);\n    _this.uniforms.mask = new THREE.Uniform(mask);\n    _this.uniforms.boostLight = new THREE.Uniform(false);\n    _this.uniforms.noProjectiveMaterial = new THREE.Uniform({\n      lightDirection: new THREE.Vector3(0.5, 0.5, -0.5),\n      ambient: new THREE.Color(0.1, 0.1, 0.1),\n      opacity: 0.75\n    });\n\n    if (_Capabilities[\"default\"].isLogDepthBufferSupported()) {\n      _this.defines.USE_LOGDEPTHBUF = 1;\n      _this.defines.USE_LOGDEPTHBUF_EXT = 1;\n    }\n\n    _this.vertexShader = textureVS;\n    _this.fragmentShader = _ShaderUtils[\"default\"].unrollLoops(textureFS, _this.defines);\n    return _this;\n  }\n  /**\n   * Set new textures and new position/orientation of the camera set.\n   * @param {THREE.Texture} textures - Array of [THREE.Texture]{@link https://threejs.org/docs/#api/en/textures/Texture}.\n   * @param {Object} feature - New position / orientation of the set of cameras\n   * @param {Array} camerasNames - camera names of panoramic feature\n   * @param {THREE.Vector3} feature.position - New position.\n   * @param {THREE.Quaternion} feature.quaternion - New orientation.\n   */\n\n\n  (0, _createClass2[\"default\"])(OrientedImageMaterial, [{\n    key: \"setTextures\",\n    value: function setTextures(textures, feature, camerasNames) {\n      var _this2 = this;\n\n      if (!textures) {\n        return;\n      }\n\n      this.group.position.copy(feature.position);\n      this.group.quaternion.copy(feature.quaternion);\n\n      var _loop = function (i) {\n        _this2.uniforms.projectiveTexture.value[i].dispose();\n\n        _this2.uniforms.projectiveTexture.value[i] = textures[i]; // check camera changes\n\n        if (camerasNames) {\n          var currentCamera = _this2.group.children[i];\n\n          if (camerasNames[i] != currentCamera.name) {\n            var camera = _this2.cameras.find(function (cam) {\n              return cam.name === camerasNames[i];\n            });\n\n            _this2.uniforms.mask.value[i] = camera.maskTexture || noMask;\n            _this2.uniforms.mask.value[i].needsUpdate = true;\n            _this2.uniforms.projectiveTextureDistortion.value[i] = camera.distortion;\n            _this2.group.children[i] = camera;\n            camera.parent = _this2.group;\n          }\n        }\n\n        _this2.group.children[i].needsUpdate = true;\n      };\n\n      for (var i = 0; i < textures.length && i < this.defines.ORIENTED_IMAGES_COUNT; ++i) {\n        _loop(i);\n      }\n\n      this.group.updateMatrixWorld(true); // update the matrixWorldInverse of the cameras\n    }\n    /**\n     * Udate the uniforms using the current value of camera.matrixWorld.\n     * Need to be called when the camera of the scene has changed.\n     * @param {THREE.Camera} viewCamera - Camera of the scene.\n     */\n\n  }, {\n    key: \"updateUniforms\",\n    value: function updateUniforms(viewCamera) {\n      for (var i = 0; i < this.group.children.length; ++i) {\n        var camera = this.group.children[i];\n\n        if (camera.needsUpdate) {\n          camera.textureMatrixWorldInverse.multiplyMatrices(ndcToTextureMatrix, camera.projectionMatrix);\n          camera.textureMatrixWorldInverse.multiply(camera.matrixWorldInverse);\n          camera.needsUpdate = false;\n        }\n\n        this.uniforms.projectiveTextureMatrix.value[i].multiplyMatrices(camera.textureMatrixWorldInverse, viewCamera.matrixWorld);\n      }\n    }\n  }]);\n  return OrientedImageMaterial;\n}(THREE.RawShaderMaterial);\n\nvar _default = OrientedImageMaterial;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/OrientedImageMaterial.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/PointsMaterial.js":
/*!************************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/PointsMaterial.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.MODE = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ \"./node_modules/@babel/runtime/helpers/get.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _three = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _Capabilities = _interopRequireDefault(__webpack_require__(/*! ../Core/System/Capabilities */ \"./node_modules/itowns/lib/Core/System/Capabilities.js\"));\n\nvar _ShaderUtils = _interopRequireDefault(__webpack_require__(/*! ./Shader/ShaderUtils */ \"./node_modules/itowns/lib/Renderer/Shader/ShaderUtils.js\"));\n\n/* babel-plugin-inline-import './Shader/PointsVS.glsl' */\nvar PointsVS = \"#include <itowns/precision_qualifier>\\n#include <itowns/project_pars_vertex>\\n#if defined(USE_TEXTURES_PROJECTIVE)\\n#include <itowns/projective_texturing_pars_vertex>\\n#endif\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n\\nuniform float size;\\n\\nuniform bool pickingMode;\\nuniform int mode;\\nuniform float opacity;\\nuniform vec4 overlayColor;\\nattribute vec3 color;\\nattribute vec4 unique_id;\\nattribute float intensity;\\n\\n#if defined(NORMAL_OCT16)\\nattribute vec2 oct16Normal;\\n#elif defined(NORMAL_SPHEREMAPPED)\\nattribute vec2 sphereMappedNormal;\\n#else\\nattribute vec3 normal;\\n#endif\\n\\nvarying vec4 vColor;\\n\\n// see https://web.archive.org/web/20150303053317/http://lgdv.cs.fau.de/get/1602\\n// and implementation in PotreeConverter (BINPointReader.cpp) and potree (BinaryDecoderWorker.js)\\n#if defined(NORMAL_OCT16)\\nvec3 decodeOct16Normal(vec2 encodedNormal) {\\n    vec2 nNorm = 2. * (encodedNormal / 255.) - 1.;\\n    vec3 n;\\n    n.z = 1. - abs(nNorm.x) - abs(nNorm.y);\\n    if (n.z >= 0.) {\\n        n.x = nNorm.x;\\n        n.y = nNorm.y;\\n    } else {\\n        n.x = sign(nNorm.x) - sign(nNorm.x) * sign(nNorm.y) * nNorm.y;\\n        n.y = sign(nNorm.y) - sign(nNorm.y) * sign(nNorm.x) * nNorm.x;\\n    }\\n    return normalize(n);\\n}\\n#elif defined(NORMAL_SPHEREMAPPED)\\n// see http://aras-p.info/texts/CompactNormalStorage.html method #4\\n// or see potree's implementation in BINPointReader.cpp\\nvec3 decodeSphereMappedNormal(vec2 encodedNormal) {\\n    vec2 fenc = 2. * encodedNormal / 255. - 1.;\\n    float f = dot(fenc,fenc);\\n    float g = 2. * sqrt(1. - f);\\n    vec3 n;\\n    n.xy = fenc * g;\\n    n.z = 1. - 2. * f;\\n    return n;\\n}\\n#endif\\n\\nvoid main() {\\n\\n#if defined(NORMAL_OCT16)\\n    vec3  normal = decodeOct16Normal(oct16Normal);\\n#elif defined(NORMAL_SPHEREMAPPED)\\n    vec3 normal = decodeSphereMappedNormal(sphereMappedNormal);\\n#elif defined(NORMAL)\\n    // nothing to do\\n#else\\n    // default to color\\n    vec3 normal = color;\\n#endif\\n\\n    if (pickingMode) {\\n        vColor = unique_id;\\n    } else if (mode == MODE_INTENSITY) {\\n        vColor = vec4(intensity, intensity, intensity, opacity);\\n    } else if (mode == MODE_NORMAL) {\\n        vColor = vec4(abs(normal), opacity);\\n    } else {\\n        // default to color mode\\n        vColor = vec4(mix(color, overlayColor.rgb, overlayColor.a), opacity);\\n    }\\n\\n    #include <begin_vertex>\\n    #include <project_vertex>\\n\\n    if (size > 0.) {\\n        gl_PointSize = size;\\n    } else {\\n        gl_PointSize = clamp(-size / gl_Position.w, 3.0, 10.0);\\n    }\\n\\n#if defined(USE_TEXTURES_PROJECTIVE)\\n    #include <itowns/projective_texturing_vertex>\\n#endif\\n    #include <logdepthbuf_vertex>\\n}\\n\";\n\n/* babel-plugin-inline-import './Shader/PointsFS.glsl' */\nvar PointsFS = \"#include <itowns/precision_qualifier>\\n#include <logdepthbuf_pars_fragment>\\n#if defined(USE_TEXTURES_PROJECTIVE)\\n#include <itowns/projective_texturing_pars_fragment>\\n#endif\\n\\nvarying vec4 vColor;\\nuniform bool pickingMode;\\nvoid main() {\\n    #include <logdepthbuf_fragment>\\n    // circular point rendering\\n    if(length(gl_PointCoord - 0.5) > 0.5){\\n        discard;\\n    }\\n\\n#if defined(USE_TEXTURES_PROJECTIVE)\\n    vec4 color = vColor;\\n    if (!pickingMode) {\\n        #pragma unroll_loop\\n        for (int i = 0; i < ORIENTED_IMAGES_COUNT; i++) {\\n            color = projectiveTextureColor(projectiveTextureCoords[ ORIENTED_IMAGES_COUNT - 1 - i ], projectiveTextureDistortion[ ORIENTED_IMAGES_COUNT - 1 - i ], projectiveTexture[ ORIENTED_IMAGES_COUNT - 1 - i ], mask[ORIENTED_IMAGES_COUNT - 1 - i], color);\\n        }\\n        gl_FragColor = vec4(color.rgb, color.a * opacity);\\n    } else {\\n        gl_FragColor = color;\\n    }\\n#else\\n    gl_FragColor = vColor;\\n#endif\\n}\\n\";\nvar MODE = {\n  COLOR: 0,\n  INTENSITY: 1,\n  CLASSIFICATION: 2,\n  NORMAL: 3\n};\nexports.MODE = MODE;\n\nvar PointsMaterial =\n/*#__PURE__*/\nfunction (_RawShaderMaterial) {\n  (0, _inherits2[\"default\"])(PointsMaterial, _RawShaderMaterial);\n\n  function PointsMaterial() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2[\"default\"])(this, PointsMaterial);\n    var oiMaterial = options.orientedImageMaterial;\n    delete options.orientedImageMaterial;\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(PointsMaterial).call(this, options));\n    _this.vertexShader = PointsVS;\n    _this.size = options.size || 0;\n    _this.scale = options.scale || 0.05 * 0.5 / Math.tan(1.0 / 2.0); // autosizing scale\n\n    _this.overlayColor = options.overlayColor || new _three.Vector4(0, 0, 0, 0);\n    _this.mode = options.mode || MODE.COLOR;\n    _this.picking = false;\n\n    for (var key in MODE) {\n      if (Object.prototype.hasOwnProperty.call(MODE, key)) {\n        _this.defines[\"MODE_\".concat(key)] = MODE[key];\n      }\n    }\n\n    _this.uniforms.size = new _three.Uniform(_this.size);\n    _this.uniforms.mode = new _three.Uniform(_this.mode);\n    _this.uniforms.pickingMode = new _three.Uniform(_this.picking);\n    _this.uniforms.opacity = new _three.Uniform(_this.opacity);\n    _this.uniforms.overlayColor = new _three.Uniform(_this.overlayColor);\n\n    if (oiMaterial) {\n      _this.uniforms.projectiveTextureAlphaBorder = oiMaterial.uniforms.projectiveTextureAlphaBorder;\n      _this.uniforms.projectiveTextureDistortion = oiMaterial.uniforms.projectiveTextureDistortion;\n      _this.uniforms.projectiveTextureMatrix = oiMaterial.uniforms.projectiveTextureMatrix;\n      _this.uniforms.projectiveTexture = oiMaterial.uniforms.projectiveTexture;\n      _this.uniforms.mask = oiMaterial.uniforms.mask;\n      _this.uniforms.boostLight = oiMaterial.uniforms.boostLight;\n      _this.defines.ORIENTED_IMAGES_COUNT = oiMaterial.defines.ORIENTED_IMAGES_COUNT;\n      _this.defines.USE_DISTORTION = oiMaterial.defines.USE_DISTORTION;\n      _this.defines.DEBUG_ALPHA_BORDER = oiMaterial.defines.DEBUG_ALPHA_BORDER;\n      _this.defines.USE_TEXTURES_PROJECTIVE = true;\n      _this.defines.USE_BASE_MATERIAL = true;\n      _this.fragmentShader = _ShaderUtils[\"default\"].unrollLoops(PointsFS, _this.defines);\n    } else {\n      _this.fragmentShader = PointsFS;\n    }\n\n    if (_Capabilities[\"default\"].isLogDepthBufferSupported()) {\n      _this.defines.USE_LOGDEPTHBUF = 1;\n      _this.defines.USE_LOGDEPTHBUF_EXT = 1;\n    }\n\n    _this.updateUniforms();\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(PointsMaterial, [{\n    key: \"copy\",\n    value: function copy(source) {\n      (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(PointsMaterial.prototype), \"copy\", this).call(this, source);\n\n      if (source.uniforms.projectiveTextureAlphaBorder) {\n        // Don't copy oriented image because, it's a link to oriented image material.\n        // It needs a reference to oriented image material.\n        this.uniforms.projectiveTextureAlphaBorder = source.uniforms.projectiveTextureAlphaBorder;\n        this.uniforms.projectiveTextureDistortion = source.uniforms.projectiveTextureDistortion;\n        this.uniforms.projectiveTextureMatrix = source.uniforms.projectiveTextureMatrix;\n        this.uniforms.projectiveTexture = source.uniforms.projectiveTexture;\n        this.uniforms.mask = source.uniforms.mask;\n        this.uniforms.boostLight = source.uniforms.boostLight;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"enablePicking\",\n    value: function enablePicking(picking) {\n      this.picking = picking;\n      this.blending = picking ? _three.NoBlending : _three.NormalBlending;\n      this.updateUniforms();\n    }\n  }, {\n    key: \"updateUniforms\",\n    value: function updateUniforms() {\n      // if size is null, switch to autosizing using the canvas height\n      this.uniforms.size.value = this.size > 0 ? this.size : -this.scale * window.innerHeight;\n      this.uniforms.mode.value = this.mode;\n      this.uniforms.pickingMode.value = this.picking;\n      this.uniforms.opacity.value = this.opacity;\n      this.uniforms.overlayColor.value = this.overlayColor;\n    }\n  }, {\n    key: \"update\",\n    value: function update(source) {\n      this.visible = source.visible;\n      this.opacity = source.opacity;\n      this.transparent = source.transparent;\n      this.size = source.size;\n      this.mode = source.mode;\n      this.picking = source.picking;\n      this.scale = source.scale;\n      this.overlayColor.copy(source.overlayColor);\n      this.updateUniforms();\n      Object.assign(this.defines, source.defines);\n      return this;\n    }\n  }]);\n  return PointsMaterial;\n}(_three.RawShaderMaterial);\n\nvar _default = PointsMaterial;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/PointsMaterial.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/RenderMode.js":
/*!********************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/RenderMode.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar MODES = {\n  FINAL: 0,\n  // final color\n  DEPTH: 1,\n  // depth buffer\n  ID: 2 // id object\n\n};\n\nfunction push(object3d, mode) {\n  var _mode = object3d.mode !== undefined ? object3d.mode : MODES.FINAL;\n\n  if (_mode == mode) {\n    return function () {};\n  }\n\n  var setMode = function (m) {\n    return function (node) {\n      var material = node.material;\n\n      if (material) {\n        material.mode = m;\n      }\n    };\n  };\n\n  object3d.traverse(setMode(mode));\n  return function () {\n    object3d.traverse(setMode(_mode));\n  };\n} // Rendering mode\n// According to the rendering mode, the material's object switches\n// the mode property of the materials\n\n\nvar _default = {\n  MODES: MODES,\n  push: push\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/RenderMode.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/Shader/ShaderChunk.js":
/*!****************************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/Shader/ShaderChunk.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\n/* babel-plugin-inline-import './Chunk/color_layers_pars_fragment.glsl' */\nvar color_layers_pars_fragment = \"struct Layer {\\n    int textureOffset;\\n    int crs;\\n    float effect;\\n    float opacity;\\n};\\n\\nuniform sampler2D   colorTextures[NUM_FS_TEXTURES];\\nuniform vec4        colorOffsetScales[NUM_FS_TEXTURES];\\nuniform Layer       colorLayers[NUM_FS_TEXTURES];\\nuniform int         colorTextureCount;\\n\\nvec3 uvs[NUM_CRS];\\n\\nfloat getBorderDistance(vec2 uv) {\\n    vec2 p2 = min(uv, 1. -uv);\\n    return min(p2.x, p2.y);\\n}\\n\\nvec4 applyWhiteToInvisibleEffect(vec4 color, float intensity) {\\n    float a = dot(color.rgb, vec3(0.333333333));\\n    color.a *= 1.0 - pow(abs(a), intensity);\\n    return color;\\n}\\n\\nvec4 applyLightColorToInvisibleEffect(vec4 color, float intensity) {\\n    float a = max(0.05,1. - length(color.xyz - 1.));\\n    color.a *= 1.0 - pow(abs(a), intensity);\\n    color.rgb *= color.rgb * color.rgb;\\n    return color;\\n}\\n\\n#if defined(DEBUG)\\nuniform bool showOutline;\\nuniform vec3 outlineColors[NUM_CRS];\\nuniform float outlineWidth;\\n\\nvec4 getOutlineColor(vec3 outlineColor, vec2 uv) {\\n    float alpha = 1. - clamp(getBorderDistance(uv) / outlineWidth, 0., 1.);\\n    return vec4(outlineColor, alpha);\\n}\\n#endif\\n\\nuniform float minBorderDistance;\\nvec4 getLayerColor(int textureOffset, sampler2D texture, vec4 offsetScale, Layer layer) {\\n    if ( textureOffset >= colorTextureCount ) return vec4(0);\\n\\n    vec3 uv;\\n    // #pragma unroll_loop\\n    for ( int i = 0; i < NUM_CRS; i ++ ) {\\n        if ( i == layer.crs ) uv = uvs[ i ];\\n    }\\n\\n    float borderDistance = getBorderDistance(uv.xy);\\n    if (textureOffset != layer.textureOffset + int(uv.z) || borderDistance < minBorderDistance ) return vec4(0);\\n    vec4 color = texture2D(texture, pitUV(uv.xy, offsetScale));\\n    if(color.a > 0.0) {\\n        if(layer.effect > 2.0) {\\n            color.rgb /= color.a;\\n            color = applyLightColorToInvisibleEffect(color, layer.effect);\\n        } else if(layer.effect > 0.0) {\\n            color.rgb /= color.a;\\n            color = applyWhiteToInvisibleEffect(color, layer.effect);\\n        }\\n    }\\n\\n    color.a *= layer.opacity;\\n    return color;\\n}\\n\";\n\n/* babel-plugin-inline-import './Chunk/elevation_pars_vertex.glsl' */\nvar elevation_pars_vertex = \"#if NUM_VS_TEXTURES > 0\\n    struct Layer {\\n        float scale;\\n        float bias;\\n        int mode;\\n        float zmin;\\n        float zmax;\\n    };\\n\\n    uniform Layer       elevationLayers[NUM_VS_TEXTURES];\\n    uniform sampler2D   elevationTextures[NUM_VS_TEXTURES];\\n    uniform vec4        elevationOffsetScales[NUM_VS_TEXTURES];\\n    uniform int         elevationTextureCount;\\n\\n    highp float decode32(highp vec4 rgba) {\\n        highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\\n        highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\\n        highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\\n        highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\\n        return Result;\\n    }\\n\\n    float getElevationMode(vec2 uv, sampler2D texture, int mode) {\\n        if (mode == ELEVATION_RGBA)\\n            return decode32(texture2D( texture, uv ).abgr * 255.0);\\n        if (mode == ELEVATION_DATA)\\n            return texture2D( texture, uv ).w;\\n        if (mode == ELEVATION_COLOR)\\n            return texture2D( texture, uv ).r;\\n        return 0.;\\n    }\\n\\n    float getElevation(vec2 uv, sampler2D texture, vec4 offsetScale, Layer layer) {\\n        uv = uv * offsetScale.zw + offsetScale.xy;\\n        float d = getElevationMode(uv, texture, layer.mode);\\n        if (d < layer.zmin || d > layer.zmax) d = 0.;\\n        return d * layer.scale + layer.bias;\\n    }\\n#endif\\n\";\n\n/* babel-plugin-inline-import './Chunk/elevation_vertex.glsl' */\nvar elevation_vertex = \"#if NUM_VS_TEXTURES > 0\\n    if(elevationTextureCount > 0) {\\n        float elevation = getElevation(uv, elevationTextures[0], elevationOffsetScales[0], elevationLayers[0]);\\n        transformed += elevation * normal;\\n    }\\n#endif\\n\";\n\n/* babel-plugin-inline-import './Chunk/fog_fragment.glsl' */\nvar fog_fragment = \"#if defined(USE_FOG)\\n    float fogFactor = 1. - min( exp(-fogDepth / fogDistance), 1.);\\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, fogFactor);\\n#endif\\n\";\n\n/* babel-plugin-inline-import './Chunk/fog_pars_fragment.glsl' */\nvar fog_pars_fragment = \"#if defined(USE_FOG)\\nuniform vec3  fogColor;\\nuniform float fogDistance;\\nvarying float fogDepth;\\n#endif\\n\";\n\n/* babel-plugin-inline-import './Chunk/lighting_fragment.glsl' */\nvar lighting_fragment = \"if (lightingEnabled) {\\n    float light = min(2. * dot(vNormal, lightPosition), 1.);\\n    gl_FragColor.rgb *= light;\\n}\\n\";\n\n/* babel-plugin-inline-import './Chunk/lighting_pars_fragment.glsl' */\nvar lighting_pars_fragment = \"uniform bool lightingEnabled;\\nuniform vec3 lightPosition;\\nvarying vec3 vNormal;\\n\";\n\n/* babel-plugin-inline-import './Chunk/mode_pars_fragment.glsl' */\nvar mode_pars_fragment = \"#if MODE == MODE_ID || MODE == MODE_DEPTH\\n#include <packing>\\n#endif\\n\\n#if MODE == MODE_ID\\nuniform int objectId;\\n#endif\\n\";\n\n/* babel-plugin-inline-import './Chunk/mode_depth_fragment.glsl' */\nvar mode_depth_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\ngl_FragColor = packDepthToRGBA(gl_FragDepthEXT);\\n#else\\ngl_FragColor = packDepthToRGBA(gl_FragCoord.z);\\n#endif\\n\";\n\n/* babel-plugin-inline-import './Chunk/mode_id_fragment.glsl' */\nvar mode_id_fragment = \"// 16777216.0 == 256.0 * 256.0 * 256.0\\ngl_FragColor = packDepthToRGBA(float(objectId) / 16777216.0);\\n\";\n\n/* babel-plugin-inline-import './Chunk/overlay_fragment.glsl' */\nvar overlay_fragment = \"gl_FragColor.rgb = mix(gl_FragColor.rgb, overlayColor, overlayAlpha);\\n\";\n\n/* babel-plugin-inline-import './Chunk/overlay_pars_fragment.glsl' */\nvar overlay_pars_fragment = \"uniform vec3  overlayColor;\\nuniform float overlayAlpha;\\n\";\n\n/* babel-plugin-inline-import './Chunk/pitUV.glsl' */\nvar pitUV = \"vec2 pitUV(vec2 uv, vec4 pit)\\n{\\n    return uv * pit.zw + vec2(pit.x, 1.0 - pit.w - pit.y);\\n}\\n\\n\";\n\n/* babel-plugin-inline-import './Chunk/precision_qualifier.glsl' */\nvar precision_qualifier = \"precision highp float;\\nprecision highp int;\\n\";\n\n/* babel-plugin-inline-import './Chunk/project_pars_vertex.glsl' */\nvar project_pars_vertex = \"attribute vec3 position;\\nuniform mat4 projectionMatrix;\\nuniform mat4 modelViewMatrix;\\n\";\n\n/* babel-plugin-inline-import './Chunk/projective_texturing_vertex.glsl' */\nvar projective_texturing_vertex = \"for(int i = 0; i < ORIENTED_IMAGES_COUNT; ++i)\\n    projectiveTextureCoords[i] = projectiveTextureMatrix[i] * mvPosition;\\n\";\n\n/* babel-plugin-inline-import './Chunk/projective_texturing_pars_vertex.glsl' */\nvar projective_texturing_pars_vertex = \"uniform mat4 projectiveTextureMatrix[ORIENTED_IMAGES_COUNT];\\nvarying vec4 projectiveTextureCoords[ORIENTED_IMAGES_COUNT];\\n\";\n\n/* babel-plugin-inline-import './Chunk/projective_texturing_pars_fragment.glsl' */\nvar projective_texturing_pars_fragment = \"uniform sampler2D projectiveTexture[ORIENTED_IMAGES_COUNT];\\nuniform sampler2D mask[ORIENTED_IMAGES_COUNT];\\nvarying vec4      projectiveTextureCoords[ORIENTED_IMAGES_COUNT];\\nuniform float     projectiveTextureAlphaBorder;\\nuniform float     opacity;\\nuniform bool      boostLight;\\n\\nstruct Distortion {\\n    vec2 size;\\n#if USE_DISTORTION\\n    vec2 pps;\\n    vec4 polynom;\\n    vec3 l1l2;\\n#endif\\n};\\n\\nuniform Distortion projectiveTextureDistortion[ORIENTED_IMAGES_COUNT];\\n\\nfloat getAlphaBorder(vec2 p)\\n{\\n    vec2 d = clamp(projectiveTextureAlphaBorder * min(p, 1. - p), 0., 1.);\\n    return min(d.x, d.y);\\n}\\n\\n#if USE_DISTORTION\\nvoid distort(inout vec2 p, vec4 polynom, vec2 pps)\\n{\\n    vec2 v = p - pps;\\n    float v2 = dot(v, v);\\n    if (v2 > polynom.w) {\\n        p = vec2(-1.);\\n    }\\n    else {\\n        p += (v2 * (polynom.x + v2 * (polynom.y + v2 * polynom.z) ) ) * v;\\n    }\\n}\\n\\nvoid distort(inout vec2 p, vec4 polynom, vec3 l1l2, vec2 pps)\\n{\\n    if ((l1l2.x == 0.) && (l1l2.y == 0.)) {\\n        distort(p, polynom, pps);\\n    } else {\\n        vec2 AB = (p - pps) / l1l2.z;\\n        float R = length(AB);\\n        float lambda = atan(R) / R;\\n        vec2 ab = lambda * AB;\\n        float rho2 = dot(ab, ab);\\n        float r357 = 1. + rho2* (polynom.x + rho2* (polynom.y + rho2 * polynom.z));\\n        p = pps + l1l2.z * (r357 * ab + vec2(dot(l1l2.xy, ab), l1l2.y * ab.x));\\n    }\\n}\\n#endif\\n\\nvec4 mixBaseColor(vec4 aColor, vec4 baseColor) {\\n    #ifdef USE_BASE_MATERIAL\\n        baseColor.rgb = aColor.a == 1.0 ? aColor.rgb : mix(baseColor, aColor, aColor.a).rgb;\\n        baseColor.a = min(1.0, aColor.a + baseColor.a);\\n    #else\\n        baseColor.rgb += aColor.rgb * aColor.a;\\n        baseColor.a += aColor.a;\\n    #endif\\n    return baseColor;\\n}\\n\\nvec4 projectiveTextureColor(vec4 coords, Distortion distortion, sampler2D texture, sampler2D mask, vec4 baseColor) {\\n    vec3 p = coords.xyz / coords.w;\\n    if(p.z * p.z < 1.) {\\n#if USE_DISTORTION\\n        p.xy *= distortion.size;\\n        distort(p.xy, distortion.polynom, distortion.l1l2, distortion.pps);\\n        p.xy /= distortion.size;\\n#endif\\n\\n        float d = getAlphaBorder(p.xy) * texture2D(mask, p.xy).r;\\n\\n        if(d > 0.) {\\n\\n#if DEBUG_ALPHA_BORDER\\n        vec3 r = texture2D(texture, p.xy).rgb;\\n        return mixBaseColor(vec4( r.r * d, r.g, r.b, 1.0), baseColor);\\n#else\\n        vec4 color = texture2D(texture, p.xy);\\n        color.a *= d;\\n        if (boostLight) {\\n            return mixBaseColor(vec4(sqrt(color.rgb), color.a), baseColor);\\n        } else {\\n            return mixBaseColor(color, baseColor);\\n        }\\n#endif\\n\\n        }\\n    }\\n    return mixBaseColor(vec4(0.), baseColor);\\n}\\n\";\nvar ShaderChunk = {\n  color_layers_pars_fragment: color_layers_pars_fragment,\n  elevation_pars_vertex: elevation_pars_vertex,\n  elevation_vertex: elevation_vertex,\n  fog_fragment: fog_fragment,\n  fog_pars_fragment: fog_pars_fragment,\n  lighting_fragment: lighting_fragment,\n  lighting_pars_fragment: lighting_pars_fragment,\n  mode_depth_fragment: mode_depth_fragment,\n  mode_id_fragment: mode_id_fragment,\n  mode_pars_fragment: mode_pars_fragment,\n  overlay_fragment: overlay_fragment,\n  overlay_pars_fragment: overlay_pars_fragment,\n  pitUV: pitUV,\n  precision_qualifier: precision_qualifier,\n  projective_texturing_vertex: projective_texturing_vertex,\n  projective_texturing_pars_vertex: projective_texturing_pars_vertex,\n  projective_texturing_pars_fragment: projective_texturing_pars_fragment,\n  project_pars_vertex: project_pars_vertex\n};\n/**\n * Install chunks in a target, for example THREE.ShaderChunk, with adding an\n * optional path.\n *\n * @param {Object} target - The target to install the chunks into.\n * @param {Object} chunks - The chunks to install. The key of each chunk will be\n * the name of installation of the chunk in the target (plus an optional path).\n * @param {string} [path] - A path to add before a chunk name as a prefix.\n *\n * @return {Object} The target with installed chunks.\n */\n\nShaderChunk.install = function (target, chunks, path) {\n  if (!path) {\n    return Object.assign(target, this);\n  }\n\n  Object.keys(chunks).forEach(function (key) {\n    if (key == 'install') {\n      return;\n    }\n\n    target[path + key] = chunks[key];\n  });\n  return target;\n}; // Install all default shaders under the itowns\n\n\nShaderChunk.install(THREE.ShaderChunk, ShaderChunk, 'itowns/');\nvar _default = ShaderChunk;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/Shader/ShaderChunk.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/Shader/ShaderUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/Shader/ShaderUtils.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar rePosition = new RegExp('gl_Position.*(?![^]*gl_Position)');\nvar reMain = new RegExp('[^\\\\w]*main[^\\\\w]*(void)?[^\\\\w]*{');\nvar _default = {\n  patchMaterialForLogDepthSupport: function patchMaterialForLogDepthSupport(material) {\n    // Check if the shader does not already use the log depth buffer\n    if (material.vertexShader.includes('USE_LOGDEPTHBUF') || material.vertexShader.includes('logdepthbuf_pars_vertex')) {\n      return;\n    } // Add vertex shader log depth buffer header\n\n\n    material.vertexShader = \"#include <logdepthbuf_pars_vertex>\\n#define EPSILON 1e-6\\n\".concat(material.vertexShader); // Add log depth buffer code snippet after last gl_Position modification\n\n    var re = rePosition.exec(material.vertexShader);\n    var idx = re[0].length + re.index;\n    material.vertexShader = \"\".concat(material.vertexShader.slice(0, idx), \"\\n#include <logdepthbuf_vertex>\\n\").concat(material.vertexShader.slice(idx)); // Add fragment shader log depth buffer header\n\n    material.fragmentShader = \"#include <itowns/precision_qualifier\\n\".concat(material.fragmentShader);\n    material.fragmentShader = \"#include <logdepthbuf_pars_fragment>\\n\".concat(material.fragmentShader); // Add log depth buffer code snippet at the first line of the main function\n\n    re = reMain.exec(material.fragmentShader);\n    idx = re[0].length + re.index;\n    material.fragmentShader = \"\".concat(material.fragmentShader.slice(0, idx), \"\\n#include <logdepthbuf_fragment>\\n\").concat(material.fragmentShader.slice(idx));\n    material.defines = {\n      USE_LOGDEPTHBUF: 1,\n      USE_LOGDEPTHBUF_EXT: 1\n    };\n  },\n  // adapted from unrollLoops in WebGLProgram\n  unrollLoops: function unrollLoops(string, defines) {\n    // look for a for loop with an unroll_loop pragma\n    // The detection of the scope of the for loop is hacky as it does not support nested scopes\n    var pattern = /#pragma unroll_loop\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*([\\w\\d]+);\\s*i\\s+<\\s+([\\w\\d]+);\\s*i\\s*\\+\\+\\s*\\)\\s*\\{\\n([^}]*)\\}/g;\n\n    function replace(match, start, end, snippet) {\n      var unroll = '';\n      start = start in defines ? defines[start] : parseInt(start, 10);\n      end = end in defines ? defines[end] : parseInt(end, 10);\n\n      for (var i = start; i < end; i++) {\n        unroll += snippet.replace(/\\bi\\b/g, \" \".concat(i, \" \"));\n      }\n\n      return unroll;\n    }\n\n    return string.replace(pattern, replace);\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/Shader/ShaderUtils.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Renderer/c3DEngine.js":
/*!*******************************************************!*\
  !*** ./node_modules/itowns/lib/Renderer/c3DEngine.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Capabilities = _interopRequireDefault(__webpack_require__(/*! ../Core/System/Capabilities */ \"./node_modules/itowns/lib/Core/System/Capabilities.js\"));\n\nvar _LayeredMaterial = __webpack_require__(/*! ./LayeredMaterial */ \"./node_modules/itowns/lib/Renderer/LayeredMaterial.js\");\n\nvar _WebGL = __webpack_require__(/*! ../ThreeExtended/WebGL */ \"./node_modules/itowns/lib/ThreeExtended/WebGL.js\");\n\n/**\n * Generated On: 2015-10-5\n * Class: c3DEngine\n * Description: 3DEngine est l'interface avec le framework webGL.\n */\nvar depthRGBA = new THREE.Vector4();\n\nvar c3DEngine =\n/*#__PURE__*/\nfunction () {\n  function c3DEngine(rendererOrDiv) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2[\"default\"])(this, c3DEngine);\n    var NOIE = !_Capabilities[\"default\"].isInternetExplorer(); // pick sensible default options\n\n    if (options.antialias === undefined) {\n      options.antialias = true;\n    }\n\n    if (options.alpha === undefined) {\n      options.alpha = true;\n    }\n\n    if (options.logarithmicDepthBuffer === undefined) {\n      options.logarithmicDepthBuffer = this.gLDebug || NOIE;\n    }\n\n    var renderer = rendererOrDiv.domElement ? rendererOrDiv : undefined;\n    var viewerDiv = renderer ? undefined : rendererOrDiv;\n    this.width = (renderer ? renderer.domElement : viewerDiv).clientWidth;\n    this.height = (renderer ? renderer.domElement : viewerDiv).clientHeight;\n    this.positionBuffer = null;\n    this._nextThreejsLayer = 1;\n    this.fullSizeRenderTarget = new THREE.WebGLRenderTarget(this.width, this.height);\n    this.fullSizeRenderTarget.texture.minFilter = THREE.LinearFilter;\n    this.fullSizeRenderTarget.texture.magFilter = THREE.NearestFilter;\n    this.fullSizeRenderTarget.depthBuffer = true;\n    this.fullSizeRenderTarget.depthTexture = new THREE.DepthTexture();\n    this.fullSizeRenderTarget.depthTexture.type = THREE.UnsignedShortType;\n\n    this.renderView = function (view) {\n      this.renderer.clear();\n      this.renderer.render(view.scene, view.camera.camera3D);\n    }.bind(this);\n\n    this.onWindowResize = function (w, h) {\n      this.width = w;\n      this.height = h;\n      this.fullSizeRenderTarget.setSize(this.width, this.height);\n      this.renderer.setSize(this.width, this.height);\n    }.bind(this); // Create renderer\n\n\n    try {\n      this.renderer = renderer || new THREE.WebGLRenderer({\n        canvas: document.createElement('canvas'),\n        antialias: options.antialias,\n        alpha: options.alpha,\n        logarithmicDepthBuffer: options.logarithmicDepthBuffer\n      });\n    } catch (ex) {\n      console.error('Failed to create WebGLRenderer', ex);\n      this.renderer = null;\n    }\n\n    if (!this.renderer) {\n      if (!_WebGL.WEBGL.isWebGLAvailable()) {\n        viewerDiv.appendChild(_WebGL.WEBGL.getErrorMessage(1));\n      } else if (!_WebGL.WEBGL.isWebGL2Available()) {\n        viewerDiv.appendChild(_WebGL.WEBGL.getErrorMessage(2));\n      }\n\n      throw new Error('WebGL unsupported');\n    }\n\n    if (!renderer && options.logarithmicDepthBuffer) {\n      // We don't support logarithmicDepthBuffer when EXT_frag_depth is missing.\n      // So recreated a renderer if needed.\n      if (!this.renderer.extensions.get('EXT_frag_depth')) {\n        var _canvas = this.renderer.domElement;\n        this.renderer.dispose();\n        this.renderer = new THREE.WebGLRenderer({\n          canvas: _canvas,\n          antialias: options.antialias,\n          alpha: options.alpha,\n          logarithmicDepthBuffer: false\n        });\n      }\n    } // Let's allow our canvas to take focus\n    // The condition below looks weird, but it's correct: querying tabIndex\n    // returns -1 if not set, but we still need to explicitly set it to force\n    // the tabindex focus flag to true (see\n    // https://www.w3.org/TR/html5/editing.html#specially-focusable)\n\n\n    if (this.renderer.domElement.tabIndex === -1) {\n      this.renderer.domElement.tabIndex = -1;\n    }\n\n    _Capabilities[\"default\"].updateCapabilities(this.renderer);\n\n    this.renderer.setClearColor(0x030508);\n    this.renderer.autoClear = false;\n    this.renderer.sortObjects = true;\n    this.renderer.debug.checkShaderErrors = false;\n\n    if (!renderer) {\n      this.renderer.setPixelRatio(viewerDiv.devicePixelRatio);\n      this.renderer.setSize(viewerDiv.clientWidth, viewerDiv.clientHeight);\n      viewerDiv.appendChild(this.renderer.domElement);\n    }\n  }\n\n  (0, _createClass2[\"default\"])(c3DEngine, [{\n    key: \"getWindowSize\",\n    value: function getWindowSize() {\n      return new THREE.Vector2(this.width, this.height);\n    }\n    /**\n     * return renderer THREE.js\n     * @returns {undefined|c3DEngine_L7.THREE.WebGLRenderer}\n     */\n\n  }, {\n    key: \"getRenderer\",\n    value: function getRenderer() {\n      return this.renderer;\n    }\n    /**\n     * Render view to a Uint8Array.\n     *\n     * @param {View} view - The view to render\n     * @param {object} [zone] - partial zone to render\n     * @param {number} zone.x - x (in view coordinate)\n     * @param {number} zone.y - y (in view coordinate)\n     * @param {number} zone.width - width of area to render (in pixels)\n     * @param {number} zone.height - height of area to render (in pixels)\n     * @return {THREE.RenderTarget} - Uint8Array, 4 bytes per pixel. The first pixel in\n     * the array is the bottom-left pixel.\n     */\n\n  }, {\n    key: \"renderViewToBuffer\",\n    value: function renderViewToBuffer(view, zone) {\n      if (!zone) {\n        zone = {\n          x: 0,\n          y: 0,\n          width: this.width,\n          height: this.height\n        };\n      }\n\n      this.renderViewToRenderTarget(view, this.fullSizeRenderTarget, zone);\n      var pixelBuffer = new Uint8Array(4 * zone.width * zone.height);\n      this.renderer.readRenderTargetPixels(this.fullSizeRenderTarget, zone.x, this.height - (zone.y + zone.height), zone.width, zone.height, pixelBuffer);\n      return pixelBuffer;\n    }\n    /**\n     * Render view to a THREE.RenderTarget.\n     *\n     * @param {View} view - The view to render\n     * @param {THREE.RenderTarget} [target] - destination render target. Default value: full size render target owned by c3DEngine.\n     * @param {object} [zone] - partial zone to render (zone x/y uses view coordinates) Note: target must contain complete zone\n     * @return {THREE.RenderTarget} - the destination render target\n     */\n\n  }, {\n    key: \"renderViewToRenderTarget\",\n    value: function renderViewToRenderTarget(view, target, zone) {\n      if (!target) {\n        target = this.fullSizeRenderTarget;\n      }\n\n      var current = this.renderer.getRenderTarget(); // Don't use setViewport / setScissor on renderer because they would affect\n      // on screen rendering as well. Instead set them on the render target.\n      // Example : this.fullSizeRenderTarget.viewport.set(0, 0, target.width, target.height);\n\n      if (zone) {\n        this.fullSizeRenderTarget.scissor.set(zone.x, target.height - (zone.y + zone.height), zone.width, zone.height);\n        this.fullSizeRenderTarget.scissorTest = true;\n      }\n\n      this.renderer.setRenderTarget(target);\n      this.renderer.clear(true, true, false);\n      this.renderer.render(view.scene, view.camera.camera3D);\n      this.renderer.setRenderTarget(current);\n      this.fullSizeRenderTarget.scissorTest = false;\n      return target;\n    }\n  }, {\n    key: \"bufferToImage\",\n    value: function bufferToImage(pixelBuffer, width, height) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d'); // size the canvas to your desired image\n\n      canvas.width = width;\n      canvas.height = height;\n      var imgData = ctx.getImageData(0, 0, width, height);\n      imgData.data.set(pixelBuffer);\n      ctx.putImageData(imgData, 0, 0); // create a new img object\n\n      var image = new Image(); // set the img.src to the canvas data url\n\n      image.src = canvas.toDataURL();\n      return image;\n    }\n  }, {\n    key: \"getUniqueThreejsLayer\",\n    value: function getUniqueThreejsLayer() {\n      // We use three.js Object3D.layers feature to manage visibility of\n      // geometry layers; so we need an internal counter to assign a new\n      // one to each new geometry layer.\n      // Warning: only 32 ([0, 31]) different layers can exist.\n      if (this._nextThreejsLayer > 31) {\n        console.warn('Too much three.js layers. Starting from now all of them will use layerMask = 31');\n        this._nextThreejsLayer = 31;\n      }\n\n      var result = this._nextThreejsLayer++;\n      return result;\n    }\n  }, {\n    key: \"depthBufferRGBAValueToOrthoZ\",\n    value: function depthBufferRGBAValueToOrthoZ(depthBufferRGBA, camera) {\n      depthRGBA.fromArray(depthBufferRGBA).divideScalar(255.0);\n\n      if (_Capabilities[\"default\"].isLogDepthBufferSupported()) {\n        var gl_FragDepthEXT = (0, _LayeredMaterial.unpack1K)(depthRGBA);\n        var logDepthBufFC = 2.0 / (Math.log(camera.far + 1.0) / Math.LN2); // invert function : gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n        return Math.pow(2, 2 * gl_FragDepthEXT / logDepthBufFC);\n      } else {\n        var gl_FragCoord_Z = (0, _LayeredMaterial.unpack1K)(depthRGBA);\n        gl_FragCoord_Z = gl_FragCoord_Z * 2.0 - 1.0;\n        return 2.0 * camera.near * camera.far / (camera.far + camera.near - gl_FragCoord_Z * (camera.far - camera.near));\n      }\n    }\n  }]);\n  return c3DEngine;\n}();\n\nvar _default = c3DEngine;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Renderer/c3DEngine.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Source/FileSource.js":
/*!******************************************************!*\
  !*** ./node_modules/itowns/lib/Source/FileSource.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _Source2 = _interopRequireDefault(__webpack_require__(/*! ./Source */ \"./node_modules/itowns/lib/Source/Source.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar ext = new _Extent[\"default\"]('EPSG:4326', [0, 0, 0, 0]);\n/**\n * @classdesc\n * An object defining the source of a single resource to get from a direct\n * access. It inherits from {@link Source}. There is multiple ways of adding a\n * resource here:\n * <ul>\n *  <li>add the file like any other sources, using the `url` property.</li>\n *  <li>fetch the file, and give the data to the source using the `fetchedData`\n *  property.</li>\n *  <li>fetch the file, parse it and git the parsed data to the source using the\n *  `parsedData` property.</li>\n * </ul>\n * See the examples below for real use cases.\n *\n * @extends Source\n *\n * @property {boolean} isFileSource - Used to checkout whether this source is a\n * FileSource. Default is true. You should not change this, as it is used\n * internally for optimisation.\n * @property {*} fetchedData - Once the file has been loaded, the resulting data\n * is stored in this property.\n * @property {*} parsedData - Once the file has been loaded and parsed, the\n * resulting data is stored in this property.\n *\n * @example <caption>Simple: create a source, a layer, and let iTowns taking\n * care of everything.</caption>\n * const kmlSource = new itowns.FileSource({\n *     url: 'https://raw.githubusercontent.com/iTowns/iTowns2-sample-data/master/croquis.kml',\n *     projection: 'EPSG:4326',\n *     fetcher: itowns.Fetcher.xml,\n *     parser: itowns.KMLParser.parse,\n * });\n *\n * const kmlLayer = new itowns.ColorLayer('Kml', {\n *     name: 'kml',\n *     transparent: true,\n *     projection: view.tileLayer.extent.crs,\n *     source: kmlSource,\n * });\n *\n * view.addLayer(kmlLayer);\n *\n * @example <caption>Advanced: fetch some data, create a source, a layer, and\n * let iTowns do the parsing and converting.</caption>\n * // Parse and Convert by iTowns\n * itowns.Fetcher.xml('https://raw.githubusercontent.com/iTowns/iTowns2-sample-data/master/ULTRA2009.gpx')\n *     .then(function _(gpx) {\n *         const gpxSource = new itowns.FileSource({\n *             data: gpx,\n *             projection: 'EPSG:4326',\n *             parser: itowns.GpxParser.parse,\n *         });\n *\n *         const gpxLayer = new itowns.ColorLayer('Gpx', {\n *             name: 'Ultra 2009',\n *             transparent: true,\n *             source: gpxSource,\n *         });\n *\n *         return view.addLayer(gpxLayer);\n *     });\n *\n * @example <caption>More advanced: create a layer, fetch some data, parse the\n * data, append a source to the layer and add the layer to iTowns.</caption>\n * // Create a layer\n * const ariege = new itowns.GeometryLayer('ariege', new itowns.THREE.Group());\n *\n * // Specify update method and conversion\n * ariege.update = itowns.FeatureProcessing.update;\n * ariege.convert = itowns.Feature2Mesh.convert({\n *     color: () => new itowns.THREE.Color(0xffcc00),\n *     extrude: () => 5000,\n * });\n *\n * itowns.Fetcher.json('https://raw.githubusercontent.com/gregoiredavid/france-geojson/master/departements/09-ariege/departement-09-ariege.geojson')\n *     .then(function _(geojson) {\n *         return itowns.GeoJsonParser.parse(geojson, {\n *             buildExtent: true,\n *             crsIn: 'EPSG:4326',\n *             crsOut: view.tileLayer.extent.crs,\n *             mergeFeatures: true,\n *             withNormal: false,\n *             withAltitude: false,\n *         });\n *     }).then(function _(parsedData) {\n *         ariege.source = new itowns.FileSource({\n *             projection: 'EPSG:4326',\n *             parsedData,\n *         });\n *\n *         return view.addLayer(ariegeLayer);\n *     });\n */\n\nvar FileSource =\n/*#__PURE__*/\nfunction (_Source) {\n  (0, _inherits2[\"default\"])(FileSource, _Source);\n\n  /**\n   * @param {Object} source - An object that can contain all properties of a\n   * FileSource and {@link Source}. Only `projection` is mandatory, but if it\n   * presents in `parsedData` under the property `projection` or `crs`, it is\n   * fine.\n   * @param {string} crsOut - The projection of the output data after parsing.\n   *\n   * @constructor\n   */\n  function FileSource(source) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, FileSource);\n\n    if (!source.projection) {\n      if (source.parsedData && (source.parsedData.crs || source.parsedData.projection)) {\n        source.projection = source.parsedData.crs || source.parsedData.projection;\n      } else {\n        throw new Error('source.projection is required in FileSource');\n      }\n    }\n\n    if (!source.url && !source.fetchedData && !source.parsedData) {\n      throw new Error(\"url, fetchedData and parsedData are not set in\\n                FileSource; at least one needs to be present\");\n    } // the fake url is for when we use the fetchedData or parsedData mode\n\n\n    source.url = source.url || 'fake-file-url';\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(FileSource).call(this, source));\n    _this.isFileSource = true;\n    _this.fetchedData = source.fetchedData;\n    _this.parsedData = source.parsedData;\n    _this.zoom = source.zoom || {\n      min: 5,\n      max: 21\n    };\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(FileSource, [{\n    key: \"urlFromExtent\",\n    value: function urlFromExtent() {\n      return this.url;\n    }\n  }, {\n    key: \"onParsedFile\",\n    value: function onParsedFile(parsedFile) {\n      this.parsedData = parsedFile;\n\n      if (parsedFile.extent && parsedFile.extent.crs != 'EPSG:4978') {\n        this.extent = parsedFile.extent;\n      }\n\n      return parsedFile;\n    }\n  }, {\n    key: \"extentInsideLimit\",\n    value: function extentInsideLimit(extent) {\n      // Fix me => may be not\n      var localExtent = this.extent.crs == extent.crs ? extent : extent.as(this.extent.crs, ext);\n      return (extent.zoom == undefined || !(extent.zoom < this.zoom.min || extent.zoom > this.zoom.max)) && this.extent.intersectsExtent(localExtent);\n    }\n  }]);\n  return FileSource;\n}(_Source2[\"default\"]);\n\nvar _default = FileSource;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Source/FileSource.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Source/OrientedImageSource.js":
/*!***************************************************************!*\
  !*** ./node_modules/itowns/lib/Source/OrientedImageSource.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _Source2 = _interopRequireDefault(__webpack_require__(/*! ./Source */ \"./node_modules/itowns/lib/Source/Source.js\"));\n\n/**\n * @classdesc OrientedImageSource is a specific source used to load oriented images.\n * @extends Source\n */\nvar OrientedImageSource =\n/*#__PURE__*/\nfunction (_Source) {\n  (0, _inherits2[\"default\"])(OrientedImageSource, _Source);\n\n  /**\n   * @constructor\n   * @param { Object } source - Configuration object\n   * @param { string } source.url - Url for all the textures.\n   * This Url must contains {sensorId} and {cameraId}, and these pattern will be replaced to build the Url,\n   * to find the good texture for each camera for each panoramic.\n   */\n  function OrientedImageSource(source) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, OrientedImageSource);\n    source.format = source.format || 'json';\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(OrientedImageSource).call(this, source));\n    _this.isOrientedImageSource = true;\n    return _this;\n  }\n  /**\n   * Build the url of the texture, but not from extent.\n   *\n   * @param      {Object}  imageInfo - Information about the texture\n   * @param      {string}  imageInfo.camera - Id of the camera\n   * @param      {string}  imageInfo.pano - Id of the panoramic\n   * @return     {string}  Url of the image\n   */\n\n\n  (0, _createClass2[\"default\"])(OrientedImageSource, [{\n    key: \"urlFromExtent\",\n    value: function urlFromExtent(imageInfo) {\n      return this.imageUrl(imageInfo.cameraId, imageInfo.panoId);\n    }\n    /**\n     * Build the url of the image, for a given panoramic id, and a given camera id.\n     *\n     * @param      {string}  cameraId  Id of the camera\n     * @param      {string}  panoId   Id of the panoramic\n     * @return     {string}  Url of the image\n     */\n\n  }, {\n    key: \"imageUrl\",\n    value: function imageUrl(cameraId, panoId) {\n      return this.url.replace('{cameraId}', cameraId).replace('{panoId}', panoId);\n    }\n  }]);\n  return OrientedImageSource;\n}(_Source2[\"default\"]);\n\nvar _default = OrientedImageSource;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Source/OrientedImageSource.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Source/Source.js":
/*!**************************************************!*\
  !*** ./node_modules/itowns/lib/Source/Source.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.supportedFetchers = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar _GeoJsonParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/GeoJsonParser */ \"./node_modules/itowns/lib/Parser/GeoJsonParser.js\"));\n\nvar _KMLParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/KMLParser */ \"./node_modules/itowns/lib/Parser/KMLParser.js\"));\n\nvar _GpxParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/GpxParser */ \"./node_modules/itowns/lib/Parser/GpxParser.js\"));\n\nvar _VectorTileParser = _interopRequireDefault(__webpack_require__(/*! ../Parser/VectorTileParser */ \"./node_modules/itowns/lib/Parser/VectorTileParser.js\"));\n\nvar _Fetcher = _interopRequireDefault(__webpack_require__(/*! ../Provider/Fetcher */ \"./node_modules/itowns/lib/Provider/Fetcher.js\"));\n\nvar supportedFetchers = new Map([['image/x-bil;bits=32', _Fetcher[\"default\"].textureFloat], ['geojson', _Fetcher[\"default\"].json], ['application/json', _Fetcher[\"default\"].json], ['application/kml', _Fetcher[\"default\"].xml], ['application/gpx', _Fetcher[\"default\"].xml], ['application/x-protobuf;type=mapbox-vector', _Fetcher[\"default\"].arrayBuffer]]);\nexports.supportedFetchers = supportedFetchers;\nvar supportedParsers = new Map([['geojson', _GeoJsonParser[\"default\"].parse], ['application/json', _GeoJsonParser[\"default\"].parse], ['application/kml', _KMLParser[\"default\"].parse], ['application/gpx', _GpxParser[\"default\"].parse], ['application/x-protobuf;type=mapbox-vector', _VectorTileParser[\"default\"].parse]]);\nvar uid = 0;\n/**\n * @classdesc\n * Sources are object containing informations on how to fetch resources, from a\n * set source.\n *\n * To extend a Source, it is necessary to implement two functions:\n * `urlFromExtent` and `extentInsideLimit`.\n *\n * @property {boolean} isSource - Used to checkout whether this source is a\n * Source. Default is true. You should not change this, as it is used internally\n * for optimisation.\n * @property {number} uid - Unique uid mainly used to store data linked to this\n * source into Cache.\n * @property {string} url - The url of the resources that are fetched.\n * @property {string} format - The format of the resources that are fetched.\n * @property {function} fetcher - The method used to fetch the resources from\n * the source. iTowns provides some methods in {@link Fetcher}, but it can be\n * specified a custom one. This method should return a `Promise` containing the\n * fetched resource. If this property is set, it overrides the chosen fetcher\n * method with `format`.\n * @property {Object} networkOptions - Fetch options (passed directly to\n * `fetch()`), see [the syntax for more information]{@link\n * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax}.\n * By default, set to `{ crossOrigin: 'anonymous' }`.\n * @property {string} projection - The projection of the resources.\n * @property {string} attribution - The intellectual property rights for the\n * resources.\n * @property {Extent} extent - The extent of the resources.\n * @property {function} parser - The method used to parse the resources attached\n * to the layer. iTowns provides some parsers, visible in the `Parser/` folder.\n * If the method is custom, it should return a `Promise` containing the parsed\n * resource. If this property is set, it overrides the default selected parser\n * method with `source.format`. If `source.format` is also empty, no parsing\n * action is done.\n * <br><br>\n * When calling this method, two parameters are passed:\n * <ul>\n *  <li>the fetched data, i.e. the data to parse</li>\n *  <li>an object containing severals properties, set when this method is\n *  called: it is specific to each call, so the value of each property can vary\n *  depending on the current fetched tile for example</li>\n * </ul>\n *\n * The properties of the second parameter are:\n * <ul>\n *  <li>`buildExtent : boolean` - True if the layer does not inherit from {@link\n *  GeometryLayer}.</li>\n *  <li>`crsIn : string` - The projection of the source.</li>\n *  <li>`crsOut : string` - The projection of the layer.</li>\n *  <li>`filteringExtent : Extent` - If the layer inherits from {@link\n *  GeometryLayer}, it is set to the extent of destination, otherwise it is\n *  undefined.</li>\n *  <li>`filter : function` - Property of the layer.</li>\n *  <li>`mergeFeatures : boolean (default true)` - Property of the layer,\n *  default to true.</li>\n *  <li>`withNormal : boolean` - True if the layer inherits from {@link\n *  GeometryLayer}.</li>\n *  <li>`withAltitude : boolean` - True if the layer inherits from {@link\n *  GeometryLayer}.</li>\n *  <li>`isInverted : string` - Property of the source.</li>\n * </ul>\n */\n\nvar Source =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Object} source - An object that can contain all properties of a\n   * Source. Only the `url` property is mandatory.\n   *\n   * @constructor\n   */\n  function Source(source) {\n    (0, _classCallCheck2[\"default\"])(this, Source);\n    this.isSource = true;\n\n    if (!source.url) {\n      throw new Error('New Source: url is required');\n    }\n\n    this.uid = uid++;\n    this.url = source.url;\n    this.format = source.format;\n    this.fetcher = source.fetcher || supportedFetchers.get(source.format) || _Fetcher[\"default\"].texture;\n\n    this.parser = source.parser || supportedParsers.get(source.format) || function (d) {\n      return Promise.resolve(d);\n    };\n\n    this.isVectorSource = (source.parser || supportedParsers.get(source.format)) != undefined;\n    this.networkOptions = source.networkOptions || {\n      crossOrigin: 'anonymous'\n    };\n    this.projection = source.projection;\n    this.attribution = source.attribution;\n    this.whenReady = Promise.resolve();\n\n    if (source.extent && !source.extent.isExtent) {\n      this.extent = new _Extent[\"default\"](this.projection, source.extent);\n    } else {\n      this.extent = source.extent;\n    }\n  }\n\n  (0, _createClass2[\"default\"])(Source, [{\n    key: \"handlingError\",\n    value: function handlingError(err) {\n      console.warn(\"err \".concat(this), err);\n    }\n    /**\n     * Generates an url from an extent. This url is a link to fetch the\n     * resources inside the extent.\n     *\n     * @param {Extent} extent - Extent to convert in url.\n      * @return {string} The URL constructed from the extent.\n     */\n    // eslint-disable-next-line\n\n  }, {\n    key: \"urlFromExtent\",\n    value: function urlFromExtent() {\n      throw new Error('In extended Source, you have to implement the method urlFromExtent!');\n    }\n    /**\n     * Tests if an extent is inside the source limits.\n     *\n     * @param {Extent} extent - Extent to test.\n      * @return {boolean} True if the extent is inside the limit, false otherwise.\n     */\n    // eslint-disable-next-line\n\n  }, {\n    key: \"extentInsideLimit\",\n    value: function extentInsideLimit() {\n      throw new Error('In extented Source, you have to implement the method extentInsideLimit!');\n    }\n    /**\n     * Tests if an array of extents is inside the source limits.\n     *\n     * @param {Array.<Extent>} extents - Array of extents to test.\n      * @return {boolean} True if all extents are inside, false otherwise.\n     */\n\n  }, {\n    key: \"extentsInsideLimit\",\n    value: function extentsInsideLimit(extents) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = extents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var extent = _step.value;\n\n          if (!this.extentInsideLimit(extent)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"onParsedFile\",\n    value: function onParsedFile(parsedFile) {\n      return parsedFile;\n    }\n  }]);\n  return Source;\n}();\n\nvar _default = Source;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Source/Source.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Source/TMSSource.js":
/*!*****************************************************!*\
  !*** ./node_modules/itowns/lib/Source/TMSSource.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _Source2 = _interopRequireDefault(__webpack_require__(/*! ./Source */ \"./node_modules/itowns/lib/Source/Source.js\"));\n\nvar _URLBuilder = _interopRequireDefault(__webpack_require__(/*! ../Provider/URLBuilder */ \"./node_modules/itowns/lib/Provider/URLBuilder.js\"));\n\nvar _Extent = __webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\");\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\n/**\n * @classdesc\n * An object defining the source of resources to get from a [TMS]{@link\n * https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification} server. It\n * inherits from {@link Source}.\n *\n * @extends Source\n *\n * @property {boolean} isTMSSource - Used to checkout whether this source is a\n * TMSSource. Default is true. You should not change this, as it is used\n * internally for optimisation.\n * @property {boolean} isInverted - The isInverted property is to be set to the\n * correct value, true or false (default being false) if the computation of the\n * coordinates needs to be inverted to match the same scheme as OSM, Google Maps\n * or other system. See [this link]{@link\n * https://alastaira.wordpress.com/2011/07/06/converting-tms-tile-coordinates-to-googlebingosm-tile-coordinates/}\n * for more information.\n * @property {string} tileMatrixSet - Tile matrix set of the layer, used in the\n * generation of the coordinates to build the url. Default value is 'WGS84'.\n * @property {Object} zoom - Object containing the minimum and maximum values of\n * the level, to zoom in the source.\n * @property {number} zoom.min - The minimum level of the source. Default value\n * is 0.\n * @property {number} zoom.max - The maximum level of the source. Default value\n * is 20.\n *\n * @example\n * // Create the source\n * const tmsSource = new itowns.TMSSource({\n *     format: 'image/png',\n *     url: 'http://osm.io/styles/${z}/${x}/${y}.png',\n *     attribution: {\n *         name: 'OpenStreetMap',\n *         url: 'http://www.openstreetmap.org/',\n *     },\n *     tileMatrixSet: 'PM',\n * });\n *\n * // Create the layer\n * const colorLayer = new itowns.ColorLayer('OPENSM', {\n *     source: tmsSource,\n * });\n *\n * // Add the layer\n * view.addLayer(colorLayer);\n */\nvar TMSSource =\n/*#__PURE__*/\nfunction (_Source) {\n  (0, _inherits2[\"default\"])(TMSSource, _Source);\n\n  /**\n   * @param {Object} source - An object that can contain all properties of a\n   * TMSSource and {@link Source}. Only `url` is mandatory.\n   *\n   * @constructor\n   */\n  function TMSSource(source) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, TMSSource);\n\n    if (!source.projection) {\n      throw new Error('New TMSSource: projection is required');\n    }\n\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(TMSSource).call(this, source));\n    _this.isTMSSource = true;\n\n    if (!source.extent) {\n      // default to the global extent\n      _this.extent = _Extent.globalExtentTMS.get(source.projection);\n    }\n\n    _this.zoom = source.zoom;\n    _this.isInverted = source.isInverted || false;\n    _this.format = _this.format || 'image/png';\n    _this.url = source.url;\n    _this.projection = _Crs[\"default\"].formatToTms(source.projection);\n    _this.tileMatrixSetLimits = source.tileMatrixSetLimits;\n\n    if (!_this.zoom) {\n      if (_this.tileMatrixSetLimits) {\n        var arrayLimits = Object.keys(_this.tileMatrixSetLimits);\n        var size = arrayLimits.length;\n        var maxZoom = Number(arrayLimits[size - 1]);\n        _this.zoom = {\n          min: maxZoom - size + 1,\n          max: maxZoom\n        };\n      } else {\n        _this.zoom = {\n          min: 0,\n          max: 20\n        };\n      }\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(TMSSource, [{\n    key: \"urlFromExtent\",\n    value: function urlFromExtent(extent) {\n      return _URLBuilder[\"default\"].xyz(extent, this);\n    }\n  }, {\n    key: \"handlingError\",\n    value: function handlingError(err) {\n      console.warn(\"err \".concat(this.url), err);\n    }\n  }, {\n    key: \"extentInsideLimit\",\n    value: function extentInsideLimit(extent) {\n      // This layer provides data starting at level = layer.source.zoom.min\n      // (the zoom.max property is used when building the url to make\n      //  sure we don't use invalid levels)\n      return extent.zoom >= this.zoom.min && extent.zoom <= this.zoom.max && (this.tileMatrixSetLimits == undefined || extent.row >= this.tileMatrixSetLimits[extent.zoom].minTileRow && extent.row <= this.tileMatrixSetLimits[extent.zoom].maxTileRow && extent.col >= this.tileMatrixSetLimits[extent.zoom].minTileCol && extent.col <= this.tileMatrixSetLimits[extent.zoom].maxTileCol);\n    }\n  }]);\n  return TMSSource;\n}(_Source2[\"default\"]);\n\nvar _default = TMSSource;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Source/TMSSource.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Source/VectorTilesSource.js":
/*!*************************************************************!*\
  !*** ./node_modules/itowns/lib/Source/VectorTilesSource.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _TMSSource2 = _interopRequireDefault(__webpack_require__(/*! ./TMSSource */ \"./node_modules/itowns/lib/Source/TMSSource.js\"));\n\nvar _Fetcher = _interopRequireDefault(__webpack_require__(/*! ../Provider/Fetcher */ \"./node_modules/itowns/lib/Provider/Fetcher.js\"));\n\nfunction toTMSUrl(url) {\n  return url.replace(/\\{/g, '${');\n}\n/**\n * @classdesc\n * VectorTilesSource are object containing informations on how to fetch vector tiles resources.\n *\n * @property {string} style - the url to json style.\n * @property {string} sprite - the base url to sprites folder.\n * @property {function} filter - function to filter vector tiles layers, the parameter function is a layer.\n *\n */\n\n\nvar VectorTilesSource =\n/*#__PURE__*/\nfunction (_TMSSource) {\n  (0, _inherits2[\"default\"])(VectorTilesSource, _TMSSource);\n\n  /**\n   * @param {Object} source - An object that can contain all properties of a\n   * VectorTilesSource and {@link Source}.\n   *\n   * @constructor\n   */\n  function VectorTilesSource(source) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, VectorTilesSource);\n    source.format = 'application/x-protobuf;type=mapbox-vector';\n    source.projection = 'EPSG:3857';\n    source.isInverted = true;\n    source.url = source.url || '.';\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(VectorTilesSource).call(this, source));\n\n    var ffilter = source.filter || function () {\n      return true;\n    };\n\n    _this.filter = [];\n    var promises = [];\n\n    if (source.style) {\n      promises.push(_Fetcher[\"default\"].json(source.style).then(function (style) {\n        var s = Object.keys(style.sources)[0];\n        var os = style.sources[s];\n        style.layers.forEach(function (layer) {\n          if (layer.type === 'background') {\n            _this.backgroundLayer = layer;\n          } else if (ffilter(layer)) {\n            _this.filter.push(layer);\n          }\n        });\n\n        if (_this.url == '.') {\n          if (os.url) {\n            return _Fetcher[\"default\"].json(os.url).then(function (tileJSON) {\n              if (tileJSON.tiles[0]) {\n                _this.url = toTMSUrl(tileJSON.tiles[0]);\n              }\n            });\n          } else if (os.tiles[0]) {\n            _this.url = toTMSUrl(os.tiles[0]);\n          }\n        }\n      }));\n    } else {\n      throw new Error('New VectorTilesSource: style is required');\n    }\n\n    if (source.sprite) {\n      promises.push(_Fetcher[\"default\"].json(\"\".concat(source.sprite, \".json\")).then(function (sprites) {\n        _this.sprites = sprites;\n        return _Fetcher[\"default\"].texture(\"\".concat(source.sprite, \".png\"), {\n          crossOrigin: 'anonymous'\n        }).then(function (texture) {\n          _this.sprites.img = texture.image;\n        });\n      }));\n    }\n\n    _this.whenReady = Promise.all(promises);\n    return _this;\n  }\n\n  return VectorTilesSource;\n}(_TMSSource2[\"default\"]);\n\nvar _default = VectorTilesSource;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Source/VectorTilesSource.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Source/WFSSource.js":
/*!*****************************************************!*\
  !*** ./node_modules/itowns/lib/Source/WFSSource.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _Source2 = _interopRequireDefault(__webpack_require__(/*! ./Source */ \"./node_modules/itowns/lib/Source/Source.js\"));\n\nvar _URLBuilder = _interopRequireDefault(__webpack_require__(/*! ../Provider/URLBuilder */ \"./node_modules/itowns/lib/Provider/URLBuilder.js\"));\n\n/**\n * @classdesc\n * An object defining the source of resources to get from a\n * [WFS]{@link http://www.opengeospatial.org/standards/wfs} server. It inherits\n * from {@link Source}.\n *\n * @extends Source\n *\n * @property {boolean} isWFSSource - Used to checkout whether this source is a\n * WFSSource. Default is true. You should not change this, as it is used\n * internally for optimisation.\n * @property {string} typeName - The name of the feature to get, used in the\n * generation of the url.\n * @property {string} version - The version of the WFS server to request on.\n * Default value is '2.0.2'.\n * @property {Object} zoom - Object containing the minimum and maximum values of\n * the level, to zoom in the source.\n * @property {number} zoom.min - The minimum level of the source. Default value\n * is 0.\n * @property {number} zoom.max - The maximum level of the source. Default value\n * is 21.\n * @property {Object} vendorSpecific - An object containing vendor specific\n * parameters. See for example a [list of these parameters for GeoServer]{@link\n * https://docs.geoserver.org/latest/en/user/services/wfs/vendor.html}. This\n * object is read simply with the `key` being the name of the parameter and\n * `value` being the value of the parameter. If used, this property should be\n * set in the constructor parameters.\n *\n * @example\n * // Add color layer with WFS source\n * // Create the source\n * const wfsSource = new itowns.WFSSource({\n *     url: 'http://wxs.fr/wfs',\n *     version: '2.0.0',\n *     typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable',\n *     projection: 'EPSG:4326',\n *     extent: {\n *         west: 4.568,\n *         east: 5.18,\n *         south: 45.437,\n *         north: 46.03,\n *     },\n *     zoom: { min: 14, max: 14 },\n *     format: 'application/json',\n * });\n *\n * // Create the layer\n * const colorlayer = new itowns.ColorLayer('color_build', {\n *     style: {\n *         fill: 'red',\n *         fillOpacity: 0.5,\n *         stroke: 'white',\n *     },\n *     source: wfsSource,\n * });\n *\n * // Add the layer\n * view.addLayer(colorlayer);\n *\n * @example\n * // Add geometry layer with WFS source\n * // Create the source\n * const wfsSource = new itowns.WFSSource({\n *     url: 'http://wxs.fr/wfs',\n *     version: '2.0.0',\n *     typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable',\n *     projection: 'EPSG:4326',\n *     extent: {\n *         west: 4.568,\n *         east: 5.18,\n *         south: 45.437,\n *         north: 46.03,\n *     },\n *     zoom: { min: 14, max: 14 },\n *     format: 'application/json',\n * });\n *\n * // Create the layer\n * const geometryLayer = new itowns.GeometryLayer('mesh_build', {\n *     update: itowns.FeatureProcessing.update,\n *     convert: itowns.Feature2Mesh.convert({ extrude: () => 50 }),\n *     source: wfsSource,\n * });\n *\n * // Add the layer\n * view.addLayer(geometryLayer);\n */\nvar WFSSource =\n/*#__PURE__*/\nfunction (_Source) {\n  (0, _inherits2[\"default\"])(WFSSource, _Source);\n\n  /**\n   * @param {Object} source - An object that can contain all properties of a\n   * WFSSource and {@link Source}. `url`, `typeName` and `projection` are\n   * mandatory.\n   *\n   * @constructor\n   */\n  function WFSSource(source) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, WFSSource);\n\n    if (!source.typeName) {\n      throw new Error('source.typeName is required in wfs source.');\n    }\n\n    if (!source.projection) {\n      throw new Error('source.projection is required in wfs source');\n    }\n\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(WFSSource).call(this, source));\n    _this.isWFSSource = true;\n    _this.typeName = source.typeName;\n    _this.format = _this.format || 'application/json';\n    _this.version = source.version || '2.0.2';\n    _this.url = \"\".concat(source.url, \"SERVICE=WFS&REQUEST=GetFeature&typeName=\").concat(_this.typeName, \"&VERSION=\").concat(_this.version, \"&SRSNAME=\").concat(_this.projection, \"&outputFormat=\").concat(_this.format, \"&BBOX=%bbox,\").concat(_this.projection);\n    _this.zoom = source.zoom || {\n      min: 0,\n      max: 21\n    };\n    _this.vendorSpecific = source.vendorSpecific;\n\n    for (var name in _this.vendorSpecific) {\n      if (Object.prototype.hasOwnProperty.call(_this.vendorSpecific, name)) {\n        _this.url = \"\".concat(_this.url, \"&\").concat(name, \"=\").concat(_this.vendorSpecific[name]);\n      }\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(WFSSource, [{\n    key: \"handlingError\",\n    value: function handlingError(err) {\n      var _this2 = this;\n\n      if (err.response && err.response.status == 400) {\n        return err.response.text().then(function (text) {\n          var getCapUrl = \"\".concat(_this2.url, \"SERVICE=WFS&REQUEST=GetCapabilities&VERSION=\").concat(_this2.version);\n          var xml = new DOMParser().parseFromString(text, 'application/xml');\n          var errorElem = xml.querySelector('Exception');\n          var errorCode = errorElem.getAttribute('exceptionCode');\n          var errorMessage = errorElem.querySelector('ExceptionText').textContent;\n          console.error(\"Source \".concat(_this2.typeName, \": bad request when fetching data. Server says: \\\"\").concat(errorCode, \": \").concat(errorMessage, \"\\\". \\nReviewing \").concat(getCapUrl, \" may help.\"), err);\n          throw err;\n        });\n      } else {\n        console.error(\"Source \".concat(this.typeName, \": error while trying to fetch/parse/convert WFS data.\"), err);\n        throw err;\n      }\n    }\n  }, {\n    key: \"urlFromExtent\",\n    value: function urlFromExtent(extent) {\n      return _URLBuilder[\"default\"].bbox(extent, this);\n    }\n  }, {\n    key: \"extentInsideLimit\",\n    value: function extentInsideLimit(extent) {\n      return (extent.zoom == undefined || extent.zoom >= this.zoom.min && extent.zoom <= this.zoom.max) && this.extent.intersectsExtent(extent);\n    }\n  }]);\n  return WFSSource;\n}(_Source2[\"default\"]);\n\nvar _default = WFSSource;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Source/WFSSource.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Source/WMSSource.js":
/*!*****************************************************!*\
  !*** ./node_modules/itowns/lib/Source/WMSSource.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _Source2 = _interopRequireDefault(__webpack_require__(/*! ./Source */ \"./node_modules/itowns/lib/Source/Source.js\"));\n\nvar _URLBuilder = _interopRequireDefault(__webpack_require__(/*! ../Provider/URLBuilder */ \"./node_modules/itowns/lib/Provider/URLBuilder.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar _extent = new _Extent[\"default\"]('EPSG:4326', 0, 0, 0, 0);\n/**\n * @classdesc\n * An object defining the source of images to get from a\n * [WMS]{@link http://www.opengeospatial.org/standards/wms} server. It inherits\n * from {@link Source}.\n *\n * @extends Source\n *\n * @property {boolean} isWMSSource - Used to checkout whether this source is a\n * WMSSource. Default is true. You should not change this, as it is used\n * internally for optimisation.\n * @property {string} name - The name of the layer, used in the generation of\n * the url.\n * @property {string} version - The version of the WMS server to request on.\n * Default value is '1.3.0'.\n * @property {string} style - The style to query on the WMS server. Default\n * value is 'normal'.\n * @property {number} width - The width of the image to fetch, in pixel.\n * Default value is the height if set or 256.\n * @property {number} height - The height of the image to fetch, in pixel.\n * Default value is the width if set or 256.\n * @property {string} axisOrder - The order of the axis, that helps building the\n * BBOX to put in the url requesting a resource. Default value is 'wsen', other\n * value can be 'swne'.\n * @property {boolean} transparent - Tells if the image to fetch needs\n * transparency support. Default value is false.\n * @property {Object} zoom - Object containing the minimum and maximum values of\n * the level, to zoom in the source.\n * @property {number} zoom.min - The minimum level of the source. Default value\n * is 0.\n * @property {number} zoom.max - The maximum level of the source. Default value\n * is 21.\n * @property {Object} vendorSpecific - An object containing vendor specific\n * parameters. See for example a [list of these parameters for GeoServer]{@link\n * https://docs.geoserver.org/latest/en/user/services/wms/vendor.html}. This\n * object is read simply with the `key` being the name of the parameter and\n * `value` being the value of the parameter. If used, this property should be\n * set in the constructor parameters.\n *\n * @example\n * // Create the source\n * const wmsSource = new itowns.WMSSource({\n *     url: 'https://server.geo/wms',\n *     version: '1.3.0',\n *     name: 'REGION.2016',\n *     style: '',\n *     projection: 'EPSG:3857',\n *     extent: {\n *         west: '-6880639.13557728',\n *         east: '6215707.87974825',\n *         south: '-2438399.00148845',\n *         north: '7637050.03850605',\n *     },\n *     transparent: true,\n * });\n *\n * // Create the layer\n * const colorlayer = new itowns.ColorLayer('Region', {\n *     source: wmsSource,\n * });\n *\n * // Add the layer\n * view.addLayer(colorlayer);\n */\n\n\nvar WMSSource =\n/*#__PURE__*/\nfunction (_Source) {\n  (0, _inherits2[\"default\"])(WMSSource, _Source);\n\n  /**\n   * @param {Object} source - An object that can contain all properties of\n   * WMSSource and {@link Source}. `url`, `name`, `extent` and `projection`\n   * are mandatory.\n   *\n   * @constructor\n   */\n  function WMSSource(source) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, WMSSource);\n\n    if (!source.name) {\n      throw new Error('source.name is required.');\n    }\n\n    if (!source.extent) {\n      throw new Error('source.extent is required');\n    }\n\n    if (!source.projection) {\n      throw new Error('source.projection is required');\n    }\n\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(WMSSource).call(this, source));\n    _this.isWMSSource = true;\n    _this.name = source.name;\n    _this.zoom = source.zoom || {\n      min: 0,\n      max: 21\n    };\n    _this.format = _this.format || 'image/png';\n    _this.style = source.style || '';\n    _this.width = source.width || source.height || 256;\n    _this.height = source.height || source.width || 256;\n    _this.version = source.version || '1.3.0';\n    _this.transparent = source.transparent || false;\n\n    if (!source.axisOrder) {\n      // 4326 (lat/long) axis order depends on the WMS version used\n      if (source.projection == 'EPSG:4326') {\n        // EPSG 4326 x = lat, long = y\n        // version 1.1.0 long/lat while version 1.3.0 mandates xy (so lat,long)\n        _this.axisOrder = _this.version === '1.1.0' ? 'wsen' : 'swne';\n      } else {\n        // xy,xy order\n        _this.axisOrder = 'wsen';\n      }\n    }\n\n    var crsPropName = _this.version === '1.3.0' ? 'CRS' : 'SRS';\n    _this.url = \"\".concat(source.url, \"?SERVICE=WMS&REQUEST=GetMap&LAYERS=\").concat(_this.name, \"&VERSION=\").concat(_this.version, \"&STYLES=\").concat(_this.style, \"&FORMAT=\").concat(_this.format, \"&TRANSPARENT=\").concat(_this.transparent, \"&BBOX=%bbox&\").concat(crsPropName, \"=\").concat(_this.projection, \"&WIDTH=\").concat(_this.width, \"&HEIGHT=\").concat(_this.height);\n    _this.vendorSpecific = source.vendorSpecific;\n\n    for (var name in _this.vendorSpecific) {\n      if (Object.prototype.hasOwnProperty.call(_this.vendorSpecific, name)) {\n        _this.url = \"\".concat(_this.url, \"&\").concat(name, \"=\").concat(_this.vendorSpecific[name]);\n      }\n    }\n\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(WMSSource, [{\n    key: \"urlFromExtent\",\n    value: function urlFromExtent(extent) {\n      return _URLBuilder[\"default\"].bbox(extent, this);\n    }\n  }, {\n    key: \"extentInsideLimit\",\n    value: function extentInsideLimit(extent) {\n      var localExtent = this.projection == extent.crs ? extent : extent.as(this.projection, _extent);\n      return (extent.zoom == undefined || !(extent.zoom < this.zoom.min || extent.zoom > this.zoom.max)) && this.extent.intersectsExtent(localExtent);\n    }\n  }]);\n  return WMSSource;\n}(_Source2[\"default\"]);\n\nvar _default = WMSSource;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Source/WMSSource.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Source/WMTSSource.js":
/*!******************************************************!*\
  !*** ./node_modules/itowns/lib/Source/WMTSSource.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _TMSSource2 = _interopRequireDefault(__webpack_require__(/*! ./TMSSource */ \"./node_modules/itowns/lib/Source/TMSSource.js\"));\n\n/**\n * @classdesc\n * An object defining the source of resources to get from a\n * [WMTS]{@link http://www.opengeospatial.org/standards/wmts} server. It inherits\n * from {@link Source}.\n *\n * @extends Source\n *\n * @property {boolean} isWMTSSource - Used to checkout whether this source is a\n * WMTSSource. Default is true. You should not change this, as it is used\n * internally for optimisation.\n * @property {string} name - The name of the layer, used in the generation of\n * the url.\n * @property {string} version - The version of the WMTS server to request on.\n * Default value is '1.0.0'.\n * @property {string} style - The style to query on the WMTS server. Default\n * value is 'normal'.\n * @property {string} projection - The projection in which to fetch the data. If\n * not specified, it is deduced from `tileMatrixSet`. Default value is\n * 'EPSG:3857'.\n * @property {string} tileMatrixSet - Tile matrix set of the layer, used in the\n * generation of the url. Default value is 'WGS84'.\n * @property {Object} tileMatrixSetLimits - Limits of the tile matrix set. Each\n * limit has for key its level number, and their properties are the\n * `minTileRow`, `maxTileRow`, `minTileCol` and `maxTileCol`.\n * @property {number} tileMatrixSetLimits.minTileRow - Minimum row for tiles at\n * the specified level.\n * @property {number} tileMatrixSetLimits.maxTileRow - Maximum row for tiles at\n * the specified level.\n * @property {number} tileMatrixSetLimits.minTileCol - Minimum column for tiles\n * at the specified level.\n * @property {number} tileMatrixSetLimits.maxTileCol - Maximum column for tiles\n * at the specified level.\n * @property {Object} zoom - Object containing the minimum and maximum values of\n * the level, to zoom in the source.\n * @property {number} zoom.min - The minimum level of the source. Default value\n * is 2.\n * @property {number} zoom.max - The maximum level of the source. Default value\n * is 20.\n *\n * @example\n * // Create the source\n * const wmtsSource = new itowns.WMTSSource({\n *     name: 'DARK',\n *     tileMatrixSet: 'PM',\n *     url: 'http://server.geo/wmts',\n *     format: 'image/jpg',\n * });\n *\n * // Create the layer\n * const colorLayer = new itowns.ColorLayer('darkmap', {\n *     source: wmtsSource,\n * });\n *\n * // Add the layer\n * view.addLayer(colorLayer);\n */\nvar WMTSSource =\n/*#__PURE__*/\nfunction (_TMSSource) {\n  (0, _inherits2[\"default\"])(WMTSSource, _TMSSource);\n\n  /**\n   * @param {Object} source - An object that can contain all properties of a\n   * WMTSSource and {@link Source}. Only `url` and `name` are mandatory.\n   *\n   * @constructor\n   */\n  function WMTSSource(source) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, WMTSSource);\n\n    if (!source.name) {\n      throw new Error('New WMTSSource: name is required');\n    }\n\n    if (!source.projection) {\n      throw new Error('New WMTSSource: projection is required');\n    }\n\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(WMTSSource).call(this, source));\n    _this.isWMTSSource = true;\n    _this.url = \"\".concat(_this.url) + \"?LAYER=\".concat(source.name) + \"&FORMAT=\".concat(_this.format) + '&SERVICE=WMTS' + \"&VERSION=\".concat(source.version || '1.0.0') + '&REQUEST=GetTile' + \"&STYLE=\".concat(source.style || 'normal') + \"&TILEMATRIXSET=\".concat(source.tileMatrixSet) + '&TILEMATRIX=%TILEMATRIX&TILEROW=%ROW&TILECOL=%COL';\n    return _this;\n  }\n\n  return WMTSSource;\n}(_TMSSource2[\"default\"]);\n\nvar _default = WMTSSource;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Source/WMTSSource.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/ThreeExtended/WebGL.js":
/*!********************************************************!*\
  !*** ./node_modules/itowns/lib/ThreeExtended/WebGL.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WEBGL = exports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\n// This file has been added and patched after installing the NPM modules (via NPM script 'prepare')\nvar threeExamples = {};\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mr.doob / http://mrdoob.com/\n */\n\nvar WEBGL = {\n  isWebGLAvailable: function isWebGLAvailable() {\n    try {\n      var canvas = document.createElement('canvas');\n      return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      return false;\n    }\n  },\n  isWebGL2Available: function isWebGL2Available() {\n    try {\n      var canvas = document.createElement('canvas');\n      return !!(window.WebGL2RenderingContext && canvas.getContext('webgl2'));\n    } catch (e) {\n      return false;\n    }\n  },\n  getWebGLErrorMessage: function getWebGLErrorMessage() {\n    return this.getErrorMessage(1);\n  },\n  getWebGL2ErrorMessage: function getWebGL2ErrorMessage() {\n    return this.getErrorMessage(2);\n  },\n  getErrorMessage: function getErrorMessage(version) {\n    var contexts = {\n      1: window.WebGLRenderingContext,\n      2: window.WebGL2RenderingContext\n    };\n    var message = 'Your $0 does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">$1</a>';\n    var element = document.createElement('div');\n    element.id = 'webglmessage';\n    element.style.fontFamily = 'monospace';\n    element.style.fontSize = '13px';\n    element.style.fontWeight = 'normal';\n    element.style.textAlign = 'center';\n    element.style.background = '#fff';\n    element.style.color = '#000';\n    element.style.padding = '1.5em';\n    element.style.width = '400px';\n    element.style.margin = '5em auto 0';\n\n    if (contexts[version]) {\n      message = message.replace('$0', 'graphics card');\n    } else {\n      message = message.replace('$0', 'browser');\n    }\n\n    message = message.replace('$1', {\n      1: 'WebGL',\n      2: 'WebGL 2'\n    }[version]);\n    element.innerHTML = message;\n    return element;\n  }\n};\nexports.WEBGL = WEBGL;\nvar _default = threeExamples.WebGL;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/ThreeExtended/WebGL.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/ThreeExtended/loaders/DDSLoader.js":
/*!********************************************************************!*\
  !*** ./node_modules/itowns/lib/ThreeExtended/loaders/DDSLoader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\n// This file has been added and patched after installing the NPM modules (via NPM script 'prepare')\nvar threeExamples = {};\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nthreeExamples.DDSLoader = function (manager) {\n  THREE.CompressedTextureLoader.call(this, manager);\n};\n\nthreeExamples.DDSLoader.prototype = Object.assign(Object.create(THREE.CompressedTextureLoader.prototype), {\n  constructor: threeExamples.DDSLoader,\n  parse: function parse(buffer, loadMipmaps) {\n    var dds = {\n      mipmaps: [],\n      width: 0,\n      height: 0,\n      format: null,\n      mipmapCount: 1\n    }; // Adapted from @toji's DDS utils\n    // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n    // All values and structures referenced from:\n    // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n    function fourCCToInt32(value) {\n      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n    }\n\n    function int32ToFourCC(value) {\n      return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n    }\n\n    function loadARGBMip(buffer, dataOffset, width, height) {\n      var dataLength = width * height * 4;\n      var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);\n      var byteArray = new Uint8Array(dataLength);\n      var dst = 0;\n      var src = 0;\n\n      for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n          var b = srcBuffer[src];\n          src++;\n          var g = srcBuffer[src];\n          src++;\n          var r = srcBuffer[src];\n          src++;\n          var a = srcBuffer[src];\n          src++;\n          byteArray[dst] = r;\n          dst++; //r\n\n          byteArray[dst] = g;\n          dst++; //g\n\n          byteArray[dst] = b;\n          dst++; //b\n\n          byteArray[dst] = a;\n          dst++; //a\n        }\n      }\n\n      return byteArray;\n    }\n\n    var FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n    var FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n    var FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n    var FOURCC_ETC1 = fourCCToInt32(\"ETC1\");\n    // Parse header\n    var header = new Int32Array(buffer, 0, 31);\n\n    if (header[0] !== 0x20534444) {\n      console.error('threeExamples.DDSLoader.parse: Invalid magic number in DDS header.');\n      return dds;\n    }\n\n    if (!header[20] & 0x4) {\n      console.error('threeExamples.DDSLoader.parse: Unsupported format, must contain a FourCC code.');\n      return dds;\n    }\n\n    var blockBytes;\n    var fourCC = header[21];\n    var isRGBAUncompressed = false;\n\n    switch (fourCC) {\n      case FOURCC_DXT1:\n        blockBytes = 8;\n        dds.format = THREE.RGB_S3TC_DXT1_Format;\n        break;\n\n      case FOURCC_DXT3:\n        blockBytes = 16;\n        dds.format = THREE.RGBA_S3TC_DXT3_Format;\n        break;\n\n      case FOURCC_DXT5:\n        blockBytes = 16;\n        dds.format = THREE.RGBA_S3TC_DXT5_Format;\n        break;\n\n      case FOURCC_ETC1:\n        blockBytes = 8;\n        dds.format = THREE.RGB_ETC1_Format;\n        break;\n\n      default:\n        if (header[22] === 32 && header[23] & 0xff0000 && header[24] & 0xff00 && header[25] & 0xff && header[26] & 0xff000000) {\n          isRGBAUncompressed = true;\n          blockBytes = 64;\n          dds.format = THREE.RGBAFormat;\n        } else {\n          console.error('threeExamples.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));\n          return dds;\n        }\n\n    }\n\n    dds.mipmapCount = 1;\n\n    if (header[2] & 0x20000 && loadMipmaps !== false) {\n      dds.mipmapCount = Math.max(1, header[7]);\n    }\n\n    var caps2 = header[28];\n    dds.isCubemap = caps2 & 0x200 ? true : false;\n\n    if (dds.isCubemap && (!(caps2 & 0x400) || !(caps2 & 0x800) || !(caps2 & 0x1000) || !(caps2 & 0x2000) || !(caps2 & 0x4000) || !(caps2 & 0x8000))) {\n      console.error('threeExamples.DDSLoader.parse: Incomplete cubemap faces');\n      return dds;\n    }\n\n    dds.width = header[4];\n    dds.height = header[3];\n    var dataOffset = header[1] + 4; // Extract mipmaps buffers\n\n    var faces = dds.isCubemap ? 6 : 1;\n\n    for (var face = 0; face < faces; face++) {\n      var width = dds.width;\n      var height = dds.height;\n\n      for (var i = 0; i < dds.mipmapCount; i++) {\n        if (isRGBAUncompressed) {\n          var byteArray = loadARGBMip(buffer, dataOffset, width, height);\n          var dataLength = byteArray.length;\n        } else {\n          var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n          var byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n        }\n\n        var mipmap = {\n          \"data\": byteArray,\n          \"width\": width,\n          \"height\": height\n        };\n        dds.mipmaps.push(mipmap);\n        dataOffset += dataLength;\n        width = Math.max(width >> 1, 1);\n        height = Math.max(height >> 1, 1);\n      }\n    }\n\n    return dds;\n  }\n});\nvar _default = threeExamples.DDSLoader;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/ThreeExtended/loaders/DDSLoader.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/ThreeExtended/loaders/DRACOLoader.js":
/*!**********************************************************************!*\
  !*** ./node_modules/itowns/lib/ThreeExtended/loaders/DRACOLoader.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\n// This file has been added and patched after installing the NPM modules (via NPM script 'prepare')\nvar threeExamples = {};\n/**\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nthreeExamples.DRACOLoader = function (manager) {\n  THREE.Loader.call(this, manager);\n  this.decoderPath = '';\n  this.decoderConfig = {};\n  this.decoderBinary = null;\n  this.decoderPending = null;\n  this.workerLimit = 4;\n  this.workerPool = [];\n  this.workerNextTaskID = 1;\n  this.workerSourceURL = '';\n  this.defaultAttributeIDs = {\n    position: 'POSITION',\n    normal: 'NORMAL',\n    color: 'COLOR',\n    uv: 'TEX_COORD'\n  };\n  this.defaultAttributeTypes = {\n    position: 'Float32Array',\n    normal: 'Float32Array',\n    color: 'Float32Array',\n    uv: 'Float32Array'\n  };\n};\n\nthreeExamples.DRACOLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n  constructor: threeExamples.DRACOLoader,\n  setDecoderPath: function setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  },\n  setDecoderConfig: function setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  },\n  setWorkerLimit: function setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  },\n\n  /** @deprecated */\n  setVerbosity: function setVerbosity() {\n    console.warn('threeExamples.DRACOLoader: The .setVerbosity() method has been removed.');\n  },\n\n  /** @deprecated */\n  setDrawMode: function setDrawMode() {\n    console.warn('threeExamples.DRACOLoader: The .setDrawMode() method has been removed.');\n  },\n\n  /** @deprecated */\n  setSkipDequantization: function setSkipDequantization() {\n    console.warn('threeExamples.DRACOLoader: The .setSkipDequantization() method has been removed.');\n  },\n  load: function load(url, onLoad, onProgress, onError) {\n    var _this = this;\n\n    var loader = new THREE.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n\n    if (this.crossOrigin === 'use-credentials') {\n      loader.setWithCredentials(true);\n    }\n\n    loader.load(url, function (buffer) {\n      var taskConfig = {\n        attributeIDs: _this.defaultAttributeIDs,\n        attributeTypes: _this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n\n      _this.decodeGeometry(buffer, taskConfig).then(onLoad)[\"catch\"](onError);\n    }, onProgress, onError);\n  },\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    var taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  },\n  decodeGeometry: function decodeGeometry(buffer, taskConfig) {\n    var _this2 = this;\n\n    var worker;\n    var taskID = this.workerNextTaskID++;\n    var taskCost = buffer.byteLength; // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n\n    for (var attribute in taskConfig.attributeTypes) {\n      var type = taskConfig.attributeTypes[attribute];\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    } // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n\n\n    var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {\n      worker = _worker;\n      return new Promise(function (resolve, reject) {\n        worker._callbacks[taskID] = {\n          resolve: resolve,\n          reject: reject\n        };\n        worker.postMessage({\n          type: 'decode',\n          id: taskID,\n          taskConfig: taskConfig,\n          buffer: buffer\n        }, [buffer]); // this.debug();\n      });\n    }).then(function (message) {\n      return _this2._createGeometry(message.geometry);\n    }); // Remove task from the task list.\n\n\n    geometryPending[\"finally\"](function () {\n      if (worker && taskID) {\n        _this2._releaseTask(worker, taskID); // this.debug();\n\n      }\n    });\n    return geometryPending;\n  },\n  _createGeometry: function _createGeometry(geometryData) {\n    var geometry = new THREE.BufferGeometry();\n\n    if (geometryData.index) {\n      geometry.setIndex(new THREE.BufferAttribute(geometryData.index.array, 1));\n    }\n\n    for (var i = 0; i < geometryData.attributes.length; i++) {\n      var attribute = geometryData.attributes[i];\n      var name = attribute.name;\n      var array = attribute.array;\n      var itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new THREE.BufferAttribute(array, itemSize));\n    }\n\n    return geometry;\n  },\n  _loadLibrary: function _loadLibrary(url, responseType) {\n    var loader = new THREE.FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    return new Promise(function (resolve, reject) {\n      loader.load(url, resolve, undefined, reject);\n    });\n  },\n  _initDecoder: function _initDecoder() {\n    var _this3 = this;\n\n    if (this.decoderPending) return this.decoderPending;\n    var useJS = (typeof WebAssembly === \"undefined\" ? \"undefined\" : (0, _typeof2[\"default\"])(WebAssembly)) !== 'object' || this.decoderConfig.type === 'js';\n    var librariesPending = [];\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then(function (libraries) {\n      var jsContent = libraries[0];\n\n      if (!useJS) {\n        _this3.decoderConfig.wasmBinary = libraries[1];\n      }\n\n      var fn = threeExamples.DRACOLoader.DRACOWorker.toString();\n      var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n      _this3.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  },\n  _getWorker: function _getWorker(taskID, taskCost) {\n    var _this4 = this;\n\n    return this._initDecoder().then(function () {\n      if (_this4.workerPool.length < _this4.workerLimit) {\n        var worker = new Worker(_this4.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          decoderConfig: _this4.decoderConfig\n        });\n\n        worker.onmessage = function (e) {\n          var message = e.data;\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('threeExamples.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        _this4.workerPool.push(worker);\n      } else {\n        _this4.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      var worker = _this4.workerPool[_this4.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  },\n  _releaseTask: function _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  },\n  debug: function debug() {\n    console.log('Task load: ', this.workerPool.map(function (worker) {\n      return worker._taskLoad;\n    }));\n  },\n  dispose: function dispose() {\n    for (var i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n});\n/* WEB WORKER */\n\nthreeExamples.DRACOLoader.DRACOWorker = function () {\n  var decoderConfig;\n  var decoderPending;\n\n  onmessage = function onmessage(e) {\n    var message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n\n      case 'decode':\n        var buffer = message.buffer;\n        var taskConfig = message.taskConfig;\n        decoderPending.then(function (module) {\n          var draco = module.draco;\n          var decoder = new draco.Decoder();\n          var decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            var buffers = geometry.attributes.map(function (attr) {\n              return attr.array.buffer;\n            });\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry: geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    var attributeIDs = taskConfig.attributeIDs;\n    var attributeTypes = taskConfig.attributeTypes;\n    var dracoGeometry;\n    var decodingStatus;\n    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('threeExamples.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('threeExamples.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    var geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (var attributeName in attributeIDs) {\n      var attributeType = self[attributeTypes[attributeName]];\n      var attribute;\n      var attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      // Generate mesh faces.\n      var numFaces = dracoGeometry.num_faces();\n      var index = new Uint32Array(numFaces * 3);\n      var indexArray = new draco.DracoInt32Array();\n\n      for (var i = 0; i < numFaces; ++i) {\n        decoder.GetFaceFromMesh(dracoGeometry, i, indexArray);\n\n        for (var j = 0; j < 3; ++j) {\n          index[i * 3 + j] = indexArray.GetValue(j);\n        }\n      }\n\n      geometry.index = {\n        array: index,\n        itemSize: 1\n      };\n      draco.destroy(indexArray);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    var numComponents = attribute.num_components();\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    var dracoArray;\n    var array;\n\n    switch (attributeType) {\n      case Float32Array:\n        dracoArray = new draco.DracoFloat32Array();\n        decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, dracoArray);\n        array = new Float32Array(numValues);\n        break;\n\n      case Int8Array:\n        dracoArray = new draco.DracoInt8Array();\n        decoder.GetAttributeInt8ForAllPoints(dracoGeometry, attribute, dracoArray);\n        array = new Int8Array(numValues);\n        break;\n\n      case Int16Array:\n        dracoArray = new draco.DracoInt16Array();\n        decoder.GetAttributeInt16ForAllPoints(dracoGeometry, attribute, dracoArray);\n        array = new Int16Array(numValues);\n        break;\n\n      case Int32Array:\n        dracoArray = new draco.DracoInt32Array();\n        decoder.GetAttributeInt32ForAllPoints(dracoGeometry, attribute, dracoArray);\n        array = new Int32Array(numValues);\n        break;\n\n      case Uint8Array:\n        dracoArray = new draco.DracoUInt8Array();\n        decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, attribute, dracoArray);\n        array = new Uint8Array(numValues);\n        break;\n\n      case Uint16Array:\n        dracoArray = new draco.DracoUInt16Array();\n        decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, attribute, dracoArray);\n        array = new Uint16Array(numValues);\n        break;\n\n      case Uint32Array:\n        dracoArray = new draco.DracoUInt32Array();\n        decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, attribute, dracoArray);\n        array = new Uint32Array(numValues);\n        break;\n\n      default:\n        throw new Error('threeExamples.DRACOLoader: Unexpected attribute type.');\n    }\n\n    for (var i = 0; i < numValues; i++) {\n      array[i] = dracoArray.GetValue(i);\n    }\n\n    draco.destroy(dracoArray);\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n};\n/** Deprecated static methods */\n\n/** @deprecated */\n\n\nthreeExamples.DRACOLoader.setDecoderPath = function () {\n  console.warn('threeExamples.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.');\n};\n/** @deprecated */\n\n\nthreeExamples.DRACOLoader.setDecoderConfig = function () {\n  console.warn('threeExamples.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.');\n};\n/** @deprecated */\n\n\nthreeExamples.DRACOLoader.releaseDecoderModule = function () {\n  console.warn('threeExamples.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.');\n};\n/** @deprecated */\n\n\nthreeExamples.DRACOLoader.getDecoderModule = function () {\n  console.warn('threeExamples.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.');\n};\n\nvar _default = threeExamples.DRACOLoader;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/ThreeExtended/loaders/DRACOLoader.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/ThreeExtended/loaders/GLTFLoader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/itowns/lib/ThreeExtended/loaders/GLTFLoader.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _DDSLoader = _interopRequireDefault(__webpack_require__(/*! ./DDSLoader */ \"./node_modules/itowns/lib/ThreeExtended/loaders/DDSLoader.js\"));\n\n// This file has been added and patched after installing the NPM modules (via NPM script 'prepare')\nvar threeExamples = {};\n\n/**\n* @author Rich Tibbett / https://github.com/richtr\n* @author mrdoob / http://mrdoob.com/\n* @author Tony Parisi / http://www.tonyparisi.com/\n* @author Takahiro / https://github.com/takahirox\n* @author Don McCurdy / https://www.donmccurdy.com\n*/\nthreeExamples.GLTFLoader = function () {\n  function GLTFLoader(manager) {\n    THREE.Loader.call(this, manager);\n    this.dracoLoader = null;\n    this.ddsLoader = null;\n  }\n\n  GLTFLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n    constructor: GLTFLoader,\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var resourcePath;\n\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = THREE.LoaderUtils.extractUrlBase(url);\n      } // Tells the LoadingManager to track an extra item, which resolves after\n      // the model is fully loaded. This means the count of items loaded will\n      // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n      scope.manager.itemStart(url);\n\n      var _onError = function (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      };\n\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n\n      if (scope.crossOrigin === 'use-credentials') {\n        loader.setWithCredentials(true);\n      }\n\n      loader.load(url, function (data) {\n        try {\n          scope.parse(data, resourcePath, function (gltf) {\n            onLoad(gltf);\n            scope.manager.itemEnd(url);\n          }, _onError);\n        } catch (e) {\n          _onError(e);\n        }\n      }, onProgress, _onError);\n    },\n    setDRACOLoader: function setDRACOLoader(dracoLoader) {\n      this.dracoLoader = dracoLoader;\n      return this;\n    },\n    setDDSLoader: function setDDSLoader(ddsLoader) {\n      this.ddsLoader = ddsLoader;\n      return this;\n    },\n    parse: function parse(data, path, onLoad, onError) {\n      var content;\n      var extensions = {};\n\n      if (typeof data === 'string') {\n        content = data;\n      } else {\n        var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n          try {\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n          } catch (error) {\n            if (onError) onError(error);\n            return;\n          }\n\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n        } else {\n          content = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n        }\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.asset === undefined || json.asset.version[0] < 2) {\n        if (onError) onError(new Error('threeExamples.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));\n        return;\n      }\n\n      if (json.extensionsUsed) {\n        for (var i = 0; i < json.extensionsUsed.length; ++i) {\n          var extensionName = json.extensionsUsed[i];\n          var extensionsRequired = json.extensionsRequired || [];\n\n          switch (extensionName) {\n            case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n              extensions[extensionName] = new GLTFLightsExtension(json);\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_UNLIT:\n              extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n              break;\n\n            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n              break;\n\n            case EXTENSIONS.MSFT_TEXTURE_DDS:\n              extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);\n              break;\n\n            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n              extensions[extensionName] = new GLTFTextureTransformExtension();\n              break;\n\n            default:\n              if (extensionsRequired.indexOf(extensionName) >= 0) {\n                console.warn('threeExamples.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n              }\n\n          }\n        }\n      }\n\n      var parser = new GLTFParser(json, extensions, {\n        path: path || this.resourcePath || '',\n        crossOrigin: this.crossOrigin,\n        manager: this.manager\n      });\n      parser.parse(onLoad, onError);\n    }\n  });\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    var objects = {};\n    return {\n      get: function get(key) {\n        return objects[key];\n      },\n      add: function add(key, object) {\n        objects[key] = object;\n      },\n      remove: function remove(key) {\n        delete objects[key];\n      },\n      removeAll: function removeAll() {\n        objects = {};\n      }\n    };\n  }\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n\n  var EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n    MSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n  };\n  /**\n   * DDS Texture Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n   *\n   */\n\n  function GLTFTextureDDSExtension(ddsLoader) {\n    if (!ddsLoader) {\n      throw new Error('threeExamples.GLTFLoader: Attempting to load .dds texture without importing DDSLoader');\n    }\n\n    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n    this.ddsLoader = ddsLoader;\n  }\n  /**\n   * Punctual Lights Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n   */\n\n\n  function GLTFLightsExtension(json) {\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};\n    this.lightDefs = extension.lights || [];\n  }\n\n  GLTFLightsExtension.prototype.loadLight = function (lightIndex) {\n    var lightDef = this.lightDefs[lightIndex];\n    var lightNode;\n    var color = new THREE.Color(0xffffff);\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n    var range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new THREE.DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new THREE.PointLight(color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new THREE.SpotLight(color);\n        lightNode.distance = range; // Handle spotlight properties.\n\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error('threeExamples.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".');\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n\n\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n    lightNode.name = lightDef.name || 'light_' + lightIndex;\n    return Promise.resolve(lightNode);\n  };\n  /**\n   * Unlit Materials Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n   */\n\n\n  function GLTFMaterialsUnlitExtension() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n    return THREE.MeshBasicMaterial;\n  };\n\n  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {\n    var pending = [];\n    materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    var metallicRoughness = materialDef.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /* BINARY EXTENSION */\n\n\n  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n  var BINARY_EXTENSION_HEADER_LENGTH = 12;\n  var BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 0x4E4F534A,\n    BIN: 0x004E4942\n  };\n\n  function GLTFBinaryExtension(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('threeExamples.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('threeExamples.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');\n    }\n\n    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    var chunkIndex = 0;\n\n    while (chunkIndex < chunkView.byteLength) {\n      var chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      var chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = THREE.LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('threeExamples.GLTFLoader: JSON content not found.');\n    }\n  }\n  /**\n   * DRACO Mesh Compression Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n   */\n\n\n  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('threeExamples.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n  }\n\n  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n    var json = this.json;\n    var dracoLoader = this.dracoLoader;\n    var bufferViewIndex = primitive.extensions[this.name].bufferView;\n    var gltfAttributeMap = primitive.extensions[this.name].attributes;\n    var threeAttributeMap = {};\n    var attributeNormalizedMap = {};\n    var attributeTypeMap = {};\n\n    for (var attributeName in gltfAttributeMap) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (attributeName in primitive.attributes) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        var accessorDef = json.accessors[primitive.attributes[attributeName]];\n        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (var attributeName in geometry.attributes) {\n            var attribute = geometry.attributes[attributeName];\n            var normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== undefined) attribute.normalized = normalized;\n          }\n\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  };\n  /**\n   * Texture Transform Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n   */\n\n\n  function GLTFTextureTransformExtension() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    if (transform.texCoord !== undefined) {\n      console.warn('threeExamples.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n\n    texture.needsUpdate = true;\n    return texture;\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n\n  function GLTFMaterialsPbrSpecularGlossinessExtension() {\n    return {\n      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n      specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n      getMaterialType: function getMaterialType() {\n        return THREE.ShaderMaterial;\n      },\n      extendParams: function extendParams(materialParams, materialDef, parser) {\n        var pbrSpecularGlossiness = materialDef.extensions[this.name];\n        var shader = THREE.ShaderLib['standard'];\n        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n        var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n        var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n        var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n        var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n        var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n        var fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n        delete uniforms.roughness;\n        delete uniforms.metalness;\n        delete uniforms.roughnessMap;\n        delete uniforms.metalnessMap;\n        uniforms.specular = {\n          value: new THREE.Color().setHex(0x111111)\n        };\n        uniforms.glossiness = {\n          value: 0.5\n        };\n        uniforms.specularMap = {\n          value: null\n        };\n        uniforms.glossinessMap = {\n          value: null\n        };\n        materialParams.vertexShader = shader.vertexShader;\n        materialParams.fragmentShader = fragmentShader;\n        materialParams.uniforms = uniforms;\n        materialParams.defines = {\n          'STANDARD': ''\n        };\n        materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n        materialParams.opacity = 1.0;\n        var pending = [];\n\n        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n          var array = pbrSpecularGlossiness.diffuseFactor;\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n        }\n\n        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n        }\n\n        materialParams.emissive = new THREE.Color(0.0, 0.0, 0.0);\n        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n        materialParams.specular = new THREE.Color(1.0, 1.0, 1.0);\n\n        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n        }\n\n        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n          pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n          pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n        }\n\n        return Promise.all(pending);\n      },\n      createMaterial: function createMaterial(params) {\n        // setup material properties based on MeshStandardMaterial for Specular-Glossiness\n        var material = new THREE.ShaderMaterial({\n          defines: params.defines,\n          vertexShader: params.vertexShader,\n          fragmentShader: params.fragmentShader,\n          uniforms: params.uniforms,\n          fog: true,\n          lights: true,\n          opacity: params.opacity,\n          transparent: params.transparent\n        });\n        material.isGLTFSpecularGlossinessMaterial = true;\n        material.color = params.color;\n        material.map = params.map === undefined ? null : params.map;\n        material.lightMap = null;\n        material.lightMapIntensity = 1.0;\n        material.aoMap = params.aoMap === undefined ? null : params.aoMap;\n        material.aoMapIntensity = 1.0;\n        material.emissive = params.emissive;\n        material.emissiveIntensity = 1.0;\n        material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n        material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n        material.bumpScale = 1;\n        material.normalMap = params.normalMap === undefined ? null : params.normalMap;\n        if (params.normalScale) material.normalScale = params.normalScale;\n        material.displacementMap = null;\n        material.displacementScale = 1;\n        material.displacementBias = 0;\n        material.specularMap = params.specularMap === undefined ? null : params.specularMap;\n        material.specular = params.specular;\n        material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n        material.glossiness = params.glossiness;\n        material.alphaMap = null;\n        material.envMap = params.envMap === undefined ? null : params.envMap;\n        material.envMapIntensity = 1.0;\n        material.refractionRatio = 0.98;\n        material.extensions.derivatives = true;\n        return material;\n      },\n\n      /**\n       * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n       * copy only properties it knows about or inherits, and misses many properties that would\n       * normally be defined by MeshStandardMaterial.\n       *\n       * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n       * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n       * AND also updating `.onBeforeRender` on the parent mesh.\n       *\n       * @param  {THREE.ShaderMaterial} source\n       * @return {THREE.ShaderMaterial}\n       */\n      cloneMaterial: function cloneMaterial(source) {\n        var target = source.clone();\n        target.isGLTFSpecularGlossinessMaterial = true;\n        var params = this.specularGlossinessParams;\n\n        for (var i = 0, il = params.length; i < il; i++) {\n          var value = source[params[i]];\n          target[params[i]] = value && value.isColor ? value.clone() : value;\n        }\n\n        return target;\n      },\n      // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n      refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material) {\n        if (material.isGLTFSpecularGlossinessMaterial !== true) {\n          return;\n        }\n\n        var uniforms = material.uniforms;\n        var defines = material.defines;\n        uniforms.opacity.value = material.opacity;\n        uniforms.diffuse.value.copy(material.color);\n        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n        uniforms.map.value = material.map;\n        uniforms.specularMap.value = material.specularMap;\n        uniforms.alphaMap.value = material.alphaMap;\n        uniforms.lightMap.value = material.lightMap;\n        uniforms.lightMapIntensity.value = material.lightMapIntensity;\n        uniforms.aoMap.value = material.aoMap;\n        uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities\n        // 1. color map\n        // 2. specular map\n        // 3. normal map\n        // 4. bump map\n        // 5. alpha map\n        // 6. emissive map\n\n        var uvScaleMap;\n\n        if (material.map) {\n          uvScaleMap = material.map;\n        } else if (material.specularMap) {\n          uvScaleMap = material.specularMap;\n        } else if (material.displacementMap) {\n          uvScaleMap = material.displacementMap;\n        } else if (material.normalMap) {\n          uvScaleMap = material.normalMap;\n        } else if (material.bumpMap) {\n          uvScaleMap = material.bumpMap;\n        } else if (material.glossinessMap) {\n          uvScaleMap = material.glossinessMap;\n        } else if (material.alphaMap) {\n          uvScaleMap = material.alphaMap;\n        } else if (material.emissiveMap) {\n          uvScaleMap = material.emissiveMap;\n        }\n\n        if (uvScaleMap !== undefined) {\n          // backwards compatibility\n          if (uvScaleMap.isWebGLRenderTarget) {\n            uvScaleMap = uvScaleMap.texture;\n          }\n\n          if (uvScaleMap.matrixAutoUpdate === true) {\n            uvScaleMap.updateMatrix();\n          }\n\n          uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n        }\n\n        if (material.envMap) {\n          uniforms.envMap.value = material.envMap;\n          uniforms.envMapIntensity.value = material.envMapIntensity; // don't flip CubeTexture envMaps, flip everything else:\n          //  WebGLRenderTargetCube will be flipped for backwards compatibility\n          //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n          // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\n          uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;\n          uniforms.reflectivity.value = material.reflectivity;\n          uniforms.refractionRatio.value = material.refractionRatio;\n          uniforms.maxMipLevel.value = renderer.properties.get(material.envMap).__maxMipLevel;\n        }\n\n        uniforms.specular.value.copy(material.specular);\n        uniforms.glossiness.value = material.glossiness;\n        uniforms.glossinessMap.value = material.glossinessMap;\n        uniforms.emissiveMap.value = material.emissiveMap;\n        uniforms.bumpMap.value = material.bumpMap;\n        uniforms.normalMap.value = material.normalMap;\n        uniforms.displacementMap.value = material.displacementMap;\n        uniforms.displacementScale.value = material.displacementScale;\n        uniforms.displacementBias.value = material.displacementBias;\n\n        if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n          defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv\n\n          defines.USE_ROUGHNESSMAP = '';\n        }\n\n        if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n          delete defines.USE_GLOSSINESSMAP;\n          delete defines.USE_ROUGHNESSMAP;\n        }\n      }\n    };\n  }\n  /*********************************/\n\n  /********** INTERPOLATION ********/\n\n  /*********************************/\n  // Spline Interpolation\n  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\n  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);\n  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n    var result = this.resultBuffer,\n        values = this.sampleValues,\n        valueSize = this.valueSize;\n\n    for (var i = 0; i !== valueSize; i++) {\n      result[i] = values[index * valueSize * 3 + valueSize + i];\n    }\n\n    return result;\n  };\n\n  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n    var result = this.resultBuffer;\n    var values = this.sampleValues;\n    var stride = this.valueSize;\n    var stride3 = stride * 3;\n    var td = t1 - t0;\n    var p = (t - t0) / td;\n    var pp = p * p;\n    var ppp = pp * p;\n    var offset1 = i1 * stride3;\n    var offset0 = offset1 - stride3;\n    var s2 = -2 * ppp + 3 * pp;\n    var s3 = ppp - pp;\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (var i = 0; i !== stride; i++) {\n      var p0 = values[offset0 + i + stride]; // splineVertex_k\n\n      var m0 = values[offset0 + i + stride * 2] * td; // outTangent_k * (t_k+1 - t_k)\n\n      var p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = (1 - s2) * p0 + (s3 - pp + p) * m0 + s2 * p1 + s3 * m1;\n    }\n\n    return result;\n  };\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n\n  var WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n  };\n  var WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  var WEBGL_FILTERS = {\n    9728: THREE.NearestFilter,\n    9729: THREE.LinearFilter,\n    9984: THREE.NearestMipmapNearestFilter,\n    9985: THREE.LinearMipmapNearestFilter,\n    9986: THREE.NearestMipmapLinearFilter,\n    9987: THREE.LinearMipmapLinearFilter\n  };\n  var WEBGL_WRAPPINGS = {\n    33071: THREE.ClampToEdgeWrapping,\n    33648: THREE.MirroredRepeatWrapping,\n    10497: THREE.RepeatWrapping\n  };\n  var WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n  };\n  var ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex',\n    _BATCHID: '_BATCHID'\n  };\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion',\n    weights: 'morphTargetInfluences'\n  };\n  var INTERPOLATION = {\n    CUBICSPLINE: undefined,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: THREE.InterpolateLinear,\n    STEP: THREE.InterpolateDiscrete\n  };\n  var ALPHA_MODES = {\n    OPAQUE: 'OPAQUE',\n    MASK: 'MASK',\n    BLEND: 'BLEND'\n  };\n  var MIME_TYPE_FORMATS = {\n    'image/png': THREE.RGBAFormat,\n    'image/jpeg': THREE.RGBFormat\n  };\n  /* UTILITY FUNCTIONS */\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Host Relative URL\n\n    if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n      path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    } // Absolute URL http://,https://,//\n\n\n    if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n    if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n    return path + url;\n  }\n\n  var defaultMaterial;\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n   */\n\n  function createDefaultMaterial() {\n    defaultMaterial = defaultMaterial || new THREE.MeshStandardMaterial({\n      color: 0xFFFFFF,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: THREE.FrontSide\n    });\n    return defaultMaterial;\n  }\n\n  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    // Add unknown glTF extensions to an object's userData.\n    for (var name in objectDef.extensions) {\n      if (knownExtensions[name] === undefined) {\n        object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n        object.userData.gltfExtensions[name] = objectDef.extensions[name];\n      }\n    }\n  }\n  /**\n   * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object\n   * @param {GLTF.definition} gltfDef\n   */\n\n\n  function assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== undefined) {\n      if ((0, _typeof2[\"default\"])(gltfDef.extras) === 'object') {\n        Object.assign(object.userData, gltfDef.extras);\n      } else {\n        console.warn('threeExamples.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n      }\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n   *\n   * @param {THREE.BufferGeometry} geometry\n   * @param {Array<GLTF.Target>} targets\n   * @param {GLTFParser} parser\n   * @return {Promise<THREE.BufferGeometry>}\n   */\n\n\n  function addMorphTargets(geometry, targets, parser) {\n    var hasMorphPosition = false;\n    var hasMorphNormal = false;\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n      if (target.POSITION !== undefined) hasMorphPosition = true;\n      if (target.NORMAL !== undefined) hasMorphNormal = true;\n      if (hasMorphPosition && hasMorphNormal) break;\n    }\n\n    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n    var pendingPositionAccessors = [];\n    var pendingNormalAccessors = [];\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n\n      if (hasMorphPosition) {\n        var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n        pendingPositionAccessors.push(pendingAccessor);\n      }\n\n      if (hasMorphNormal) {\n        var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n        pendingNormalAccessors.push(pendingAccessor);\n      }\n    }\n\n    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n      var morphPositions = accessors[0];\n      var morphNormals = accessors[1]; // Clone morph target accessors before modifying them.\n\n      for (var i = 0, il = morphPositions.length; i < il; i++) {\n        if (geometry.attributes.position === morphPositions[i]) continue;\n        morphPositions[i] = cloneBufferAttribute(morphPositions[i]);\n      }\n\n      for (var i = 0, il = morphNormals.length; i < il; i++) {\n        if (geometry.attributes.normal === morphNormals[i]) continue;\n        morphNormals[i] = cloneBufferAttribute(morphNormals[i]);\n      }\n\n      for (var i = 0, il = targets.length; i < il; i++) {\n        var target = targets[i];\n        var attributeName = 'morphTarget' + i;\n\n        if (hasMorphPosition) {\n          // Three.js morph position is absolute value. The formula is\n          //   basePosition\n          //     + weight0 * ( morphPosition0 - basePosition )\n          //     + weight1 * ( morphPosition1 - basePosition )\n          //     ...\n          // while the glTF one is relative\n          //   basePosition\n          //     + weight0 * glTFmorphPosition0\n          //     + weight1 * glTFmorphPosition1\n          //     ...\n          // then we need to convert from relative to absolute here.\n          if (target.POSITION !== undefined) {\n            var positionAttribute = morphPositions[i];\n            positionAttribute.name = attributeName;\n            var position = geometry.attributes.position;\n\n            for (var j = 0, jl = positionAttribute.count; j < jl; j++) {\n              positionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));\n            }\n          }\n        }\n\n        if (hasMorphNormal) {\n          // see target.POSITION's comment\n          if (target.NORMAL !== undefined) {\n            var normalAttribute = morphNormals[i];\n            normalAttribute.name = attributeName;\n            var normal = geometry.attributes.normal;\n\n            for (var j = 0, jl = normalAttribute.count; j < jl; j++) {\n              normalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));\n            }\n          }\n        }\n      }\n\n      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n      return geometry;\n    });\n  }\n  /**\n   * @param {THREE.Mesh} mesh\n   * @param {GLTF.Mesh} meshDef\n   */\n\n\n  function updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n\n    if (meshDef.weights !== undefined) {\n      for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n        mesh.morphTargetInfluences[i] = meshDef.weights[i];\n      }\n    } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n      var targetNames = meshDef.extras.targetNames;\n\n      if (mesh.morphTargetInfluences.length === targetNames.length) {\n        mesh.morphTargetDictionary = {};\n\n        for (var i = 0, il = targetNames.length; i < il; i++) {\n          mesh.morphTargetDictionary[targetNames[i]] = i;\n        }\n      } else {\n        console.warn('threeExamples.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n      }\n    }\n  }\n\n  function createPrimitiveKey(primitiveDef) {\n    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    var geometryKey;\n\n    if (dracoExtension) {\n      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n    } else {\n      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n    }\n\n    return geometryKey;\n  }\n\n  function createAttributesKey(attributes) {\n    var attributesKey = '';\n    var keys = Object.keys(attributes).sort();\n\n    for (var i = 0, il = keys.length; i < il; i++) {\n      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n    }\n\n    return attributesKey;\n  }\n\n  function cloneBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) {\n      var count = attribute.count;\n      var itemSize = attribute.itemSize;\n      var array = attribute.array.slice(0, count * itemSize);\n\n      for (var i = 0, j = 0; i < count; ++i) {\n        array[j++] = attribute.getX(i);\n        if (itemSize >= 2) array[j++] = attribute.getY(i);\n        if (itemSize >= 3) array[j++] = attribute.getZ(i);\n        if (itemSize >= 4) array[j++] = attribute.getW(i);\n      }\n\n      return new THREE.BufferAttribute(array, itemSize, attribute.normalized);\n    }\n\n    return attribute.clone();\n  }\n  /* GLTF PARSER */\n\n\n  function GLTFParser(json, extensions, options) {\n    this.json = json || {};\n    this.extensions = extensions || {};\n    this.options = options || {}; // loader object cache\n\n    this.cache = new GLTFRegistry(); // BufferGeometry caching\n\n    this.primitiveCache = {};\n    this.textureLoader = new THREE.TextureLoader(this.options.manager);\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.fileLoader = new THREE.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  GLTFParser.prototype.parse = function (onLoad, onError) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this.markDefs();\n    Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {\n      var result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser: parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      onLoad(result);\n    })[\"catch\"](onError);\n  };\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  GLTFParser.prototype.markDefs = function () {\n    var nodeDefs = this.json.nodes || [];\n    var skinDefs = this.json.skins || [];\n    var meshDefs = this.json.meshes || [];\n    var meshReferences = {};\n    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      var joints = skinDefs[skinIndex].joints;\n\n      for (var i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n    // avoid having more than one THREE.Mesh with the same name, count\n    // references and rename instances below.\n    //\n    // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\n\n    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      var nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        if (meshReferences[nodeDef.mesh] === undefined) {\n          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n        }\n\n        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n    }\n\n    this.json.meshReferences = meshReferences;\n    this.json.meshUses = meshUses;\n  };\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}\n   */\n\n\n  GLTFParser.prototype.getDependency = function (type, index) {\n    var cacheKey = type + ':' + index;\n    var dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this.loadMesh(index);\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this.loadBufferView(index);\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this.loadMaterial(index);\n          break;\n\n        case 'texture':\n          dependency = this.loadTexture(index);\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        case 'light':\n          dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  };\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  GLTFParser.prototype.getDependencies = function (type) {\n    var dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      var parser = this;\n      var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBuffer = function (bufferIndex) {\n    var bufferDef = this.json.buffers[bufferIndex];\n    var loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('threeExamples.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    var options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('threeExamples.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n    var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      var byteLength = bufferViewDef.byteLength || 0;\n      var byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n   */\n\n\n  GLTFParser.prototype.loadAccessor = function (accessorIndex) {\n    var parser = this;\n    var json = this.json;\n    var accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    var pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      var bufferView = bufferViews[0];\n      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      var byteOffset = accessorDef.byteOffset || 0;\n      var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n      var normalized = accessorDef.normalized === true;\n      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== elementBytes * itemSize) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        var ibSlice = Math.floor(byteOffset / byteStride);\n        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n        var ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new THREE.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n\n        for (var i = 0, il = sparseIndices.length; i < il; i++) {\n          var index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('threeExamples.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  GLTFParser.prototype.loadTexture = function (textureIndex) {\n    var parser = this;\n    var json = this.json;\n    var options = this.options;\n    var textureLoader = this.textureLoader;\n    var URL = window.URL || window.webkitURL;\n    var textureDef = json.textures[textureIndex];\n    var textureExtensions = textureDef.extensions || {};\n    var source;\n\n    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n    } else {\n      source = json.images[textureDef.source];\n    }\n\n    var sourceURI = source.uri;\n    var isObjectURL = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n        isObjectURL = true;\n        var blob = new Blob([bufferView], {\n          type: source.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    }\n\n    return Promise.resolve(sourceURI).then(function (sourceURI) {\n      // Load Texture resource.\n      var loader = options.manager.getHandler(sourceURI);\n\n      if (!loader) {\n        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n      }\n\n      return new Promise(function (resolve, reject) {\n        loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.flipY = false;\n      if (textureDef.name !== undefined) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.\n\n      if (source.mimeType in MIME_TYPE_FORMATS) {\n        texture.format = MIME_TYPE_FORMATS[source.mimeType];\n      }\n\n      var samplers = json.samplers || {};\n      var sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n      return texture;\n    });\n  };\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise}\n   */\n\n\n  GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {\n    var parser = this;\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture.isCompressedTexture) {\n        switch (mapName) {\n          case 'aoMap':\n          case 'emissiveMap':\n          case 'metalnessMap':\n          case 'normalMap':\n          case 'roughnessMap':\n            texture.format = THREE.RGBFormat;\n            break;\n        }\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n        if (transform) {\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n        }\n      }\n\n      materialParams[mapName] = texture;\n    });\n  };\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accomodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.\n   */\n\n\n  GLTFParser.prototype.assignFinalMaterial = function (mesh) {\n    var geometry = mesh.geometry;\n    var material = mesh.material;\n    var extensions = this.extensions;\n    var useVertexTangents = geometry.attributes.tangent !== undefined;\n    var useVertexColors = geometry.attributes.color !== undefined;\n    var useFlatShading = geometry.attributes.normal === undefined;\n    var useSkinning = mesh.isSkinnedMesh === true;\n    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n    if (mesh.isPoints) {\n      var cacheKey = 'PointsMaterial:' + material.uuid;\n      var pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new THREE.PointsMaterial();\n        THREE.Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      var cacheKey = 'LineBasicMaterial:' + material.uuid;\n      var lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new THREE.LineBasicMaterial();\n        THREE.Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    } // Clone the material if it will be modified\n\n\n    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n      var cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n      if (useSkinning) cacheKey += 'skinning:';\n      if (useVertexTangents) cacheKey += 'vertex-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n      if (useMorphTargets) cacheKey += 'morph-targets:';\n      if (useMorphNormals) cacheKey += 'morph-normals:';\n      var cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material) : material.clone();\n        if (useSkinning) cachedMaterial.skinning = true;\n        if (useVertexTangents) cachedMaterial.vertexTangents = true;\n        if (useVertexColors) cachedMaterial.vertexColors = THREE.VertexColors;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n        if (useMorphTargets) cachedMaterial.morphTargets = true;\n        if (useMorphNormals) cachedMaterial.morphNormals = true;\n        this.cache.add(cacheKey, cachedMaterial);\n      }\n\n      material = cachedMaterial;\n    } // workarounds for mesh and geometry\n\n\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n      console.log('threeExamples.GLTFLoader: Duplicating UVs to support aoMap.');\n      geometry.setAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n\n    if (material.isGLTFSpecularGlossinessMaterial) {\n      // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update\n      mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n    }\n\n    mesh.material = material;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<THREE.Material>}\n   */\n\n\n  GLTFParser.prototype.loadMaterial = function (materialIndex) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions;\n    var materialDef = json.materials[materialIndex];\n    var materialType;\n    var materialParams = {};\n    var materialExtensions = materialDef.extensions || {};\n    var pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      materialType = THREE.MeshStandardMaterial;\n      var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n      }\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = THREE.DoubleSide;\n    }\n\n    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\n      materialParams.normalScale = new THREE.Vector2(1, 1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n    }\n\n    return Promise.all(pending).then(function () {\n      var material;\n\n      if (materialType === THREE.ShaderMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name !== undefined) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n      if (material.map) material.map.encoding = THREE.sRGBEncoding;\n      if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\n      if (material.specularMap) material.specularMap.encoding = THREE.sRGBEncoding;\n      assignExtrasToUserData(material, materialDef);\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  };\n  /**\n   * @param {THREE.BufferGeometry} geometry\n   * @param {GLTF.Primitive} primitiveDef\n   * @param {GLTFParser} parser\n   * @return {Promise<THREE.BufferGeometry>}\n   */\n\n\n  function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    var attributes = primitiveDef.attributes;\n    var pending = [];\n\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n        geometry.setAttribute(attributeName, accessor);\n      });\n    }\n\n    for (var gltfAttributeName in attributes) {\n      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n      if (threeAttributeName in geometry.attributes) continue;\n      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n\n    if (primitiveDef.indices !== undefined && !geometry.index) {\n      var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n        geometry.setIndex(accessor);\n      });\n      pending.push(accessor);\n    }\n\n    assignExtrasToUserData(geometry, primitiveDef);\n    return Promise.all(pending).then(function () {\n      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<THREE.BufferGeometry>>}\n   */\n\n\n  GLTFParser.prototype.loadGeometries = function (primitives) {\n    var parser = this;\n    var extensions = this.extensions;\n    var cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var primitive = primitives[i];\n      var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n      var cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        var geometryPromise;\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);\n        } // Cache this geometry\n\n\n        cache[cacheKey] = {\n          primitive: primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n   */\n\n\n  GLTFParser.prototype.loadMesh = function (meshIndex) {\n    var parser = this;\n    var json = this.json;\n    var meshDef = json.meshes[meshIndex];\n    var primitives = meshDef.primitives;\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var material = primitives[i].material === undefined ? createDefaultMaterial() : this.getDependency('material', primitives[i].material);\n      pending.push(material);\n    }\n\n    return Promise.all(pending).then(function (originalMaterials) {\n      return parser.loadGeometries(primitives).then(function (geometries) {\n        var meshes = [];\n\n        for (var i = 0, il = geometries.length; i < il; i++) {\n          var geometry = geometries[i];\n          var primitive = primitives[i]; // 1. create Mesh\n\n          var mesh;\n          var material = originalMaterials[i];\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n            // .isSkinnedMesh isn't in glTF spec. See .markDefs()\n            mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh(geometry, material) : new THREE.Mesh(geometry, material);\n\n            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n              // we normalize floating point skin weight array to fix malformed assets (see #15319)\n              // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n              mesh.normalizeSkinWeights();\n            }\n\n            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n              mesh.drawMode = THREE.TriangleStripDrawMode;\n            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n              mesh.drawMode = THREE.TriangleFanDrawMode;\n            }\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n            mesh = new THREE.LineSegments(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n            mesh = new THREE.Line(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n            mesh = new THREE.LineLoop(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n            mesh = new THREE.Points(geometry, material);\n          } else {\n            throw new Error('threeExamples.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n          }\n\n          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n            updateMorphTargets(mesh, meshDef);\n          }\n\n          mesh.name = meshDef.name || 'mesh_' + meshIndex;\n          if (geometries.length > 1) mesh.name += '_' + i;\n          assignExtrasToUserData(mesh, meshDef);\n          parser.assignFinalMaterial(mesh);\n          meshes.push(mesh);\n        }\n\n        if (meshes.length === 1) {\n          return meshes[0];\n        }\n\n        var group = new THREE.Group();\n\n        for (var i = 0, il = meshes.length; i < il; i++) {\n          group.add(meshes[i]);\n        }\n\n        return group;\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  GLTFParser.prototype.loadCamera = function (cameraIndex) {\n    var camera;\n    var cameraDef = this.json.cameras[cameraIndex];\n    var params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('threeExamples.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name !== undefined) camera.name = cameraDef.name;\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  GLTFParser.prototype.loadSkin = function (skinIndex) {\n    var skinDef = this.json.skins[skinIndex];\n    var skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<THREE.AnimationClip>}\n   */\n\n\n  GLTFParser.prototype.loadAnimation = function (animationIndex) {\n    var json = this.json;\n    var animationDef = json.animations[animationIndex];\n    var pendingNodes = [];\n    var pendingInputAccessors = [];\n    var pendingOutputAccessors = [];\n    var pendingSamplers = [];\n    var pendingTargets = [];\n\n    for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n      var channel = animationDef.channels[i];\n      var sampler = animationDef.samplers[channel.sampler];\n      var target = channel.target;\n      var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n      var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n      var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      var nodes = dependencies[0];\n      var inputAccessors = dependencies[1];\n      var outputAccessors = dependencies[2];\n      var samplers = dependencies[3];\n      var targets = dependencies[4];\n      var tracks = [];\n\n      for (var i = 0, il = nodes.length; i < il; i++) {\n        var node = nodes[i];\n        var inputAccessor = inputAccessors[i];\n        var outputAccessor = outputAccessors[i];\n        var sampler = samplers[i];\n        var target = targets[i];\n        if (node === undefined) continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        var TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = THREE.NumberKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = THREE.VectorKeyframeTrack;\n            break;\n        }\n\n        var targetName = node.name ? node.name : node.uuid;\n        var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n        var targetNames = [];\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          // Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\n          node.traverse(function (object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        var outputArray = outputAccessor.array;\n\n        if (outputAccessor.normalized) {\n          var scale;\n\n          if (outputArray.constructor === Int8Array) {\n            scale = 1 / 127;\n          } else if (outputArray.constructor === Uint8Array) {\n            scale = 1 / 255;\n          } else if (outputArray.constructor == Int16Array) {\n            scale = 1 / 32767;\n          } else if (outputArray.constructor === Uint16Array) {\n            scale = 1 / 65535;\n          } else {\n            throw new Error('threeExamples.GLTFLoader: Unsupported output accessor component type.');\n          }\n\n          var scaled = new Float32Array(outputArray.length);\n\n          for (var j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n\n          outputArray = scaled;\n        }\n\n        for (var j = 0, jl = targetNames.length; j < jl; j++) {\n          var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function (result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n      return new THREE.AnimationClip(name, undefined, tracks);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<THREE.Object3D>}\n   */\n\n\n  GLTFParser.prototype.loadNode = function (nodeIndex) {\n    var json = this.json;\n    var extensions = this.extensions;\n    var parser = this;\n    var meshReferences = json.meshReferences;\n    var meshUses = json.meshUses;\n    var nodeDef = json.nodes[nodeIndex];\n    return function () {\n      var pending = [];\n\n      if (nodeDef.mesh !== undefined) {\n        pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n          var node;\n\n          if (meshReferences[nodeDef.mesh] > 1) {\n            var instanceNum = meshUses[nodeDef.mesh]++;\n            node = mesh.clone();\n            node.name += '_instance_' + instanceNum; // onBeforeRender copy for Specular-Glossiness\n\n            node.onBeforeRender = mesh.onBeforeRender;\n\n            for (var i = 0, il = node.children.length; i < il; i++) {\n              node.children[i].name += '_instance_' + instanceNum;\n              node.children[i].onBeforeRender = mesh.children[i].onBeforeRender;\n            }\n          } else {\n            node = mesh;\n          } // if weights are provided on the node, override weights on the mesh.\n\n\n          if (nodeDef.weights !== undefined) {\n            node.traverse(function (o) {\n              if (!o.isMesh) return;\n\n              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\n                o.morphTargetInfluences[i] = nodeDef.weights[i];\n              }\n            });\n          }\n\n          return node;\n        }));\n      }\n\n      if (nodeDef.camera !== undefined) {\n        pending.push(parser.getDependency('camera', nodeDef.camera));\n      }\n\n      if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {\n        pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));\n      }\n\n      return Promise.all(pending);\n    }().then(function (objects) {\n      var node; // .isBone isn't in glTF spec. See .markDefs\n\n      if (nodeDef.isBone === true) {\n        node = new THREE.Bone();\n      } else if (objects.length > 1) {\n        node = new THREE.Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new THREE.Object3D();\n      }\n\n      if (node !== objects[0]) {\n        for (var i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n\n      if (nodeDef.name !== undefined) {\n        node.userData.name = nodeDef.name;\n        node.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        var matrix = new THREE.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      return node;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<THREE.Scene>}\n   */\n\n\n  GLTFParser.prototype.loadScene = function () {\n    // scene node hierachy builder\n    function buildNodeHierachy(nodeId, parentObject, json, parser) {\n      var nodeDef = json.nodes[nodeId];\n      return parser.getDependency('node', nodeId).then(function (node) {\n        if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n        var skinEntry;\n        return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n          skinEntry = skin;\n          var pendingJoints = [];\n\n          for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\n            pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n          }\n\n          return Promise.all(pendingJoints);\n        }).then(function (jointNodes) {\n          node.traverse(function (mesh) {\n            if (!mesh.isMesh) return;\n            var bones = [];\n            var boneInverses = [];\n\n            for (var j = 0, jl = jointNodes.length; j < jl; j++) {\n              var jointNode = jointNodes[j];\n\n              if (jointNode) {\n                bones.push(jointNode);\n                var mat = new THREE.Matrix4();\n\n                if (skinEntry.inverseBindMatrices !== undefined) {\n                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n                }\n\n                boneInverses.push(mat);\n              } else {\n                console.warn('threeExamples.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n              }\n            }\n\n            mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n          });\n          return node;\n        });\n      }).then(function (node) {\n        // build node hierachy\n        parentObject.add(node);\n        var pending = [];\n\n        if (nodeDef.children) {\n          var children = nodeDef.children;\n\n          for (var i = 0, il = children.length; i < il; i++) {\n            var child = children[i];\n            pending.push(buildNodeHierachy(child, node, json, parser));\n          }\n        }\n\n        return Promise.all(pending);\n      });\n    }\n\n    return function (sceneIndex) {\n      var json = this.json;\n      var extensions = this.extensions;\n      var sceneDef = this.json.scenes[sceneIndex];\n      var parser = this;\n      var scene = new THREE.Scene();\n      if (sceneDef.name !== undefined) scene.name = sceneDef.name;\n      assignExtrasToUserData(scene, sceneDef);\n      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n      var nodeIds = sceneDef.nodes || [];\n      var pending = [];\n\n      for (var i = 0, il = nodeIds.length; i < il; i++) {\n        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n      }\n\n      return Promise.all(pending).then(function () {\n        return scene;\n      });\n    };\n  }();\n\n  return GLTFLoader;\n}();\n\nvar _default = threeExamples.GLTFLoader;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/ThreeExtended/loaders/GLTFLoader.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Utils/CameraUtils.js":
/*!******************************************************!*\
  !*** ./node_modules/itowns/lib/Utils/CameraUtils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _tween = _interopRequireDefault(__webpack_require__(/*! @tweenjs/tween.js */ \"./node_modules/@tweenjs/tween.js/dist/tween.esm.js\"));\n\nvar _DEMUtils = _interopRequireDefault(__webpack_require__(/*! ./DEMUtils */ \"./node_modules/itowns/lib/Utils/DEMUtils.js\"));\n\nvar _MainLoop = __webpack_require__(/*! ../Core/MainLoop */ \"./node_modules/itowns/lib/Core/MainLoop.js\");\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Ellipsoid = _interopRequireDefault(__webpack_require__(/*! ../Core/Math/Ellipsoid */ \"./node_modules/itowns/lib/Core/Math/Ellipsoid.js\"));\n\nTHREE.Object3D.DefaultUp.set(0, 0, 1);\nvar targetPosition = new THREE.Vector3();\nvar targetCoord = new _Coordinates[\"default\"]('EPSG:4326', 0, 0, 0);\nvar ellipsoid = new _Ellipsoid[\"default\"]();\nvar rigs = [];\n\nvar deferred = function () {\n  var resolve;\n  var reject;\n  return {\n    promise: new Promise(function (re, rej) {\n      resolve = re;\n      reject = rej;\n    }),\n    resolve: resolve,\n    reject: reject\n  };\n}; // Wrap angle in degrees to [-180 180]\n\n\nfunction wrapTo180(angle) {\n  return angle - Math.floor((angle + 180.0) / 360) * 360;\n}\n\nfunction tileLayer(view) {\n  return view.getLayers(function (l) {\n    return l.isTiledGeometryLayer;\n  })[0];\n}\n\nfunction getLookAtFromMath(view, camera) {\n  var direction = new THREE.Vector3(0, 0, 0.5);\n  direction.unproject(camera);\n  direction.sub(camera.position).normalize();\n\n  if (view.referenceCrs == 'EPSG:4978') {\n    // Intersect Ellispoid\n    return ellipsoid.intersection({\n      direction: direction,\n      origin: camera.position\n    });\n  } else {\n    // Intersect plane\n    var distance = camera.position.z / direction.z;\n    return direction.multiplyScalar(distance).add(camera.position);\n  }\n}\n\nfunction getGroundTargetFromCamera(view, camera, target) {\n  camera.updateMatrixWorld(true);\n  var pickedPosition = view.getPickingPositionFromDepth() || getLookAtFromMath(view, camera);\n  var range = pickedPosition && !isNaN(pickedPosition.x) ? camera.position.distanceTo(pickedPosition) : 100;\n  camera.localToWorld(target.set(0, 0, -range));\n}\n\nfunction proxyProperty(view, camera, rig, key) {\n  rig.proxy.position[key] = camera.position[key];\n  Object.defineProperty(camera.position, key, {\n    get: function get() {\n      return rig.proxy.position[key];\n    },\n    set: function set(newValue) {\n      rig.removeProxy(view, camera);\n      camera.position[key] = newValue;\n    }\n  });\n} // the rig is used to manipulate the camera\n// It consists of a tree of 3D objects, each element is assigned a task\n//\n//                      Transformation\n//\n// rig                  position on Coordinate  (for the globe is rotation)\n// |\n// └── sealevel         position on altitude zero\n//     |\n//     └── target       position on DEM, and rotation (pitch and heading)\n//         |\n//         └── camera   distance to target\n//\n// When all transformations are calculated,\n// this.camera's transformation is applied to view.camera.camera\n\n\nvar CameraRig =\n/*#__PURE__*/\nfunction (_THREE$Object3D) {\n  (0, _inherits2[\"default\"])(CameraRig, _THREE$Object3D);\n\n  function CameraRig() {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, CameraRig);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(CameraRig).call(this)); // seaLevel is on rig's z axis, it's at altitude zero\n\n    _this.seaLevel = new THREE.Object3D(); // target is on seaLevel's z axis and target.position.z is the DEM altitude\n\n    _this.target = new THREE.Object3D();\n    _this.target.rotation.order = 'ZXY'; // camera look at target\n\n    _this.camera = new THREE.Camera();\n\n    _this.add(_this.seaLevel);\n\n    _this.seaLevel.add(_this.target);\n\n    _this.target.add(_this.camera); // sea level's geograohic coordinate\n\n\n    _this.coord = new _Coordinates[\"default\"]('EPSG:4978', 0, 0); // sea level's worldPoistion\n\n    _this.targetWorldPosition = new THREE.Vector3();\n\n    _this.removeAll = function () {};\n\n    _this._onChangeCallback = null;\n    return _this;\n  } // apply rig.camera's transformation to camera\n\n\n  (0, _createClass2[\"default\"])(CameraRig, [{\n    key: \"applyTransformToCamera\",\n    value: function applyTransformToCamera(view, camera) {\n      var _this2 = this;\n\n      if (this.proxy) {\n        camera.quaternion._onChange(this._onChangeCallback);\n\n        this.camera.matrixWorld.decompose(this.proxy.position, camera.quaternion, camera.scale);\n\n        camera.quaternion._onChange(function () {\n          return _this2.removeProxy(view, camera);\n        });\n      } else {\n        this.camera.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n      }\n    }\n  }, {\n    key: \"setProxy\",\n    value: function setProxy(view, camera) {\n      var _this3 = this;\n\n      if (!this.proxy && view && camera) {\n        this.proxy = {\n          position: new THREE.Vector3()\n        };\n        Object.keys(camera.position).forEach(function (key) {\n          return proxyProperty(view, camera, _this3, key);\n        });\n        this._onChangeCallback = camera.quaternion._onChangeCallback;\n\n        camera.quaternion._onChange(function () {\n          return _this3.removeProxy(view, camera);\n        });\n      }\n    }\n  }, {\n    key: \"removeProxy\",\n    value: function removeProxy(view, camera) {\n      var _this4 = this;\n\n      this.stop(view);\n\n      if (this.proxy && view && camera) {\n        Object.keys(camera.position).forEach(function (key) {\n          return Object.defineProperty(camera.position, key, {\n            value: _this4.proxy.position[key],\n            writable: true\n          });\n        });\n\n        camera.quaternion._onChange(this._onChangeCallback);\n\n        this.proxy = null;\n      }\n    }\n  }, {\n    key: \"setTargetFromCoordinate\",\n    value: function setTargetFromCoordinate(view, coord) {\n      // clamp altitude to seaLevel\n      coord.as(tileLayer(view).extent.crs, this.coord);\n      var altitude = Math.max(0, this.coord.z);\n      this.coord.z = altitude; // adjust target's position with clamped altitude\n\n      this.coord.as(view.referenceCrs).toVector3(targetPosition);\n\n      if (view.referenceCrs == 'EPSG:4978') {\n        // ellipsoid geocentric projection\n        this.lookAt(targetPosition);\n        this.seaLevel.position.set(0, 0, targetPosition.length() - altitude);\n      } else {\n        // planar projection\n        this.position.set(targetPosition.x, targetPosition.y, 0);\n        this.seaLevel.position.set(0, 0, 0);\n      } // place camera's target\n\n\n      this.target.position.set(0, 0, altitude);\n    } // set rig's objects transformation from camera's position and target's position\n\n  }, {\n    key: \"setFromPositions\",\n    value: function setFromPositions(view, cameraPosition) {\n      this.setTargetFromCoordinate(view, new _Coordinates[\"default\"](view.referenceCrs, targetPosition));\n      this.target.rotation.set(0, 0, 0);\n      this.updateMatrixWorld(true);\n      this.camera.position.copy(cameraPosition);\n      this.target.worldToLocal(this.camera.position);\n      var range = this.camera.position.length();\n      this.target.rotation.x = Math.asin(this.camera.position.z / range);\n      var cosPlanXY = THREE.Math.clamp(this.camera.position.y / (Math.cos(this.target.rotation.x) * range), -1, 1);\n      this.target.rotation.z = Math.sign(-this.camera.position.x) * Math.acos(cosPlanXY);\n      this.camera.position.set(0, range, 0);\n    } // set from target's coordinate, rotation and range between target and camera\n\n  }, {\n    key: \"applyParams\",\n    value: function applyParams(view, params) {\n      if (params.coord) {\n        this.setTargetFromCoordinate(view, params.coord);\n      }\n\n      if (params.tilt != undefined) {\n        this.target.rotation.x = THREE.Math.degToRad(params.tilt);\n      }\n\n      if (params.heading != undefined) {\n        this.target.rotation.z = THREE.Math.degToRad(wrapTo180(params.heading + 180));\n      }\n\n      if (params.range) {\n        this.camera.position.set(0, params.range, 0);\n      }\n\n      this.camera.rotation.set(-Math.PI * 0.5, 0, Math.PI);\n      this.updateMatrixWorld(true);\n      this.targetWorldPosition.setFromMatrixPosition(this.seaLevel.matrixWorld);\n    }\n  }, {\n    key: \"getParams\",\n    value: function getParams() {\n      return {\n        coord: this.coord.clone(),\n        tilt: this.tilt,\n        heading: this.heading,\n        range: this.range,\n        targetWorldPosition: this.targetWorldPosition\n      };\n    }\n  }, {\n    key: \"setfromCamera\",\n    value: function setfromCamera(view, camera) {\n      getGroundTargetFromCamera(view, camera, targetPosition);\n      this.setFromPositions(view, camera.position);\n    }\n  }, {\n    key: \"copyObject3D\",\n    value: function copyObject3D(rig) {\n      this.copy(rig, false);\n      this.seaLevel.copy(rig.seaLevel, false);\n      this.target.copy(rig.target, false);\n      this.camera.copy(rig.camera);\n      return this;\n    }\n  }, {\n    key: \"animateCameraToLookAtTarget\",\n    value: function animateCameraToLookAtTarget(view, camera, params) {\n      var _this5 = this;\n\n      params.easing = params.easing || _tween[\"default\"].Easing.Quartic.InOut;\n      this.setfromCamera(view, camera);\n      var tweenGroup = new _tween[\"default\"].Group();\n      this.start = (this.start || new CameraRig()).copyObject3D(this);\n      this.end = (this.end || new CameraRig()).copyObject3D(this);\n      var time = params.time || 2500;\n      var factor = {\n        t: 0\n      };\n      var animations = [];\n      var def = deferred();\n      this.addPlaceTargetOnGround(view, camera, params.coord, factor);\n      this.end.applyParams(view, params);\n      animations.push(new _tween[\"default\"].Tween(factor, tweenGroup).to({\n        t: 1\n      }, time).easing(params.easing).onUpdate(function (d) {\n        // rotate to coord destination in geocentric projection\n        if (view.referenceCrs == 'EPSG:4978') {\n          THREE.Quaternion.slerp(_this5.start.quaternion, _this5.end.quaternion, _this5.quaternion, d.t);\n        } // camera rotation\n\n\n        THREE.Quaternion.slerp(_this5.start.camera.quaternion, _this5.end.camera.quaternion, _this5.camera.quaternion, d.t); // camera's target rotation\n\n        _this5.target.rotation.set(0, 0, 0);\n\n        _this5.target.rotateZ(THREE.Math.lerp(_this5.start.target.rotation.z, _this5.end.target.rotation.z, d.t));\n\n        _this5.target.rotateX(THREE.Math.lerp(_this5.start.target.rotation.x, _this5.end.target.rotation.x, d.t));\n      })); // translate to coordinate destination in planar projection\n\n      if (view.referenceCrs != 'EPSG:4978') {\n        animations.push(new _tween[\"default\"].Tween(this.position, tweenGroup).to(this.end.position, time).easing(params.easing));\n      } // translate to altitude zero\n\n\n      animations.push(new _tween[\"default\"].Tween(this.seaLevel.position, tweenGroup).to(this.end.seaLevel.position, time).easing(params.easing)); // translate camera position\n\n      animations.push(new _tween[\"default\"].Tween(this.camera.position, tweenGroup).to(this.end.camera.position, time).easing(params.easing)); // update animations, transformation and view\n\n      this.animationFrameRequester = function () {\n        tweenGroup.update();\n\n        _this5.updateMatrixWorld(true);\n\n        _this5.applyTransformToCamera(view, camera);\n\n        _this5.targetWorldPosition.setFromMatrixPosition(_this5.seaLevel.matrixWorld);\n\n        if (params.callback) {\n          params.callback(_this5);\n        }\n\n        targetCoord.crs = view.referenceCrs;\n        targetCoord.setFromVector3(_this5.targetWorldPosition).as(tileLayer(view).extent.crs, _this5.coord);\n        view.notifyChange(camera);\n      };\n\n      this.removeAll = function (o) {\n        this.removeAll = function () {};\n\n        tweenGroup.removeAll();\n\n        if (this.animationFrameRequester) {\n          view.removeFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.BEFORE_RENDER, this.animationFrameRequester);\n        }\n\n        def.resolve(o !== undefined);\n        this.animationFrameRequester = null;\n      }; // Waiting last animation complete,\n      // we assume that the animation that completes last is the one that was started last\n\n\n      animations[animations.length - 1].onComplete(this.removeAll);\n      animations.forEach(function (anim) {\n        return anim.start();\n      });\n      view.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.BEFORE_RENDER, this.animationFrameRequester);\n      view.notifyChange(camera);\n      return def;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(view) {\n      this.removePlaceTargetOnGround(view);\n      this.removeAll();\n    } // update target position to coordinate's altitude\n\n  }, {\n    key: \"addPlaceTargetOnGround\",\n    value: function addPlaceTargetOnGround(view, camera, coord) {\n      var _this6 = this;\n\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        t: 1.0\n      };\n      this.removePlaceTargetOnGround(view);\n\n      if (view && camera) {\n        var startAltitude = this.target.position.z;\n\n        this.placeTargetOnGround = function () {\n          var result = _DEMUtils[\"default\"].getElevationValueAt(tileLayer(view), coord || _this6.coord, _DEMUtils[\"default\"].PRECISE_READ_Z);\n\n          var altitude = Math.max(0, result ? result.z : 0);\n          _this6.target.position.z = startAltitude * (1.0 - options.t) + altitude * options.t;\n\n          _this6.target.updateMatrixWorld(true);\n\n          _this6.applyTransformToCamera(view, camera);\n        };\n\n        this.placeTargetOnGround();\n        view.addFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.BEFORE_RENDER, this.placeTargetOnGround);\n      }\n    }\n  }, {\n    key: \"removePlaceTargetOnGround\",\n    value: function removePlaceTargetOnGround(view) {\n      if (view && this.placeTargetOnGround) {\n        view.removeFrameRequester(_MainLoop.MAIN_LOOP_EVENTS.BEFORE_RENDER, this.placeTargetOnGround);\n        this.placeTargetOnGround = null;\n      }\n    }\n  }, {\n    key: \"tilt\",\n    get: function get() {\n      return THREE.Math.radToDeg(this.target.rotation.x);\n    }\n  }, {\n    key: \"heading\",\n    get: function get() {\n      return wrapTo180(THREE.Math.radToDeg(this.target.rotation.z) + 180);\n    }\n  }, {\n    key: \"range\",\n    get: function get() {\n      return this.camera.position.y;\n    }\n  }]);\n  return CameraRig;\n}(THREE.Object3D);\n\nfunction getRig(camera) {\n  rigs[camera.uuid] = rigs[camera.uuid] || new CameraRig(camera);\n  return rigs[camera.uuid];\n}\n/**\n * @module CameraUtils\n */\n\n\nvar _default = {\n  /**\n   * @typedef {Object} CameraTransformOptions\n   * @property {Coordinate} [coord=currentCoordinate] Camera look at geographic coordinate\n   * @property {Number} [tilt=currentTilt] camera's tilt, in degree\n   * @property {Number} [heading=currentHeading] camera's heading, in degree\n   * @property {Number} [range=currentRange] camera distance to target coordinate, in meter\n   * @property {Number} [time=2500] duration of the animation, in ms\n   * @property {boolean} [proxy=true] use proxy to handling camera's transformation. if proxy == true, other camera's transformation stops rig's transformation\n   * @property {Number} [easing=TWEEN.Easing.Quartic.InOut] in and out easing animation\n   * @property {function} [callback] callback call each animation's frame (params are current cameraTransform and worldTargetPosition)\n   * @property {boolean} [stopPlaceOnGroundAtEnd=defaultStopPlaceOnGroundAtEnd] stop place target on the ground at animation ending\n   */\n\n  /**\n   * Default value for option to stop place target\n   * on the ground at animation ending.\n   * Default value is false.\n   */\n  defaultStopPlaceOnGroundAtEnd: false,\n  Easing: _tween[\"default\"].Easing,\n\n  /**\n   * Stop camera's animation\n   *\n   * @param      {View}  view    The camera view\n   * @param      {Camera}  camera  The camera to stop animation\n   */\n  stop: function stop(view, camera) {\n    getRig(camera).stop(view);\n  },\n\n  /**\n   * Gets the current parameters transform camera looking at target.\n   *\n   * @param      {View}  view    The camera view\n   * @param      {Camera}  camera  The camera to get transform\n   * @return     {CameraUtils~CameraTransformOptions}  The transform camera looking at target\n   */\n  getTransformCameraLookingAtTarget: function getTransformCameraLookingAtTarget(view, camera) {\n    var rig = getRig(camera);\n    rig.setfromCamera(view, camera);\n    return rig.getParams();\n  },\n\n  /**\n   * Apply transform to camera\n   *\n   * @param      {View}  view    The camera view\n   * @param      {Camera}  camera  The camera to transform\n   * @param      {CameraUtils~CameraTransformOptions}  params  The parameters\n   * @return     {Promise} promise with resolve final CameraUtils~CameraTransformOptions\n   */\n  transformCameraToLookAtTarget: function transformCameraToLookAtTarget(view, camera) {\n    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    params.proxy = params.proxy === undefined || params.proxy;\n    var rig = getRig(camera);\n    rig.stop(view);\n    rig.setfromCamera(view, camera);\n\n    if (params.proxy) {\n      rig.setProxy(view, camera);\n    }\n\n    rig.applyParams(view, params);\n    rig.addPlaceTargetOnGround(view, camera, params.coord);\n    rig.applyTransformToCamera(view, camera);\n    view.notifyChange(camera);\n    return Promise.resolve(rig.getParams());\n  },\n\n  /**\n   * Apply transform to camera with animation\n   *\n   * @param      {View}  view    The camera view\n   * @param      {Camera}  camera  The camera to animate\n   * @param      {CameraUtils~CameraTransformOptions}  params  The parameters\n   * @return     {Promise} promise with resolve final CameraUtils~CameraTransformOptions\n   */\n  animateCameraToLookAtTarget: function animateCameraToLookAtTarget(view, camera) {\n    var _this7 = this;\n\n    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    params.proxy = params.proxy === undefined || params.proxy;\n    var rig = getRig(camera);\n    rig.stop(view);\n\n    if (params.proxy) {\n      rig.setProxy(view, camera);\n    }\n\n    return rig.animateCameraToLookAtTarget(view, camera, params).promise.then(function (finished) {\n      var params = rig.getParams();\n      var stopPlaceOnGround = params.stopPlaceOnGroundAtEnd === undefined ? _this7.defaultStopPlaceOnGroundAtEnd : params.stopPlaceOnGroundAtEnd;\n\n      if (stopPlaceOnGround) {\n        rig.stop(view);\n      }\n\n      params.finished = finished;\n      return params;\n    });\n  },\n\n  /**\n   * chain animation transform to camera\n   *\n   * @param      {View}  view    The camera view\n   * @param      {Camera}  camera  The camera to animate\n   * @param      {CameraUtils~CameraTransformOptions[]}  params  array parameters, each parameters transforms are apply to camera, in serial\n   * @return     {Promise} promise with resolve final CameraUtils~CameraTransformOptions\n   */\n  sequenceAnimationsToLookAtTarget: function sequenceAnimationsToLookAtTarget(view, camera) {\n    var _this8 = this;\n\n    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [{}];\n    // convert each param to a function\n    var funcs = params.map(function (param) {\n      return function () {\n        return _this8.animateCameraToLookAtTarget(view, camera, param);\n      };\n    }); // execute Promises in serial\n\n    return function promiseSerial(funcs) {\n      return funcs.reduce(function (promise, func) {\n        return promise.then(function (result) {\n          var finished = result.length ? result[result.length - 1].finished : true;\n\n          if (finished) {\n            return func().then(Array.prototype.concat.bind(result));\n          } else {\n            return Promise.resolve([{\n              finished: false\n            }]);\n          }\n        });\n      }, Promise.resolve([]));\n    }(funcs);\n  },\n\n  /**\n   * Gets the difference camera transformation\n   *\n   * @param      {CameraUtils~CameraTransformOptions}  first  param to compare with the second\n   * @param      {CameraUtils~CameraTransformOptions}  second param to compare with the first\n   * @return     {object} The difference parameters\n   */\n  getDiffParams: function getDiffParams(first, second) {\n    if (!first || !second) {\n      return;\n    }\n\n    var diff;\n\n    if (Math.abs(first.range - second.range) / first.range > 0.001) {\n      diff = diff || {};\n      diff.range = {\n        previous: first.range,\n        \"new\": second.range\n      };\n    }\n\n    if (Math.abs(first.tilt - second.tilt) > 0.1) {\n      diff = diff || {};\n      diff.tilt = {\n        previous: first.tilt,\n        \"new\": second.tilt\n      };\n    }\n\n    if (Math.abs(first.heading - second.heading) > 0.1) {\n      diff = diff || {};\n      diff.heading = {\n        previous: first.heading,\n        \"new\": second.heading\n      };\n    }\n\n    if (Math.abs(first.coord.x - second.coord.x) > 0.000001 || Math.abs(first.coord.y - second.coord.y) > 0.000001) {\n      diff = diff || {};\n      diff.coord = {\n        previous: first.coord,\n        \"new\": second.coord\n      };\n    }\n\n    return diff;\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Utils/CameraUtils.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Utils/DEMUtils.js":
/*!***************************************************!*\
  !*** ./node_modules/itowns/lib/Utils/DEMUtils.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar FAST_READ_Z = 0;\nvar PRECISE_READ_Z = 1;\n/**\n * Utility module to retrieve elevation at a given coordinates.\n * The returned value is read in the elevation textures used by the graphics card\n * to render the tiles (globe or plane).\n * This implies that the return value may change depending on the current tile resolution.\n */\n\nvar _default = {\n  /**\n   * Return current displayed elevation at coord in meters.\n   * @param {GeometryLayer} layer The tile layer owning the elevation textures we're going to query.\n   * This is typically the globeLayer or a planeLayer.\n   * @param {Coordinates} coord The coordinates that we're interested in\n   * @param {Number} method 2 available method: FAST_READ_Z (default) or PRECISE_READ_Z. Chosing between\n   * the 2 is a compromise between performance and visual quality\n   * @param {Array} tileHint Optional array of tiles to speed up the process. You can give candidates tiles\n   * likely to contain 'coord'. Otherwise the lookup process starts from the root.\n   * @return {object}  undefined if no result or z: displayed elevation in meters, texture: where the z value comes from, tile: owner of the texture\n   */\n  getElevationValueAt: function getElevationValueAt(layer, coord) {\n    var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : FAST_READ_Z;\n    var tileHint = arguments.length > 3 ? arguments[3] : undefined;\n\n    var result = _readZ(layer, method, coord, tileHint || layer.level0Nodes);\n\n    if (result) {\n      return {\n        z: result.coord.z,\n        texture: result.texture,\n        tile: result.tile\n      };\n    }\n  },\n\n  /**\n   * Helper method that will position an object directly on the ground.\n   * @param {GeometryLayer} layer The tile layer owning the elevation textures we're going to query.\n   * This is typically the globeLayer or a planeLayer.\n   * @param {string} objectCRS the CRS used by the object coordinates. You probably want to use view.referenceCRS here.\n   * @param {Object3D} obj the object we want to modify.\n   * @param {object} options\n   * @param {number} options.method see getElevationValueAt documentation\n   * @param {boolean} options.modifyGeometry if unset/false, this function will modify object.position. If true, it will\n   * modify obj.geometry.vertices or obj.geometry.attributes.position\n   * @param {Array} tileHint see getElevationValueAt documentation\n   * @return {boolean} true if successful, false if we couldn't lookup the elevation at the given coords\n   */\n  placeObjectOnGround: function placeObjectOnGround(layer, objectCRS, obj) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var tileHint = arguments.length > 4 ? arguments[4] : undefined;\n    var tiles;\n\n    if (tileHint) {\n      tiles = tileHint.concat(layer.level0Nodes);\n    } else {\n      tiles = layer.level0Nodes;\n    }\n\n    if (!options.modifyGeometry) {\n      if (options.cache) {\n        options.cache.length = 1;\n      }\n\n      var matrices = {\n        worldFromLocal: obj.parent ? obj.parent.matrixWorld : undefined,\n        localFromWorld: obj.parent ? new THREE.Matrix4().getInverse(obj.parent.matrixWorld) : undefined\n      };\n\n      var result = _updateVector3(layer, options.method || FAST_READ_Z, tiles, objectCRS, obj.position, options.offset || 0, matrices, undefined, options.cache ? options.cache[0] : undefined);\n\n      if (result) {\n        if (options.cache) {\n          options.cache[0] = result;\n        }\n\n        obj.updateMatrix();\n        obj.updateMatrixWorld();\n        return true;\n      }\n    } else {\n      var _matrices = {\n        worldFromLocal: obj.matrixWorld,\n        localFromWorld: new THREE.Matrix4().getInverse(obj.matrixWorld)\n      };\n      var geometry = obj.geometry;\n\n      if (geometry.vertices) {\n        if (options.cache) {\n          options.cache.length = geometry.vertices.length;\n        }\n\n        var success = true;\n        var coord = new _Coordinates[\"default\"](objectCRS);\n\n        for (var i = 0; i < geometry.vertices.length; i++) {\n          var cached = options.cache ? options.cache[i] : undefined;\n\n          var _result = _updateVector3(layer, options.method || FAST_READ_Z, tiles, objectCRS, geometry.vertices[i], options.offset || 0, _matrices, coord, cached);\n\n          if (options.cache) {\n            options.cache[i] = _result;\n          }\n\n          if (!_result) {\n            success = false;\n          }\n        }\n\n        geometry.verticesNeedUpdate = true;\n        return success;\n      } else if (geometry.isBufferGeometry) {\n        if (options.cache) {\n          options.cache.length = geometry.attributes.position.count;\n        }\n\n        var _success = true;\n        var tmp = new THREE.Vector3();\n\n        var _coord = new _Coordinates[\"default\"](objectCRS);\n\n        for (var _i = 0; _i < geometry.attributes.position.count; _i++) {\n          var _cached = options.cache ? options.cache[_i] : undefined;\n\n          tmp.fromBufferAttribute(geometry.attributes.position, _i);\n          var prev = tmp.z;\n\n          var _result2 = _updateVector3(layer, options.method || FAST_READ_Z, tiles, objectCRS, tmp, options.offset || 0, _matrices, _coord, _cached);\n\n          if (options.cache) {\n            options.cache[_i] = _result2;\n          }\n\n          if (!_result2) {\n            _success = false;\n          }\n\n          if (prev != tmp.z) {\n            geometry.attributes.position.needsUpdate = true;\n          }\n\n          geometry.attributes.position.setXYZ(_i, tmp.x, tmp.y, tmp.z);\n        }\n\n        return _success;\n      }\n    }\n  },\n  FAST_READ_Z: FAST_READ_Z,\n  PRECISE_READ_Z: PRECISE_READ_Z\n};\nexports[\"default\"] = _default;\n\nfunction tileAt(pt, tile) {\n  if (tile.extent) {\n    if (!tile.extent.isPointInside(pt)) {\n      return undefined;\n    }\n\n    for (var i = 0; i < tile.children.length; i++) {\n      var t = tileAt(pt, tile.children[i]);\n\n      if (t) {\n        return t;\n      }\n    }\n\n    var tileLayer = tile.material.getElevationLayer();\n\n    if (tileLayer && tileLayer.level >= 0) {\n      return tile;\n    }\n\n    return undefined;\n  }\n}\n\nvar _canvas;\n\nfunction _readTextureValueAt(layer, texture) {\n  for (var _len = arguments.length, uv = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    uv[_key - 2] = arguments[_key];\n  }\n\n  for (var i = 0; i < uv.length; i += 2) {\n    uv[i] = THREE.Math.clamp(uv[i], 0, texture.image.width - 1);\n    uv[i + 1] = THREE.Math.clamp(uv[i + 1], 0, texture.image.height - 1);\n  }\n\n  if (texture.image.data) {\n    // read a single value\n    if (uv.length === 2) {\n      return texture.image.data[uv[1] * texture.image.width + uv[0]];\n    } // or read multiple values\n\n\n    var result = [];\n\n    for (var _i2 = 0; _i2 < uv.length; _i2 += 2) {\n      result.push(texture.image.data[uv[_i2 + 1] * texture.image.width + uv[_i2]]);\n    }\n\n    return result;\n  } else {\n    if (!_canvas) {\n      _canvas = document.createElement('canvas');\n      _canvas.width = 2;\n      _canvas.height = 2;\n    }\n\n    var minx = Infinity;\n    var miny = Infinity;\n    var maxx = -Infinity;\n    var maxy = -Infinity;\n\n    for (var _i3 = 0; _i3 < uv.length; _i3 += 2) {\n      minx = Math.min(uv[_i3], minx);\n      miny = Math.min(uv[_i3 + 1], miny);\n      maxx = Math.max(uv[_i3], maxx);\n      maxy = Math.max(uv[_i3 + 1], maxy);\n    }\n\n    var dw = maxx - minx + 1;\n    var dh = maxy - miny + 1;\n    _canvas.width = Math.max(_canvas.width, dw);\n    _canvas.height = Math.max(_canvas.height, dh);\n\n    var ctx = _canvas.getContext('2d');\n\n    ctx.drawImage(texture.image, minx, miny, dw, dh, 0, 0, dw, dh);\n    var d = ctx.getImageData(0, 0, dw, dh);\n    var elevationLayer = layer.attachedLayers.filter(function (l) {\n      return l.isElevationLayer;\n    })[0];\n    var _result3 = [];\n\n    for (var _i4 = 0; _i4 < uv.length; _i4 += 2) {\n      var ox = uv[_i4] - minx;\n      var oy = uv[_i4 + 1] - miny; // d is 4 bytes per pixel\n\n      _result3.push(THREE.Math.lerp(elevationLayer.colorTextureElevationMinZ, elevationLayer.colorTextureElevationMaxZ, d.data[4 * oy * dw + 4 * ox] / 255));\n    }\n\n    if (uv.length === 2) {\n      return _result3[0];\n    } else {\n      return _result3;\n    }\n  }\n}\n\nfunction _convertUVtoTextureCoords(texture, u, v) {\n  var width = texture.image.width;\n  var height = texture.image.height;\n  var up = Math.max(0, u * width - 0.5);\n  var vp = Math.max(0, v * height - 0.5);\n  var u1 = Math.floor(up);\n  var u2 = Math.ceil(up);\n  var v1 = Math.floor(vp);\n  var v2 = Math.ceil(vp);\n  return {\n    u1: u1,\n    u2: u2,\n    v1: v1,\n    v2: v2,\n    wu: up - u1,\n    wv: vp - v1\n  };\n}\n\nfunction _readTextureValueNearestFiltering(layer, texture, vertexU, vertexV) {\n  var coords = _convertUVtoTextureCoords(texture, vertexU, vertexV);\n\n  var u = coords.wu <= 0 ? coords.u1 : coords.u2;\n  var v = coords.wv <= 0 ? coords.v1 : coords.v2;\n  return _readTextureValueAt(layer, texture, u, v);\n}\n\nfunction _readTextureValueWithBilinearFiltering(layer, texture, vertexU, vertexV) {\n  var coords = _convertUVtoTextureCoords(texture, vertexU, vertexV);\n\n  var _readTextureValueAt2 = _readTextureValueAt(layer, texture, coords.u1, coords.v1, coords.u2, coords.v1, coords.u1, coords.v2, coords.u2, coords.v2),\n      _readTextureValueAt3 = (0, _slicedToArray2[\"default\"])(_readTextureValueAt2, 4),\n      z11 = _readTextureValueAt3[0],\n      z21 = _readTextureValueAt3[1],\n      z12 = _readTextureValueAt3[2],\n      z22 = _readTextureValueAt3[3]; // horizontal filtering\n\n\n  var zu1 = THREE.Math.lerp(z11, z21, coords.wu);\n  var zu2 = THREE.Math.lerp(z12, z22, coords.wu); // then vertical filtering\n\n  return THREE.Math.lerp(zu1, zu2, coords.wv);\n}\n\nfunction _readZFast(layer, texture, uv) {\n  return _readTextureValueNearestFiltering(layer, texture, uv.x, uv.y);\n}\n\nvar bary = new THREE.Vector3();\n\nfunction _readZCorrect(layer, texture, uv, tileDimensions, tileOwnerDimensions) {\n  // We need to emulate the vertex shader code that does 2 thing:\n  //   - interpolate (u, v) between triangle vertices: u,v will be multiple of 1/nsegments\n  //     (for now assume nsegments == 16)\n  //   - read elevation texture at (u, v) for\n  // Determine u,v based on the vertices count.\n  // 'modulo' is the gap (in [0, 1]) between 2 successive vertices in the geometry\n  // e.g if you have 5 vertices, the only possible values for u (or v) are: 0, 0.25, 0.5, 0.75, 1\n  // so modulo would be 0.25\n  // note: currently the number of segments is hard-coded to 16 (see TileProvider) => 17 vertices\n  var modulo = tileDimensions.x / tileOwnerDimensions.x / (17 - 1);\n  var u = Math.floor(uv.x / modulo) * modulo;\n  var v = Math.floor(uv.y / modulo) * modulo;\n\n  if (u == 1) {\n    u -= modulo;\n  }\n\n  if (v == 1) {\n    v -= modulo;\n  } // Build 4 vertices, 3 of them will be our triangle:\n  //    11---21\n  //    |   / |\n  //    |  /  |\n  //    | /   |\n  //    21---22\n\n\n  var u1 = u;\n  var u2 = u + modulo;\n  var v1 = v;\n  var v2 = v + modulo; // Our multiple z-value will be weigh-blended, depending on the distance of the real point\n  // so lu (resp. lv) are the weight. When lu -> 0 (resp. 1) the final value -> z at u1 (resp. u2)\n\n  var lu = (uv.x - u) / modulo;\n  var lv = (uv.y - v) / modulo; // Determine if we're going to read the vertices from the top-left or lower-right triangle\n  // (low-right = on the line 21-22 or under the diagonal lu = 1 - lv)\n\n  var tri = new THREE.Triangle(new THREE.Vector3(u1, v2), new THREE.Vector3(u2, v1), lv == 1 || lu / (1 - lv) >= 1 ? new THREE.Vector3(u2, v2) : new THREE.Vector3(u1, v1)); // bary holds the respective weight of each vertices of the triangles\n\n  tri.getBarycoord(new THREE.Vector3(uv.x, uv.y), bary); // read the 3 interesting values\n\n  var z1 = _readTextureValueWithBilinearFiltering(layer, texture, tri.a.x, tri.a.y);\n\n  var z2 = _readTextureValueWithBilinearFiltering(layer, texture, tri.b.x, tri.b.y);\n\n  var z3 = _readTextureValueWithBilinearFiltering(layer, texture, tri.c.x, tri.c.y); // Blend with bary\n\n\n  return z1 * bary.x + z2 * bary.y + z3 * bary.z;\n}\n\nvar temp = {\n  v: new THREE.Vector3(),\n  coord1: new _Coordinates[\"default\"]('EPSG:4978'),\n  coord2: new _Coordinates[\"default\"]('EPSG:4978'),\n  offset: new THREE.Vector2()\n};\nvar dimension = new THREE.Vector2();\n\nfunction offsetInExtent(point, extent) {\n  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();\n\n  if (point.crs != extent.crs) {\n    throw new Error(\"Unsupported mix: \".concat(point.crs, \" and \").concat(extent.crs));\n  }\n\n  extent.dimensions(dimension);\n  var originX = (point.x - extent.west) / dimension.x;\n  var originY = (extent.north - point.y) / dimension.y;\n  return target.set(originX, originY);\n}\n\nfunction _readZ(layer, method, coord, nodes, cache) {\n  var pt = coord.as(layer.extent.crs, temp.coord1);\n  var tileWithValidElevationTexture = null; // first check in cache\n\n  if (cache && cache.tile && cache.tile.material) {\n    tileWithValidElevationTexture = tileAt(pt, cache.tile);\n  }\n\n  for (var i = 0; !tileWithValidElevationTexture && i < nodes.length; i++) {\n    tileWithValidElevationTexture = tileAt(pt, nodes[i]);\n  }\n\n  if (!tileWithValidElevationTexture) {\n    // failed to find a tile, abort\n    return;\n  }\n\n  var tile = tileWithValidElevationTexture;\n  var tileLayer = tile.material.getElevationLayer();\n  var src = tileLayer.textures[0]; // check cache value if existing\n\n  if (cache) {\n    if (cache.id === src.id && cache.version === src.version) {\n      return {\n        coord: pt,\n        texture: src,\n        tile: tile\n      };\n    }\n  } // Assuming that tiles are split in 4 children, we lookup the parent that\n  // really owns this texture\n\n\n  var stepsUpInHierarchy = Math.round(Math.log2(1.0 / tileLayer.offsetScales[0].z));\n\n  for (var _i5 = 0; _i5 < stepsUpInHierarchy; _i5++) {\n    tileWithValidElevationTexture = tileWithValidElevationTexture.parent;\n  } // offset = offset from top-left\n\n\n  offsetInExtent(pt, tileWithValidElevationTexture.extent, temp.offset); // At this point we have:\n  //   - tileWithValidElevationTexture.texture.image which is the current image\n  //     used for rendering\n  //   - offset which is the offset in this texture for the coordinate we're\n  //     interested in\n  // We now have 2 options:\n  //   - the fast one: read the value of tileWithValidElevationTexture.texture.image\n  //     at (offset.x, offset.y) and we're done\n  //   - the correct one: emulate the vertex shader code\n\n  if (method == PRECISE_READ_Z) {\n    pt.z = _readZCorrect(layer, src, temp.offset, tile.extent.dimensions(), tileWithValidElevationTexture.extent.dimensions());\n  } else {\n    pt.z = _readZFast(layer, src, temp.offset);\n  }\n\n  return {\n    coord: pt,\n    texture: src,\n    tile: tile\n  };\n}\n\nfunction _updateVector3(layer, method, nodes, vecCRS, vec, offset) {\n  var matrices = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n  var coords = arguments.length > 7 ? arguments[7] : undefined;\n  var cache = arguments.length > 8 ? arguments[8] : undefined;\n  var coord = coords || new _Coordinates[\"default\"](vecCRS);\n\n  if (matrices.worldFromLocal) {\n    coord.setFromVector3(temp.v.copy(vec).applyMatrix4(matrices.worldFromLocal));\n  } else {\n    coord.setFromVector3(vec);\n  }\n\n  var result = _readZ(layer, method, coord, nodes, cache);\n\n  if (result) {\n    result.coord.z += offset;\n    result.coord.as(vecCRS, temp.coord2).toVector3(vec);\n\n    if (matrices.localFromWorld) {\n      vec.applyMatrix4(matrices.localFromWorld);\n    }\n\n    return {\n      id: result.texture.id,\n      version: result.texture.version,\n      tile: result.tile\n    };\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Utils/DEMUtils.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Utils/FeaturesUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/itowns/lib/Utils/FeaturesUtils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Feature = __webpack_require__(/*! ../Core/Feature */ \"./node_modules/itowns/lib/Core/Feature.js\");\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar _Extent = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Extent */ \"./node_modules/itowns/lib/Core/Geographic/Extent.js\"));\n\nvar _Crs = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Crs */ \"./node_modules/itowns/lib/Core/Geographic/Crs.js\"));\n\nfunction pointIsOverLine(point, linePoints, epsilon, offset, count, size) {\n  var x0 = point.x;\n  var y0 = point.y; // for each segment of the line (j is i -1)\n\n  for (var i = offset + size, j = offset; i < offset + count; j = i, i += size) {\n    /* **********************************************************\n        norm     : norm of vector P1P2\n        distance : distance point P0 to line P1P2\n        scalar   : dot product of P1P0 and P1P2 divide by norm, it represents the projection of P0 on the line\n         Point is over segment P1P2 if :\n            * if the distance, , is inferior to epsilon\n            * and if :  -epsilon ≤ scalar ≤ (||P1P2|| +  epsilon)\n                         + (P0) _\n                        |      |\n                        |      |\n         <---scalar---->|    distance\n                        |      |\n                        |      v\n         +-------------------------------+\n        (P1)                            (P2)\n    *********************************************************** */\n    var x1 = linePoints[i];\n    var y1 = linePoints[i + 1];\n    var x2 = linePoints[j];\n    var y2 = linePoints[j + 1];\n    var x21 = x2 - x1;\n    var y21 = y2 - y1;\n    var norm = Math.sqrt(x21 * x21 + y21 * y21);\n    var scalar = ((x0 - x1) * x21 + (y0 - y1) * y21) / norm;\n\n    if (scalar >= -epsilon && scalar <= norm + epsilon) {\n      var distance = Math.abs(y21 * x0 - x21 * y0 + x2 * y1 - y2 * x1) / norm;\n\n      if (distance <= epsilon) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction getClosestPoint(point, points, epsilon, offset, count, size) {\n  var x0 = point.x;\n  var y0 = point.y;\n  var squaredEpsilon = epsilon * epsilon;\n  var closestPoint;\n\n  for (var i = offset; i < offset + count; i += size) {\n    var x1 = points[i];\n    var y1 = points[i + 1];\n    var xP = x0 - x1;\n    var yP = y0 - y1;\n    var n = xP * xP + yP * yP;\n\n    if (n < squaredEpsilon) {\n      closestPoint = [points[i], points[i + 1]];\n      squaredEpsilon = n;\n    }\n  }\n\n  return closestPoint;\n}\n\nfunction pointIsInsidePolygon(point, polygonPoints, offset, count, size) {\n  // ray-casting algorithm based on\n  // http://wrf.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n  var x = point.x;\n  var y = point.y;\n  var inside = false; // in first j is last point of polygon\n  // for each segment of the polygon (j is i -1)\n  // debugger;\n\n  for (var i = offset, j = offset + count - size; i < offset + count; j = i, i += size) {\n    var xi = polygonPoints[i];\n    var yi = polygonPoints[i + 1];\n    var xj = polygonPoints[j];\n    var yj = polygonPoints[j + 1]; // isIntersect semi-infinite ray horizontally with polygon's edge\n\n    if (yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n}\n\nfunction isFeatureSingleGeometryUnderCoordinate(coordinate, type, coordinates, epsilon, offset, count, size) {\n  if (type == _Feature.FEATURE_TYPES.LINE && pointIsOverLine(coordinate, coordinates, epsilon, offset, count, size)) {\n    return true;\n  } else if (type == _Feature.FEATURE_TYPES.POLYGON && pointIsInsidePolygon(coordinate, coordinates, offset, count, size)) {\n    return true;\n  } else if (type == _Feature.FEATURE_TYPES.POINT) {\n    var closestPoint = getClosestPoint(coordinate, coordinates, epsilon, offset, count, size);\n\n    if (closestPoint) {\n      return {\n        coordinates: closestPoint\n      };\n    }\n  }\n}\n\nfunction isFeatureUnderCoordinate(coordinate, feature, epsilon, result) {\n  var featCoord = coordinate.as(feature.crs);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = feature.geometry[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var geometry = _step.value;\n\n      if (geometry.extent == undefined || geometry.extent.isPointInside(featCoord, epsilon)) {\n        var offset = geometry.indices[0].offset * feature.size;\n        var count = geometry.indices[0].count * feature.size;\n        var under = isFeatureSingleGeometryUnderCoordinate(featCoord, feature.type, feature.vertices, epsilon, offset, count, feature.size);\n\n        if (under) {\n          result.push({\n            type: feature.type,\n            geometry: geometry,\n            coordinates: under.coordinates\n            /* || coordinates */\n\n          });\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nvar ex = new _Extent[\"default\"]('EPSG:4326', 0, 0, 0, 0);\nvar coord = new _Coordinates[\"default\"]('EPSG:4326', 0, 0, 0);\nvar _default = {\n  /**\n   * Filter from a list of features, features that are under a coordinate.\n   *\n   * @param {Coordinates} coordinate - The coordinate for the filter\n   * condition.\n   * @param {Feature|FeatureCollection} features - A single feature or a\n   * collection of them, to filter given the previous coordinate.\n   * @param {number} [epsilon=0.1] Tolerance around the coordinate (in\n   * coordinate's unit).\n   *\n   * @return {Feature[]} Array of filtered features.\n   */\n  filterFeaturesUnderCoordinate: function filterFeaturesUnderCoordinate(coordinate, features) {\n    var epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    var result = [];\n    coord.copy(coordinate); // We can take this shortcut because either Feature and\n    // FeatureCollection have an extent property\n\n    if (features.extent) {\n      coord.as(_Crs[\"default\"].formatToEPSG(features.extent.crs), coord);\n      features.extent.as(coord.crs, ex);\n\n      if (!ex.isPointInside(coord, epsilon)) {\n        return result; // Special case, because of the way tiles in VectorTileParser are\n        // handled (see Feature2Texture for a similar solution)\n      } else if (features.scale.x != 1 && features.scale.y != 1 || features.translation.x != 0 && features.translation.y != 0) {\n        coord.x = (coord.x + features.translation.x) * features.scale.x;\n        coord.y = (coord.y + features.translation.y) * features.scale.y;\n\n        if (features.scale.x != 1 && features.scale.y != 1) {\n          epsilon *= Math.sqrt(Math.pow(features.scale.x, 2) + Math.pow(features.scale.y, 2));\n        }\n      }\n    }\n\n    if (Array.isArray(features.features)) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = features.features[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var feature = _step2.value;\n\n          if (feature.extent && !feature.extent.isPointInside(coord, epsilon)) {\n            continue;\n          }\n\n          isFeatureUnderCoordinate(coord, feature, epsilon, result);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    } else if (features.geometry) {\n      isFeatureUnderCoordinate(coord, features, epsilon, result);\n    }\n\n    return result;\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Utils/FeaturesUtils.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Utils/OrientationUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/itowns/lib/Utils/OrientationUtils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar THREE = _interopRequireWildcard(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'three'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _proj = _interopRequireDefault(__webpack_require__(/*! proj4 */ \"./node_modules/proj4/lib/index.js\"));\n\nvar _Coordinates = _interopRequireDefault(__webpack_require__(/*! ../Core/Geographic/Coordinates */ \"./node_modules/itowns/lib/Core/Geographic/Coordinates.js\"));\n\nvar DEG2RAD = THREE.Math.DEG2RAD;\nvar matrix = new THREE.Matrix4();\nvar north = new THREE.Vector3();\nvar east = new THREE.Vector3();\nvar axis = new THREE.Vector3().set(0, 0, 1);\nvar coord = new _Coordinates[\"default\"]('EPSG:4326', 0, 0, 0);\nvar euler = new THREE.Euler();\nvar quat = new THREE.Quaternion();\n\nfunction quaternionIdentity(coordinates) {\n  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n  return coordinates ? target.set(0, 0, 0, 1) : quaternionIdentity;\n}\n/**\n * The OrientationUtils module provides methods to compute the quaternion that\n * models a rotation defined with various conventions, including between different\n * CRS.\n * The local <a href=\"https://en.wikipedia.org/wiki/Local_tangent_plane_coordinates#Local_east,_north,_up_(ENU)_coordinates\">\n * East/North/Up frame (ENU)</a> is used as a pivot frame when computing the rotation between two distinct CRS.\n * If the origin of the frame is undefined, CRS-related methods precompute and return a function\n * that can be applied efficiently to many points of origin.\n * Otherwise, the target quaternion is returned at the provided origin coordinates.\n *\n * @example\n * // Compute the rotation around the point of origin from a frame aligned with Lambert93 axes (epsg:2154),\n * // to the geocentric frame (epsg:4978)\n * quat_crs2crs = OrientationUtils.quaternionFromCRSToCRS(\"EPSG:2154\", \"EPSG:4978\")(origin);\n * // Compute the rotation of a sensor platform defined by its attitude\n * quat_attitude = OrientationUtils.quaternionFromAttitude(attitude);\n * // Compute the rotation from the sensor platform frame to the geocentric frame\n * quat = quat_crs2crs.multiply(quat_attitude);\n *\n * @module OrientationUtils\n */\n\n\nvar _default = {\n  /**\n   * @typedef {Object} Attitude\n   * Properties are either defined as (omega, phi, kappa) or as (roll, pitch,\n   * heading) or all `undefined`.\n   *\n   * @property {number} omega - angle in degrees\n   * @property {number} phi - angle in degrees\n   * @property {number} kappa - angle in degrees\n   * @property {number} roll - angle in degrees\n   * @property {number} pitch - angle in degrees\n   * @property {number} heading - angle in degrees\n   */\n\n  /**\n   * The transform from the platform frame to the local East, North, Up (ENU)\n   * frame is `RotationZ(heading).RotationX(pitch).RotationY(roll)`\n   *\n   * @param {number} [roll=0] - angle in degrees\n   * @param {number} [pitch=0] - angle in degrees\n   * @param {number} [heading=0] - angle in degrees\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] - output Quaternion\n   *\n   * @return {THREE.Quaternion} target quaternion\n   */\n  quaternionFromRollPitchHeading: function quaternionFromRollPitchHeading() {\n    var roll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var pitch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var heading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Quaternion();\n    roll *= DEG2RAD;\n    pitch *= DEG2RAD;\n    heading *= DEG2RAD; // return this.setFromEuler(euler.set(pitch, roll, heading , 'ZXY')).conjugate();\n\n    return target.setFromEuler(euler.set(-pitch, -roll, -heading, 'YXZ')); // optimized version of above\n  },\n\n  /**\n   * From\n   * [DocMicMac](https://github.com/micmacIGN/Documentation/raw/master/DocMicMac.pdf),\n   * the transform from the platform frame to the local East, North, Up (ENU)\n   * frame is:\n   *\n   * ```\n   * RotationX(omega).RotationY(phi).RotationZ(kappa).RotationX(PI)\n   * RotationX(PI) <=> Quaternion(1,0,0,0) : converts between the 2 conventions for the camera local frame:\n   * X right, Y bottom, Z front : convention in photogrammetry and computer vision\n   * X right, Y top,    Z back  : convention in webGL, threejs\n   * ```\n   *\n   * @param {number} [omega=0] - angle in degrees\n   * @param {number} [phi=0] - angle in degrees\n   * @param {number} [kappa=0] - angle in degrees\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   *\n   * @return {THREE.Quaternion} target quaternion\n   */\n  quaternionFromOmegaPhiKappa: function quaternionFromOmegaPhiKappa() {\n    var omega = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var phi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var kappa = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Quaternion();\n    omega *= DEG2RAD;\n    phi *= DEG2RAD;\n    kappa *= DEG2RAD;\n    target.setFromEuler(euler.set(omega, phi, kappa, 'XYZ'));\n    target.set(target.w, target.z, -target.y, -target.x); // <=> target.multiply(new THREE.Quaternion(1, 0, 0, 0));\n\n    return target;\n  },\n\n  /**\n   * Set the quaternion according to the rotation from the platform frame to\n   * the local frame.\n   *\n   * @param {Attitude} attitude - Attitude\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   *\n   * @return {THREE.Quaternion} target quaternion\n   */\n  quaternionFromAttitude: function quaternionFromAttitude(attitude) {\n    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n\n    if (attitude.roll !== undefined || attitude.pitch !== undefined || attitude.heading !== undefined) {\n      return this.quaternionFromRollPitchHeading(attitude.roll, attitude.pitch, attitude.heading, target);\n    }\n\n    if (attitude.omega !== undefined || attitude.phi !== undefined || attitude.kappa !== undefined) {\n      return this.quaternionFromOmegaPhiKappa(attitude.omega, attitude.phi, attitude.kappa, target);\n    }\n\n    return target.set(0, 0, 0, 1);\n  },\n\n  /**\n   * FunctionOrQuaternion is either a THREE.Quaternion or a function that accepts\n   * arguments `(coordinates, target)` and returns the quaternion that models a rotation\n   * around the point of origin. If target is not provided, a new quaternion is\n   * created and returned instead.\n   *\n   * @typedef {function|THREE.Quaternion} FunctionOrQuaternion\n   *\n   * @property {Coordinates} coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @property {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion.\n  */\n\n  /**\n   * A Projection object models a Coordinate Reference System (CRS).\n   * Such an object is usually created with proj4 using `proj4.defs(crs);`\n   *\n   * @typedef {Object} Projection\n   *\n   * @property {string} projName\n   */\n\n  /**\n   * Set the quaternion according to the rotation from the local East North Up (ENU)\n   * frame to the geocentric frame. The up direction of the ENU frame is\n   * provided by the normalized geodetic normal of the provided coordinates\n   * (geodeticNormal property).\n   *\n   * @param {Coordinates} [coordinates] the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n   */\n  quaternionFromEnuToGeocent: function quaternionFromEnuToGeocent(coordinates) {\n    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n\n    if (coordinates) {\n      return this.quaternionFromEnuToGeocent()(coordinates, target);\n    }\n\n    return function (coordinates) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n      var up = coordinates.geodesicNormal;\n\n      if (up.x == 0 && up.y == 0) {\n        return target.set(0, 0, 0, 1);\n      } // this is an optimized version of matrix.lookAt(up, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1));\n\n\n      east.set(-up.y, up.x, 0).normalize();\n      north.crossVectors(up, east);\n      matrix.makeBasis(east, north, up);\n      return target.setFromRotationMatrix(matrix);\n    };\n  },\n\n  /**\n   * Set the quaternion according to the rotation from a geocentric frame\n   * to the local East North Up (ENU) frame. The up direction of the ENU frame is\n   * provided by the normalized geodetic normal of the provided coordinates\n   * (geodeticNormal property).\n   *\n   * @param {Coordinates} [coordinates] the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n   */\n  quaternionFromGeocentToEnu: function quaternionFromGeocentToEnu(coordinates) {\n    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n\n    if (coordinates) {\n      return this.quaternionFromGeocentToEnu()(coordinates, target);\n    }\n\n    var toGeocent = this.quaternionFromEnuToGeocent();\n    return function (coordinates) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n      return toGeocent(coordinates, target).conjugate();\n    };\n  },\n\n  /**\n   * Computes the rotation from a Lambert Conformal Conic (LCC) frame to the local East North Up (ENU) frame.\n   * The quaternion accounts for the\n   * <a href=\"https://geodesie.ign.fr/contenu/fichiers/documentation/algorithmes/alg0060.pdf\">meridian convergence</a>\n   * between the ENU and LCC frames.\n   * This is a generally small rotation around Z.\n   *\n   * @param {Projection} proj the lcc projection (may be parsed using proj4)\n   * @param {number} proj.lat0 - the latitude of origin\n   * @param {number} proj.long0 - the longitude of the central meridian\n   * @param {Coordinates} [coordinates]  coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n  */\n  quaternionFromLCCToEnu: function quaternionFromLCCToEnu(proj, coordinates) {\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Quaternion();\n\n    if (coordinates) {\n      return this.quaternionFromLCCToEnu(proj)(coordinates, target);\n    }\n\n    var sinlat0 = Math.sin(proj.lat0);\n    return function (coordinates) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n\n      var _long = coordinates.as(coord.crs, coord).longitude * DEG2RAD;\n\n      return target.setFromAxisAngle(axis, sinlat0 * (proj.long0 - _long));\n    };\n  },\n\n  /**\n   * Computes the rotation from the local East North Up (ENU) frame to a Lambert Conformal Conic (LCC) frame.\n   * The quaternion accounts for the\n   * <a href=\"https://geodesie.ign.fr/contenu/fichiers/documentation/algorithmes/alg0060.pdf\">meridian convergence</a>\n   * between the ENU and LCC frames.\n   * This is a generally small rotation around Z.\n   *\n   * @param {Projection} proj the lcc projection (may be parsed using proj4)\n   * @param {number} proj.lat0 - the latitude of origin\n   * @param {number} proj.long0 - the longitude of the central meridian\n   * @param {Coordinates} [coordinates]  coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n  */\n  quaternionFromEnuToLCC: function quaternionFromEnuToLCC(proj, coordinates) {\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Quaternion();\n\n    if (coordinates) {\n      return this.quaternionFromEnuToLCC(proj)(coordinates, target);\n    }\n\n    var fromLCC = this.quaternionFromLCCToEnu(proj);\n    return function (coordinates) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n      return fromLCC(coordinates, target).conjugate();\n    };\n  },\n\n  /**\n   * Computes the rotation from a Transverse Mercator frame (TMerc) to the local East North Up (ENU) frame.\n   * The quaternion accounts for the\n   * <a href=\"https://geodesie.ign.fr/contenu/fichiers/documentation/algorithmes/alg0061.pdf\">meridian convergence</a>\n   * between the ENU and TMerc frames.\n   * This is a generally small rotation around Z.\n   *\n   * @param {Projection} proj the tmerc projection (may be parsed using proj4)\n   * @param {number} proj.e - the excentricity of the ellipsoid (supersedes {proj.a} and {proj.b})\n   * @param {number} proj.a - the semimajor radius of the ellipsoid axis\n   * @param {number} proj.b - the semiminor radius of the ellipsoid axis\n   * @param {number} proj.long0 - the longitude of the central meridian\n   *\n   * @param {Coordinates} [coordinates]  coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n  */\n  quaternionFromTMercToEnu: function quaternionFromTMercToEnu(proj, coordinates) {\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Quaternion();\n\n    if (coordinates) {\n      return this.quaternionFromTMercToEnu(proj)(coordinates, target);\n    }\n\n    var a2 = proj.a * proj.a;\n    var b2 = proj.b * proj.b;\n    var e2 = proj.e * proj.e;\n    var eta0 = proj.e ? e2 / (1 - e2) : a2 / b2 - 1;\n    return function (coordinates) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n      coordinates.as(coord.crs, coord);\n\n      var _long2 = coord.longitude * DEG2RAD;\n\n      var lat = coord.latitude * DEG2RAD;\n      var dlong = proj.long0 - _long2;\n      var coslat = Math.cos(lat);\n      var sinlat = Math.sin(lat);\n      var coslat2 = coslat * coslat;\n      var dl2 = dlong * dlong * coslat2;\n      var eta2 = eta0 * coslat2;\n      return target.setFromAxisAngle(axis, dlong * sinlat * (1 + dl2 / 3 * (1 + 3 * eta2 + 2 * eta2 * eta2) + dl2 * dl2 * (2 - sinlat / coslat) / 15));\n    };\n  },\n\n  /**\n   * Computes the rotation from the local East North Up (ENU) to a Transverse Mercator frame.\n   * The quaternion accounts for the\n   * <a href=\"https://geodesie.ign.fr/contenu/fichiers/documentation/algorithmes/alg0061.pdf\">meridian convergence</a>\n   * between the ENU and TMerc frames.\n   * This is a generally small rotation around Z.\n   *\n   * @param {Projection} proj the tmerc projection (may be parsed using proj4)\n   * @param {number} proj.e - the excentricity of the ellipsoid (supersedes\n   * {proj.a} and {proj.b})\n   * @param {number} proj.a - the semimajor radius of the ellipsoid axis\n   * @param {number} proj.b - the semiminor radius of the ellipsoid axis\n   * @param {number} proj.long0 - the longitude of the central meridian\n   *\n   * @param {Coordinates} [coordinates]  coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n  */\n  quaternionFromEnuToTMerc: function quaternionFromEnuToTMerc(proj, coordinates) {\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Quaternion();\n\n    if (coordinates) {\n      return this.quaternionFromEnuToTMerc(proj)(coordinates, target);\n    }\n\n    var fromTMerc = this.quaternionFromTMercToEnu(proj);\n    return function (coordinates) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n      return fromTMerc(coordinates, target).conjugate();\n    };\n  },\n\n  /**\n   * Computes the rotation from a LongLat frame to the local East North Up (ENU) frame.\n   * The identity quaternion (0,0,0,1) is returned, as longlat and ENU frame are assumed to be aligned.\n   *\n   * @param {Coordinates} [coordinates]  coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n   */\n  quaternionFromLongLatToEnu: function quaternionFromLongLatToEnu(coordinates) {\n    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n    return quaternionIdentity(coordinates, target);\n  },\n\n  /**\n  * Computes the rotation from the local East North Up (ENU) frame to a LongLat frame.\n  * The identity quaternion (0,0,0,1) is returned, as longlat and ENU frame are assumed to be aligned.\n   *\n   * @param {Coordinates} [coordinates]  coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n   */\n  quaternionFromEnuToLongLat: function quaternionFromEnuToLongLat(coordinates) {\n    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n    return quaternionIdentity(coordinates, target);\n  },\n\n  /**\n   * Warns for an unimplemented projection, sets the quaternion to the\n   * identity (0,0,0,1).\n   *\n   * @param {Projection} proj - the unimplemented projection (may be parsed\n   * using proj4)\n   *\n   * @param {Coordinates} [coordinates]  coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n   */\n  quaternionUnimplemented: function quaternionUnimplemented(proj, coordinates) {\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Quaternion();\n    console.warn('This quaternion function is not implemented for projections of type', proj.projName);\n    return quaternionIdentity(coordinates, target);\n  },\n\n  /**\n   * Compute the quaternion that models the rotation from the local East North\n   * Up (ENU) frame to the frame of the given crs.\n   *\n   * @param {string|Projection} crsOrProj - the CRS of the target frame or its\n   * proj4-compatible object.\n   *\n   * @param {Coordinates} [coordinates]  coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n   */\n  quaternionFromEnuToCRS: function quaternionFromEnuToCRS(crsOrProj, coordinates) {\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Quaternion();\n\n    if (coordinates) {\n      return this.quaternionFromEnuToCRS(crsOrProj)(coordinates, target);\n    }\n\n    var proj = crsOrProj.projName ? crsOrProj : _proj[\"default\"].defs(crsOrProj);\n\n    switch (proj.projName) {\n      case 'geocent':\n        return this.quaternionFromEnuToGeocent();\n\n      case 'lcc':\n        return this.quaternionFromEnuToLCC(proj);\n\n      case 'tmerc':\n        return this.quaternionFromEnuToTMerc(proj);\n\n      case 'longlat':\n        return this.quaternionFromEnuToLongLat();\n\n      default:\n        return this.quaternionUnimplemented(proj);\n    }\n  },\n\n  /**\n   * Compute the quaternion that models the rotation from the frame of the\n   * given crs to the local East North Up (ENU) frame.\n   *\n   * @param {string|Projection} crsOrProj - the CRS of the source frame or its\n   * proj4-compatible object.\n   *\n   * @param {Coordinates} [coordinates]  coordinates the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n   */\n  quaternionFromCRSToEnu: function quaternionFromCRSToEnu(crsOrProj, coordinates) {\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Quaternion();\n\n    if (coordinates) {\n      return this.quaternionFromCRSToEnu(crsOrProj)(coordinates, target);\n    }\n\n    var proj = crsOrProj.projName ? crsOrProj : _proj[\"default\"].defs(crsOrProj);\n\n    switch (proj.projName) {\n      case 'geocent':\n        return this.quaternionFromGeocentToEnu();\n\n      case 'lcc':\n        return this.quaternionFromLCCToEnu(proj);\n\n      case 'tmerc':\n        return this.quaternionFromTMercToEnu(proj);\n\n      case 'longlat':\n        return this.quaternionFromLongLatToEnu();\n\n      default:\n        return this.quaternionUnimplemented(proj);\n    }\n  },\n\n  /**\n   * Return the function that computes the quaternion that represents a\n   * rotation of coordinates between two CRS frames.\n   *\n   * @param {string} crsIn - the CRS of the input frame.\n   * @param {string} crsOut - the CRS of the output frame.\n   * @param {Coordinates} [coordinates]  coordinates - the origin of the local East North Up\n   * (ENU) frame\n   * @param {THREE.Quaternion} [target=new THREE.Quaternion()] output Quaternion\n   * @return {FunctionOrQuaternion} The target quaternion if coordinates is defined, otherwise, a function to compute it from coordinates.\n  */\n  quaternionFromCRSToCRS: function quaternionFromCRSToCRS(crsIn, crsOut, coordinates) {\n    var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Quaternion();\n\n    if (coordinates) {\n      return this.quaternionFromCRSToCRS(crsIn, crsOut)(coordinates, target);\n    }\n\n    if (crsIn == crsOut) {\n      return function () {\n        var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n        return target.set(0, 0, 0, 1);\n      };\n    } // get rotations from the local East/North/Up (ENU) frame to both CRS.\n\n\n    var fromCrs = this.quaternionFromCRSToEnu(crsIn);\n    var toCrs = this.quaternionFromEnuToCRS(crsOut);\n    return function (origin) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Quaternion();\n      return toCrs(origin, target).multiply(fromCrs(origin, quat));\n    };\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Utils/OrientationUtils.js?");

/***/ }),

/***/ "./node_modules/itowns/lib/Utils/Utf8Decoder.js":
/*!******************************************************!*\
  !*** ./node_modules/itowns/lib/Utils/Utf8Decoder.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.TextDecoder = void 0;\n\nvar _textEncodingUtf = __webpack_require__(/*! text-encoding-utf-8 */ \"./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs\");\n\nvar TextDecoder = typeof global.TextDecoder === 'function' ? global.TextDecoder : _textEncodingUtf.TextDecoder;\nexports.TextDecoder = TextDecoder;\n\nvar _default = new TextDecoder('utf-8');\n\nexports[\"default\"] = _default;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/itowns/lib/Utils/Utf8Decoder.js?");

/***/ }),

/***/ "./node_modules/js-priority-queue/priority-queue.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-priority-queue/priority-queue.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;var require;(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\nvar AbstractPriorityQueue, ArrayStrategy, BHeapStrategy, BinaryHeapStrategy, PriorityQueue,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nAbstractPriorityQueue = _dereq_('./PriorityQueue/AbstractPriorityQueue');\n\nArrayStrategy = _dereq_('./PriorityQueue/ArrayStrategy');\n\nBinaryHeapStrategy = _dereq_('./PriorityQueue/BinaryHeapStrategy');\n\nBHeapStrategy = _dereq_('./PriorityQueue/BHeapStrategy');\n\nPriorityQueue = (function(superClass) {\n  extend(PriorityQueue, superClass);\n\n  function PriorityQueue(options) {\n    options || (options = {});\n    options.strategy || (options.strategy = BinaryHeapStrategy);\n    options.comparator || (options.comparator = function(a, b) {\n      return (a || 0) - (b || 0);\n    });\n    PriorityQueue.__super__.constructor.call(this, options);\n  }\n\n  return PriorityQueue;\n\n})(AbstractPriorityQueue);\n\nPriorityQueue.ArrayStrategy = ArrayStrategy;\n\nPriorityQueue.BinaryHeapStrategy = BinaryHeapStrategy;\n\nPriorityQueue.BHeapStrategy = BHeapStrategy;\n\nmodule.exports = PriorityQueue;\n\n\n},{\"./PriorityQueue/AbstractPriorityQueue\":2,\"./PriorityQueue/ArrayStrategy\":3,\"./PriorityQueue/BHeapStrategy\":4,\"./PriorityQueue/BinaryHeapStrategy\":5}],2:[function(_dereq_,module,exports){\nvar AbstractPriorityQueue;\n\nmodule.exports = AbstractPriorityQueue = (function() {\n  function AbstractPriorityQueue(options) {\n    var ref;\n    if ((options != null ? options.strategy : void 0) == null) {\n      throw 'Must pass options.strategy, a strategy';\n    }\n    if ((options != null ? options.comparator : void 0) == null) {\n      throw 'Must pass options.comparator, a comparator';\n    }\n    this.priv = new options.strategy(options);\n    this.length = (options != null ? (ref = options.initialValues) != null ? ref.length : void 0 : void 0) || 0;\n  }\n\n  AbstractPriorityQueue.prototype.queue = function(value) {\n    this.length++;\n    this.priv.queue(value);\n    return void 0;\n  };\n\n  AbstractPriorityQueue.prototype.dequeue = function(value) {\n    if (!this.length) {\n      throw 'Empty queue';\n    }\n    this.length--;\n    return this.priv.dequeue();\n  };\n\n  AbstractPriorityQueue.prototype.peek = function(value) {\n    if (!this.length) {\n      throw 'Empty queue';\n    }\n    return this.priv.peek();\n  };\n\n  AbstractPriorityQueue.prototype.clear = function() {\n    this.length = 0;\n    return this.priv.clear();\n  };\n\n  return AbstractPriorityQueue;\n\n})();\n\n\n},{}],3:[function(_dereq_,module,exports){\nvar ArrayStrategy, binarySearchForIndexReversed;\n\nbinarySearchForIndexReversed = function(array, value, comparator) {\n  var high, low, mid;\n  low = 0;\n  high = array.length;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(array[mid], value) >= 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n};\n\nmodule.exports = ArrayStrategy = (function() {\n  function ArrayStrategy(options) {\n    var ref;\n    this.options = options;\n    this.comparator = this.options.comparator;\n    this.data = ((ref = this.options.initialValues) != null ? ref.slice(0) : void 0) || [];\n    this.data.sort(this.comparator).reverse();\n  }\n\n  ArrayStrategy.prototype.queue = function(value) {\n    var pos;\n    pos = binarySearchForIndexReversed(this.data, value, this.comparator);\n    this.data.splice(pos, 0, value);\n    return void 0;\n  };\n\n  ArrayStrategy.prototype.dequeue = function() {\n    return this.data.pop();\n  };\n\n  ArrayStrategy.prototype.peek = function() {\n    return this.data[this.data.length - 1];\n  };\n\n  ArrayStrategy.prototype.clear = function() {\n    this.data.length = 0;\n    return void 0;\n  };\n\n  return ArrayStrategy;\n\n})();\n\n\n},{}],4:[function(_dereq_,module,exports){\nvar BHeapStrategy;\n\nmodule.exports = BHeapStrategy = (function() {\n  function BHeapStrategy(options) {\n    var arr, i, j, k, len, ref, ref1, shift, value;\n    this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {\n      return a - b;\n    };\n    this.pageSize = (options != null ? options.pageSize : void 0) || 512;\n    this.length = 0;\n    shift = 0;\n    while ((1 << shift) < this.pageSize) {\n      shift += 1;\n    }\n    if (1 << shift !== this.pageSize) {\n      throw 'pageSize must be a power of two';\n    }\n    this._shift = shift;\n    this._emptyMemoryPageTemplate = arr = [];\n    for (i = j = 0, ref = this.pageSize; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      arr.push(null);\n    }\n    this._memory = [];\n    this._mask = this.pageSize - 1;\n    if (options.initialValues) {\n      ref1 = options.initialValues;\n      for (k = 0, len = ref1.length; k < len; k++) {\n        value = ref1[k];\n        this.queue(value);\n      }\n    }\n  }\n\n  BHeapStrategy.prototype.queue = function(value) {\n    this.length += 1;\n    this._write(this.length, value);\n    this._bubbleUp(this.length, value);\n    return void 0;\n  };\n\n  BHeapStrategy.prototype.dequeue = function() {\n    var ret, val;\n    ret = this._read(1);\n    val = this._read(this.length);\n    this.length -= 1;\n    if (this.length > 0) {\n      this._write(1, val);\n      this._bubbleDown(1, val);\n    }\n    return ret;\n  };\n\n  BHeapStrategy.prototype.peek = function() {\n    return this._read(1);\n  };\n\n  BHeapStrategy.prototype.clear = function() {\n    this.length = 0;\n    this._memory.length = 0;\n    return void 0;\n  };\n\n  BHeapStrategy.prototype._write = function(index, value) {\n    var page;\n    page = index >> this._shift;\n    while (page >= this._memory.length) {\n      this._memory.push(this._emptyMemoryPageTemplate.slice(0));\n    }\n    return this._memory[page][index & this._mask] = value;\n  };\n\n  BHeapStrategy.prototype._read = function(index) {\n    return this._memory[index >> this._shift][index & this._mask];\n  };\n\n  BHeapStrategy.prototype._bubbleUp = function(index, value) {\n    var compare, indexInPage, parentIndex, parentValue;\n    compare = this.comparator;\n    while (index > 1) {\n      indexInPage = index & this._mask;\n      if (index < this.pageSize || indexInPage > 3) {\n        parentIndex = (index & ~this._mask) | (indexInPage >> 1);\n      } else if (indexInPage < 2) {\n        parentIndex = (index - this.pageSize) >> this._shift;\n        parentIndex += parentIndex & ~(this._mask >> 1);\n        parentIndex |= this.pageSize >> 1;\n      } else {\n        parentIndex = index - 2;\n      }\n      parentValue = this._read(parentIndex);\n      if (compare(parentValue, value) < 0) {\n        break;\n      }\n      this._write(parentIndex, value);\n      this._write(index, parentValue);\n      index = parentIndex;\n    }\n    return void 0;\n  };\n\n  BHeapStrategy.prototype._bubbleDown = function(index, value) {\n    var childIndex1, childIndex2, childValue1, childValue2, compare;\n    compare = this.comparator;\n    while (index < this.length) {\n      if (index > this._mask && !(index & (this._mask - 1))) {\n        childIndex1 = childIndex2 = index + 2;\n      } else if (index & (this.pageSize >> 1)) {\n        childIndex1 = (index & ~this._mask) >> 1;\n        childIndex1 |= index & (this._mask >> 1);\n        childIndex1 = (childIndex1 + 1) << this._shift;\n        childIndex2 = childIndex1 + 1;\n      } else {\n        childIndex1 = index + (index & this._mask);\n        childIndex2 = childIndex1 + 1;\n      }\n      if (childIndex1 !== childIndex2 && childIndex2 <= this.length) {\n        childValue1 = this._read(childIndex1);\n        childValue2 = this._read(childIndex2);\n        if (compare(childValue1, value) < 0 && compare(childValue1, childValue2) <= 0) {\n          this._write(childIndex1, value);\n          this._write(index, childValue1);\n          index = childIndex1;\n        } else if (compare(childValue2, value) < 0) {\n          this._write(childIndex2, value);\n          this._write(index, childValue2);\n          index = childIndex2;\n        } else {\n          break;\n        }\n      } else if (childIndex1 <= this.length) {\n        childValue1 = this._read(childIndex1);\n        if (compare(childValue1, value) < 0) {\n          this._write(childIndex1, value);\n          this._write(index, childValue1);\n          index = childIndex1;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    return void 0;\n  };\n\n  return BHeapStrategy;\n\n})();\n\n\n},{}],5:[function(_dereq_,module,exports){\nvar BinaryHeapStrategy;\n\nmodule.exports = BinaryHeapStrategy = (function() {\n  function BinaryHeapStrategy(options) {\n    var ref;\n    this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {\n      return a - b;\n    };\n    this.length = 0;\n    this.data = ((ref = options.initialValues) != null ? ref.slice(0) : void 0) || [];\n    this._heapify();\n  }\n\n  BinaryHeapStrategy.prototype._heapify = function() {\n    var i, j, ref;\n    if (this.data.length > 0) {\n      for (i = j = 1, ref = this.data.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n        this._bubbleUp(i);\n      }\n    }\n    return void 0;\n  };\n\n  BinaryHeapStrategy.prototype.queue = function(value) {\n    this.data.push(value);\n    this._bubbleUp(this.data.length - 1);\n    return void 0;\n  };\n\n  BinaryHeapStrategy.prototype.dequeue = function() {\n    var last, ret;\n    ret = this.data[0];\n    last = this.data.pop();\n    if (this.data.length > 0) {\n      this.data[0] = last;\n      this._bubbleDown(0);\n    }\n    return ret;\n  };\n\n  BinaryHeapStrategy.prototype.peek = function() {\n    return this.data[0];\n  };\n\n  BinaryHeapStrategy.prototype.clear = function() {\n    this.length = 0;\n    this.data.length = 0;\n    return void 0;\n  };\n\n  BinaryHeapStrategy.prototype._bubbleUp = function(pos) {\n    var parent, x;\n    while (pos > 0) {\n      parent = (pos - 1) >>> 1;\n      if (this.comparator(this.data[pos], this.data[parent]) < 0) {\n        x = this.data[parent];\n        this.data[parent] = this.data[pos];\n        this.data[pos] = x;\n        pos = parent;\n      } else {\n        break;\n      }\n    }\n    return void 0;\n  };\n\n  BinaryHeapStrategy.prototype._bubbleDown = function(pos) {\n    var last, left, minIndex, right, x;\n    last = this.data.length - 1;\n    while (true) {\n      left = (pos << 1) + 1;\n      right = left + 1;\n      minIndex = pos;\n      if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {\n        minIndex = left;\n      }\n      if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {\n        minIndex = right;\n      }\n      if (minIndex !== pos) {\n        x = this.data[minIndex];\n        this.data[minIndex] = this.data[pos];\n        this.data[pos] = x;\n        pos = minIndex;\n      } else {\n        break;\n      }\n    }\n    return void 0;\n  };\n\n  return BinaryHeapStrategy;\n\n})();\n\n\n},{}]},{},[1])(1)\n});\n\n//# sourceURL=webpack:///./node_modules/js-priority-queue/priority-queue.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/arrayReader.js":
/*!***********************************************!*\
  !*** ./node_modules/jszip/lib/arrayReader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar DataReader = __webpack_require__(/*! ./dataReader */ \"./node_modules/jszip/lib/dataReader.js\");\n\nfunction ArrayReader(data) {\n    if (data) {\n        this.data = data;\n        this.length = this.data.length;\n        this.index = 0;\n        this.zero = 0;\n\n        for(var i = 0; i < this.data.length; i++) {\n            data[i] = data[i] & 0xFF;\n        }\n    }\n}\nArrayReader.prototype = new DataReader();\n/**\n * @see DataReader.byteAt\n */\nArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3);\n    for (var i = this.length - 4; i >= 0; --i) {\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n\n    return -1;\n};\n/**\n * @see DataReader.readData\n */\nArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/arrayReader.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/base64.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/base64.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// private property\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n\n// public method for encoding\nexports.encode = function(input, utf8) {\n    var output = \"\";\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0;\n\n    while (i < input.length) {\n\n        chr1 = input.charCodeAt(i++);\n        chr2 = input.charCodeAt(i++);\n        chr3 = input.charCodeAt(i++);\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n            enc3 = enc4 = 64;\n        }\n        else if (isNaN(chr3)) {\n            enc4 = 64;\n        }\n\n        output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);\n\n    }\n\n    return output;\n};\n\n// public method for decoding\nexports.decode = function(input, utf8) {\n    var output = \"\";\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0;\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n    while (i < input.length) {\n\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        output = output + String.fromCharCode(chr1);\n\n        if (enc3 != 64) {\n            output = output + String.fromCharCode(chr2);\n        }\n        if (enc4 != 64) {\n            output = output + String.fromCharCode(chr3);\n        }\n\n    }\n\n    return output;\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/base64.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/compressedObject.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/compressedObject.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction CompressedObject() {\n    this.compressedSize = 0;\n    this.uncompressedSize = 0;\n    this.crc32 = 0;\n    this.compressionMethod = null;\n    this.compressedContent = null;\n}\n\nCompressedObject.prototype = {\n    /**\n     * Return the decompressed content in an unspecified format.\n     * The format will depend on the decompressor.\n     * @return {Object} the decompressed content.\n     */\n    getContent: function() {\n        return null; // see implementation\n    },\n    /**\n     * Return the compressed content in an unspecified format.\n     * The format will depend on the compressed conten source.\n     * @return {Object} the compressed content.\n     */\n    getCompressedContent: function() {\n        return null; // see implementation\n    }\n};\nmodule.exports = CompressedObject;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/compressedObject.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/compressions.js":
/*!************************************************!*\
  !*** ./node_modules/jszip/lib/compressions.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.STORE = {\n    magic: \"\\x00\\x00\",\n    compress: function(content, compressionOptions) {\n        return content; // no compression\n    },\n    uncompress: function(content) {\n        return content; // no compression\n    },\n    compressInputType: null,\n    uncompressInputType: null\n};\nexports.DEFLATE = __webpack_require__(/*! ./flate */ \"./node_modules/jszip/lib/flate.js\");\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/compressions.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/crc32.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/crc32.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\n\nvar table = [\n    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,\n    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\n    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\n    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\n    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,\n    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,\n    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\n    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\n    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\n    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,\n    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,\n    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\n    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\n    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\n    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,\n    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,\n    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\n    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\n    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\n    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,\n    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,\n    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\n    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\n    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\n    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,\n    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,\n    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\n    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\n    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\n    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,\n    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,\n    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\n    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\n    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\n    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,\n    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,\n    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\n    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\n    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\n    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,\n    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,\n    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\n    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\n    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\n    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,\n    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,\n    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\n    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\n    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\n    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,\n    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,\n    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\n    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\n    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\n];\n\n/**\n *\n *  Javascript crc32\n *  http://www.webtoolkit.info/\n *\n */\nmodule.exports = function crc32(input, crc) {\n    if (typeof input === \"undefined\" || !input.length) {\n        return 0;\n    }\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n\n    if (typeof(crc) == \"undefined\") {\n        crc = 0;\n    }\n    var x = 0;\n    var y = 0;\n    var b = 0;\n\n    crc = crc ^ (-1);\n    for (var i = 0, iTop = input.length; i < iTop; i++) {\n        b = isArray ? input[i] : input.charCodeAt(i);\n        y = (crc ^ b) & 0xFF;\n        x = table[y];\n        crc = (crc >>> 8) ^ x;\n    }\n\n    return crc ^ (-1);\n};\n// vim: set shiftwidth=4 softtabstop=4:\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/crc32.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/dataReader.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/lib/dataReader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\n\nfunction DataReader(data) {\n    this.data = null; // type : see implementation\n    this.length = 0;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specifed index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1); // second\n    }\n};\nmodule.exports = DataReader;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/dataReader.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = false;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/defaults.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/deprecatedPublicUtils.js":
/*!*********************************************************!*\
  !*** ./node_modules/jszip/lib/deprecatedPublicUtils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.string2binary = function(str) {\n    return utils.string2binary(str);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.string2Uint8Array = function(str) {\n    return utils.transformTo(\"uint8array\", str);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.uint8Array2String = function(array) {\n    return utils.transformTo(\"string\", array);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.string2Blob = function(str) {\n    var buffer = utils.transformTo(\"arraybuffer\", str);\n    return utils.arrayBuffer2Blob(buffer);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.arrayBuffer2Blob = function(buffer) {\n    return utils.arrayBuffer2Blob(buffer);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.transformTo = function(outputType, input) {\n    return utils.transformTo(outputType, input);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.getTypeOf = function(input) {\n    return utils.getTypeOf(input);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.checkSupport = function(type) {\n    return utils.checkSupport(type);\n};\n\n/**\n * @deprecated\n * This value will be removed in a future version without replacement.\n */\nexports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;\n\n/**\n * @deprecated\n * This value will be removed in a future version without replacement.\n */\nexports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;\n\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.pretty = function(str) {\n    return utils.pretty(str);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.findCompression = function(compressionMethod) {\n    return utils.findCompression(compressionMethod);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.isRegExp = function (object) {\n    return utils.isRegExp(object);\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/deprecatedPublicUtils.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/flate.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/flate.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');\n\nvar pako = __webpack_require__(/*! pako */ \"./node_modules/pako/index.js\");\nexports.uncompressInputType = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\nexports.compressInputType = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\nexports.magic = \"\\x08\\x00\";\nexports.compress = function(input, compressionOptions) {\n    return pako.deflateRaw(input, {\n        level : compressionOptions.level || -1 // default compression\n    });\n};\nexports.uncompress =  function(input) {\n    return pako.inflateRaw(input);\n};\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/flate.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar base64 = __webpack_require__(/*! ./base64 */ \"./node_modules/jszip/lib/base64.js\");\n\n/**\nUsage:\n   zip = new JSZip();\n   zip.file(\"hello.txt\", \"Hello, World!\").file(\"tempfile\", \"nothing\");\n   zip.folder(\"images\").file(\"smile.gif\", base64Data, {base64: true});\n   zip.file(\"Xmas.txt\", \"Ho ho ho !\", {date : new Date(\"December 25, 2007 00:00:01\")});\n   zip.remove(\"tempfile\");\n\n   base64zip = zip.generate();\n\n**/\n\n/**\n * Representation a of zip file in js\n * @constructor\n * @param {String=|ArrayBuffer=|Uint8Array=} data the data to load, if any (optional).\n * @param {Object=} options the options for creating this objects (optional).\n */\nfunction JSZip(data, options) {\n    // if this constructor is used without `new`, it adds `new` before itself:\n    if(!(this instanceof JSZip)) return new JSZip(data, options);\n\n    // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    this.files = {};\n\n    this.comment = null;\n\n    // Where we are in the hierarchy\n    this.root = \"\";\n    if (data) {\n        this.load(data, options);\n    }\n    this.clone = function() {\n        var newObj = new JSZip();\n        for (var i in this) {\n            if (typeof this[i] !== \"function\") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = __webpack_require__(/*! ./object */ \"./node_modules/jszip/lib/object.js\");\nJSZip.prototype.load = __webpack_require__(/*! ./load */ \"./node_modules/jszip/lib/load.js\");\nJSZip.support = __webpack_require__(/*! ./support */ \"./node_modules/jszip/lib/support.js\");\nJSZip.defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/jszip/lib/defaults.js\");\n\n/**\n * @deprecated\n * This namespace will be removed in a future version without replacement.\n */\nJSZip.utils = __webpack_require__(/*! ./deprecatedPublicUtils */ \"./node_modules/jszip/lib/deprecatedPublicUtils.js\");\n\nJSZip.base64 = {\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    encode : function(input) {\n        return base64.encode(input);\n    },\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    decode : function(input) {\n        return base64.decode(input);\n    }\n};\nJSZip.compressions = __webpack_require__(/*! ./compressions */ \"./node_modules/jszip/lib/compressions.js\");\nmodule.exports = JSZip;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/index.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/load.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/load.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar base64 = __webpack_require__(/*! ./base64 */ \"./node_modules/jszip/lib/base64.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"./node_modules/jszip/lib/utf8.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\nvar ZipEntries = __webpack_require__(/*! ./zipEntries */ \"./node_modules/jszip/lib/zipEntries.js\");\nmodule.exports = function(data, options) {\n    var files, zipEntries, i, input;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString : false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n    if (options.base64) {\n        data = base64.decode(data);\n    }\n\n    zipEntries = new ZipEntries(data, options);\n    files = zipEntries.files;\n    for (i = 0; i < files.length; i++) {\n        input = files[i];\n        this.file(input.fileNameStr, input.decompressed, {\n            binary: true,\n            optimizedBinaryString: true,\n            date: input.date,\n            dir: input.dir,\n            comment : input.fileCommentStr.length ? input.fileCommentStr : null,\n            unixPermissions : input.unixPermissions,\n            dosPermissions : input.dosPermissions,\n            createFolders: options.createFolders\n        });\n    }\n    if (zipEntries.zipComment.length) {\n        this.comment = zipEntries.zipComment;\n    }\n\n    return this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/load.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/nodeBuffer.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/lib/nodeBuffer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nmodule.exports = function(data, encoding){\n    return new Buffer(data, encoding);\n};\nmodule.exports.test = function(b){\n    return Buffer.isBuffer(b);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/nodeBuffer.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/nodeBufferReader.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/nodeBufferReader.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Uint8ArrayReader = __webpack_require__(/*! ./uint8ArrayReader */ \"./node_modules/jszip/lib/uint8ArrayReader.js\");\n\nfunction NodeBufferReader(data) {\n    this.data = data;\n    this.length = this.data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nNodeBufferReader.prototype = new Uint8ArrayReader();\n\n/**\n * @see DataReader.readData\n */\nNodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/nodeBufferReader.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/object.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/object.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar support = __webpack_require__(/*! ./support */ \"./node_modules/jszip/lib/support.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"./node_modules/jszip/lib/crc32.js\");\nvar signature = __webpack_require__(/*! ./signature */ \"./node_modules/jszip/lib/signature.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/jszip/lib/defaults.js\");\nvar base64 = __webpack_require__(/*! ./base64 */ \"./node_modules/jszip/lib/base64.js\");\nvar compressions = __webpack_require__(/*! ./compressions */ \"./node_modules/jszip/lib/compressions.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"./node_modules/jszip/lib/compressedObject.js\");\nvar nodeBuffer = __webpack_require__(/*! ./nodeBuffer */ \"./node_modules/jszip/lib/nodeBuffer.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"./node_modules/jszip/lib/utf8.js\");\nvar StringWriter = __webpack_require__(/*! ./stringWriter */ \"./node_modules/jszip/lib/stringWriter.js\");\nvar Uint8ArrayWriter = __webpack_require__(/*! ./uint8ArrayWriter */ \"./node_modules/jszip/lib/uint8ArrayWriter.js\");\n\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getRawData = function(file) {\n    if (file._data instanceof CompressedObject) {\n        file._data = file._data.getContent();\n        file.options.binary = true;\n        file.options.base64 = false;\n\n        if (utils.getTypeOf(file._data) === \"uint8array\") {\n            var copy = file._data;\n            // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n            // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n            file._data = new Uint8Array(copy.length);\n            // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n            if (copy.length !== 0) {\n                file._data.set(copy, 0);\n            }\n        }\n    }\n    return file._data;\n};\n\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getBinaryData = function(file) {\n    var result = getRawData(file),\n        type = utils.getTypeOf(result);\n    if (type === \"string\") {\n        if (!file.options.binary) {\n            // unicode text !\n            // unicode string => binary string is a painful process, check if we can avoid it.\n            if (support.nodebuffer) {\n                return nodeBuffer(result, \"utf-8\");\n            }\n        }\n        return file.asBinary();\n    }\n    return result;\n};\n\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\nvar dataToString = function(asUTF8) {\n    var result = getRawData(this);\n    if (result === null || typeof result === \"undefined\") {\n        return \"\";\n    }\n    // if the data is a base64 string, we decode it before checking the encoding !\n    if (this.options.base64) {\n        result = base64.decode(result);\n    }\n    if (asUTF8 && this.options.binary) {\n        // JSZip.prototype.utf8decode supports arrays as input\n        // skip to array => string step, utf8decode will do it.\n        result = out.utf8decode(result);\n    }\n    else {\n        // no utf8 transformation, do the array => string step.\n        result = utils.transformTo(\"string\", result);\n    }\n\n    if (!asUTF8 && !this.options.binary) {\n        result = utils.transformTo(\"string\", out.utf8encode(result));\n    }\n    return result;\n};\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this.options = options;\n\n    /*\n     * This object contains initial values for dir and date.\n     * With them, we can check if the user changed the deprecated metadata in\n     * `ZipObject#options` or not.\n     */\n    this._initialMetadata = {\n      dir : options.dir,\n      date : options.date\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Return the content as UTF8 string.\n     * @return {string} the UTF8 string.\n     */\n    asText: function() {\n        return dataToString.call(this, true);\n    },\n    /**\n     * Returns the binary content.\n     * @return {string} the content as binary.\n     */\n    asBinary: function() {\n        return dataToString.call(this, false);\n    },\n    /**\n     * Returns the content as a nodejs Buffer.\n     * @return {Buffer} the content as a Buffer.\n     */\n    asNodeBuffer: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"nodebuffer\", result);\n    },\n    /**\n     * Returns the content as an Uint8Array.\n     * @return {Uint8Array} the content as an Uint8Array.\n     */\n    asUint8Array: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"uint8array\", result);\n    },\n    /**\n     * Returns the content as an ArrayBuffer.\n     * @return {ArrayBuffer} the content as an ArrayBufer.\n     */\n    asArrayBuffer: function() {\n        return this.asUint8Array().buffer;\n    }\n};\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\",\n        i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\nvar prepareFileAttrs = function(o) {\n    o = o || {};\n    if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n        o.binary = true;\n    }\n    o = utils.extend(o, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) o.compression = o.compression.toUpperCase();\n\n    return o;\n};\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, o) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n    o = prepareFileAttrs(o);\n\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n        o.dir = true;\n    }\n\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    if (o.dir || data === null || typeof data === \"undefined\") {\n        o.base64 = false;\n        o.binary = false;\n        data = null;\n        dataType = null;\n    }\n    else if (dataType === \"string\") {\n        if (o.binary && !o.base64) {\n            // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n            if (o.optimizedBinaryString !== true) {\n                // this is a string, not in a base64 format.\n                // Be sure that this is a correct \"binary string\"\n                data = utils.string2binary(data);\n            }\n        }\n    }\n    else { // arraybuffer, uint8array, ...\n        o.base64 = false;\n        o.binary = true;\n\n        if (!dataType && !(data instanceof CompressedObject)) {\n            throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n        }\n\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = utils.transformTo(\"uint8array\", data);\n        }\n    }\n\n    var object = new ZipObject(name, data, o);\n    this.files[name] = object;\n    return object;\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) == '/') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf('/');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n};\n\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) != \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    createFolders = (typeof createFolders !== 'undefined') ? createFolders : false;\n\n    name = forceTrailingSlash(name);\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n * Generate a JSZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {JSZip.compression} compression the compression to use.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {JSZip.CompressedObject} the compressed result.\n */\nvar generateCompressedObjectFrom = function(file, compression, compressionOptions) {\n    var result = new CompressedObject(),\n        content;\n\n    // the data has not been decompressed, we might reuse things !\n    if (file._data instanceof CompressedObject) {\n        result.uncompressedSize = file._data.uncompressedSize;\n        result.crc32 = file._data.crc32;\n\n        if (result.uncompressedSize === 0 || file.dir) {\n            compression = compressions['STORE'];\n            result.compressedContent = \"\";\n            result.crc32 = 0;\n        }\n        else if (file._data.compressionMethod === compression.magic) {\n            result.compressedContent = file._data.getCompressedContent();\n        }\n        else {\n            content = file._data.getContent();\n            // need to decompress / recompress\n            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n        }\n    }\n    else {\n        // have uncompressed data\n        content = getBinaryData(file);\n        if (!content || content.length === 0 || file.dir) {\n            compression = compressions['STORE'];\n            content = \"\";\n        }\n        result.uncompressedSize = content.length;\n        result.crc32 = crc32(content);\n        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n    }\n\n    result.compressedSize = result.compressedContent.length;\n    result.compressionMethod = compression.magic;\n\n    return result;\n};\n\n\n\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {JSZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {object} the zip parts.\n */\nvar generateZipParts = function(name, file, compressedObject, offset, platform, encodeFileName) {\n    var data = compressedObject.compressedContent,\n        useCustomEncoding = encodeFileName !== utf8.utf8encode,\n        encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n        utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n        comment = file.comment || \"\",\n        encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n        utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n        useUTF8ForComment = utfEncodedComment.length !== comment.length,\n        o = file.options,\n        dosTime,\n        dosDate,\n        extraFields = \"\",\n        unicodePathExtraField = \"\",\n        unicodeCommentExtraField = \"\",\n        dir, date;\n\n\n    // handle the deprecated options.dir\n    if (file._initialMetadata.dir !== file.dir) {\n        dir = file.dir;\n    } else {\n        dir = o.dir;\n    }\n\n    // handle the deprecated options.date\n    if(file._initialMetadata.date !== file.date) {\n        date = file.date;\n    } else {\n        date = o.date;\n    }\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getSeconds() / 2;\n\n    dosDate = date.getFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(encodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(this.crc32(encodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    // set bit 11 if utf8\n    header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? \"\\x00\\x08\" : \"\\x00\\x00\";\n    // compression method\n    header += compressedObject.compressionMethod;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(compressedObject.crc32, 4);\n    // compressed size\n    header += decToHex(compressedObject.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(compressedObject.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n    // version made by (00: DOS)\n    decToHex(versionMadeBy, 2) +\n    // file header (common to file and central directory)\n    header +\n    // file comment length\n    decToHex(encodedComment.length, 2) +\n    // disk number start\n    \"\\x00\\x00\" +\n    // internal file attributes TODO\n    \"\\x00\\x00\" +\n    // external file attributes\n    decToHex(extFileAttr, 4) +\n    // relative offset of local header\n    decToHex(offset, 4) +\n    // file name\n    encodedFileName +\n    // extra field\n    extraFields +\n    // file comment\n    encodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord,\n        compressedObject: compressedObject\n    };\n};\n\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * Read an existing zip and merge the data in the current JSZip object.\n     * The implementation is in jszip-load.js, don't forget to include it.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n     * @param {Object} options Options for loading the stream.\n     *  options.base64 : is the stream in base64 ? default : false\n     * @return {JSZip} the current JSZip object\n     */\n    load: function(stream, options) {\n        throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [],\n            filename, relativePath, file, fileClone;\n        for (filename in this.files) {\n            if (!this.files.hasOwnProperty(filename)) {\n                continue;\n            }\n            file = this.files[filename];\n            // return a new object, don't let the user mess with our internal objects :)\n            fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (filename.slice(0, this.root.length) === this.root && // the file is in the current root\n            search(relativePath, fileClone)) { // and the file matches the function\n                result.push(fileClone);\n            }\n        }\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (utils.isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && relativePath === name;\n                })[0] || null;\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (utils.isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) != \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - base64, (deprecated, use type instead) true to generate base64.\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        options = utils.extend(options || {}, {\n            base64: true,\n            compression: \"STORE\",\n            compressionOptions : null,\n            type: \"base64\",\n            platform: \"DOS\",\n            comment: null,\n            mimeType: 'application/zip',\n            encodeFileName: utf8.utf8encode\n        });\n\n        utils.checkSupport(options.type);\n\n        // accept nodejs `process.platform`\n        if(\n          options.platform === 'darwin' ||\n          options.platform === 'freebsd' ||\n          options.platform === 'linux' ||\n          options.platform === 'sunos'\n        ) {\n          options.platform = \"UNIX\";\n        }\n        if (options.platform === 'win32') {\n          options.platform = \"DOS\";\n        }\n\n        var zipData = [],\n            localDirLength = 0,\n            centralDirLength = 0,\n            writer, i,\n            encodedComment = utils.transformTo(\"string\", options.encodeFileName(options.comment || this.comment || \"\"));\n\n        // first, generate all the zip parts.\n        for (var name in this.files) {\n            if (!this.files.hasOwnProperty(name)) {\n                continue;\n            }\n            var file = this.files[name];\n\n            var compressionName = file.options.compression || options.compression.toUpperCase();\n            var compression = compressions[compressionName];\n            if (!compression) {\n                throw new Error(compressionName + \" is not a valid compression method !\");\n            }\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n\n            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);\n\n            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);\n            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n            centralDirLength += zipPart.dirRecord.length;\n            zipData.push(zipPart);\n        }\n\n        var dirEnd = \"\";\n\n        // end of central dir signature\n        dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(zipData.length, 2) +\n        // total number of entries in the central directory\n        decToHex(zipData.length, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(encodedComment.length, 2) +\n        // .ZIP file comment\n        encodedComment;\n\n\n        // we have all the parts (and the total length)\n        // time to create a writer !\n        var typeName = options.type.toLowerCase();\n        if(typeName===\"uint8array\"||typeName===\"arraybuffer\"||typeName===\"blob\"||typeName===\"nodebuffer\") {\n            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n        }else{\n            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n        }\n\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].fileRecord);\n            writer.append(zipData[i].compressedObject.compressedContent);\n        }\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].dirRecord);\n        }\n\n        writer.append(dirEnd);\n\n        var zip = writer.finalize();\n\n\n\n        switch(options.type.toLowerCase()) {\n            // case \"zip is an Uint8Array\"\n            case \"uint8array\" :\n            case \"arraybuffer\" :\n            case \"nodebuffer\" :\n               return utils.transformTo(options.type.toLowerCase(), zip);\n            case \"blob\" :\n               return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip), options.mimeType);\n            // case \"zip is a string\"\n            case \"base64\" :\n               return (options.base64) ? base64.encode(zip) : zip;\n            default : // case \"string\" :\n               return zip;\n         }\n\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    crc32: function (input, crc) {\n        return crc32(input, crc);\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8encode: function (string) {\n        return utils.transformTo(\"string\", utf8.utf8encode(string));\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8decode: function (input) {\n        return utf8.utf8decode(input);\n    }\n};\nmodule.exports = out;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/object.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/signature.js":
/*!*********************************************!*\
  !*** ./node_modules/jszip/lib/signature.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nexports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nexports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nexports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nexports.DATA_DESCRIPTOR = \"PK\\x07\\x08\";\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/signature.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/stringReader.js":
/*!************************************************!*\
  !*** ./node_modules/jszip/lib/stringReader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar DataReader = __webpack_require__(/*! ./dataReader */ \"./node_modules/jszip/lib/dataReader.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\n\nfunction StringReader(data, optimizedBinaryString) {\n    this.data = data;\n    if (!optimizedBinaryString) {\n        this.data = utils.string2binary(this.data);\n    }\n    this.length = this.data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nStringReader.prototype = new DataReader();\n/**\n * @see DataReader.byteAt\n */\nStringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nStringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readData\n */\nStringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the \"& 0xff\" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/stringReader.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/stringWriter.js":
/*!************************************************!*\
  !*** ./node_modules/jszip/lib/stringWriter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\n\n/**\n * An object to write any content to a string.\n * @constructor\n */\nvar StringWriter = function() {\n    this.data = [];\n};\nStringWriter.prototype = {\n    /**\n     * Append any content to the current string.\n     * @param {Object} input the content to add.\n     */\n    append: function(input) {\n        input = utils.transformTo(\"string\", input);\n        this.data.push(input);\n    },\n    /**\n     * Finalize the construction an return the result.\n     * @return {string} the generated string.\n     */\n    finalize: function() {\n        return this.data.join(\"\");\n    }\n};\n\nmodule.exports = StringWriter;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/stringWriter.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/support.js":
/*!*******************************************!*\
  !*** ./node_modules/jszip/lib/support.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\n// contains true if JSZip can read/generate nodejs Buffer, false otherwise.\n// Browserify will provide a Buffer implementation for browsers, which is\n// an augmented Uint8Array (i.e., can be used as either Buffer or U8).\nexports.nodebuffer = typeof Buffer !== \"undefined\";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== \"undefined\";\n\nif (typeof ArrayBuffer === \"undefined\") {\n    exports.blob = false;\n}\nelse {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([buffer], {\n            type: \"application/zip\"\n        }).size === 0;\n    }\n    catch (e) {\n        try {\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob('application/zip').size === 0;\n        }\n        catch (e) {\n            exports.blob = false;\n        }\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/support.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/uint8ArrayReader.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/uint8ArrayReader.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ArrayReader = __webpack_require__(/*! ./arrayReader */ \"./node_modules/jszip/lib/arrayReader.js\");\n\nfunction Uint8ArrayReader(data) {\n    if (data) {\n        this.data = data;\n        this.length = this.data.length;\n        this.index = 0;\n        this.zero = 0;\n    }\n}\nUint8ArrayReader.prototype = new ArrayReader();\n/**\n * @see DataReader.readData\n */\nUint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/uint8ArrayReader.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/uint8ArrayWriter.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/uint8ArrayWriter.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\n\n/**\n * An object to write any content to an Uint8Array.\n * @constructor\n * @param {number} length The length of the array.\n */\nvar Uint8ArrayWriter = function(length) {\n    this.data = new Uint8Array(length);\n    this.index = 0;\n};\nUint8ArrayWriter.prototype = {\n    /**\n     * Append any content to the current array.\n     * @param {Object} input the content to add.\n     */\n    append: function(input) {\n        if (input.length !== 0) {\n            // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n            input = utils.transformTo(\"uint8array\", input);\n            this.data.set(input, this.index);\n            this.index += input.length;\n        }\n    },\n    /**\n     * Finalize the construction an return the result.\n     * @return {Uint8Array} the generated array.\n     */\n    finalize: function() {\n        return this.data;\n    }\n};\n\nmodule.exports = Uint8ArrayWriter;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/uint8ArrayWriter.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/utf8.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/utf8.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"./node_modules/jszip/lib/support.js\");\nvar nodeBuffer = __webpack_require__(/*! ./nodeBuffer */ \"./node_modules/jszip/lib/nodeBuffer.js\");\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodeBuffer(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    // return buf2string(buf);\n    // Chrome prefers to work with \"small\" chunks of data\n    // for the method buf2string.\n    // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.\n    var result = [], k = 0, len = buf.length, chunk = 65536;\n    while (k < len) {\n        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n        if (support.uint8array) {\n            result.push(buf2string(buf.subarray(k, nextBoundary)));\n        } else {\n            result.push(buf2string(buf.slice(k, nextBoundary)));\n        }\n        k = nextBoundary;\n    }\n    return result.join(\"\");\n\n};\n// vim: set shiftwidth=4 softtabstop=4:\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/utf8.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar support = __webpack_require__(/*! ./support */ \"./node_modules/jszip/lib/support.js\");\nvar compressions = __webpack_require__(/*! ./compressions */ \"./node_modules/jszip/lib/compressions.js\");\nvar nodeBuffer = __webpack_require__(/*! ./nodeBuffer */ \"./node_modules/jszip/lib/nodeBuffer.js\");\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\nexports.string2binary = function(str) {\n    var result = \"\";\n    for (var i = 0; i < str.length; i++) {\n        result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n    }\n    return result;\n};\nexports.arrayBuffer2Blob = function(buffer, mimeType) {\n    exports.checkSupport(\"blob\");\n\tmimeType = mimeType || 'application/zip';\n\n    try {\n        // Blob constructor\n        return new Blob([buffer], {\n            type: mimeType\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            return builder.getBlob(mimeType);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    var chunk = 65536;\n    var result = [],\n        len = array.length,\n        type = exports.getTypeOf(array),\n        k = 0,\n        canUseApply = true;\n      try {\n         switch(type) {\n            case \"uint8array\":\n               String.fromCharCode.apply(null, new Uint8Array(0));\n               break;\n            case \"nodebuffer\":\n               String.fromCharCode.apply(null, nodeBuffer(0));\n               break;\n         }\n      } catch(e) {\n         canUseApply = false;\n      }\n\n      // no apply : slow and painful algorithm\n      // default browser on android 4.*\n      if (!canUseApply) {\n         var resultStr = \"\";\n         for(var i = 0; i < array.length;i++) {\n            resultStr += String.fromCharCode(array[i]);\n         }\n    return resultStr;\n    }\n    while (k < len && chunk > 1) {\n        try {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        catch (e) {\n            chunk = Math.floor(chunk / 2);\n        }\n    }\n    return result.join(\"\");\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodeBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodeBuffer.test(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this browser\");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nexports.findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nexports.isRegExp = function (object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/utils.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/zipEntries.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntries.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar StringReader = __webpack_require__(/*! ./stringReader */ \"./node_modules/jszip/lib/stringReader.js\");\nvar NodeBufferReader = __webpack_require__(/*! ./nodeBufferReader */ \"./node_modules/jszip/lib/nodeBufferReader.js\");\nvar Uint8ArrayReader = __webpack_require__(/*! ./uint8ArrayReader */ \"./node_modules/jszip/lib/uint8ArrayReader.js\");\nvar ArrayReader = __webpack_require__(/*! ./arrayReader */ \"./node_modules/jszip/lib/arrayReader.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\nvar sig = __webpack_require__(/*! ./signature */ \"./node_modules/jszip/lib/signature.js\");\nvar ZipEntry = __webpack_require__(/*! ./zipEntry */ \"./node_modules/jszip/lib/zipEntry.js\");\nvar support = __webpack_require__(/*! ./support */ \"./node_modules/jszip/lib/support.js\");\nvar jszipProto = __webpack_require__(/*! ./object */ \"./node_modules/jszip/lib/object.js\");\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {String|ArrayBuffer|Uint8Array} data the binary stream to load.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntries(data, loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n    if (data) {\n        this.load(data);\n    }\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the speficied signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */\n    checkSignature: function(expectedSignature) {\n        var signature = this.reader.readString(4);\n        if (signature !== expectedSignature) {\n            throw new Error(\"Corrupted zip or bug : unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */\n    isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */\n    readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don't want to read the wrong number of bytes !\n     */\n    readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.versionMadeBy = this.reader.readString(2);\n        this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44,\n            index = 0,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n        while (index < extraDataSize) {\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readString(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */\n    readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error(\"Multi-volumes zip are not supported\");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */\n    readLocalFiles: function() {\n        var i, file;\n        for (i = 0; i < this.files.length; i++) {\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */\n    readCentralDir: function() {\n        var file;\n\n        this.reader.setIndex(this.centralDirOffset);\n        while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn't find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n            } else {\n                // We found some records but not all.\n                // Something is wrong but we got something for the user: no error here.\n                // console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */\n    readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n\n            if (isGarbage) {\n                throw new Error(\"Can't find end of central directory : is this a zip file ? \" +\n                                \"If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n            } else {\n                throw new Error(\"Corrupted zip : can't find end of central directory\");\n            }\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n\n\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */\n        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */\n\n            // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error(\"Corrupted zip : can't find the ZIP64 end of central directory locator\");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn(\"ZIP64 end of central directory not where expected.\");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error(\"Corrupted zip : can't find the ZIP64 end of central directory\");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;\n        }\n\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n                // The offsets seem wrong, but we have something at the specified offset.\n                // So… we keep it.\n            } else {\n                // the offset is wrong, update the \"zero\" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n        }\n    },\n    prepareReader: function(data) {\n        var type = utils.getTypeOf(data);\n        utils.checkSupport(type);\n        if (type === \"string\" && !support.uint8array) {\n            this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);\n        }\n        else if (type === \"nodebuffer\") {\n            this.reader = new NodeBufferReader(data);\n        }\n        else if (support.uint8array) {\n            this.reader = new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n        } else if (support.array) {\n            this.reader = new ArrayReader(utils.transformTo(\"array\", data));\n        } else {\n            throw new Error(\"Unexpected error: unsupported type '\" + type + \"'\");\n        }\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */\n    load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/zipEntries.js?");

/***/ }),

/***/ "./node_modules/jszip/lib/zipEntry.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar StringReader = __webpack_require__(/*! ./stringReader */ \"./node_modules/jszip/lib/stringReader.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/jszip/lib/utils.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"./node_modules/jszip/lib/compressedObject.js\");\nvar jszipProto = __webpack_require__(/*! ./object */ \"./node_modules/jszip/lib/object.js\");\nvar support = __webpack_require__(/*! ./support */ \"./node_modules/jszip/lib/support.js\");\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */\n    isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */\n    useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Prepare the function used to generate the compressed content from this ZipFile.\n     * @param {DataReader} reader the reader to use.\n     * @param {number} from the offset from where we should read the data.\n     * @param {number} length the length of the data to read.\n     * @return {Function} the callback to get the compressed content (the type depends of the DataReader class).\n     */\n    prepareCompressedContent: function(reader, from, length) {\n        return function() {\n            var previousIndex = reader.index;\n            reader.setIndex(from);\n            var compressedFileData = reader.readData(length);\n            reader.setIndex(previousIndex);\n\n            return compressedFileData;\n        };\n    },\n    /**\n     * Prepare the function used to generate the uncompressed content from this ZipFile.\n     * @param {DataReader} reader the reader to use.\n     * @param {number} from the offset from where we should read the data.\n     * @param {number} length the length of the data to read.\n     * @param {JSZip.compression} compression the compression used on this file.\n     * @param {number} uncompressedSize the uncompressed size to expect.\n     * @return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).\n     */\n    prepareContent: function(reader, from, length, compression, uncompressedSize) {\n        return function() {\n\n            var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());\n            var uncompressedFileData = compression.uncompress(compressedFileData);\n\n            if (uncompressedFileData.length !== uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n\n            return uncompressedFileData;\n        };\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n\n        if (this.compressedSize == -1 || this.uncompressedSize == -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory \" + \"(compressedSize == -1 || uncompressedSize == -1)\");\n        }\n\n        compression = utils.findCompression(this.compressionMethod);\n        if (compression === null) { // no compression found\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" +  utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject();\n        this.decompressed.compressedSize = this.compressedSize;\n        this.decompressed.uncompressedSize = this.uncompressedSize;\n        this.decompressed.crc32 = this.crc32;\n        this.decompressed.compressionMethod = this.compressionMethod;\n        this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);\n        this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);\n\n        // we need to compute the crc32...\n        if (this.loadOptions.checkCRC32) {\n            this.decompressed = utils.transformTo(\"string\", this.decompressed.getContent());\n            if (jszipProto.crc32(this.decompressed) !== this.crc32) {\n                throw new Error(\"Corrupted zip : CRC32 mismatch\");\n            }\n        }\n    },\n\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        this.fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n\n        this.fileName = reader.readData(this.fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */\n    processAttributes: function () {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n        if(madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n\n        if(madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;\n            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n            this.dir = true;\n        }\n    },\n\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */\n    parseZIP64ExtraField: function(reader) {\n\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n\n        // should be something, preparing the extra reader\n        var extraReader = new StringReader(this.extraFields[0x0001].value);\n\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readExtraFields: function(reader) {\n        var start = reader.index,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n\n        this.extraFields = this.extraFields || {};\n\n        while (reader.index < start + this.extraFieldsLength) {\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readString(extraFieldLength);\n\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */\n    handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = jszipProto.utf8decode(this.fileName);\n            this.fileCommentStr = jszipProto.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */\n    findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = new StringReader(upathField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the filename changed, this field is out of date.\n            if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));\n        }\n        return null;\n    },\n\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */\n    findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = new StringReader(ucommentField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the comment changed, this field is out of date.\n            if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n\n\n//# sourceURL=webpack:///./node_modules/jszip/lib/zipEntry.js?");

/***/ }),

/***/ "./node_modules/lie/lib/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/lie/lib/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar immediate = __webpack_require__(/*! immediate */ \"./node_modules/immediate/lib/browser.js\");\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"finally\"] = function (callback) {\n  if (typeof callback !== 'function') {\n    return this;\n  }\n  var p = this.constructor;\n  return this.then(resolve, reject);\n\n  function resolve(value) {\n    function yes () {\n      return value;\n    }\n    return p.resolve(callback()).then(yes);\n  }\n  function reject(reason) {\n    function no () {\n      throw reason;\n    }\n    return p.resolve(callback()).then(no);\n  }\n};\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/lie/lib/browser.js?");

/***/ }),

/***/ "./node_modules/lru-cache/lib/lru-cache.js":
/*!*************************************************!*\
  !*** ./node_modules/lru-cache/lib/lru-cache.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function () { // closure for web browsers\n\nif ( true && module.exports) {\n  module.exports = LRUCache\n} else {\n  // just set the global for non-node platforms.\n  this.LRUCache = LRUCache\n}\n\nfunction hOP (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nfunction naiveLength () { return 1 }\n\nvar didTypeWarning = false\nfunction typeCheckKey(key) {\n  if (!didTypeWarning && typeof key !== 'string' && typeof key !== 'number') {\n    didTypeWarning = true\n    console.error(new TypeError(\"LRU: key must be a string or number. Almost certainly a bug! \" + typeof key).stack)\n  }\n}\n\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache))\n    return new LRUCache(options)\n\n  if (typeof options === 'number')\n    options = { max: options }\n\n  if (!options)\n    options = {}\n\n  this._max = options.max\n  // Kind of weird to have a default max of Infinity, but oh well.\n  if (!this._max || !(typeof this._max === \"number\") || this._max <= 0 )\n    this._max = Infinity\n\n  this._lengthCalculator = options.length || naiveLength\n  if (typeof this._lengthCalculator !== \"function\")\n    this._lengthCalculator = naiveLength\n\n  this._allowStale = options.stale || false\n  this._maxAge = options.maxAge || null\n  this._dispose = options.dispose\n  this.reset()\n}\n\n// resize the cache when the max changes.\nObject.defineProperty(LRUCache.prototype, \"max\",\n  { set : function (mL) {\n      if (!mL || !(typeof mL === \"number\") || mL <= 0 ) mL = Infinity\n      this._max = mL\n      if (this._length > this._max) trim(this)\n    }\n  , get : function () { return this._max }\n  , enumerable : true\n  })\n\n// resize the cache when the lengthCalculator changes.\nObject.defineProperty(LRUCache.prototype, \"lengthCalculator\",\n  { set : function (lC) {\n      if (typeof lC !== \"function\") {\n        this._lengthCalculator = naiveLength\n        this._length = this._itemCount\n        for (var key in this._cache) {\n          this._cache[key].length = 1\n        }\n      } else {\n        this._lengthCalculator = lC\n        this._length = 0\n        for (var key in this._cache) {\n          this._cache[key].length = this._lengthCalculator(this._cache[key].value)\n          this._length += this._cache[key].length\n        }\n      }\n\n      if (this._length > this._max) trim(this)\n    }\n  , get : function () { return this._lengthCalculator }\n  , enumerable : true\n  })\n\nObject.defineProperty(LRUCache.prototype, \"length\",\n  { get : function () { return this._length }\n  , enumerable : true\n  })\n\n\nObject.defineProperty(LRUCache.prototype, \"itemCount\",\n  { get : function () { return this._itemCount }\n  , enumerable : true\n  })\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  var i = 0\n  var itemCount = this._itemCount\n\n  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {\n    i++\n    var hit = this._lruList[k]\n    if (isStale(this, hit)) {\n      del(this, hit)\n      if (!this._allowStale) hit = undefined\n    }\n    if (hit) {\n      fn.call(thisp, hit.value, hit.key, this)\n    }\n  }\n}\n\nLRUCache.prototype.keys = function () {\n  var keys = new Array(this._itemCount)\n  var i = 0\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    keys[i++] = hit.key\n  }\n  return keys\n}\n\nLRUCache.prototype.values = function () {\n  var values = new Array(this._itemCount)\n  var i = 0\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    values[i++] = hit.value\n  }\n  return values\n}\n\nLRUCache.prototype.reset = function () {\n  if (this._dispose && this._cache) {\n    for (var k in this._cache) {\n      this._dispose(k, this._cache[k].value)\n    }\n  }\n\n  this._cache = Object.create(null) // hash of items by key\n  this._lruList = Object.create(null) // list of items in order of use recency\n  this._mru = 0 // most recently used\n  this._lru = 0 // least recently used\n  this._length = 0 // number of items in the list\n  this._itemCount = 0\n}\n\nLRUCache.prototype.dump = function () {\n  var arr = []\n  var i = 0\n\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    if (!isStale(this, hit)) {\n      //Do not store staled hits\n      ++i\n      arr.push({\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      });\n    }\n  }\n  //arr has the most read first\n  return arr\n}\n\nLRUCache.prototype.dumpLru = function () {\n  return this._lruList\n}\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this._maxAge\n  typeCheckKey(key)\n\n  var now = maxAge ? Date.now() : 0\n  var len = this._lengthCalculator(value)\n\n  if (hOP(this._cache, key)) {\n    if (len > this._max) {\n      del(this, this._cache[key])\n      return false\n    }\n    // dispose of the old one before overwriting\n    if (this._dispose)\n      this._dispose(key, this._cache[key].value)\n\n    this._cache[key].now = now\n    this._cache[key].maxAge = maxAge\n    this._cache[key].value = value\n    this._length += (len - this._cache[key].length)\n    this._cache[key].length = len\n    this.get(key)\n\n    if (this._length > this._max)\n      trim(this)\n\n    return true\n  }\n\n  var hit = new Entry(key, value, this._mru++, len, now, maxAge)\n\n  // oversized objects fall out of cache automatically.\n  if (hit.length > this._max) {\n    if (this._dispose) this._dispose(key, value)\n    return false\n  }\n\n  this._length += hit.length\n  this._lruList[hit.lu] = this._cache[key] = hit\n  this._itemCount ++\n\n  if (this._length > this._max)\n    trim(this)\n\n  return true\n}\n\nLRUCache.prototype.has = function (key) {\n  typeCheckKey(key)\n  if (!hOP(this._cache, key)) return false\n  var hit = this._cache[key]\n  if (isStale(this, hit)) {\n    return false\n  }\n  return true\n}\n\nLRUCache.prototype.get = function (key) {\n  typeCheckKey(key)\n  return get(this, key, true)\n}\n\nLRUCache.prototype.peek = function (key) {\n  typeCheckKey(key)\n  return get(this, key, false)\n}\n\nLRUCache.prototype.pop = function () {\n  var hit = this._lruList[this._lru]\n  del(this, hit)\n  return hit || null\n}\n\nLRUCache.prototype.del = function (key) {\n  typeCheckKey(key)\n  del(this, this._cache[key])\n}\n\nLRUCache.prototype.load = function (arr) {\n  //reset the cache\n  this.reset();\n\n  var now = Date.now()\n  //A previous serialized cache has the most recent items first\n  for (var l = arr.length - 1; l >= 0; l-- ) {\n    var hit = arr[l]\n    typeCheckKey(hit.k)\n    var expiresAt = hit.e || 0\n    if (expiresAt === 0) {\n      //the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v)\n    } else {\n      var maxAge = expiresAt - now\n      //dont add already expired items\n      if (maxAge > 0) this.set(hit.k, hit.v, maxAge)\n    }\n  }\n}\n\nfunction get (self, key, doUse) {\n  typeCheckKey(key)\n  var hit = self._cache[key]\n  if (hit) {\n    if (isStale(self, hit)) {\n      del(self, hit)\n      if (!self._allowStale) hit = undefined\n    } else {\n      if (doUse) use(self, hit)\n    }\n    if (hit) hit = hit.value\n  }\n  return hit\n}\n\nfunction isStale(self, hit) {\n  if (!hit || (!hit.maxAge && !self._maxAge)) return false\n  var stale = false;\n  var diff = Date.now() - hit.now\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge\n  } else {\n    stale = self._maxAge && (diff > self._maxAge)\n  }\n  return stale;\n}\n\nfunction use (self, hit) {\n  shiftLU(self, hit)\n  hit.lu = self._mru ++\n  self._lruList[hit.lu] = hit\n}\n\nfunction trim (self) {\n  while (self._lru < self._mru && self._length > self._max)\n    del(self, self._lruList[self._lru])\n}\n\nfunction shiftLU (self, hit) {\n  delete self._lruList[ hit.lu ]\n  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++\n}\n\nfunction del (self, hit) {\n  if (hit) {\n    if (self._dispose) self._dispose(hit.key, hit.value)\n    self._length -= hit.length\n    self._itemCount --\n    delete self._cache[ hit.key ]\n    shiftLU(self, hit)\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, lu, length, now, maxAge) {\n  this.key = key\n  this.value = value\n  this.lu = lu\n  this.length = length\n  this.now = now\n  if (maxAge) this.maxAge = maxAge\n}\n\n})()\n\n\n//# sourceURL=webpack:///./node_modules/lru-cache/lib/lru-cache.js?");

/***/ }),

/***/ "./node_modules/mgrs/mgrs.js":
/*!***********************************!*\
  !*** ./node_modules/mgrs/mgrs.js ***!
  \***********************************/
/*! exports provided: default, forward, inverse, toPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toPoint\", function() { return toPoint; });\n\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\nvar A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar V = 86; // V\nvar Z = 90; // Z\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  forward: forward,\n  inverse: inverse,\n  toPoint: toPoint\n});\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nfunction forward(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nfunction inverse(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nfunction toPoint(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg.\"60N\" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn't exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < 'N') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = 'Z';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = 'X';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = 'W';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = 'V';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = 'U';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = 'T';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = 'S';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = 'R';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = 'Q';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = 'P';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = 'N';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = 'M';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = 'L';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = 'K';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = 'J';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = 'H';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = 'G';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = 'F';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = 'E';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = 'D';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = 'C';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = \"00000\" + utm.easting,\n    snorthing = \"00000\" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw (\"MGRSPoint coverting from nothing\");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100´k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > Z) {\n      if (rewindMarker) {\n        throw (\"Bad character: \" + e);\n      }\n      curCol = A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > 'V') {\n    throw (\"MGRSPoint given invalid Northing \" + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when 'n' is a wrong character\n    if (curRow > V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw (\"Bad character: \" + n);\n      }\n      curRow = A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case 'C':\n    northing = 1100000.0;\n    break;\n  case 'D':\n    northing = 2000000.0;\n    break;\n  case 'E':\n    northing = 2800000.0;\n    break;\n  case 'F':\n    northing = 3700000.0;\n    break;\n  case 'G':\n    northing = 4600000.0;\n    break;\n  case 'H':\n    northing = 5500000.0;\n    break;\n  case 'J':\n    northing = 6400000.0;\n    break;\n  case 'K':\n    northing = 7300000.0;\n    break;\n  case 'L':\n    northing = 8200000.0;\n    break;\n  case 'M':\n    northing = 9100000.0;\n    break;\n  case 'N':\n    northing = 0.0;\n    break;\n  case 'P':\n    northing = 800000.0;\n    break;\n  case 'Q':\n    northing = 1700000.0;\n    break;\n  case 'R':\n    northing = 2600000.0;\n    break;\n  case 'S':\n    northing = 3500000.0;\n    break;\n  case 'T':\n    northing = 4400000.0;\n    break;\n  case 'U':\n    northing = 5300000.0;\n    break;\n  case 'V':\n    northing = 6200000.0;\n    break;\n  case 'W':\n    northing = 7000000.0;\n    break;\n  case 'X':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw (\"Invalid zone letter: \" + zoneLetter);\n  }\n\n}\n\n\n//# sourceURL=webpack:///./node_modules/mgrs/mgrs.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/node-libs-browser/node_modules/string_decoder/node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/string_decoder/node_modules/safe-buffer/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/string_decoder/node_modules/safe-buffer/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/string_decoder/node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Top level file is just a mixin of submodules & constants\n\n\nvar assign    = __webpack_require__(/*! ./lib/utils/common */ \"./node_modules/pako/lib/utils/common.js\").assign;\n\nvar deflate   = __webpack_require__(/*! ./lib/deflate */ \"./node_modules/pako/lib/deflate.js\");\nvar inflate   = __webpack_require__(/*! ./lib/inflate */ \"./node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n\n//# sourceURL=webpack:///./node_modules/pako/index.js?");

/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"./node_modules/pako/lib/zlib/deflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/deflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"./node_modules/pako/lib/zlib/inflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\nvar c            = __webpack_require__(/*! ./zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader     = __webpack_require__(/*! ./zlib/gzheader */ \"./node_modules/pako/lib/zlib/gzheader.js\");\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/inflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/utils/common.js?");

/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// String encode/decode helpers\n\n\n\nvar utils = __webpack_require__(/*! ./common */ \"./node_modules/pako/lib/utils/common.js\");\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/utils/strings.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/adler32.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/constants.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/crc32.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar trees   = __webpack_require__(/*! ./trees */ \"./node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\nvar crc32   = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\nvar msg     = __webpack_require__(/*! ./messages */ \"./node_modules/pako/lib/zlib/messages.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/deflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/gzheader.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/inffast.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar adler32       = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\nvar crc32         = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast  = __webpack_require__(/*! ./inffast */ \"./node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"./node_modules/pako/lib/zlib/inftrees.js\");\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/inflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/inftrees.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/messages.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/trees.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/zstream.js?");

/***/ }),

/***/ "./node_modules/parsedbf/decoder-browser.js":
/*!**************************************************!*\
  !*** ./node_modules/parsedbf/decoder-browser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! text-encoding-polyfill */ \"./node_modules/text-encoding-polyfill/index.js\");\nvar StringDecoder = __webpack_require__(/*! string_decoder */ \"./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\nfunction defaultDecoder(data) {\n  var decoder = new StringDecoder();\n  var out = decoder.write(data) + decoder.end();\n  return out.replace(/\\0/g, '').trim();\n}\nmodule.exports = createDecoder;\nvar regex = /^(?:ASNI\\s)?(\\d+)$/m;\nfunction createDecoder(encoding) {\n  if (!encoding) {\n    return defaultDecoder;\n  }\n  try {\n    new TextDecoder(encoding.trim());\n  } catch(e) {\n    var match = regex.exec(encoding);\n    if (match) {\n      encoding = 'windows-' + match[1];\n    }\n  }\n  return browserDecoder;\n  function browserDecoder(buffer) {\n    var decoder = new TextDecoder(encoding);\n    var out = decoder.decode(buffer, {\n      stream: true\n    }) + decoder.decode();\n    return out.replace(/\\0/g, '').trim();\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/parsedbf/decoder-browser.js?");

/***/ }),

/***/ "./node_modules/parsedbf/index.js":
/*!****************************************!*\
  !*** ./node_modules/parsedbf/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var createDecoder = __webpack_require__(/*! ./decoder */ \"./node_modules/parsedbf/decoder-browser.js\");\nfunction dbfHeader(data) {\n  var out = {};\n  out.lastUpdated = new Date(data.readUInt8(1) + 1900, data.readUInt8(2), data.readUInt8(3));\n  out.records = data.readUInt32LE(4);\n  out.headerLen = data.readUInt16LE(8);\n  out.recLen = data.readUInt16LE(10);\n  return out;\n}\n\nfunction dbfRowHeader(data, headerLen, decoder) {\n  var out = [];\n  var offset = 32;\n  while (offset < headerLen) {\n    out.push({\n      name: decoder(data.slice(offset, offset + 11)),\n      dataType: String.fromCharCode(data.readUInt8(offset + 11)),\n      len: data.readUInt8(offset + 16),\n      decimal: data.readUInt8(offset + 17)\n    });\n    if (data.readUInt8(offset + 32) === 13) {\n      break;\n    } else {\n      offset += 32;\n    }\n  }\n  return out;\n}\n\nfunction rowFuncs(buffer, offset, len, type, decoder) {\n  var data = buffer.slice(offset, offset + len);\n  var textData = decoder(data);\n  switch (type) {\n    case 'N':\n    case 'F':\n    case 'O':\n      return parseFloat(textData, 10);\n    case 'D':\n      return new Date(textData.slice(0, 4), parseInt(textData.slice(4, 6), 10) - 1, textData.slice(6, 8));\n    case 'L':\n      return textData.toLowerCase() === 'y' || textData.toLowerCase() === 't';\n    default:\n      return textData;\n  }\n}\n\nfunction parseRow(buffer, offset, rowHeaders, decoder) {\n  var out = {};\n  var i = 0;\n  var len = rowHeaders.length;\n  var field;\n  var header;\n  while (i < len) {\n    header = rowHeaders[i];\n    field = rowFuncs(buffer, offset, header.len, header.dataType, decoder);\n    offset += header.len;\n    if (typeof field !== 'undefined') {\n      out[header.name] = field;\n    }\n    i++;\n  }\n  return out;\n}\n\nmodule.exports = function(buffer, encoding) {\n  var decoder = createDecoder(encoding);\n  var header = dbfHeader(buffer);\n  var rowHeaders = dbfRowHeader(buffer, header.headerLen - 1, decoder);\n\n  var offset = ((rowHeaders.length + 1) << 5) + 2;\n  var recLen = header.recLen;\n  var records = header.records;\n  var out = [];\n  while (records) {\n    out.push(parseRow(buffer, offset, rowHeaders, decoder));\n    offset += recLen;\n    records--;\n  }\n  return out;\n};\n\n\n//# sourceURL=webpack:///./node_modules/parsedbf/index.js?");

/***/ }),

/***/ "./node_modules/pbf/index.js":
/*!***********************************!*\
  !*** ./node_modules/pbf/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = Pbf;\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\n\nfunction Pbf(buf) {\n    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n    this.pos = 0;\n    this.type = 0;\n    this.length = this.buf.length;\n}\n\nPbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nPbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\nPbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nPbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\n// Threshold chosen based on both benchmarking and knowledge about browser string\n// data structures (which currently switch structure types at 12 bytes or more)\nvar TEXT_DECODER_MIN_LENGTH = 12;\nvar utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');\n\nPbf.prototype = {\n\n    destroy: function() {\n        this.buf = null;\n    },\n\n    // === READING =================================================================\n\n    readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n            var val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    },\n\n    readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    },\n\n    readFixed32: function() {\n        var val = readUInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readSFixed32: function() {\n        var val = readInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readSFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readFloat: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n        this.pos += 4;\n        return val;\n    },\n\n    readDouble: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n        this.pos += 8;\n        return val;\n    },\n\n    readVarint: function(isSigned) {\n        var buf = this.buf,\n            val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    },\n\n    readVarint64: function() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    },\n\n    readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    },\n\n    readBoolean: function() {\n        return Boolean(this.readVarint());\n    },\n\n    readString: function() {\n        var end = this.readVarint() + this.pos;\n        var pos = this.pos;\n        this.pos = end;\n\n        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {\n            // longer strings are fast with the built-in browser TextDecoder API\n            return readUtf8TextDecoder(this.buf, pos, end);\n        }\n        // short strings are fast with our custom implementation\n        return readUtf8(this.buf, pos, end);\n    },\n\n    readBytes: function() {\n        var end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    },\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    readPackedVarint: function(arr, isSigned) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    },\n    readPackedSVarint: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    },\n    readPackedBoolean: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    },\n    readPackedFloat: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    },\n    readPackedDouble: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    },\n    readPackedFixed32: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    },\n    readPackedSFixed32: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    },\n    readPackedFixed64: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    },\n    readPackedSFixed64: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    },\n\n    skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n    },\n\n    // === WRITING =================================================================\n\n    writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    },\n\n    realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            var buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.length = length;\n        }\n    },\n\n    finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    },\n\n    writeFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeSFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeSFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeVarint: function(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    },\n\n    writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    },\n\n    writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n    },\n\n    writeString: function(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        var startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeFloat: function(val) {\n        this.realloc(4);\n        ieee754.write(this.buf, val, this.pos, true, 23, 4);\n        this.pos += 4;\n    },\n\n    writeDouble: function(val) {\n        this.realloc(8);\n        ieee754.write(this.buf, val, this.pos, true, 52, 8);\n        this.pos += 8;\n    },\n\n    writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    },\n\n    writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n    },\n\n    writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },\n    writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },\n    writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },\n    writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },\n    writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },\n    writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },\n    writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },\n    writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },\n    writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },\n\n    writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n    },\n    writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n    },\n    writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n    },\n    writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n    },\n    writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n    },\n    writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n    },\n    writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n    },\n    writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n    },\n    writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n    },\n    writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n    },\n    writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n    }\n};\n\nfunction readVarintRemainder(l, s, p) {\n    var buf = p.buf,\n        h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\nfunction readPackedEnd(pbf) {\n    return pbf.type === Pbf.Bytes ?\n        pbf.readVarint() + pbf.pos : pbf.pos + 1;\n}\n\nfunction toNum(low, high, isSigned) {\n    if (isSigned) {\n        return high * 0x100000000 + (low >>> 0);\n    }\n\n    return ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\nfunction writeBigVarint(val, pbf) {\n    var low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\nfunction writeBigVarintHigh(high, pbf) {\n    var lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    var extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\nfunction writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\nfunction writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\nfunction writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\nfunction writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\nfunction writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\nfunction writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\nfunction writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\nfunction writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\nfunction writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\nfunction readUInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] * 0x1000000);\n}\n\nfunction writeInt32(buf, val, pos) {\n    buf[pos] = val;\n    buf[pos + 1] = (val >>> 8);\n    buf[pos + 2] = (val >>> 16);\n    buf[pos + 3] = (val >>> 24);\n}\n\nfunction readInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] << 24);\n}\n\nfunction readUtf8(buf, pos, end) {\n    var str = '';\n    var i = pos;\n\n    while (i < end) {\n        var b0 = buf[i];\n        var c = null; // codepoint\n        var bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        var b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\nfunction readUtf8TextDecoder(buf, pos, end) {\n    return utf8TextDecoder.decode(buf.subarray(pos, end));\n}\n\nfunction writeUtf8(buf, str, pos) {\n    for (var i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n\n\n//# sourceURL=webpack:///./node_modules/pbf/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/Point.js":
/*!*****************************************!*\
  !*** ./node_modules/proj4/lib/Point.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var mgrs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mgrs */ \"./node_modules/mgrs/mgrs.js\");\n\n\nfunction Point(x, y, z) {\n  if (!(this instanceof Point)) {\n    return new Point(x, y, z);\n  }\n  if (Array.isArray(x)) {\n    this.x = x[0];\n    this.y = x[1];\n    this.z = x[2] || 0.0;\n  } else if(typeof x === 'object') {\n    this.x = x.x;\n    this.y = x.y;\n    this.z = x.z || 0.0;\n  } else if (typeof x === 'string' && typeof y === 'undefined') {\n    var coords = x.split(',');\n    this.x = parseFloat(coords[0], 10);\n    this.y = parseFloat(coords[1], 10);\n    this.z = parseFloat(coords[2], 10) || 0.0;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z || 0.0;\n  }\n  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');\n}\n\nPoint.fromMGRS = function(mgrsStr) {\n  return new Point(Object(mgrs__WEBPACK_IMPORTED_MODULE_0__[\"toPoint\"])(mgrsStr));\n};\nPoint.prototype.toMGRS = function(accuracy) {\n  return Object(mgrs__WEBPACK_IMPORTED_MODULE_0__[\"forward\"])([this.x, this.y], accuracy);\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Point);\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/Point.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/Proj.js":
/*!****************************************!*\
  !*** ./node_modules/proj4/lib/Proj.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parseCode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseCode */ \"./node_modules/proj4/lib/parseCode.js\");\n/* harmony import */ var _extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extend */ \"./node_modules/proj4/lib/extend.js\");\n/* harmony import */ var _projections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projections */ \"./node_modules/proj4/lib/projections.js\");\n/* harmony import */ var _deriveConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./deriveConstants */ \"./node_modules/proj4/lib/deriveConstants.js\");\n/* harmony import */ var _constants_Datum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants/Datum */ \"./node_modules/proj4/lib/constants/Datum.js\");\n/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./datum */ \"./node_modules/proj4/lib/datum.js\");\n/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./match */ \"./node_modules/proj4/lib/match.js\");\n\n\n\n\n\n\n\n\nfunction Projection(srsCode,callback) {\n  if (!(this instanceof Projection)) {\n    return new Projection(srsCode);\n  }\n  callback = callback || function(error){\n    if(error){\n      throw error;\n    }\n  };\n  var json = Object(_parseCode__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(srsCode);\n  if(typeof json !== 'object'){\n    callback(srsCode);\n    return;\n  }\n  var ourProj = Projection.projections.get(json.projName);\n  if(!ourProj){\n    callback(srsCode);\n    return;\n  }\n  if (json.datumCode && json.datumCode !== 'none') {\n    var datumDef = Object(_match__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(_constants_Datum__WEBPACK_IMPORTED_MODULE_4__[\"default\"], json.datumCode);\n    if (datumDef) {\n      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  json.k0 = json.k0 || 1.0;\n  json.axis = json.axis || 'enu';\n  json.ellps = json.ellps || 'wgs84';\n  var sphere_ = Object(_deriveConstants__WEBPACK_IMPORTED_MODULE_3__[\"sphere\"])(json.a, json.b, json.rf, json.ellps, json.sphere);\n  var ecc = Object(_deriveConstants__WEBPACK_IMPORTED_MODULE_3__[\"eccentricity\"])(sphere_.a, sphere_.b, sphere_.rf, json.R_A);\n  var datumObj = json.datum || Object(_datum__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);\n\n  Object(_extend__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, json); // transfer everything over from the projection because we don't know what we'll need\n  Object(_extend__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, ourProj); // transfer all the methods from the projection\n\n  // copy the 4 things over we calulated in deriveConstants.sphere\n  this.a = sphere_.a;\n  this.b = sphere_.b;\n  this.rf = sphere_.rf;\n  this.sphere = sphere_.sphere;\n\n  // copy the 3 things we calculated in deriveConstants.eccentricity\n  this.es = ecc.es;\n  this.e = ecc.e;\n  this.ep2 = ecc.ep2;\n\n  // add in the datum object\n  this.datum = datumObj;\n\n  // init the projection\n  this.init();\n\n  // legecy callback from back in the day when it went to spatialreference.org\n  callback(null, this);\n\n}\nProjection.projections = _projections__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\nProjection.projections.start();\n/* harmony default export */ __webpack_exports__[\"default\"] = (Projection);\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/Proj.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/adjust_axis.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/adjust_axis.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(crs, denorm, point) {\n  var xin = point.x,\n    yin = point.y,\n    zin = point.z || 0.0;\n  var v, t, i;\n  var out = {};\n  for (i = 0; i < 3; i++) {\n    if (denorm && i === 2 && point.z === undefined) {\n      continue;\n    }\n    if (i === 0) {\n      v = xin;\n      t = 'x';\n    }\n    else if (i === 1) {\n      v = yin;\n      t = 'y';\n    }\n    else {\n      v = zin;\n      t = 'z';\n    }\n    switch (crs.axis[i]) {\n    case 'e':\n      out[t] = v;\n      break;\n    case 'w':\n      out[t] = -v;\n      break;\n    case 'n':\n      out[t] = v;\n      break;\n    case 's':\n      out[t] = -v;\n      break;\n    case 'u':\n      if (point[t] !== undefined) {\n        out.z = v;\n      }\n      break;\n    case 'd':\n      if (point[t] !== undefined) {\n        out.z = -v;\n      }\n      break;\n    default:\n      //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n      return null;\n    }\n  }\n  return out;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/adjust_axis.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/checkSanity.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/checkSanity.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (point) {\n  checkCoord(point.x);\n  checkCoord(point.y);\n});\nfunction checkCoord(num) {\n  if (typeof Number.isFinite === 'function') {\n    if (Number.isFinite(num)) {\n      return;\n    }\n    throw new TypeError('coordinates must be finite numbers');\n  }\n  if (typeof num !== 'number' || num !== num || !isFinite(num)) {\n    throw new TypeError('coordinates must be finite numbers');\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/checkSanity.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/adjust_lat.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/common/adjust_lat.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign */ \"./node_modules/proj4/lib/common/sign.js\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  return (Math.abs(x) < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]) ? x : (x - (Object(_sign__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(x) * Math.PI));\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/adjust_lat.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/adjust_lon.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/common/adjust_lon.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign */ \"./node_modules/proj4/lib/common/sign.js\");\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  return (Math.abs(x) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]) ? x : (x - (Object(_sign__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(x) * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"]));\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/adjust_lon.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/adjust_zone.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/common/adjust_zone.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(zone, lon) {\n  if (zone === undefined) {\n    zone = Math.floor((Object(_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon) + Math.PI) * 30 / Math.PI) + 1;\n\n    if (zone < 0) {\n      return 0;\n    } else if (zone > 60) {\n      return 60;\n    }\n  }\n  return zone;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/adjust_zone.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/asinhy.js":
/*!*************************************************!*\
  !*** ./node_modules/proj4/lib/common/asinhy.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _hypot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hypot */ \"./node_modules/proj4/lib/common/hypot.js\");\n/* harmony import */ var _log1py__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log1py */ \"./node_modules/proj4/lib/common/log1py.js\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  var y = Math.abs(x);\n  y = Object(_log1py__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(y * (1 + y / (Object(_hypot__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(1, y) + 1)));\n\n  return x < 0 ? -y : y;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/asinhy.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/asinz.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/asinz.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  if (Math.abs(x) > 1) {\n    x = (x > 1) ? 1 : -1;\n  }\n  return Math.asin(x);\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/asinz.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/clens.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/clens.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(pp, arg_r) {\n  var r = 2 * Math.cos(arg_r);\n  var i = pp.length - 1;\n  var hr1 = pp[i];\n  var hr2 = 0;\n  var hr;\n\n  while (--i >= 0) {\n    hr = -hr2 + r * hr1 + pp[i];\n    hr2 = hr1;\n    hr1 = hr;\n  }\n\n  return Math.sin(arg_r) * hr;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/clens.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/clens_cmplx.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/common/clens_cmplx.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sinh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sinh */ \"./node_modules/proj4/lib/common/sinh.js\");\n/* harmony import */ var _cosh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cosh */ \"./node_modules/proj4/lib/common/cosh.js\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(pp, arg_r, arg_i) {\n  var sin_arg_r = Math.sin(arg_r);\n  var cos_arg_r = Math.cos(arg_r);\n  var sinh_arg_i = Object(_sinh__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arg_i);\n  var cosh_arg_i = Object(_cosh__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arg_i);\n  var r = 2 * cos_arg_r * cosh_arg_i;\n  var i = -2 * sin_arg_r * sinh_arg_i;\n  var j = pp.length - 1;\n  var hr = pp[j];\n  var hi1 = 0;\n  var hr1 = 0;\n  var hi = 0;\n  var hr2;\n  var hi2;\n\n  while (--j >= 0) {\n    hr2 = hr1;\n    hi2 = hi1;\n    hr1 = hr;\n    hi1 = hi;\n    hr = -hr2 + r * hr1 - i * hi1 + pp[j];\n    hi = -hi2 + i * hr1 + r * hi1;\n  }\n\n  r = sin_arg_r * cosh_arg_i;\n  i = cos_arg_r * sinh_arg_i;\n\n  return [r * hr - i * hi, r * hi + i * hr];\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/clens_cmplx.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/cosh.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/cosh.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  var r = Math.exp(x);\n  r = (r + 1 / r) / 2;\n  return r;\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/cosh.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/e0fn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/e0fn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/e0fn.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/e1fn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/e1fn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/e1fn.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/e2fn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/e2fn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  return (0.05859375 * x * x * (1 + 0.75 * x));\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/e2fn.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/e3fn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/e3fn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  return (x * x * x * (35 / 3072));\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/e3fn.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/gN.js":
/*!*********************************************!*\
  !*** ./node_modules/proj4/lib/common/gN.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(a, e, sinphi) {\n  var temp = e * sinphi;\n  return a / Math.sqrt(1 - temp * temp);\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/gN.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/gatg.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/gatg.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(pp, B) {\n  var cos_2B = 2 * Math.cos(2 * B);\n  var i = pp.length - 1;\n  var h1 = pp[i];\n  var h2 = 0;\n  var h;\n\n  while (--i >= 0) {\n    h = -h2 + cos_2B * h1 + pp[i];\n    h2 = h1;\n    h1 = h;\n  }\n\n  return (B + h * Math.sin(2 * B));\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/gatg.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/hypot.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/hypot.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x, y) {\n  x = Math.abs(x);\n  y = Math.abs(y);\n  var a = Math.max(x, y);\n  var b = Math.min(x, y) / (a ? a : 1);\n\n  return a * Math.sqrt(1 + Math.pow(b, 2));\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/hypot.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/imlfn.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/imlfn.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(ml, e0, e1, e2, e3) {\n  var phi;\n  var dphi;\n\n  phi = ml / e0;\n  for (var i = 0; i < 15; i++) {\n    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //..reportError(\"IMLFN-CONV:Latitude failed to converge after 15 iterations\");\n  return NaN;\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/imlfn.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/iqsfnz.js":
/*!*************************************************!*\
  !*** ./node_modules/proj4/lib/common/iqsfnz.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(eccent, q) {\n  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));\n  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {\n    if (q < 0) {\n      return (-1 * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]);\n    }\n    else {\n      return _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    }\n  }\n  //var phi = 0.5* q/(1-eccent*eccent);\n  var phi = Math.asin(0.5 * q);\n  var dphi;\n  var sin_phi;\n  var cos_phi;\n  var con;\n  for (var i = 0; i < 30; i++) {\n    sin_phi = Math.sin(phi);\n    cos_phi = Math.cos(phi);\n    con = eccent * sin_phi;\n    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //console.log(\"IQSFN-CONV:Latitude failed to converge after 30 iterations\");\n  return NaN;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/iqsfnz.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/log1py.js":
/*!*************************************************!*\
  !*** ./node_modules/proj4/lib/common/log1py.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  var y = 1 + x;\n  var z = y - 1;\n\n  return z === 0 ? x : x * Math.log(y) / z;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/log1py.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/mlfn.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/mlfn.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(e0, e1, e2, e3, phi) {\n  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/mlfn.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/msfnz.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/msfnz.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(eccent, sinphi, cosphi) {\n  var con = eccent * sinphi;\n  return cosphi / (Math.sqrt(1 - con * con));\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/msfnz.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/phi2z.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/phi2z.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(eccent, ts) {\n  var eccnth = 0.5 * eccent;\n  var con, dphi;\n  var phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] - 2 * Math.atan(ts);\n  for (var i = 0; i <= 15; i++) {\n    con = eccent * Math.sin(phi);\n    dphi = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n  //console.log(\"phi2z has NoConvergence\");\n  return -9999;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/phi2z.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/pj_enfn.js":
/*!**************************************************!*\
  !*** ./node_modules/proj4/lib/common/pj_enfn.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar C00 = 1;\nvar C02 = 0.25;\nvar C04 = 0.046875;\nvar C06 = 0.01953125;\nvar C08 = 0.01068115234375;\nvar C22 = 0.75;\nvar C44 = 0.46875;\nvar C46 = 0.01302083333333333333;\nvar C48 = 0.00712076822916666666;\nvar C66 = 0.36458333333333333333;\nvar C68 = 0.00569661458333333333;\nvar C88 = 0.3076171875;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(es) {\n  var en = [];\n  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));\n  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));\n  var t = es * es;\n  en[2] = t * (C44 - es * (C46 + es * C48));\n  t *= es;\n  en[3] = t * (C66 - es * C68);\n  en[4] = t * es * C88;\n  return en;\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/pj_enfn.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/pj_inv_mlfn.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/common/pj_inv_mlfn.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pj_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pj_mlfn */ \"./node_modules/proj4/lib/common/pj_mlfn.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n\nvar MAX_ITER = 20;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(arg, es, en) {\n  var k = 1 / (1 - es);\n  var phi = arg;\n  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */\n    var s = Math.sin(phi);\n    var t = 1 - es * s * s;\n    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;\n    //phi -= t * (t * Math.sqrt(t)) * k;\n    t = (Object(_pj_mlfn__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;\n    phi -= t;\n    if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n      return phi;\n    }\n  }\n  //..reportError(\"cass:pj_inv_mlfn: Convergence error\");\n  return phi;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/pj_inv_mlfn.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/pj_mlfn.js":
/*!**************************************************!*\
  !*** ./node_modules/proj4/lib/common/pj_mlfn.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(phi, sphi, cphi, en) {\n  cphi *= sphi;\n  sphi *= sphi;\n  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/pj_mlfn.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/qsfnz.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/qsfnz.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(eccent, sinphi) {\n  var con;\n  if (eccent > 1.0e-7) {\n    con = eccent * sinphi;\n    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));\n  }\n  else {\n    return (2 * sinphi);\n  }\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/qsfnz.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/sign.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/sign.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  return x<0 ? -1 : 1;\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/sign.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/sinh.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/sinh.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(x) {\n  var r = Math.exp(x);\n  r = (r - 1 / r) / 2;\n  return r;\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/sinh.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/srat.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/common/srat.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(esinp, exp) {\n  return (Math.pow((1 - esinp) / (1 + esinp), exp));\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/srat.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/toPoint.js":
/*!**************************************************!*\
  !*** ./node_modules/proj4/lib/common/toPoint.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (array){\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length>2) {\n    out.z = array[2];\n  }\n  if (array.length>3) {\n    out.m = array[3];\n  }\n  return out;\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/toPoint.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/common/tsfnz.js":
/*!************************************************!*\
  !*** ./node_modules/proj4/lib/common/tsfnz.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(eccent, phi, sinphi) {\n  var con = eccent * sinphi;\n  var com = 0.5 * eccent;\n  con = Math.pow(((1 - con) / (1 + con)), com);\n  return (Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] - phi)) / con);\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/common/tsfnz.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/constants/Datum.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/constants/Datum.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return exports; });\nvar exports = {};\n\nexports.wgs84 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"WGS84\",\n  datumName: \"WGS84\"\n};\n\nexports.ch1903 = {\n  towgs84: \"674.374,15.056,405.346\",\n  ellipse: \"bessel\",\n  datumName: \"swiss\"\n};\n\nexports.ggrs87 = {\n  towgs84: \"-199.87,74.79,246.62\",\n  ellipse: \"GRS80\",\n  datumName: \"Greek_Geodetic_Reference_System_1987\"\n};\n\nexports.nad83 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"GRS80\",\n  datumName: \"North_American_Datum_1983\"\n};\n\nexports.nad27 = {\n  nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n  ellipse: \"clrk66\",\n  datumName: \"North_American_Datum_1927\"\n};\n\nexports.potsdam = {\n  towgs84: \"606.0,23.0,413.0\",\n  ellipse: \"bessel\",\n  datumName: \"Potsdam Rauenberg 1950 DHDN\"\n};\n\nexports.carthage = {\n  towgs84: \"-263.0,6.0,431.0\",\n  ellipse: \"clark80\",\n  datumName: \"Carthage 1934 Tunisia\"\n};\n\nexports.hermannskogel = {\n  towgs84: \"653.0,-212.0,449.0\",\n  ellipse: \"bessel\",\n  datumName: \"Hermannskogel\"\n};\n\nexports.osni52 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"airy\",\n  datumName: \"Irish National\"\n};\n\nexports.ire65 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"mod_airy\",\n  datumName: \"Ireland 1965\"\n};\n\nexports.rassadiran = {\n  towgs84: \"-133.63,-157.5,-158.62\",\n  ellipse: \"intl\",\n  datumName: \"Rassadiran\"\n};\n\nexports.nzgd49 = {\n  towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n  ellipse: \"intl\",\n  datumName: \"New Zealand Geodetic Datum 1949\"\n};\n\nexports.osgb36 = {\n  towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n  ellipse: \"airy\",\n  datumName: \"Airy 1830\"\n};\n\nexports.s_jtsk = {\n  towgs84: \"589,76,480\",\n  ellipse: 'bessel',\n  datumName: 'S-JTSK (Ferro)'\n};\n\nexports.beduaram = {\n  towgs84: '-106,-87,188',\n  ellipse: 'clrk80',\n  datumName: 'Beduaram'\n};\n\nexports.gunung_segara = {\n  towgs84: '-403,684,41',\n  ellipse: 'bessel',\n  datumName: 'Gunung Segara Jakarta'\n};\n\nexports.rnb72 = {\n  towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n  ellipse: \"intl\",\n  datumName: \"Reseau National Belge 1972\"\n};\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/constants/Datum.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/constants/Ellipsoid.js":
/*!*******************************************************!*\
  !*** ./node_modules/proj4/lib/constants/Ellipsoid.js ***!
  \*******************************************************/
/*! exports provided: default, WGS84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return exports; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WGS84\", function() { return WGS84; });\nvar exports = {};\n\nexports.MERIT = {\n  a: 6378137.0,\n  rf: 298.257,\n  ellipseName: \"MERIT 1983\"\n};\n\nexports.SGS85 = {\n  a: 6378136.0,\n  rf: 298.257,\n  ellipseName: \"Soviet Geodetic System 85\"\n};\n\nexports.GRS80 = {\n  a: 6378137.0,\n  rf: 298.257222101,\n  ellipseName: \"GRS 1980(IUGG, 1980)\"\n};\n\nexports.IAU76 = {\n  a: 6378140.0,\n  rf: 298.257,\n  ellipseName: \"IAU 1976\"\n};\n\nexports.airy = {\n  a: 6377563.396,\n  b: 6356256.910,\n  ellipseName: \"Airy 1830\"\n};\n\nexports.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: \"Appl. Physics. 1965\"\n};\n\nexports.NWL9D = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"Naval Weapons Lab., 1965\"\n};\n\nexports.mod_airy = {\n  a: 6377340.189,\n  b: 6356034.446,\n  ellipseName: \"Modified Airy\"\n};\n\nexports.andrae = {\n  a: 6377104.43,\n  rf: 300.0,\n  ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n};\n\nexports.aust_SA = {\n  a: 6378160.0,\n  rf: 298.25,\n  ellipseName: \"Australian Natl & S. Amer. 1969\"\n};\n\nexports.GRS67 = {\n  a: 6378160.0,\n  rf: 298.2471674270,\n  ellipseName: \"GRS 67(IUGG 1967)\"\n};\n\nexports.bessel = {\n  a: 6377397.155,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841\"\n};\n\nexports.bess_nam = {\n  a: 6377483.865,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841 (Namibia)\"\n};\n\nexports.clrk66 = {\n  a: 6378206.4,\n  b: 6356583.8,\n  ellipseName: \"Clarke 1866\"\n};\n\nexports.clrk80 = {\n  a: 6378249.145,\n  rf: 293.4663,\n  ellipseName: \"Clarke 1880 mod.\"\n};\n\nexports.clrk58 = {\n  a: 6378293.645208759,\n  rf: 294.2606763692654,\n  ellipseName: \"Clarke 1858\"\n};\n\nexports.CPM = {\n  a: 6375738.7,\n  rf: 334.29,\n  ellipseName: \"Comm. des Poids et Mesures 1799\"\n};\n\nexports.delmbr = {\n  a: 6376428.0,\n  rf: 311.5,\n  ellipseName: \"Delambre 1810 (Belgium)\"\n};\n\nexports.engelis = {\n  a: 6378136.05,\n  rf: 298.2566,\n  ellipseName: \"Engelis 1985\"\n};\n\nexports.evrst30 = {\n  a: 6377276.345,\n  rf: 300.8017,\n  ellipseName: \"Everest 1830\"\n};\n\nexports.evrst48 = {\n  a: 6377304.063,\n  rf: 300.8017,\n  ellipseName: \"Everest 1948\"\n};\n\nexports.evrst56 = {\n  a: 6377301.243,\n  rf: 300.8017,\n  ellipseName: \"Everest 1956\"\n};\n\nexports.evrst69 = {\n  a: 6377295.664,\n  rf: 300.8017,\n  ellipseName: \"Everest 1969\"\n};\n\nexports.evrstSS = {\n  a: 6377298.556,\n  rf: 300.8017,\n  ellipseName: \"Everest (Sabah & Sarawak)\"\n};\n\nexports.fschr60 = {\n  a: 6378166.0,\n  rf: 298.3,\n  ellipseName: \"Fischer (Mercury Datum) 1960\"\n};\n\nexports.fschr60m = {\n  a: 6378155.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1960\"\n};\n\nexports.fschr68 = {\n  a: 6378150.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1968\"\n};\n\nexports.helmert = {\n  a: 6378200.0,\n  rf: 298.3,\n  ellipseName: \"Helmert 1906\"\n};\n\nexports.hough = {\n  a: 6378270.0,\n  rf: 297.0,\n  ellipseName: \"Hough\"\n};\n\nexports.intl = {\n  a: 6378388.0,\n  rf: 297.0,\n  ellipseName: \"International 1909 (Hayford)\"\n};\n\nexports.kaula = {\n  a: 6378163.0,\n  rf: 298.24,\n  ellipseName: \"Kaula 1961\"\n};\n\nexports.lerch = {\n  a: 6378139.0,\n  rf: 298.257,\n  ellipseName: \"Lerch 1979\"\n};\n\nexports.mprts = {\n  a: 6397300.0,\n  rf: 191.0,\n  ellipseName: \"Maupertius 1738\"\n};\n\nexports.new_intl = {\n  a: 6378157.5,\n  b: 6356772.2,\n  ellipseName: \"New International 1967\"\n};\n\nexports.plessis = {\n  a: 6376523.0,\n  rf: 6355863.0,\n  ellipseName: \"Plessis 1817 (France)\"\n};\n\nexports.krass = {\n  a: 6378245.0,\n  rf: 298.3,\n  ellipseName: \"Krassovsky, 1942\"\n};\n\nexports.SEasia = {\n  a: 6378155.0,\n  b: 6356773.3205,\n  ellipseName: \"Southeast Asia\"\n};\n\nexports.walbeck = {\n  a: 6376896.0,\n  b: 6355834.8467,\n  ellipseName: \"Walbeck\"\n};\n\nexports.WGS60 = {\n  a: 6378165.0,\n  rf: 298.3,\n  ellipseName: \"WGS 60\"\n};\n\nexports.WGS66 = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"WGS 66\"\n};\n\nexports.WGS7 = {\n  a: 6378135.0,\n  rf: 298.26,\n  ellipseName: \"WGS 72\"\n};\n\nvar WGS84 = exports.WGS84 = {\n  a: 6378137.0,\n  rf: 298.257223563,\n  ellipseName: \"WGS 84\"\n};\n\nexports.sphere = {\n  a: 6370997.0,\n  b: 6370997.0,\n  ellipseName: \"Normal Sphere (r=6370997)\"\n};\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/constants/Ellipsoid.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/constants/PrimeMeridian.js":
/*!***********************************************************!*\
  !*** ./node_modules/proj4/lib/constants/PrimeMeridian.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return exports; });\nvar exports = {};\n\n\nexports.greenwich = 0.0; //\"0dE\",\nexports.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\nexports.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\nexports.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\nexports.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\nexports.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\nexports.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\nexports.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\nexports.ferro = -17.666666666667; //\"17d40'W\",\nexports.brussels = 4.367975; //\"4d22'4.71\\\"E\",\nexports.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\nexports.athens = 23.7163375; //\"23d42'58.815\\\"E\",\nexports.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/constants/PrimeMeridian.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/constants/units.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/constants/units.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  ft: {to_meter: 0.3048},\n  'us-ft': {to_meter: 1200 / 3937}\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/constants/units.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/constants/values.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/constants/values.js ***!
  \****************************************************/
/*! exports provided: PJD_3PARAM, PJD_7PARAM, PJD_WGS84, PJD_NODATUM, SEC_TO_RAD, HALF_PI, SIXTH, RA4, RA6, EPSLN, D2R, R2D, FORTPI, TWO_PI, SPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PJD_3PARAM\", function() { return PJD_3PARAM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PJD_7PARAM\", function() { return PJD_7PARAM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PJD_WGS84\", function() { return PJD_WGS84; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PJD_NODATUM\", function() { return PJD_NODATUM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SEC_TO_RAD\", function() { return SEC_TO_RAD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HALF_PI\", function() { return HALF_PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SIXTH\", function() { return SIXTH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RA4\", function() { return RA4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RA6\", function() { return RA6; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EPSLN\", function() { return EPSLN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D2R\", function() { return D2R; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R2D\", function() { return R2D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FORTPI\", function() { return FORTPI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TWO_PI\", function() { return TWO_PI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SPI\", function() { return SPI; });\nvar PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar PJD_WGS84 = 4; // WGS84 or equivalent\nvar PJD_NODATUM = 5; // WGS84 or equivalent\nvar SEC_TO_RAD = 4.84813681109535993589914102357e-6;\nvar HALF_PI = Math.PI/2;\n// ellipoid pj_set_ell.c\nvar SIXTH = 0.1666666666666666667;\n/* 1/6 */\nvar RA4 = 0.04722222222222222222;\n/* 17/360 */\nvar RA6 = 0.02215608465608465608;\nvar EPSLN = 1.0e-10;\n// you'd think you could use Number.EPSILON above but that makes\n// Mollweide get into an infinate loop.\n\nvar D2R = 0.01745329251994329577;\nvar R2D = 57.29577951308232088;\nvar FORTPI = Math.PI/4;\nvar TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nvar SPI = 3.14159265359;\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/constants/values.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/core.js":
/*!****************************************!*\
  !*** ./node_modules/proj4/lib/core.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Proj */ \"./node_modules/proj4/lib/Proj.js\");\n/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform */ \"./node_modules/proj4/lib/transform.js\");\n\n\nvar wgs84 = Object(_Proj__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('WGS84');\n\nfunction transformer(from, to, coords) {\n  var transformedArray, out, keys;\n  if (Array.isArray(coords)) {\n    transformedArray = Object(_transform__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(from, to, coords) || {x: NaN, y: NaN};\n    if (coords.length > 2) {\n      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {\n        if (typeof transformedArray.z === 'number') {\n          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));\n        } else {\n          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));\n        }\n      } else {\n        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));\n      }\n    } else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  } else {\n    out = Object(_transform__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(from, to, coords);\n    keys = Object.keys(coords);\n    if (keys.length === 2) {\n      return out;\n    }\n    keys.forEach(function (key) {\n      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {\n        if (key === 'x' || key === 'y' || key === 'z') {\n          return;\n        }\n      } else {\n        if (key === 'x' || key === 'y') {\n          return;\n        }\n      }\n      out[key] = coords[key];\n    });\n    return out;\n  }\n}\n\nfunction checkProj(item) {\n  if (item instanceof _Proj__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return Object(_Proj__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(item);\n}\n\nfunction proj4(fromProj, toProj, coord) {\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === 'undefined') {\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  } else {\n    obj = {\n      forward: function (coords) {\n        return transformer(fromProj, toProj, coords);\n      },\n      inverse: function (coords) {\n        return transformer(toProj, fromProj, coords);\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (proj4);\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/core.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/datum.js":
/*!*****************************************!*\
  !*** ./node_modules/proj4/lib/datum.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\nfunction datum(datumCode, datum_params, a, b, es, ep2) {\n  var out = {};\n\n  if (datumCode === undefined || datumCode === 'none') {\n    out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_NODATUM\"];\n  } else {\n    out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_WGS84\"];\n  }\n\n  if (datum_params) {\n    out.datum_params = datum_params.map(parseFloat);\n    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n      out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_3PARAM\"];\n    }\n    if (out.datum_params.length > 3) {\n      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n        out.datum_type = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_7PARAM\"];\n        out.datum_params[3] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SEC_TO_RAD\"];\n        out.datum_params[4] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SEC_TO_RAD\"];\n        out.datum_params[5] *= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SEC_TO_RAD\"];\n        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n      }\n    }\n  }\n\n  out.a = a; //datum object also uses these values\n  out.b = b;\n  out.es = es;\n  out.ep2 = ep2;\n  return out;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (datum);\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/datum.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/datumUtils.js":
/*!**********************************************!*\
  !*** ./node_modules/proj4/lib/datumUtils.js ***!
  \**********************************************/
/*! exports provided: compareDatums, geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compareDatums\", function() { return compareDatums; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"geodeticToGeocentric\", function() { return geodeticToGeocentric; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"geocentricToGeodetic\", function() { return geocentricToGeodetic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"geocentricToWgs84\", function() { return geocentricToWgs84; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"geocentricFromWgs84\", function() { return geocentricFromWgs84; });\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\nfunction compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_3PARAM\"]) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_7PARAM\"]) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nfunction geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] && Latitude > -1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]) {\n    Latitude = -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n  } else if (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] && Latitude < 1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]) {\n    Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n  } else if (Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return { x: -Infinity, y: -Infinity, z: p.z };\n  } else if (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]) {\n    /* Latitude out of range */\n    return { x: Infinity, y: Infinity, z: p.z };\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nfunction geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nfunction geocentricToWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_3PARAM\"]) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_7PARAM\"]) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nfunction geocentricFromWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_3PARAM\"]) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_7PARAM\"]) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n}\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/datumUtils.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/datum_transform.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/datum_transform.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _datumUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datumUtils */ \"./node_modules/proj4/lib/datumUtils.js\");\n\n\n\nfunction checkParams(type) {\n  return (type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_3PARAM\"] || type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_7PARAM\"]);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__[\"compareDatums\"])(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_NODATUM\"] || dest.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_NODATUM\"]) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n  // Do we need to go through geocentric coordinates?\n  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__[\"geodeticToGeocentric\"])(point, source.es, source.a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__[\"geocentricToWgs84\"])(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__[\"geocentricFromWgs84\"])(point, dest.datum_type, dest.datum_params);\n  }\n  return Object(_datumUtils__WEBPACK_IMPORTED_MODULE_1__[\"geocentricToGeodetic\"])(point, dest.es, dest.a, dest.b);\n\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/datum_transform.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/defs.js":
/*!****************************************!*\
  !*** ./node_modules/proj4/lib/defs.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global */ \"./node_modules/proj4/lib/global.js\");\n/* harmony import */ var _projString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projString */ \"./node_modules/proj4/lib/projString.js\");\n/* harmony import */ var wkt_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wkt-parser */ \"./node_modules/wkt-parser/index.js\");\n\n\n\n\nfunction defs(name) {\n  /*global console*/\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === 'string') {\n      if (def.charAt(0) === '+') {\n        defs[name] = Object(_projString__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arguments[1]);\n      }\n      else {\n        defs[name] = Object(wkt_parser__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  }\n  else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v) {\n        if (Array.isArray(v)) {\n          defs.apply(that, v);\n        }\n        else {\n          defs(v);\n        }\n      });\n    }\n    else if (typeof name === 'string') {\n      if (name in defs) {\n        return defs[name];\n      }\n    }\n    else if ('EPSG' in name) {\n      defs['EPSG:' + name.EPSG] = name;\n    }\n    else if ('ESRI' in name) {\n      defs['ESRI:' + name.ESRI] = name;\n    }\n    else if ('IAU2000' in name) {\n      defs['IAU2000:' + name.IAU2000] = name;\n    }\n    else {\n      console.log(name);\n    }\n    return;\n  }\n\n\n}\nObject(_global__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(defs);\n/* harmony default export */ __webpack_exports__[\"default\"] = (defs);\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/defs.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/deriveConstants.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/deriveConstants.js ***!
  \***************************************************/
/*! exports provided: eccentricity, sphere */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eccentricity\", function() { return eccentricity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sphere\", function() { return sphere; });\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/Ellipsoid */ \"./node_modules/proj4/lib/constants/Ellipsoid.js\");\n/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./match */ \"./node_modules/proj4/lib/match.js\");\n\n\n\n\nfunction eccentricity(a, b, rf, R_A) {\n  var a2 = a * a; // used in geocentric\n  var b2 = b * b; // used in geocentric\n  var es = (a2 - b2) / a2; // e ^ 2\n  var e = 0;\n  if (R_A) {\n    a *= 1 - es * (_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SIXTH\"] + es * (_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"RA4\"] + es * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"RA6\"]));\n    a2 = a * a;\n    es = 0;\n  } else {\n    e = Math.sqrt(es); // eccentricity\n  }\n  var ep2 = (a2 - b2) / b2; // used in geocentric\n  return {\n    es: es,\n    e: e,\n    ep2: ep2\n  };\n}\nfunction sphere(a, b, rf, ellps, sphere) {\n  if (!a) { // do we have an ellipsoid?\n    var ellipse = Object(_match__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__[\"default\"], ellps);\n    if (!ellipse) {\n      ellipse = _constants_Ellipsoid__WEBPACK_IMPORTED_MODULE_1__[\"WGS84\"];\n    }\n    a = ellipse.a;\n    b = ellipse.b;\n    rf = ellipse.rf;\n  }\n\n  if (rf && !b) {\n    b = (1.0 - 1.0 / rf) * a;\n  }\n  if (rf === 0 || Math.abs(a - b) < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n    sphere = true;\n    b = a;\n  }\n  return {\n    a: a,\n    b: b,\n    rf: rf,\n    sphere: sphere\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/deriveConstants.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/extend.js":
/*!******************************************!*\
  !*** ./node_modules/proj4/lib/extend.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== undefined) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/extend.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/global.js":
/*!******************************************!*\
  !*** ./node_modules/proj4/lib/global.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(defs) {\n  defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n  defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n  defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n\n  defs.WGS84 = defs['EPSG:4326'];\n  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n  defs.GOOGLE = defs['EPSG:3857'];\n  defs['EPSG:900913'] = defs['EPSG:3857'];\n  defs['EPSG:102113'] = defs['EPSG:3857'];\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/global.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/proj4/lib/index.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"./node_modules/proj4/lib/core.js\");\n/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proj */ \"./node_modules/proj4/lib/Proj.js\");\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Point */ \"./node_modules/proj4/lib/Point.js\");\n/* harmony import */ var _common_toPoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/toPoint */ \"./node_modules/proj4/lib/common/toPoint.js\");\n/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defs */ \"./node_modules/proj4/lib/defs.js\");\n/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transform */ \"./node_modules/proj4/lib/transform.js\");\n/* harmony import */ var mgrs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mgrs */ \"./node_modules/mgrs/mgrs.js\");\n/* harmony import */ var _projs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../projs */ \"./node_modules/proj4/projs.js\");\n\n\n\n\n\n\n\n\n\n_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultDatum = 'WGS84'; //default datum\n_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Proj = _Proj__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WGS84 = new _core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Proj('WGS84');\n_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Point = _Point__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toPoint = _common_toPoint__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defs = _defs__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].transform = _transform__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mgrs = mgrs__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].version = '__VERSION__';\nObject(_projs__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ __webpack_exports__[\"default\"] = (_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/index.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/match.js":
/*!*****************************************!*\
  !*** ./node_modules/proj4/lib/match.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return match; });\nvar ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction match(obj, key) {\n  if (obj[key]) {\n    return obj[key];\n  }\n  var keys = Object.keys(obj);\n  var lkey = key.toLowerCase().replace(ignoredChar, '');\n  var i = -1;\n  var testkey, processedKey;\n  while (++i < keys.length) {\n    testkey = keys[i];\n    processedKey = testkey.toLowerCase().replace(ignoredChar, '');\n    if (processedKey === lkey) {\n      return obj[testkey];\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/match.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/parseCode.js":
/*!*********************************************!*\
  !*** ./node_modules/proj4/lib/parseCode.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defs */ \"./node_modules/proj4/lib/defs.js\");\n/* harmony import */ var wkt_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wkt-parser */ \"./node_modules/wkt-parser/index.js\");\n/* harmony import */ var _projString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projString */ \"./node_modules/proj4/lib/projString.js\");\n/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./match */ \"./node_modules/proj4/lib/match.js\");\n\n\n\n\nfunction testObj(code){\n  return typeof code === 'string';\n}\nfunction testDef(code){\n  return code in _defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n}\n var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];\nfunction testWKT(code){\n  return codeWords.some(function (word) {\n    return code.indexOf(word) > -1;\n  });\n}\nvar codes = ['3857', '900913', '3785', '102113'];\nfunction checkMercator(item) {\n  var auth = Object(_match__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(item, 'authority');\n  if (!auth) {\n    return;\n  }\n  var code = Object(_match__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(auth, 'epsg');\n  return code && codes.indexOf(code) > -1;\n}\nfunction checkProjStr(item) {\n  var ext = Object(_match__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(item, 'extension');\n  if (!ext) {\n    return;\n  }\n  return Object(_match__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(ext, 'proj4');\n}\nfunction testProj(code){\n  return code[0] === '+';\n}\nfunction parse(code){\n  if (testObj(code)) {\n    //check to see if this is a WKT string\n    if (testDef(code)) {\n      return _defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"][code];\n    }\n    if (testWKT(code)) {\n      var out = Object(wkt_parser__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(code);\n      // test of spetial case, due to this being a very common and often malformed\n      if (checkMercator(out)) {\n        return _defs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]['EPSG:3857'];\n      }\n      var maybeProjStr = checkProjStr(out);\n      if (maybeProjStr) {\n        return Object(_projString__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(maybeProjStr);\n      }\n      return out;\n    }\n    if (testProj(code)) {\n      return Object(_projString__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(code);\n    }\n  }else{\n    return code;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (parse);\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/parseCode.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projString.js":
/*!**********************************************!*\
  !*** ./node_modules/proj4/lib/projString.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _constants_PrimeMeridian__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/PrimeMeridian */ \"./node_modules/proj4/lib/constants/PrimeMeridian.js\");\n/* harmony import */ var _constants_units__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants/units */ \"./node_modules/proj4/lib/constants/units.js\");\n/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./match */ \"./node_modules/proj4/lib/match.js\");\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(defData) {\n  var self = {};\n  var paramObj = defData.split('+').map(function(v) {\n    return v.trim();\n  }).filter(function(a) {\n    return a;\n  }).reduce(function(p, a) {\n    var split = a.split('=');\n    split.push(true);\n    p[split[0].toLowerCase()] = split[1];\n    return p;\n  }, {});\n  var paramName, paramVal, paramOutname;\n  var params = {\n    proj: 'projName',\n    datum: 'datumCode',\n    rf: function(v) {\n      self.rf = parseFloat(v);\n    },\n    lat_0: function(v) {\n      self.lat0 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    lat_1: function(v) {\n      self.lat1 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    lat_2: function(v) {\n      self.lat2 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    lat_ts: function(v) {\n      self.lat_ts = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    lon_0: function(v) {\n      self.long0 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    lon_1: function(v) {\n      self.long1 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    lon_2: function(v) {\n      self.long2 = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    alpha: function(v) {\n      self.alpha = parseFloat(v) * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    lonc: function(v) {\n      self.longc = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    x_0: function(v) {\n      self.x0 = parseFloat(v);\n    },\n    y_0: function(v) {\n      self.y0 = parseFloat(v);\n    },\n    k_0: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    k: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    a: function(v) {\n      self.a = parseFloat(v);\n    },\n    b: function(v) {\n      self.b = parseFloat(v);\n    },\n    r_a: function() {\n      self.R_A = true;\n    },\n    zone: function(v) {\n      self.zone = parseInt(v, 10);\n    },\n    south: function() {\n      self.utmSouth = true;\n    },\n    towgs84: function(v) {\n      self.datum_params = v.split(\",\").map(function(a) {\n        return parseFloat(a);\n      });\n    },\n    to_meter: function(v) {\n      self.to_meter = parseFloat(v);\n    },\n    units: function(v) {\n      self.units = v;\n      var unit = Object(_match__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_constants_units__WEBPACK_IMPORTED_MODULE_2__[\"default\"], v);\n      if (unit) {\n        self.to_meter = unit.to_meter;\n      }\n    },\n    from_greenwich: function(v) {\n      self.from_greenwich = v * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    pm: function(v) {\n      var pm = Object(_match__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_constants_PrimeMeridian__WEBPACK_IMPORTED_MODULE_1__[\"default\"], v);\n      self.from_greenwich = (pm ? pm : parseFloat(v)) * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n    },\n    nadgrids: function(v) {\n      if (v === '@null') {\n        self.datumCode = 'none';\n      }\n      else {\n        self.nadgrids = v;\n      }\n    },\n    axis: function(v) {\n      var legalAxis = \"ewnsud\";\n      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n        self.axis = v;\n      }\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params) {\n      paramOutname = params[paramName];\n      if (typeof paramOutname === 'function') {\n        paramOutname(paramVal);\n      }\n      else {\n        self[paramOutname] = paramVal;\n      }\n    }\n    else {\n      self[paramName] = paramVal;\n    }\n  }\n  if(typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\"){\n    self.datumCode = self.datumCode.toLowerCase();\n  }\n  return self;\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projString.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections.js":
/*!***********************************************!*\
  !*** ./node_modules/proj4/lib/projections.js ***!
  \***********************************************/
/*! exports provided: add, get, start, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"start\", function() { return start; });\n/* harmony import */ var _projections_merc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./projections/merc */ \"./node_modules/proj4/lib/projections/merc.js\");\n/* harmony import */ var _projections_longlat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projections/longlat */ \"./node_modules/proj4/lib/projections/longlat.js\");\n\n\nvar projs = [_projections_merc__WEBPACK_IMPORTED_MODULE_0__[\"default\"], _projections_longlat__WEBPACK_IMPORTED_MODULE_1__[\"default\"]];\nvar names = {};\nvar projStore = [];\n\nfunction add(proj, i) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n) {\n    names[n.toLowerCase()] = len;\n  });\n  return this;\n}\n\n\n\nfunction get(name) {\n  if (!name) {\n    return false;\n  }\n  var n = name.toLowerCase();\n  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n    return projStore[names[n]];\n  }\n}\n\nfunction start() {\n  projs.forEach(add);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  start: start,\n  add: add,\n  get: get\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/aea.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/aea.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, phi1z, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"phi1z\", function() { return phi1z; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ \"./node_modules/proj4/lib/common/msfnz.js\");\n/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ \"./node_modules/proj4/lib/common/qsfnz.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/asinz */ \"./node_modules/proj4/lib/common/asinz.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n\n\n\n\nfunction init() {\n\n  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"EPSLN\"]) {\n    return;\n  }\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e3 = Math.sqrt(this.es);\n\n  this.sin_po = Math.sin(this.lat1);\n  this.cos_po = Math.cos(this.lat1);\n  this.t1 = this.sin_po;\n  this.con = this.sin_po;\n  this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e3, this.sin_po, this.cos_po);\n  this.qs1 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat2);\n  this.cos_po = Math.cos(this.lat2);\n  this.t2 = this.sin_po;\n  this.ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e3, this.sin_po, this.cos_po);\n  this.qs2 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat0);\n  this.cos_po = Math.cos(this.lat0);\n  this.t3 = this.sin_po;\n  this.qs0 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e3, this.sin_po, this.cos_po);\n\n  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"EPSLN\"]) {\n    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);\n  }\n  else {\n    this.ns0 = this.con;\n  }\n  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;\n  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;\n}\n\n/* Albers Conical Equal Area forward equations--mapping lat,long to x,y\n  -------------------------------------------------------------------*/\nfunction forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  this.sin_phi = Math.sin(lat);\n  this.cos_phi = Math.cos(lat);\n\n  var qs = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e3, this.sin_phi, this.cos_phi);\n  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;\n  var theta = this.ns0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(lon - this.long0);\n  var x = rh1 * Math.sin(theta) + this.x0;\n  var y = this.rh - rh1 * Math.cos(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction inverse(p) {\n  var rh1, qs, con, theta, lon, lat;\n\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  if (this.ns0 >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n  con = rh1 * this.ns0 / this.a;\n  if (this.sphere) {\n    lat = Math.asin((this.c - con * con) / (2 * this.ns0));\n  }\n  else {\n    qs = (this.c - con * con) / this.ns0;\n    lat = this.phi1z(this.e3, qs);\n  }\n\n  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(theta / this.ns0 + this.long0);\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\n/* Function to compute phi1, the latitude for the inverse of the\n   Albers Conical Equal-Area projection.\n-------------------------------------------*/\nfunction phi1z(eccent, qs) {\n  var sinphi, cosphi, con, com, dphi;\n  var phi = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(0.5 * qs);\n  if (eccent < _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"EPSLN\"]) {\n    return phi;\n  }\n\n  var eccnts = eccent * eccent;\n  for (var i = 1; i <= 25; i++) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    con = eccent * sinphi;\n    com = 1 - con * con;\n    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi = phi + dphi;\n    if (Math.abs(dphi) <= 1e-7) {\n      return phi;\n    }\n  }\n  return null;\n}\n\nvar names = [\"Albers_Conic_Equal_Area\", \"Albers\", \"aea\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  phi1z: phi1z\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/aea.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/aeqd.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/aeqd.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/mlfn */ \"./node_modules/proj4/lib/common/mlfn.js\");\n/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e0fn */ \"./node_modules/proj4/lib/common/e0fn.js\");\n/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/e1fn */ \"./node_modules/proj4/lib/common/e1fn.js\");\n/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/e2fn */ \"./node_modules/proj4/lib/common/e2fn.js\");\n/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/e3fn */ \"./node_modules/proj4/lib/common/e3fn.js\");\n/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/gN */ \"./node_modules/proj4/lib/common/gN.js\");\n/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/asinz */ \"./node_modules/proj4/lib/common/asinz.js\");\n/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/imlfn */ \"./node_modules/proj4/lib/common/imlfn.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction init() {\n  this.sin_p12 = Math.sin(this.lat0);\n  this.cos_p12 = Math.cos(this.lat0);\n}\n\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinphi = Math.sin(p.y);\n  var cosphi = Math.cos(p.y);\n  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;\n  if (this.sphere) {\n    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n      //North Pole case\n      p.x = this.x0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"] - lat) * Math.sin(dlon);\n      p.y = this.y0 - this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"] - lat) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n      //South Pole case\n      p.x = this.x0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"] + lat) * Math.sin(dlon);\n      p.y = this.y0 + this.a * (_constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"] + lat) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //default case\n      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);\n      c = Math.acos(cos_c);\n      kp = c / Math.sin(c);\n      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);\n      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));\n      return p;\n    }\n  }\n  else {\n    e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.es);\n    e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.es);\n    e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.es);\n    e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n      //North Pole case\n      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"]);\n      Ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);\n      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n      //South Pole case\n      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"]);\n      Ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);\n      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //Default case\n      tanphi = sinphi / cosphi;\n      Nl1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.a, this.e, this.sin_p12);\n      Nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.a, this.e, sinphi);\n      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));\n      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));\n      if (Az === 0) {\n        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else if (Math.abs(Math.abs(Az) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else {\n        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));\n      }\n      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);\n      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);\n      GH = G * H;\n      Hs = H * H;\n      s2 = s * s;\n      s3 = s2 * s;\n      s4 = s3 * s;\n      s5 = s4 * s;\n      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);\n      p.x = this.x0 + c * Math.sin(Az);\n      p.y = this.y0 + c * Math.cos(Az);\n      return p;\n    }\n  }\n\n\n}\n\nfunction inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;\n  if (this.sphere) {\n    rh = Math.sqrt(p.x * p.x + p.y * p.y);\n    if (rh > (2 * _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"] * this.a)) {\n      return;\n    }\n    z = rh / this.a;\n\n    sinz = Math.sin(z);\n    cosz = Math.cos(z);\n\n    lon = this.long0;\n    if (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n      lat = this.lat0;\n    }\n    else {\n      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);\n      con = Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"];\n      if (Math.abs(con) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n        if (this.lat0 >= 0) {\n          lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + Math.atan2(p.x, - p.y));\n        }\n        else {\n          lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 - Math.atan2(-p.x, p.y));\n        }\n      }\n      else {\n        /*con = cosz - this.sin_p12 * Math.sin(lat);\n        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {\n          //no-op, just keep the lon value as is\n        } else {\n          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));\n          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));\n        }*/\n        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));\n      }\n    }\n\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.es);\n    e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.es);\n    e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.es);\n    e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n      //North pole case\n      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"]);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = Mlp - rh;\n      lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(M / this.a, e0, e1, e2, e3);\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n      //South pole case\n      Mlp = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(e0, e1, e2, e3, _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"]);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = rh - Mlp;\n\n      lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(M / this.a, e0, e1, e2, e3);\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + Math.atan2(p.x, p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else {\n      //default case\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      Az = Math.atan2(p.x, p.y);\n      N1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.a, this.e, this.sin_p12);\n      cosAz = Math.cos(Az);\n      tmp = this.e * this.cos_p12 * cosAz;\n      A = -tmp * tmp / (1 - this.es);\n      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);\n      D = rh / N1;\n      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;\n      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;\n      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));\n      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n  }\n\n}\n\nvar names = [\"Azimuthal_Equidistant\", \"aeqd\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/aeqd.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/cass.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/cass.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/mlfn */ \"./node_modules/proj4/lib/common/mlfn.js\");\n/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e0fn */ \"./node_modules/proj4/lib/common/e0fn.js\");\n/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e1fn */ \"./node_modules/proj4/lib/common/e1fn.js\");\n/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e2fn */ \"./node_modules/proj4/lib/common/e2fn.js\");\n/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/e3fn */ \"./node_modules/proj4/lib/common/e3fn.js\");\n/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/gN */ \"./node_modules/proj4/lib/common/gN.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/adjust_lat */ \"./node_modules/proj4/lib/common/adjust_lat.js\");\n/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/imlfn */ \"./node_modules/proj4/lib/common/imlfn.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n\n\n\n\n\n\n\n\n\nfunction init() {\n  if (!this.sphere) {\n    this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.es);\n    this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.es);\n    this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.es);\n    this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.es);\n    this.ml0 = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  }\n}\n\n/* Cassini forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nfunction forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y;\n  var lam = p.x;\n  var phi = p.y;\n  lam = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(lam - this.long0);\n\n  if (this.sphere) {\n    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));\n    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);\n  }\n  else {\n    //ellipsoid\n    var sinphi = Math.sin(phi);\n    var cosphi = Math.cos(phi);\n    var nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.a, this.e, sinphi);\n    var tl = Math.tan(phi) * Math.tan(phi);\n    var al = lam * Math.cos(phi);\n    var asq = al * al;\n    var cl = this.es * cosphi * cosphi / (1 - this.es);\n    var ml = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e0, this.e1, this.e2, this.e3, phi);\n\n    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));\n    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);\n\n\n  }\n\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nfunction inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var phi, lam;\n\n  if (this.sphere) {\n    var dd = y + this.lat0;\n    phi = Math.asin(Math.sin(dd) * Math.cos(x));\n    lam = Math.atan2(Math.tan(x), Math.cos(dd));\n  }\n  else {\n    /* ellipsoid */\n    var ml1 = this.ml0 / this.a + y;\n    var phi1 = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(ml1, this.e0, this.e1, this.e2, this.e3);\n    if (Math.abs(Math.abs(phi1) - _constants_values__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_9__[\"EPSLN\"]) {\n      p.x = this.long0;\n      p.y = _constants_values__WEBPACK_IMPORTED_MODULE_9__[\"HALF_PI\"];\n      if (y < 0) {\n        p.y *= -1;\n      }\n      return p;\n    }\n    var nl1 = Object(_common_gN__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.a, this.e, Math.sin(phi1));\n\n    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);\n    var tl1 = Math.pow(Math.tan(phi1), 2);\n    var dl = x * this.a / nl1;\n    var dsq = dl * dl;\n    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);\n    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);\n\n  }\n\n  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(lam + this.long0);\n  p.y = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(phi);\n  return p;\n\n}\n\nvar names = [\"Cassini\", \"Cassini_Soldner\", \"cass\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/cass.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/cea.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/cea.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ \"./node_modules/proj4/lib/common/qsfnz.js\");\n/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/msfnz */ \"./node_modules/proj4/lib/common/msfnz.js\");\n/* harmony import */ var _common_iqsfnz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/iqsfnz */ \"./node_modules/proj4/lib/common/iqsfnz.js\");\n\n\n\n\n\n/*\n  reference:\n    \"Cartographic Projection Procedures for the UNIX Environment-\n    A User's Manual\" by Gerald I. Evenden,\n    USGS Open File Report 90-284and Release 4 Interim Reports (2003)\n*/\nfunction init() {\n  //no-op\n  if (!this.sphere) {\n    this.k0 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n  }\n}\n\n/* Cylindrical Equal Area forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y;\n  /* Forward equations\n      -----------------*/\n  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n  if (this.sphere) {\n    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);\n    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);\n  }\n  else {\n    var qs = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e, Math.sin(lat));\n    x = this.x0 + this.a * this.k0 * dlon;\n    y = this.y0 + this.a * qs * 0.5 / this.k0;\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nfunction inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));\n    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));\n  }\n  else {\n    lat = Object(_common_iqsfnz__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.e, 2 * p.y * this.k0 / this.a);\n    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + p.x / (this.a * this.k0));\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"cea\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/cea.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/eqc.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/eqc.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lat */ \"./node_modules/proj4/lib/common/adjust_lat.js\");\n\n\n\nfunction init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Equidistant Cylindrical (Plate Carre)\";\n\n  this.rc = Math.cos(this.lat_ts);\n}\n\n// forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nfunction forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n  var dlat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(lat - this.lat0);\n  p.x = this.x0 + (this.a * dlon * this.rc);\n  p.y = this.y0 + (this.a * dlat);\n  return p;\n}\n\n// inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nfunction inverse(p) {\n\n  var x = p.x;\n  var y = p.y;\n\n  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + ((x - this.x0) / (this.a * this.rc)));\n  p.y = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.lat0 + ((y - this.y0) / (this.a)));\n  return p;\n}\n\nvar names = [\"Equirectangular\", \"Equidistant_Cylindrical\", \"eqc\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/eqc.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/eqdc.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/eqdc.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/e0fn */ \"./node_modules/proj4/lib/common/e0fn.js\");\n/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e1fn */ \"./node_modules/proj4/lib/common/e1fn.js\");\n/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e2fn */ \"./node_modules/proj4/lib/common/e2fn.js\");\n/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e3fn */ \"./node_modules/proj4/lib/common/e3fn.js\");\n/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/msfnz */ \"./node_modules/proj4/lib/common/msfnz.js\");\n/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/mlfn */ \"./node_modules/proj4/lib/common/mlfn.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/adjust_lat */ \"./node_modules/proj4/lib/common/adjust_lat.js\");\n/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/imlfn */ \"./node_modules/proj4/lib/common/imlfn.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n\n\n\n\n\n\n\n\n\nfunction init() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__[\"EPSLN\"]) {\n    return;\n  }\n  this.lat2 = this.lat2 || this.lat1;\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e = Math.sqrt(this.es);\n  this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.es);\n  this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.es);\n  this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.es);\n  this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.es);\n\n  this.sinphi = Math.sin(this.lat1);\n  this.cosphi = Math.cos(this.lat1);\n\n  this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.e, this.sinphi, this.cosphi);\n  this.ml1 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.e0, this.e1, this.e2, this.e3, this.lat1);\n\n  if (Math.abs(this.lat1 - this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__[\"EPSLN\"]) {\n    this.ns = this.sinphi;\n  }\n  else {\n    this.sinphi = Math.sin(this.lat2);\n    this.cosphi = Math.cos(this.lat2);\n    this.ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.e, this.sinphi, this.cosphi);\n    this.ml2 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.e0, this.e1, this.e2, this.e3, this.lat2);\n    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);\n  }\n  this.g = this.ml1 + this.ms1 / this.ns;\n  this.ml0 = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  this.rh = this.a * (this.g - this.ml0);\n}\n\n/* Equidistant Conic forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------*/\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var rh1;\n\n  /* Forward equations\n      -----------------*/\n  if (this.sphere) {\n    rh1 = this.a * (this.g - lat);\n  }\n  else {\n    var ml = Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.e0, this.e1, this.e2, this.e3, lat);\n    rh1 = this.a * (this.g - ml);\n  }\n  var theta = this.ns * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(lon - this.long0);\n  var x = this.x0 + rh1 * Math.sin(theta);\n  var y = this.y0 + this.rh - rh1 * Math.cos(theta);\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nfunction inverse(p) {\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  var con, rh1, lat, lon;\n  if (this.ns >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n\n  if (this.sphere) {\n    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this.long0 + theta / this.ns);\n    lat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this.g - rh1 / this.a);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    var ml = this.g - rh1 / this.a;\n    lat = Object(_common_imlfn__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(ml, this.e0, this.e1, this.e2, this.e3);\n    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this.long0 + theta / this.ns);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n\n}\n\nvar names = [\"Equidistant_Conic\", \"eqdc\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/eqdc.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/etmerc.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/etmerc.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_sinh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/sinh */ \"./node_modules/proj4/lib/common/sinh.js\");\n/* harmony import */ var _common_hypot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/hypot */ \"./node_modules/proj4/lib/common/hypot.js\");\n/* harmony import */ var _common_asinhy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/asinhy */ \"./node_modules/proj4/lib/common/asinhy.js\");\n/* harmony import */ var _common_gatg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/gatg */ \"./node_modules/proj4/lib/common/gatg.js\");\n/* harmony import */ var _common_clens__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/clens */ \"./node_modules/proj4/lib/common/clens.js\");\n/* harmony import */ var _common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/clens_cmplx */ \"./node_modules/proj4/lib/common/clens_cmplx.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n// Heavily based on this etmerc projection implementation\n// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js\n\n\n\n\n\n\n\n\n\nfunction init() {\n  if (this.es === undefined || this.es <= 0) {\n    throw new Error('incorrect elliptical usage');\n  }\n\n  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n  this.cgb = [];\n  this.cbg = [];\n  this.utg = [];\n  this.gtu = [];\n\n  var f = this.es / (1 + Math.sqrt(1 - this.es));\n  var n = f / (2 - f);\n  var np = n;\n\n  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));\n  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));\n\n  np = np * n;\n  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));\n  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));\n\n  np = np * n;\n  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));\n  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));\n\n  np = np * n;\n  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));\n  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));\n\n  np = np * n;\n  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));\n  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));\n\n  np = np * n;\n  this.cgb[5] = np * (601676 / 22275);\n  this.cbg[5] = np * (444337 / 155925);\n\n  np = Math.pow(n, 2);\n  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));\n\n  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));\n  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));\n\n  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));\n  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));\n\n  np = np * n;\n  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));\n  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));\n\n  np = np * n;\n  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));\n  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));\n\n  np = np * n;\n  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));\n  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));\n\n  np = np * n;\n  this.utg[5] = np * (-20648693 / 638668800);\n  this.gtu[5] = np * (212378941 / 319334400);\n\n  var Z = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.cbg, this.lat0);\n  this.Zb = -this.Qn * (Z + Object(_common_clens__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.gtu, 2 * Z));\n}\n\nfunction forward(p) {\n  var Ce = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(p.x - this.long0);\n  var Cn = p.y;\n\n  Cn = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.cbg, Cn);\n  var sin_Cn = Math.sin(Cn);\n  var cos_Cn = Math.cos(Cn);\n  var sin_Ce = Math.sin(Ce);\n  var cos_Ce = Math.cos(Ce);\n\n  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);\n  Ce = Math.atan2(sin_Ce * cos_Cn, Object(_common_hypot__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(sin_Cn, cos_Cn * cos_Ce));\n  Ce = Object(_common_asinhy__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Math.tan(Ce));\n\n  var tmp = Object(_common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.gtu, 2 * Cn, 2 * Ce);\n\n  Cn = Cn + tmp[0];\n  Ce = Ce + tmp[1];\n\n  var x;\n  var y;\n\n  if (Math.abs(Ce) <= 2.623395162778) {\n    x = this.a * (this.Qn * Ce) + this.x0;\n    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;\n  }\n  else {\n    x = Infinity;\n    y = Infinity;\n  }\n\n  p.x = x;\n  p.y = y;\n\n  return p;\n}\n\nfunction inverse(p) {\n  var Ce = (p.x - this.x0) * (1 / this.a);\n  var Cn = (p.y - this.y0) * (1 / this.a);\n\n  Cn = (Cn - this.Zb) / this.Qn;\n  Ce = Ce / this.Qn;\n\n  var lon;\n  var lat;\n\n  if (Math.abs(Ce) <= 2.623395162778) {\n    var tmp = Object(_common_clens_cmplx__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.utg, 2 * Cn, 2 * Ce);\n\n    Cn = Cn + tmp[0];\n    Ce = Ce + tmp[1];\n    Ce = Math.atan(Object(_common_sinh__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Ce));\n\n    var sin_Cn = Math.sin(Cn);\n    var cos_Cn = Math.cos(Cn);\n    var sin_Ce = Math.sin(Ce);\n    var cos_Ce = Math.cos(Ce);\n\n    Cn = Math.atan2(sin_Cn * cos_Ce, Object(_common_hypot__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(sin_Ce, cos_Ce * cos_Cn));\n    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);\n\n    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(Ce + this.long0);\n    lat = Object(_common_gatg__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.cgb, Cn);\n  }\n  else {\n    lon = Infinity;\n    lat = Infinity;\n  }\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nvar names = [\"Extended_Transverse_Mercator\", \"Extended Transverse Mercator\", \"etmerc\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/etmerc.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/gauss.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/gauss.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_srat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/srat */ \"./node_modules/proj4/lib/common/srat.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\nvar MAX_ITER = 20;\n\n\nfunction init() {\n  var sphi = Math.sin(this.lat0);\n  var cphi = Math.cos(this.lat0);\n  cphi *= cphi;\n  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);\n  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));\n  this.phic0 = Math.asin(sphi / this.C);\n  this.ratexp = 0.5 * this.C * this.e;\n  this.K = Math.tan(0.5 * this.phic0 + _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"FORTPI\"]) / (Math.pow(Math.tan(0.5 * this.lat0 + _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"FORTPI\"]), this.C) * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e * sphi, this.ratexp));\n}\n\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"FORTPI\"]), this.C) * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e * Math.sin(lat), this.ratexp)) - _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"];\n  p.x = this.C * lon;\n  return p;\n}\n\nfunction inverse(p) {\n  var DEL_TOL = 1e-14;\n  var lon = p.x / this.C;\n  var lat = p.y;\n  var num = Math.pow(Math.tan(0.5 * lat + _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"FORTPI\"]) / this.K, 1 / this.C);\n  for (var i = MAX_ITER; i > 0; --i) {\n    lat = 2 * Math.atan(num * Object(_common_srat__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e * Math.sin(p.y), - 0.5 * this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"];\n    if (Math.abs(lat - p.y) < DEL_TOL) {\n      break;\n    }\n    p.y = lat;\n  }\n  /* convergence failed */\n  if (!i) {\n    return null;\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"gauss\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/gauss.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/geocent.js":
/*!*******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/geocent.js ***!
  \*******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _datumUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../datumUtils */ \"./node_modules/proj4/lib/datumUtils.js\");\n\n\nfunction init() {\n    this.name = 'geocent';\n\n}\n\nfunction forward(p) {\n    var point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_0__[\"geodeticToGeocentric\"])(p, this.es, this.a);\n    return point;\n}\n\nfunction inverse(p) {\n    var point = Object(_datumUtils__WEBPACK_IMPORTED_MODULE_0__[\"geocentricToGeodetic\"])(p, this.es, this.a, this.b);\n    return point;\n}\n\nvar names = [\"Geocentric\", 'geocentric', \"geocent\", \"Geocent\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    init: init,\n    forward: forward,\n    inverse: inverse,\n    names: names\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/geocent.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/gnom.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/gnom.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/asinz */ \"./node_modules/proj4/lib/common/asinz.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n\n\n/*\n  reference:\n    Wolfram Mathworld \"Gnomonic Projection\"\n    http://mathworld.wolfram.com/GnomonicProjection.html\n    Accessed: 12th November 2009\n  */\nfunction init() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n  // Approximation for projecting points to the horizon (infinity)\n  this.infinity_dist = 1000 * this.a;\n  this.rc = 1;\n}\n\n/* Gnomonic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nfunction forward(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g;\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__[\"EPSLN\"])) {\n    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;\n  }\n  else {\n\n    // Point is in the opposing hemisphere and is unprojectable\n    // We still need to return a reasonable point, so we project\n    // to infinity, on a bearing\n    // equivalent to the northern hemisphere equivalent\n    // This is a reasonable approximation for short shapes and lines that\n    // straddle the horizon.\n\n    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction inverse(p) {\n  var rh; /* Rho */\n  var sinc, cosc;\n  var c;\n  var lon, lat;\n\n  /* Inverse equations\n      -----------------*/\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n\n  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    c = Math.atan2(rh, this.rc);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n\n    lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);\n    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);\n    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + lon);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"gnom\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/gnom.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/krovak.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/krovak.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n\n\nfunction init() {\n  this.a = 6377397.155;\n  this.es = 0.006674372230614;\n  this.e = Math.sqrt(this.es);\n  if (!this.lat0) {\n    this.lat0 = 0.863937979737193;\n  }\n  if (!this.long0) {\n    this.long0 = 0.7417649320975901 - 0.308341501185665;\n  }\n  /* if scale not set default to 0.9999 */\n  if (!this.k0) {\n    this.k0 = 0.9999;\n  }\n  this.s45 = 0.785398163397448; /* 45 */\n  this.s90 = 2 * this.s45;\n  this.fi0 = this.lat0;\n  this.e2 = this.es;\n  this.e = Math.sqrt(this.e2);\n  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));\n  this.uq = 1.04216856380474;\n  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);\n  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);\n  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;\n  this.k1 = this.k0;\n  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));\n  this.s0 = 1.37008346281555;\n  this.n = Math.sin(this.s0);\n  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);\n  this.ad = this.s90 - this.uq;\n}\n\n/* ellipsoid */\n/* calculate xy from lat/lon */\n/* Constants, identical to inverse transform function */\nfunction forward(p) {\n  var gfi, u, deltav, s, d, eps, ro;\n  var lon = p.x;\n  var lat = p.y;\n  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n  /* Transformation */\n  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));\n  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);\n  deltav = -delta_lon * this.alfa;\n  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));\n  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));\n  eps = this.n * d;\n  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);\n  p.y = ro * Math.cos(eps) / 1;\n  p.x = ro * Math.sin(eps) / 1;\n\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  return (p);\n}\n\n/* calculate lat/lon from xy */\nfunction inverse(p) {\n  var u, deltav, s, d, eps, ro, fi1;\n  var ok;\n\n  /* Transformation */\n  /* revert y, x*/\n  var tmp = p.x;\n  p.x = p.y;\n  p.y = tmp;\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  ro = Math.sqrt(p.x * p.x + p.y * p.y);\n  eps = Math.atan2(p.y, p.x);\n  d = eps / Math.sin(this.s0);\n  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);\n  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));\n  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));\n  p.x = this.long0 - deltav / this.alfa;\n  fi1 = u;\n  ok = 0;\n  var iter = 0;\n  do {\n    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);\n    if (Math.abs(fi1 - p.y) < 0.0000000001) {\n      ok = 1;\n    }\n    fi1 = p.y;\n    iter += 1;\n  } while (ok === 0 && iter < 15);\n  if (iter >= 15) {\n    return null;\n  }\n\n  return (p);\n}\n\nvar names = [\"Krovak\", \"krovak\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/krovak.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/laea.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/laea.js ***!
  \****************************************************/
/*! exports provided: S_POLE, N_POLE, EQUIT, OBLIQ, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"S_POLE\", function() { return S_POLE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"N_POLE\", function() { return N_POLE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EQUIT\", function() { return EQUIT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OBLIQ\", function() { return OBLIQ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/qsfnz */ \"./node_modules/proj4/lib/common/qsfnz.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n\n\n\n\n\n\n/*\n  reference\n    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\nvar S_POLE = 1;\n\nvar N_POLE = 2;\nvar EQUIT = 3;\nvar OBLIQ = 4;\n\n/* Initialize the Lambert Azimuthal Equal Area projection\n  ------------------------------------------------------*/\nfunction init() {\n  var t = Math.abs(this.lat0);\n  if (Math.abs(t - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]) < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n  }\n  else if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n    this.mode = this.EQUIT;\n  }\n  else {\n    this.mode = this.OBLIQ;\n  }\n  if (this.es > 0) {\n    var sinphi;\n\n    this.qp = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e, 1);\n    this.mmf = 0.5 / (1 - this.es);\n    this.apa = authset(this.es);\n    switch (this.mode) {\n    case this.N_POLE:\n      this.dd = 1;\n      break;\n    case this.S_POLE:\n      this.dd = 1;\n      break;\n    case this.EQUIT:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      this.dd = 1 / this.rq;\n      this.xmf = 1;\n      this.ymf = 0.5 * this.qp;\n      break;\n    case this.OBLIQ:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      sinphi = Math.sin(this.lat0);\n      this.sinb1 = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e, sinphi) / this.qp;\n      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n      this.ymf = (this.xmf = this.rq) / this.dd;\n      this.xmf *= this.dd;\n      break;\n    }\n  }\n  else {\n    if (this.mode === this.OBLIQ) {\n      this.sinph0 = Math.sin(this.lat0);\n      this.cosph0 = Math.cos(this.lat0);\n    }\n  }\n}\n\n/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nfunction forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;\n  var lam = p.x;\n  var phi = p.y;\n\n  lam = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(lam - this.long0);\n  if (this.sphere) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    coslam = Math.cos(lam);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n      if (y <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n        return null;\n      }\n      y = Math.sqrt(2 / y);\n      x = y * cosphi * Math.sin(lam);\n      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        coslam = -coslam;\n      }\n      if (Math.abs(phi + this.phi0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n        return null;\n      }\n      y = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] - phi * 0.5;\n      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));\n      x = y * Math.sin(lam);\n      y *= coslam;\n    }\n  }\n  else {\n    sinb = 0;\n    cosb = 0;\n    b = 0;\n    coslam = Math.cos(lam);\n    sinlam = Math.sin(lam);\n    sinphi = Math.sin(phi);\n    q = Object(_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e, sinphi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinb = q / this.qp;\n      cosb = Math.sqrt(1 - sinb * sinb);\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n      break;\n    case this.EQUIT:\n      b = 1 + cosb * coslam;\n      break;\n    case this.N_POLE:\n      b = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + phi;\n      q = this.qp - q;\n      break;\n    case this.S_POLE:\n      b = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n      q = this.qp + q;\n      break;\n    }\n    if (Math.abs(b) < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n      return null;\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n    case this.EQUIT:\n      b = Math.sqrt(2 / b);\n      if (this.mode === this.OBLIQ) {\n        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n      }\n      else {\n        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n      }\n      x = this.xmf * b * cosb * sinlam;\n      break;\n    case this.N_POLE:\n    case this.S_POLE:\n      if (q >= 0) {\n        x = (b = Math.sqrt(q)) * sinlam;\n        y = coslam * ((this.mode === this.S_POLE) ? b : -b);\n      }\n      else {\n        x = y = 0;\n      }\n      break;\n    }\n  }\n\n  p.x = this.a * x + this.x0;\n  p.y = this.a * y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nfunction inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var lam, phi, cCe, sCe, q, rho, ab;\n  if (this.sphere) {\n    var cosz = 0,\n      rh, sinz = 0;\n\n    rh = Math.sqrt(x * x + y * y);\n    phi = rh * 0.5;\n    if (phi > 1) {\n      return null;\n    }\n    phi = 2 * Math.asin(phi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinz = Math.sin(phi);\n      cosz = Math.cos(phi);\n    }\n    switch (this.mode) {\n    case this.EQUIT:\n      phi = (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) ? 0 : Math.asin(y * sinz / rh);\n      x *= sinz;\n      y = cosz * rh;\n      break;\n    case this.OBLIQ:\n      phi = (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);\n      x *= sinz * this.cosph0;\n      y = (cosz - Math.sin(phi) * this.sinph0) * rh;\n      break;\n    case this.N_POLE:\n      y = -y;\n      phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] - phi;\n      break;\n    case this.S_POLE:\n      phi -= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n      break;\n    }\n    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);\n  }\n  else {\n    ab = 0;\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      x /= this.dd;\n      y *= this.dd;\n      rho = Math.sqrt(x * x + y * y);\n      if (rho < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n        p.x = 0;\n        p.y = this.phi0;\n        return p;\n      }\n      sCe = 2 * Math.asin(0.5 * rho / this.rq);\n      cCe = Math.cos(sCe);\n      x *= (sCe = Math.sin(sCe));\n      if (this.mode === this.OBLIQ) {\n        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;\n        q = this.qp * ab;\n        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;\n      }\n      else {\n        ab = y * sCe / rho;\n        q = this.qp * ab;\n        y = rho * cCe;\n      }\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        y = -y;\n      }\n      q = (x * x + y * y);\n      if (!q) {\n        p.x = 0;\n        p.y = this.phi0;\n        return p;\n      }\n      ab = 1 - q / this.qp;\n      if (this.mode === this.S_POLE) {\n        ab = -ab;\n      }\n    }\n    lam = Math.atan2(x, y);\n    phi = authlat(Math.asin(ab), this.apa);\n  }\n\n  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.long0 + lam);\n  p.y = phi;\n  return p;\n}\n\n/* determine latitude from authalic latitude */\nvar P00 = 0.33333333333333333333;\n\nvar P01 = 0.17222222222222222222;\nvar P02 = 0.10257936507936507936;\nvar P10 = 0.06388888888888888888;\nvar P11 = 0.06640211640211640211;\nvar P20 = 0.01641501294219154443;\n\nfunction authset(es) {\n  var t;\n  var APA = [];\n  APA[0] = es * P00;\n  t = es * es;\n  APA[0] += t * P01;\n  APA[1] = t * P10;\n  t *= es;\n  APA[0] += t * P02;\n  APA[1] += t * P11;\n  APA[2] = t * P20;\n  return APA;\n}\n\nfunction authlat(beta, APA) {\n  var t = beta + beta;\n  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));\n}\n\nvar names = [\"Lambert Azimuthal Equal Area\", \"Lambert_Azimuthal_Equal_Area\", \"laea\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  S_POLE: S_POLE,\n  N_POLE: N_POLE,\n  EQUIT: EQUIT,\n  OBLIQ: OBLIQ\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/laea.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/lcc.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/lcc.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ \"./node_modules/proj4/lib/common/msfnz.js\");\n/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/tsfnz */ \"./node_modules/proj4/lib/common/tsfnz.js\");\n/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/sign */ \"./node_modules/proj4/lib/common/sign.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/phi2z */ \"./node_modules/proj4/lib/common/phi2z.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n\n\n\n\nfunction init() {\n\n  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north\n  //double c_lat;                   /* center latitude                      */\n  //double c_lon;                   /* center longitude                     */\n  //double lat1;                    /* first standard parallel              */\n  //double lat2;                    /* second standard parallel             */\n  //double r_maj;                   /* major axis                           */\n  //double r_min;                   /* minor axis                           */\n  //double false_east;              /* x offset in meters                   */\n  //double false_north;             /* y offset in meters                   */\n\n  if (!this.lat2) {\n    this.lat2 = this.lat1;\n  } //if lat2 is not defined\n  if (!this.k0) {\n    this.k0 = 1;\n  }\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"EPSLN\"]) {\n    return;\n  }\n\n  var temp = this.b / this.a;\n  this.e = Math.sqrt(1 - temp * temp);\n\n  var sin1 = Math.sin(this.lat1);\n  var cos1 = Math.cos(this.lat1);\n  var ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e, sin1, cos1);\n  var ts1 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e, this.lat1, sin1);\n\n  var sin2 = Math.sin(this.lat2);\n  var cos2 = Math.cos(this.lat2);\n  var ms2 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e, sin2, cos2);\n  var ts2 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e, this.lat2, sin2);\n\n  var ts0 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e, this.lat0, Math.sin(this.lat0));\n\n  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"EPSLN\"]) {\n    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n  }\n  else {\n    this.ns = sin1;\n  }\n  if (isNaN(this.ns)) {\n    this.ns = sin1;\n  }\n  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n  if (!this.title) {\n    this.title = \"Lambert Conformal Conic\";\n  }\n}\n\n// Lambert Conformal conic forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nfunction forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  // singular cases :\n  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"EPSLN\"]) {\n    lat = Object(_common_sign__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(lat) * (_constants_values__WEBPACK_IMPORTED_MODULE_5__[\"HALF_PI\"] - 2 * _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"EPSLN\"]);\n  }\n\n  var con = Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"HALF_PI\"]);\n  var ts, rh1;\n  if (con > _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"EPSLN\"]) {\n    ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.e, lat, Math.sin(lat));\n    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n  }\n  else {\n    con = lat * this.ns;\n    if (con <= 0) {\n      return null;\n    }\n    rh1 = 0;\n  }\n  var theta = this.ns * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(lon - this.long0);\n  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n\n  return p;\n}\n\n// Lambert Conformal Conic inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nfunction inverse(p) {\n\n  var rh1, con, ts;\n  var lat, lon;\n  var x = (p.x - this.x0) / this.k0;\n  var y = (this.rh - (p.y - this.y0) / this.k0);\n  if (this.ns > 0) {\n    rh1 = Math.sqrt(x * x + y * y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(x * x + y * y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2((con * x), (con * y));\n  }\n  if ((rh1 !== 0) || (this.ns > 0)) {\n    con = 1 / this.ns;\n    ts = Math.pow((rh1 / (this.a * this.f0)), con);\n    lat = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  else {\n    lat = -_constants_values__WEBPACK_IMPORTED_MODULE_5__[\"HALF_PI\"];\n  }\n  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(theta / this.ns + this.long0);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"Lambert Tangential Conformal Conic Projection\", \"Lambert_Conformal_Conic\", \"Lambert_Conformal_Conic_2SP\", \"lcc\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/lcc.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/longlat.js":
/*!*******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/longlat.js ***!
  \*******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\nfunction init() {\n  //no-op for longlat\n}\n\nfunction identity(pt) {\n  return pt;\n}\n\n\nvar names = [\"longlat\", \"identity\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: identity,\n  inverse: identity,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/longlat.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/merc.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/merc.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/msfnz */ \"./node_modules/proj4/lib/common/msfnz.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/tsfnz */ \"./node_modules/proj4/lib/common/tsfnz.js\");\n/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/phi2z */ \"./node_modules/proj4/lib/common/phi2z.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n\n\n\n\nfunction init() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if(!('x0' in this)){\n    this.x0 = 0;\n  }\n  if(!('y0' in this)){\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    }\n    else {\n      this.k0 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  }\n  else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      }\n      else {\n        this.k0 = 1;\n      }\n    }\n  }\n}\n\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  // convert to radians\n  if (lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"R2D\"] > 90 && lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"R2D\"] < -90 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"R2D\"] > 180 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"R2D\"] < -180) {\n    return null;\n  }\n\n  var x, y;\n  if (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"EPSLN\"]) {\n    return null;\n  }\n  else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_4__[\"FORTPI\"] + 0.5 * lat));\n    }\n    else {\n      var sinphi = Math.sin(lat);\n      var ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n}\n\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\nfunction inverse(p) {\n\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"] - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  }\n  else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.long0 + x / (this.a * this.k0));\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/merc.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/mill.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/mill.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n\n\n/*\n  reference\n    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\n\n/* Initialize the Miller Cylindrical projection\n  -------------------------------------------*/\nfunction init() {\n  //no-op\n}\n\n/* Miller Cylindrical forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n  var x = this.x0 + this.a * dlon;\n  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Miller Cylindrical inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nfunction inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n\n  var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + p.x / this.a);\n  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"Miller_Cylindrical\", \"mill\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/mill.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/moll.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/moll.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\nfunction init() {}\n\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\nfunction forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n  while (true) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n      break;\n    }\n  }\n  theta /= 2;\n\n  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n       this is done here because of precision problems with \"cos(theta)\"\n       --------------------------------------------------------------------------*/\n  if (Math.PI / 2 - Math.abs(lat) < _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n    delta_lon = 0;\n  }\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction inverse(p) {\n  var theta;\n  var arg;\n\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n\n  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));\n  if (lon < (-Math.PI)) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"Mollweide\", \"moll\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/moll.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/nzmg.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/nzmg.js ***!
  \****************************************************/
/*! exports provided: iterations, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"iterations\", function() { return iterations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n/*\n  reference\n    Department of Land and Survey Technical Circular 1973/32\n      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf\n    OSG Technical Report 4.1\n      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf\n  */\n\n/**\n * iterations: Number of iterations to refine inverse transform.\n *     0 -> km accuracy\n *     1 -> m accuracy -- suitable for most mapping applications\n *     2 -> mm accuracy\n */\nvar iterations = 1;\n\nfunction init() {\n  this.A = [];\n  this.A[1] = 0.6399175073;\n  this.A[2] = -0.1358797613;\n  this.A[3] = 0.063294409;\n  this.A[4] = -0.02526853;\n  this.A[5] = 0.0117879;\n  this.A[6] = -0.0055161;\n  this.A[7] = 0.0026906;\n  this.A[8] = -0.001333;\n  this.A[9] = 0.00067;\n  this.A[10] = -0.00034;\n\n  this.B_re = [];\n  this.B_im = [];\n  this.B_re[1] = 0.7557853228;\n  this.B_im[1] = 0;\n  this.B_re[2] = 0.249204646;\n  this.B_im[2] = 0.003371507;\n  this.B_re[3] = -0.001541739;\n  this.B_im[3] = 0.041058560;\n  this.B_re[4] = -0.10162907;\n  this.B_im[4] = 0.01727609;\n  this.B_re[5] = -0.26623489;\n  this.B_im[5] = -0.36249218;\n  this.B_re[6] = -0.6870983;\n  this.B_im[6] = -1.1651967;\n\n  this.C_re = [];\n  this.C_im = [];\n  this.C_re[1] = 1.3231270439;\n  this.C_im[1] = 0;\n  this.C_re[2] = -0.577245789;\n  this.C_im[2] = -0.007809598;\n  this.C_re[3] = 0.508307513;\n  this.C_im[3] = -0.112208952;\n  this.C_re[4] = -0.15094762;\n  this.C_im[4] = 0.18200602;\n  this.C_re[5] = 1.01418179;\n  this.C_im[5] = 1.64497696;\n  this.C_re[6] = 1.9660549;\n  this.C_im[6] = 2.5127645;\n\n  this.D = [];\n  this.D[1] = 1.5627014243;\n  this.D[2] = 0.5185406398;\n  this.D[3] = -0.03333098;\n  this.D[4] = -0.1052906;\n  this.D[5] = -0.0368594;\n  this.D[6] = 0.007317;\n  this.D[7] = 0.01220;\n  this.D[8] = 0.00394;\n  this.D[9] = -0.0013;\n}\n\n/**\n    New Zealand Map Grid Forward  - long/lat to x/y\n    long/lat in radians\n  */\nfunction forward(p) {\n  var n;\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lat = lat - this.lat0;\n  var delta_lon = lon - this.long0;\n\n  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda\n  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.\n  var d_phi = delta_lat / _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SEC_TO_RAD\"] * 1E-5;\n  var d_lambda = delta_lon;\n  var d_phi_n = 1; // d_phi^0\n\n  var d_psi = 0;\n  for (n = 1; n <= 10; n++) {\n    d_phi_n = d_phi_n * d_phi;\n    d_psi = d_psi + this.A[n] * d_phi_n;\n  }\n\n  // 2. Calculate theta\n  var th_re = d_psi;\n  var th_im = d_lambda;\n\n  // 3. Calculate z\n  var th_n_re = 1;\n  var th_n_im = 0; // theta^0\n  var th_n_re1;\n  var th_n_im1;\n\n  var z_re = 0;\n  var z_im = 0;\n  for (n = 1; n <= 6; n++) {\n    th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n    th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n    th_n_re = th_n_re1;\n    th_n_im = th_n_im1;\n    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;\n    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;\n  }\n\n  // 4. Calculate easting and northing\n  p.x = (z_im * this.a) + this.x0;\n  p.y = (z_re * this.a) + this.y0;\n\n  return p;\n}\n\n/**\n    New Zealand Map Grid Inverse  -  x/y to long/lat\n  */\nfunction inverse(p) {\n  var n;\n  var x = p.x;\n  var y = p.y;\n\n  var delta_x = x - this.x0;\n  var delta_y = y - this.y0;\n\n  // 1. Calculate z\n  var z_re = delta_y / this.a;\n  var z_im = delta_x / this.a;\n\n  // 2a. Calculate theta - first approximation gives km accuracy\n  var z_n_re = 1;\n  var z_n_im = 0; // z^0\n  var z_n_re1;\n  var z_n_im1;\n\n  var th_re = 0;\n  var th_im = 0;\n  for (n = 1; n <= 6; n++) {\n    z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n    z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n    z_n_re = z_n_re1;\n    z_n_im = z_n_im1;\n    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;\n    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;\n  }\n\n  // 2b. Iterate to refine the accuracy of the calculation\n  //        0 iterations gives km accuracy\n  //        1 iteration gives m accuracy -- good enough for most mapping applications\n  //        2 iterations bives mm accuracy\n  for (var i = 0; i < this.iterations; i++) {\n    var th_n_re = th_re;\n    var th_n_im = th_im;\n    var th_n_re1;\n    var th_n_im1;\n\n    var num_re = z_re;\n    var num_im = z_im;\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    th_n_re = 1;\n    th_n_im = 0;\n    var den_re = this.B_re[1];\n    var den_im = this.B_im[1];\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    // Complex division\n    var den2 = den_re * den_re + den_im * den_im;\n    th_re = (num_re * den_re + num_im * den_im) / den2;\n    th_im = (num_im * den_re - num_re * den_im) / den2;\n  }\n\n  // 3. Calculate d_phi              ...                                    // and d_lambda\n  var d_psi = th_re;\n  var d_lambda = th_im;\n  var d_psi_n = 1; // d_psi^0\n\n  var d_phi = 0;\n  for (n = 1; n <= 9; n++) {\n    d_psi_n = d_psi_n * d_psi;\n    d_phi = d_phi + this.D[n] * d_psi_n;\n  }\n\n  // 4. Calculate latitude and longitude\n  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.\n  var lat = this.lat0 + (d_phi * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SEC_TO_RAD\"] * 1E5);\n  var lon = this.long0 + d_lambda;\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nvar names = [\"New_Zealand_Map_Grid\", \"nzmg\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/nzmg.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/omerc.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/omerc.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/tsfnz */ \"./node_modules/proj4/lib/common/tsfnz.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/phi2z */ \"./node_modules/proj4/lib/common/phi2z.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n\n\n\n/* Initialize the Oblique Mercator  projection\n    ------------------------------------------*/\nfunction init() {\n  this.no_off = this.no_off || false;\n  this.no_rot = this.no_rot || false;\n\n  if (isNaN(this.k0)) {\n    this.k0 = 1;\n  }\n  var sinlat = Math.sin(this.lat0);\n  var coslat = Math.cos(this.lat0);\n  var con = this.e * sinlat;\n\n  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));\n  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);\n  var t0 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e, this.lat0, sinlat);\n  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));\n  if (dl * dl < 1) {\n    dl = 1;\n  }\n  var fl;\n  var gl;\n  if (!isNaN(this.longc)) {\n    //Central point and azimuth method\n\n    if (this.lat0 >= 0) {\n      fl = dl + Math.sqrt(dl * dl - 1);\n    }\n    else {\n      fl = dl - Math.sqrt(dl * dl - 1);\n    }\n    this.el = fl * Math.pow(t0, this.bl);\n    gl = 0.5 * (fl - 1 / fl);\n    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);\n    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;\n\n  }\n  else {\n    //2 points method\n    var t1 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e, this.lat1, Math.sin(this.lat1));\n    var t2 = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e, this.lat2, Math.sin(this.lat2));\n    if (this.lat0 >= 0) {\n      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n    }\n    else {\n      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n    }\n    var hl = Math.pow(t1, this.bl);\n    var ll = Math.pow(t2, this.bl);\n    fl = this.el / hl;\n    gl = 0.5 * (fl - 1 / fl);\n    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);\n    var pl = (ll - hl) / (ll + hl);\n    var dlon12 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.long1 - this.long2);\n    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;\n    this.long0 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.long0);\n    var dlon10 = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.long1 - this.long0);\n    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);\n    this.alpha = Math.asin(dl * Math.sin(this.gamma0));\n  }\n\n  if (this.no_off) {\n    this.uc = 0;\n  }\n  else {\n    if (this.lat0 >= 0) {\n      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n    }\n    else {\n      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n    }\n  }\n\n}\n\n/* Oblique Mercator forward equations--mapping lat,long to x,y\n    ----------------------------------------------------------*/\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(lon - this.long0);\n  var us, vs;\n  var con;\n  if (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_3__[\"HALF_PI\"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__[\"EPSLN\"]) {\n    if (lat > 0) {\n      con = -1;\n    }\n    else {\n      con = 1;\n    }\n    vs = this.al / this.bl * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_3__[\"FORTPI\"] + con * this.gamma0 * 0.5));\n    us = -1 * con * _constants_values__WEBPACK_IMPORTED_MODULE_3__[\"HALF_PI\"] * this.al / this.bl;\n  }\n  else {\n    var t = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.e, lat, Math.sin(lat));\n    var ql = this.el / Math.pow(t, this.bl);\n    var sl = 0.5 * (ql - 1 / ql);\n    var tl = 0.5 * (ql + 1 / ql);\n    var vl = Math.sin(this.bl * (dlon));\n    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;\n    if (Math.abs(Math.abs(ul) - 1) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__[\"EPSLN\"]) {\n      vs = Number.POSITIVE_INFINITY;\n    }\n    else {\n      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;\n    }\n    if (Math.abs(Math.cos(this.bl * (dlon))) <= _constants_values__WEBPACK_IMPORTED_MODULE_3__[\"EPSLN\"]) {\n      us = this.al * this.bl * (dlon);\n    }\n    else {\n      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;\n    }\n  }\n\n  if (this.no_rot) {\n    p.x = this.x0 + us;\n    p.y = this.y0 + vs;\n  }\n  else {\n\n    us -= this.uc;\n    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);\n    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);\n  }\n  return p;\n}\n\nfunction inverse(p) {\n  var us, vs;\n  if (this.no_rot) {\n    vs = p.y - this.y0;\n    us = p.x - this.x0;\n  }\n  else {\n    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);\n    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);\n    us += this.uc;\n  }\n  var qp = Math.exp(-1 * this.bl * vs / this.al);\n  var sp = 0.5 * (qp - 1 / qp);\n  var tp = 0.5 * (qp + 1 / qp);\n  var vp = Math.sin(this.bl * us / this.al);\n  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;\n  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);\n  if (Math.abs(up - 1) < _constants_values__WEBPACK_IMPORTED_MODULE_3__[\"EPSLN\"]) {\n    p.x = this.long0;\n    p.y = _constants_values__WEBPACK_IMPORTED_MODULE_3__[\"HALF_PI\"];\n  }\n  else if (Math.abs(up + 1) < _constants_values__WEBPACK_IMPORTED_MODULE_3__[\"EPSLN\"]) {\n    p.x = this.long0;\n    p.y = -1 * _constants_values__WEBPACK_IMPORTED_MODULE_3__[\"HALF_PI\"];\n  }\n  else {\n    p.y = Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.e, ts);\n    p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);\n  }\n  return p;\n}\n\nvar names = [\"Hotine_Oblique_Mercator\", \"Hotine Oblique Mercator\", \"Hotine_Oblique_Mercator_Azimuth_Natural_Origin\", \"Hotine_Oblique_Mercator_Azimuth_Center\", \"omerc\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/omerc.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/ortho.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/ortho.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/asinz */ \"./node_modules/proj4/lib/common/asinz.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\n\n\nfunction init() {\n  //double temp;      /* temporary variable    */\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n}\n\n/* Orthographic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nfunction forward(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g, x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__[\"EPSLN\"])) {\n    x = this.a * ksp * cosphi * Math.sin(dlon);\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction inverse(p) {\n  var rh; /* height above ellipsoid      */\n  var z; /* angle          */\n  var sinz, cosz; /* sin of z and cos of z      */\n  var con;\n  var lon, lat;\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  rh = Math.sqrt(p.x * p.x + p.y * p.y);\n  z = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rh / this.a);\n\n  sinz = Math.sin(z);\n  cosz = Math.cos(z);\n\n  lon = this.long0;\n  if (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__[\"EPSLN\"]) {\n    lat = this.lat0;\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);\n  con = Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_2__[\"HALF_PI\"];\n  if (Math.abs(con) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__[\"EPSLN\"]) {\n    if (this.lat0 >= 0) {\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + Math.atan2(p.x, - p.y));\n    }\n    else {\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 - Math.atan2(-p.x, p.y));\n    }\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"ortho\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/ortho.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/poly.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/poly.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/e0fn */ \"./node_modules/proj4/lib/common/e0fn.js\");\n/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/e1fn */ \"./node_modules/proj4/lib/common/e1fn.js\");\n/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/e2fn */ \"./node_modules/proj4/lib/common/e2fn.js\");\n/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/e3fn */ \"./node_modules/proj4/lib/common/e3fn.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/adjust_lat */ \"./node_modules/proj4/lib/common/adjust_lat.js\");\n/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/mlfn */ \"./node_modules/proj4/lib/common/mlfn.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/gN */ \"./node_modules/proj4/lib/common/gN.js\");\n\n\n\n\n\n\n\n\n\n\nvar MAX_ITER = 20;\n\nfunction init() {\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles\n  this.e = Math.sqrt(this.es);\n  this.e0 = Object(_common_e0fn__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.es);\n  this.e1 = Object(_common_e1fn__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.es);\n  this.e2 = Object(_common_e2fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.es);\n  this.e3 = Object(_common_e3fn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.es);\n  this.ml0 = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas\n}\n\n/* Polyconic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y, el;\n  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(lon - this.long0);\n  el = dlon * Math.sin(lat);\n  if (this.sphere) {\n    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__[\"EPSLN\"]) {\n      x = this.a * dlon;\n      y = -1 * this.a * this.lat0;\n    }\n    else {\n      x = this.a * Math.sin(el) / Math.tan(lat);\n      y = this.a * (Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));\n    }\n  }\n  else {\n    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__[\"EPSLN\"]) {\n      x = this.a * dlon;\n      y = -1 * this.ml0;\n    }\n    else {\n      var nl = Object(_common_gN__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(this.a, this.e, Math.sin(lat)) / Math.tan(lat);\n      x = nl * Math.sin(el);\n      y = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));\n    }\n\n  }\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nfunction inverse(p) {\n  var lon, lat, x, y, i;\n  var al, bl;\n  var phi, dphi;\n  x = p.x - this.x0;\n  y = p.y - this.y0;\n\n  if (this.sphere) {\n    if (Math.abs(y + this.a * this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__[\"EPSLN\"]) {\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(x / this.a + this.long0);\n      lat = 0;\n    }\n    else {\n      al = this.lat0 + y / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var tanphi;\n      for (i = MAX_ITER; i; --i) {\n        tanphi = Math.tan(phi);\n        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);\n        phi += dphi;\n        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__[\"EPSLN\"]) {\n          lat = phi;\n          break;\n        }\n      }\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));\n    }\n  }\n  else {\n    if (Math.abs(y + this.ml0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__[\"EPSLN\"]) {\n      lat = 0;\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.long0 + x / this.a);\n    }\n    else {\n\n      al = (this.ml0 + y) / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var cl, mln, mlnp, ma;\n      var con;\n      for (i = MAX_ITER; i; --i) {\n        con = this.e * Math.sin(phi);\n        cl = Math.sqrt(1 - con * con) * Math.tan(phi);\n        mln = this.a * Object(_common_mlfn__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this.e0, this.e1, this.e2, this.e3, phi);\n        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);\n        ma = mln / this.a;\n        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);\n        phi -= dphi;\n        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__[\"EPSLN\"]) {\n          lat = phi;\n          break;\n        }\n      }\n\n      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);\n      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"Polyconic\", \"poly\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/poly.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/qsc.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/qsc.js ***!
  \***************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\n\n\n\n/* constants */\nvar FACE_ENUM = {\n    FRONT: 1,\n    RIGHT: 2,\n    BACK: 3,\n    LEFT: 4,\n    TOP: 5,\n    BOTTOM: 6\n};\n\nvar AREA_ENUM = {\n    AREA_0: 1,\n    AREA_1: 2,\n    AREA_2: 3,\n    AREA_3: 4\n};\n\nfunction init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n\n  /* Determine the cube face from the center of projection. */\n  if (this.lat0 >= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"]) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"]) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n}\n\n// QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nfunction forward(p) {\n  var xy = {x: 0, y: 0};\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n  var area = {value: 0};\n\n  // move lon according to projection's lon\n  p.x -= this.long0;\n\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n  if (this.es !== 0) {//if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n  lon = p.x; //lon = lp.lam;\n  if (this.face === FACE_ENUM.TOP) {\n    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] - lat;\n    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"]) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else if (lon > _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] || lon <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"])) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = (lon > 0.0 ? lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"] : lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]);\n    } else if (lon > -(_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"]) && lon <= -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"]) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + lat;\n    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"]) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else if (lon < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] && lon >= -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"]) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] && lon >= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"])) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = (lon > 0.0 ? -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"] : -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]);\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]);\n    }\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n  mu = Math.atan((12 / _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]) * (theta + Math.acos(Math.sin(theta) * Math.cos(_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"])) - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n\n  /* Apply the result to the real area. */\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"];\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"];\n  }\n\n  /* Now compute x, y from mu and nu */\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n}\n\n// QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nfunction inverse(p) {\n  var lp = {lam: 0, phi: 0};\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {value: 0};\n\n  /* de-offset */\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = (mu < 0.0 ? mu + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"] : mu - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]);\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n  }\n\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n  t = (_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"] / 12) * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] - phi;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = (theta < 0.0 ? theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"] : theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]);\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = theta;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = (theta < 0.0 ? -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"] : -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]);\n    }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n    t += s * s;\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n    lp.phi = Math.acos(-s) - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    lp.lam = Math.atan2(r, q);\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"]);\n    }\n  }\n\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = (lp.phi < 0 ? 1 : 0);\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n  if (phi < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n    if (Math.abs(theta) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"]) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] && theta <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"]) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"] || theta <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"FORTPI\"])) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = (theta >= 0.0 ? theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"] : theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]);\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    }\n  }\n  return theta;\n}\n\n/* Helper function: shift the longitude. */\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n  if (slon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]) {\n    slon += _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"];\n  } else if (slon > +_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"SPI\"]) {\n    slon -= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"TWO_PI\"];\n  }\n  return slon;\n}\n\nvar names = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/qsc.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/robin.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/robin.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n// Robinson projection\n// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c\n// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039\n\n\n\n\nvar COEFS_X = [\n    [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],\n    [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],\n    [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],\n    [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],\n    [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],\n    [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],\n    [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],\n    [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],\n    [0.9216, -0.00467746, -0.00010457, 4.81243e-06],\n    [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],\n    [0.8679, -0.00609363, -0.000113898, 3.32484e-06],\n    [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],\n    [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],\n    [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],\n    [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],\n    [0.6732, -0.00986209, -0.000199569, 1.91974e-05],\n    [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],\n    [0.5722, -0.00906601, 0.000182, 6.24051e-06],\n    [0.5322, -0.00677797, 0.000275608, 6.24051e-06]\n];\n\nvar COEFS_Y = [\n    [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],\n    [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],\n    [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],\n    [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],\n    [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],\n    [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],\n    [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],\n    [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],\n    [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],\n    [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],\n    [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],\n    [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],\n    [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],\n    [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],\n    [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],\n    [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],\n    [0.9394, 0.00840947, -0.000192841, -4.2106e-06],\n    [0.9761, 0.00616527, -0.000256, -4.2106e-06],\n    [1.0000, 0.00328947, -0.000319159, -4.2106e-06]\n];\n\nvar FXC = 0.8487;\nvar FYC = 1.3523;\nvar C1 = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"R2D\"]/5; // rad to 5-degree interval\nvar RC1 = 1/C1;\nvar NODES = 18;\n\nvar poly3_val = function(coefs, x) {\n    return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));\n};\n\nvar poly3_der = function(coefs, x) {\n    return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);\n};\n\nfunction newton_rapshon(f_df, start, max_err, iters) {\n    var x = start;\n    for (; iters; --iters) {\n        var upd = f_df(x);\n        x -= upd;\n        if (Math.abs(upd) < max_err) {\n            break;\n        }\n    }\n    return x;\n}\n\nfunction init() {\n    this.x0 = this.x0 || 0;\n    this.y0 = this.y0 || 0;\n    this.long0 = this.long0 || 0;\n    this.es = 0;\n    this.title = this.title || \"Robinson\";\n}\n\nfunction forward(ll) {\n    var lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ll.x - this.long0);\n\n    var dphi = Math.abs(ll.y);\n    var i = Math.floor(dphi * C1);\n    if (i < 0) {\n        i = 0;\n    } else if (i >= NODES) {\n        i = NODES - 1;\n    }\n    dphi = _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"R2D\"] * (dphi - RC1 * i);\n    var xy = {\n        x: poly3_val(COEFS_X[i], dphi) * lon,\n        y: poly3_val(COEFS_Y[i], dphi)\n    };\n    if (ll.y < 0) {\n        xy.y = -xy.y;\n    }\n\n    xy.x = xy.x * this.a * FXC + this.x0;\n    xy.y = xy.y * this.a * FYC + this.y0;\n    return xy;\n}\n\nfunction inverse(xy) {\n    var ll = {\n        x: (xy.x - this.x0) / (this.a * FXC),\n        y: Math.abs(xy.y - this.y0) / (this.a * FYC)\n    };\n\n    if (ll.y >= 1) { // pathologic case\n        ll.x /= COEFS_X[NODES][0];\n        ll.y = xy.y < 0 ? -_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] : _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    } else {\n        // find table interval\n        var i = Math.floor(ll.y * NODES);\n        if (i < 0) {\n            i = 0;\n        } else if (i >= NODES) {\n            i = NODES - 1;\n        }\n        for (;;) {\n            if (COEFS_Y[i][0] > ll.y) {\n                --i;\n            } else if (COEFS_Y[i+1][0] <= ll.y) {\n                ++i;\n            } else {\n                break;\n            }\n        }\n        // linear interpolation in 5 degree interval\n        var coefs = COEFS_Y[i];\n        var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);\n        // find t so that poly3_val(coefs, t) = ll.y\n        t = newton_rapshon(function(x) {\n            return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);\n        }, t, _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"], 100);\n\n        ll.x /= poly3_val(COEFS_X[i], t);\n        ll.y = (5 * i + t) * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"];\n        if (xy.y < 0) {\n            ll.y = -ll.y;\n        }\n    }\n\n    ll.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ll.x + this.long0);\n    return ll;\n}\n\nvar names = [\"Robinson\", \"robin\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/robin.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/sinu.js":
/*!****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/sinu.js ***!
  \****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lat */ \"./node_modules/proj4/lib/common/adjust_lat.js\");\n/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/pj_enfn */ \"./node_modules/proj4/lib/common/pj_enfn.js\");\n/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/pj_mlfn */ \"./node_modules/proj4/lib/common/pj_mlfn.js\");\n/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/pj_inv_mlfn */ \"./node_modules/proj4/lib/common/pj_inv_mlfn.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/asinz */ \"./node_modules/proj4/lib/common/asinz.js\");\n\n\n\nvar MAX_ITER = 20;\n\n\n\n\n\n\n\nfunction init() {\n  /* Place parameters in static storage for common use\n    -------------------------------------------------*/\n\n\n  if (!this.sphere) {\n    this.en = Object(_common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.es);\n  }\n  else {\n    this.n = 1;\n    this.m = 0;\n    this.es = 0;\n    this.C_y = Math.sqrt((this.m + 1) / this.n);\n    this.C_x = this.C_y / (this.m + 1);\n  }\n\n}\n\n/* Sinusoidal forward equations--mapping lat,long to x,y\n  -----------------------------------------------------*/\nfunction forward(p) {\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n    -----------------*/\n  lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n\n  if (this.sphere) {\n    if (!this.m) {\n      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n    }\n    else {\n      var k = this.n * Math.sin(lat);\n      for (var i = MAX_ITER; i; --i) {\n        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));\n        lat -= V;\n        if (Math.abs(V) < _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"EPSLN\"]) {\n          break;\n        }\n      }\n    }\n    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n    y = this.a * this.C_y * lat;\n\n  }\n  else {\n\n    var s = Math.sin(lat);\n    var c = Math.cos(lat);\n    y = this.a * Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(lat, s, c, this.en);\n    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nfunction inverse(p) {\n  var lat, temp, lon, s;\n\n  p.x -= this.x0;\n  lon = p.x / this.a;\n  p.y -= this.y0;\n  lat = p.y / this.a;\n\n  if (this.sphere) {\n    lat /= this.C_y;\n    lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n    if (this.m) {\n      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((this.m * lat + Math.sin(lat)) / this.n);\n    }\n    else if (this.n !== 1) {\n      lat = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(Math.sin(lat) / this.n);\n    }\n    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon + this.long0);\n    lat = Object(_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(lat);\n  }\n  else {\n    lat = Object(_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(p.y / this.a, this.es, this.en);\n    s = Math.abs(lat);\n    if (s < _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"HALF_PI\"]) {\n      s = Math.sin(lat);\n      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));\n      //temp = this.long0 + p.x / (this.a * Math.cos(lat));\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(temp);\n    }\n    else if ((s - _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"EPSLN\"]) < _constants_values__WEBPACK_IMPORTED_MODULE_5__[\"HALF_PI\"]) {\n      lon = this.long0;\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"Sinusoidal\", \"sinu\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/sinu.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/somerc.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/somerc.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/*\n  references:\n    Formules et constantes pour le Calcul pour la\n    projection cylindrique conforme à axe oblique et pour la transformation entre\n    des systèmes de référence.\n    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf\n  */\n\nfunction init() {\n  var phy0 = this.lat0;\n  this.lambda0 = this.long0;\n  var sinPhy0 = Math.sin(phy0);\n  var semiMajorAxis = this.a;\n  var invF = this.rf;\n  var flattening = 1 / invF;\n  var e2 = 2 * flattening - Math.pow(flattening, 2);\n  var e = this.e = Math.sqrt(e2);\n  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));\n  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));\n  this.b0 = Math.asin(sinPhy0 / this.alpha);\n  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));\n  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));\n  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));\n  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;\n}\n\nfunction forward(p) {\n  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));\n  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));\n  var S = -this.alpha * (Sa1 + Sa2) + this.K;\n\n  // spheric latitude\n  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);\n\n  // spheric longitude\n  var I = this.alpha * (p.x - this.lambda0);\n\n  // psoeudo equatorial rotation\n  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));\n\n  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));\n\n  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;\n  p.x = this.R * rotI + this.x0;\n  return p;\n}\n\nfunction inverse(p) {\n  var Y = p.x - this.x0;\n  var X = p.y - this.y0;\n\n  var rotI = Y / this.R;\n  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);\n\n  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));\n  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));\n\n  var lambda = this.lambda0 + I / this.alpha;\n\n  var S = 0;\n  var phy = b;\n  var prevPhy = -1000;\n  var iteration = 0;\n  while (Math.abs(phy - prevPhy) > 0.0000001) {\n    if (++iteration > 20) {\n      //...reportError(\"omercFwdInfinity\");\n      return;\n    }\n    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));\n    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));\n    prevPhy = phy;\n    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;\n  }\n\n  p.x = lambda;\n  p.y = phy;\n  return p;\n}\n\nvar names = [\"somerc\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/somerc.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/stere.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/stere.js ***!
  \*****************************************************/
/*! exports provided: ssfn_, init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ssfn_\", function() { return ssfn_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/sign */ \"./node_modules/proj4/lib/common/sign.js\");\n/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/msfnz */ \"./node_modules/proj4/lib/common/msfnz.js\");\n/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/tsfnz */ \"./node_modules/proj4/lib/common/tsfnz.js\");\n/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/phi2z */ \"./node_modules/proj4/lib/common/phi2z.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n\n\n\n\n\n\n\n\nfunction ssfn_(phit, sinphi, eccen) {\n  sinphi *= eccen;\n  return (Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));\n}\n\nfunction init() {\n  this.coslat0 = Math.cos(this.lat0);\n  this.sinlat0 = Math.sin(this.lat0);\n  if (this.sphere) {\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n      this.k0 = 0.5 * (1 + Object(_common_sign__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.lat0) * Math.sin(this.lat_ts));\n    }\n  }\n  else {\n    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n      if (this.lat0 > 0) {\n        //North pole\n        //trace('stere:north pole');\n        this.con = 1;\n      }\n      else {\n        //South pole\n        //trace('stere:south pole');\n        this.con = -1;\n      }\n    }\n    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n      this.k0 = 0.5 * this.cons * Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));\n    }\n    this.ms1 = Object(_common_msfnz__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.e, this.sinlat0, this.coslat0);\n    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    this.cosX0 = Math.cos(this.X0);\n    this.sinX0 = Math.sin(this.X0);\n  }\n}\n\n// Stereographic forward equations--mapping lat,long to x,y\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinlat = Math.sin(lat);\n  var coslat = Math.cos(lat);\n  var A, X, sinX, cosX, ts, rh;\n  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(lon - this.long0);\n\n  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"] && Math.abs(lat + this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n    //case of the origine point\n    //trace('stere:this is the origin point');\n    p.x = NaN;\n    p.y = NaN;\n    return p;\n  }\n  if (this.sphere) {\n    //trace('stere:sphere case');\n    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));\n    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;\n    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;\n    return p;\n  }\n  else {\n    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"];\n    cosX = Math.cos(X);\n    sinX = Math.sin(X);\n    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n      ts = Object(_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.e, lat * this.con, this.con * sinlat);\n      rh = 2 * this.a * this.k0 * ts / this.cons;\n      p.x = this.x0 + rh * Math.sin(lon - this.long0);\n      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);\n      //trace(p.toString());\n      return p;\n    }\n    else if (Math.abs(this.sinlat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n      //Eq\n      //trace('stere:equateur');\n      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));\n      p.y = A * sinX;\n    }\n    else {\n      //other case\n      //trace('stere:normal case');\n      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));\n      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;\n    }\n    p.x = A * cosX * Math.sin(dlon) + this.x0;\n  }\n  //trace(p.toString());\n  return p;\n}\n\n//* Stereographic inverse equations--mapping x,y to lat/long\nfunction inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat, ts, ce, Chi;\n  var rh = Math.sqrt(p.x * p.x + p.y * p.y);\n  if (this.sphere) {\n    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));\n    lon = this.long0;\n    lat = this.lat0;\n    if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);\n    if (Math.abs(this.coslat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n      if (this.lat0 > 0) {\n        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      }\n      else {\n        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.long0 + Math.atan2(p.x, p.y));\n      }\n    }\n    else {\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));\n    }\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n        lat = this.lat0;\n        lon = this.long0;\n        p.x = lon;\n        p.y = lat;\n        //trace(p.toString());\n        return p;\n      }\n      p.x *= this.con;\n      p.y *= this.con;\n      ts = rh * this.cons / (2 * this.a * this.k0);\n      lat = this.con * Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.e, ts);\n      lon = this.con * Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));\n    }\n    else {\n      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));\n      lon = this.long0;\n      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"EPSLN\"]) {\n        Chi = this.X0;\n      }\n      else {\n        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);\n        lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));\n      }\n      lat = -1 * Object(_common_phi2z__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.e, Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__[\"HALF_PI\"] + Chi)));\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n\n  //trace(p.toString());\n  return p;\n\n}\n\nvar names = [\"stere\", \"Stereographic_South_Pole\", \"Polar Stereographic (variant B)\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  ssfn_: ssfn_\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/stere.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/sterea.js":
/*!******************************************************!*\
  !*** ./node_modules/proj4/lib/projections/sterea.js ***!
  \******************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _gauss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gauss */ \"./node_modules/proj4/lib/projections/gauss.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n\n\n\nfunction init() {\n  _gauss__WEBPACK_IMPORTED_MODULE_0__[\"default\"].init.apply(this);\n  if (!this.rc) {\n    return;\n  }\n  this.sinc0 = Math.sin(this.phic0);\n  this.cosc0 = Math.cos(this.phic0);\n  this.R2 = 2 * this.rc;\n  if (!this.title) {\n    this.title = \"Oblique Stereographic Alternative\";\n  }\n}\n\nfunction forward(p) {\n  var sinc, cosc, cosl, k;\n  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(p.x - this.long0);\n  _gauss__WEBPACK_IMPORTED_MODULE_0__[\"default\"].forward.apply(this, [p]);\n  sinc = Math.sin(p.y);\n  cosc = Math.cos(p.y);\n  cosl = Math.cos(p.x);\n  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);\n  p.x = k * cosc * Math.sin(p.x);\n  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);\n  p.x = this.a * p.x + this.x0;\n  p.y = this.a * p.y + this.y0;\n  return p;\n}\n\nfunction inverse(p) {\n  var sinc, cosc, lon, lat, rho;\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    var c = 2 * Math.atan2(rho, this.R2);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);\n    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  _gauss__WEBPACK_IMPORTED_MODULE_0__[\"default\"].inverse.apply(this, [p]);\n  p.x = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(p.x + this.long0);\n  return p;\n}\n\nvar names = [\"Stereographic_North_Pole\", \"Oblique_Stereographic\", \"Polar_Stereographic\", \"sterea\",\"Oblique Stereographic Alternative\",\"Double_Stereographic\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/sterea.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/tmerc.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/tmerc.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/pj_enfn */ \"./node_modules/proj4/lib/common/pj_enfn.js\");\n/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/pj_mlfn */ \"./node_modules/proj4/lib/common/pj_mlfn.js\");\n/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/pj_inv_mlfn */ \"./node_modules/proj4/lib/common/pj_inv_mlfn.js\");\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/sign */ \"./node_modules/proj4/lib/common/sign.js\");\n// Heavily based on this tmerc projection implementation\n// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js\n\n\n\n\n\n\n\n\n\nfunction init() {\n  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n  if (this.es) {\n    this.en = Object(_common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.es);\n    this.ml0 = Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);\n  }\n}\n\n/**\n    Transverse Mercator Forward  - long/lat to x/y\n    long/lat in radians\n  */\nfunction forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(lon - this.long0);\n  var con;\n  var x, y;\n  var sin_phi = Math.sin(lat);\n  var cos_phi = Math.cos(lat);\n\n  if (!this.es) {\n    var b = cos_phi * Math.sin(delta_lon);\n\n    if ((Math.abs(Math.abs(b) - 1)) < _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"EPSLN\"]) {\n      return (93);\n    }\n    else {\n      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;\n      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));\n      b = Math.abs(y);\n\n      if (b >= 1) {\n        if ((b - 1) > _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"EPSLN\"]) {\n          return (93);\n        }\n        else {\n          y = 0;\n        }\n      }\n      else {\n        y = Math.acos(y);\n      }\n\n      if (lat < 0) {\n        y = -y;\n      }\n\n      y = this.a * this.k0 * (y - this.lat0) + this.y0;\n    }\n  }\n  else {\n    var al = cos_phi * delta_lon;\n    var als = Math.pow(al, 2);\n    var c = this.ep2 * Math.pow(cos_phi, 2);\n    var cs = Math.pow(c, 2);\n    var tq = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"EPSLN\"] ? Math.tan(lat) : 0;\n    var t = Math.pow(tq, 2);\n    var ts = Math.pow(t, 2);\n    con = 1 - this.es * Math.pow(sin_phi, 2);\n    al = al / Math.sqrt(con);\n    var ml = Object(_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(lat, sin_phi, cos_phi, this.en);\n\n    x = this.a * (this.k0 * al * (1 +\n      als / 6 * (1 - t + c +\n      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +\n      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +\n      this.x0;\n\n    y = this.a * (this.k0 * (ml - this.ml0 +\n      sin_phi * delta_lon * al / 2 * (1 +\n      als / 12 * (5 - t + 9 * c + 4 * cs +\n      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +\n      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +\n      this.y0;\n  }\n\n  p.x = x;\n  p.y = y;\n\n  return p;\n}\n\n/**\n    Transverse Mercator Inverse  -  x/y to long/lat\n  */\nfunction inverse(p) {\n  var con, phi;\n  var lat, lon;\n  var x = (p.x - this.x0) * (1 / this.a);\n  var y = (p.y - this.y0) * (1 / this.a);\n\n  if (!this.es) {\n    var f = Math.exp(x / this.k0);\n    var g = 0.5 * (f - 1 / f);\n    var temp = this.lat0 + y / this.k0;\n    var h = Math.cos(temp);\n    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));\n    lat = Math.asin(con);\n\n    if (y < 0) {\n      lat = -lat;\n    }\n\n    if ((g === 0) && (h === 0)) {\n      lon = 0;\n    }\n    else {\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(Math.atan2(g, h) + this.long0);\n    }\n  }\n  else { // ellipsoidal form\n    con = this.ml0 + y / this.k0;\n    phi = Object(_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(con, this.es, this.en);\n\n    if (Math.abs(phi) < _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"]) {\n      var sin_phi = Math.sin(phi);\n      var cos_phi = Math.cos(phi);\n      var tan_phi = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"EPSLN\"] ? Math.tan(phi) : 0;\n      var c = this.ep2 * Math.pow(cos_phi, 2);\n      var cs = Math.pow(c, 2);\n      var t = Math.pow(tan_phi, 2);\n      var ts = Math.pow(t, 2);\n      con = 1 - this.es * Math.pow(sin_phi, 2);\n      var d = x * Math.sqrt(con) / this.k0;\n      var ds = Math.pow(d, 2);\n      con = con * tan_phi;\n\n      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -\n        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -\n        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -\n        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));\n\n      lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this.long0 + (d * (1 -\n        ds / 6 * (1 + 2 * t + c -\n        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -\n        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));\n    }\n    else {\n      lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__[\"HALF_PI\"] * Object(_common_sign__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(y);\n      lon = 0;\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nvar names = [\"Transverse_Mercator\", \"Transverse Mercator\", \"tmerc\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/tmerc.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/utm.js":
/*!***************************************************!*\
  !*** ./node_modules/proj4/lib/projections/utm.js ***!
  \***************************************************/
/*! exports provided: dependsOn, init, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dependsOn\", function() { return dependsOn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_zone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_zone */ \"./node_modules/proj4/lib/common/adjust_zone.js\");\n/* harmony import */ var _etmerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./etmerc */ \"./node_modules/proj4/lib/projections/etmerc.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n\n\nvar dependsOn = 'etmerc';\n\n\n\nfunction init() {\n  var zone = Object(_common_adjust_zone__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.zone, this.long0);\n  if (zone === undefined) {\n    throw new Error('unknown utm zone');\n  }\n  this.lat0 = 0;\n  this.long0 =  ((6 * Math.abs(zone)) - 183) * _constants_values__WEBPACK_IMPORTED_MODULE_2__[\"D2R\"];\n  this.x0 = 500000;\n  this.y0 = this.utmSouth ? 10000000 : 0;\n  this.k0 = 0.9996;\n\n  _etmerc__WEBPACK_IMPORTED_MODULE_1__[\"default\"].init.apply(this);\n  this.forward = _etmerc__WEBPACK_IMPORTED_MODULE_1__[\"default\"].forward;\n  this.inverse = _etmerc__WEBPACK_IMPORTED_MODULE_1__[\"default\"].inverse;\n}\n\nvar names = [\"Universal Transverse Mercator System\", \"utm\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  names: names,\n  dependsOn: dependsOn\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/utm.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/projections/vandg.js":
/*!*****************************************************!*\
  !*** ./node_modules/proj4/lib/projections/vandg.js ***!
  \*****************************************************/
/*! exports provided: init, forward, inverse, names, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forward\", function() { return forward; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"names\", function() { return names; });\n/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/adjust_lon */ \"./node_modules/proj4/lib/common/adjust_lon.js\");\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/asinz */ \"./node_modules/proj4/lib/common/asinz.js\");\n\n\n\n\n\n\n/* Initialize the Van Der Grinten projection\n  ----------------------------------------*/\nfunction init() {\n  //this.R = 6370997; //Radius of earth\n  this.R = this.a;\n}\n\nfunction forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  /* Forward equations\n    -----------------*/\n  var dlon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(lon - this.long0);\n  var x, y;\n\n  if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n    x = this.x0 + this.R * dlon;\n    y = this.y0;\n  }\n  var theta = Object(_common_asinz__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(2 * Math.abs(lat / Math.PI));\n  if ((Math.abs(dlon) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) || (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"HALF_PI\"]) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"])) {\n    x = this.x0;\n    if (lat >= 0) {\n      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);\n    }\n    else {\n      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);\n    }\n    //  return(OK);\n  }\n  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));\n  var asq = al * al;\n  var sinth = Math.sin(theta);\n  var costh = Math.cos(theta);\n\n  var g = costh / (sinth + costh - 1);\n  var gsq = g * g;\n  var m = g * (2 / sinth - 1);\n  var msq = m * m;\n  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);\n  if (dlon < 0) {\n    con = -con;\n  }\n  x = this.x0 + con;\n  //con = Math.abs(con / (Math.PI * this.R));\n  var q = asq + g;\n  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);\n  if (lat >= 0) {\n    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 + con;\n  }\n  else {\n    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 - con;\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Van Der Grinten inverse equations--mapping x,y to lat/long\n  ---------------------------------------------------------*/\nfunction inverse(p) {\n  var lon, lat;\n  var xx, yy, xys, c1, c2, c3;\n  var a1;\n  var m1;\n  var con;\n  var th1;\n  var d;\n\n  /* inverse equations\n    -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  con = Math.PI * this.R;\n  xx = p.x / con;\n  yy = p.y / con;\n  xys = xx * xx + yy * yy;\n  c1 = -Math.abs(yy) * (1 + xys);\n  c2 = c1 - 2 * yy * yy + xx * xx;\n  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;\n  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;\n  a1 = (c1 - c2 * c2 / 3 / c3) / c3;\n  m1 = 2 * Math.sqrt(-a1 / 3);\n  con = ((3 * d) / a1) / m1;\n  if (Math.abs(con) > 1) {\n    if (con >= 0) {\n      con = 1;\n    }\n    else {\n      con = -1;\n    }\n  }\n  th1 = Math.acos(con) / 3;\n  if (p.y >= 0) {\n    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n  else {\n    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n\n  if (Math.abs(xx) < _constants_values__WEBPACK_IMPORTED_MODULE_1__[\"EPSLN\"]) {\n    lon = this.long0;\n  }\n  else {\n    lon = Object(_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nvar names = [\"Van_der_Grinten_I\", \"VanDerGrinten\", \"vandg\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n});\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/projections/vandg.js?");

/***/ }),

/***/ "./node_modules/proj4/lib/transform.js":
/*!*********************************************!*\
  !*** ./node_modules/proj4/lib/transform.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return transform; });\n/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants/values */ \"./node_modules/proj4/lib/constants/values.js\");\n/* harmony import */ var _datum_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datum_transform */ \"./node_modules/proj4/lib/datum_transform.js\");\n/* harmony import */ var _adjust_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adjust_axis */ \"./node_modules/proj4/lib/adjust_axis.js\");\n/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Proj */ \"./node_modules/proj4/lib/Proj.js\");\n/* harmony import */ var _common_toPoint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common/toPoint */ \"./node_modules/proj4/lib/common/toPoint.js\");\n/* harmony import */ var _checkSanity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./checkSanity */ \"./node_modules/proj4/lib/checkSanity.js\");\n\n\n\n\n\n\n\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_3PARAM\"] || source.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_7PARAM\"]) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_3PARAM\"] || dest.datum.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"PJD_7PARAM\"]) && source.datumCode !== 'WGS84');\n}\n\nfunction transform(source, dest, point) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = Object(_common_toPoint__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(point);\n  }\n  Object(_checkSanity__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(point);\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new _Proj__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (source.axis !== 'enu') {\n    point = Object(_adjust_axis__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"],\n      y: point.y * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"D2R\"],\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = Object(_datum_transform__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(source.datum, dest.datum, point);\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"R2D\"],\n      y: point.y * _constants_values__WEBPACK_IMPORTED_MODULE_0__[\"R2D\"],\n      z: point.z || 0\n    };\n  } else { // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (dest.axis !== 'enu') {\n    return Object(_adjust_axis__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(dest, true, point);\n  }\n\n  return point;\n}\n\n\n//# sourceURL=webpack:///./node_modules/proj4/lib/transform.js?");

/***/ }),

/***/ "./node_modules/proj4/projs.js":
/*!*************************************!*\
  !*** ./node_modules/proj4/projs.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_projections_tmerc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/projections/tmerc */ \"./node_modules/proj4/lib/projections/tmerc.js\");\n/* harmony import */ var _lib_projections_etmerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/projections/etmerc */ \"./node_modules/proj4/lib/projections/etmerc.js\");\n/* harmony import */ var _lib_projections_utm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/projections/utm */ \"./node_modules/proj4/lib/projections/utm.js\");\n/* harmony import */ var _lib_projections_sterea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/projections/sterea */ \"./node_modules/proj4/lib/projections/sterea.js\");\n/* harmony import */ var _lib_projections_stere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/projections/stere */ \"./node_modules/proj4/lib/projections/stere.js\");\n/* harmony import */ var _lib_projections_somerc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/projections/somerc */ \"./node_modules/proj4/lib/projections/somerc.js\");\n/* harmony import */ var _lib_projections_omerc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/projections/omerc */ \"./node_modules/proj4/lib/projections/omerc.js\");\n/* harmony import */ var _lib_projections_lcc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/projections/lcc */ \"./node_modules/proj4/lib/projections/lcc.js\");\n/* harmony import */ var _lib_projections_krovak__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/projections/krovak */ \"./node_modules/proj4/lib/projections/krovak.js\");\n/* harmony import */ var _lib_projections_cass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/projections/cass */ \"./node_modules/proj4/lib/projections/cass.js\");\n/* harmony import */ var _lib_projections_laea__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/projections/laea */ \"./node_modules/proj4/lib/projections/laea.js\");\n/* harmony import */ var _lib_projections_aea__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/projections/aea */ \"./node_modules/proj4/lib/projections/aea.js\");\n/* harmony import */ var _lib_projections_gnom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/projections/gnom */ \"./node_modules/proj4/lib/projections/gnom.js\");\n/* harmony import */ var _lib_projections_cea__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/projections/cea */ \"./node_modules/proj4/lib/projections/cea.js\");\n/* harmony import */ var _lib_projections_eqc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/projections/eqc */ \"./node_modules/proj4/lib/projections/eqc.js\");\n/* harmony import */ var _lib_projections_poly__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/projections/poly */ \"./node_modules/proj4/lib/projections/poly.js\");\n/* harmony import */ var _lib_projections_nzmg__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/projections/nzmg */ \"./node_modules/proj4/lib/projections/nzmg.js\");\n/* harmony import */ var _lib_projections_mill__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/projections/mill */ \"./node_modules/proj4/lib/projections/mill.js\");\n/* harmony import */ var _lib_projections_sinu__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/projections/sinu */ \"./node_modules/proj4/lib/projections/sinu.js\");\n/* harmony import */ var _lib_projections_moll__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lib/projections/moll */ \"./node_modules/proj4/lib/projections/moll.js\");\n/* harmony import */ var _lib_projections_eqdc__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/projections/eqdc */ \"./node_modules/proj4/lib/projections/eqdc.js\");\n/* harmony import */ var _lib_projections_vandg__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lib/projections/vandg */ \"./node_modules/proj4/lib/projections/vandg.js\");\n/* harmony import */ var _lib_projections_aeqd__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/projections/aeqd */ \"./node_modules/proj4/lib/projections/aeqd.js\");\n/* harmony import */ var _lib_projections_ortho__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lib/projections/ortho */ \"./node_modules/proj4/lib/projections/ortho.js\");\n/* harmony import */ var _lib_projections_qsc__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lib/projections/qsc */ \"./node_modules/proj4/lib/projections/qsc.js\");\n/* harmony import */ var _lib_projections_robin__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lib/projections/robin */ \"./node_modules/proj4/lib/projections/robin.js\");\n/* harmony import */ var _lib_projections_geocent__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./lib/projections/geocent */ \"./node_modules/proj4/lib/projections/geocent.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(proj4){\n  proj4.Proj.projections.add(_lib_projections_tmerc__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_etmerc__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_utm__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_sterea__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_stere__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_somerc__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_omerc__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_lcc__WEBPACK_IMPORTED_MODULE_7__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_krovak__WEBPACK_IMPORTED_MODULE_8__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_cass__WEBPACK_IMPORTED_MODULE_9__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_laea__WEBPACK_IMPORTED_MODULE_10__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_aea__WEBPACK_IMPORTED_MODULE_11__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_gnom__WEBPACK_IMPORTED_MODULE_12__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_cea__WEBPACK_IMPORTED_MODULE_13__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_eqc__WEBPACK_IMPORTED_MODULE_14__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_poly__WEBPACK_IMPORTED_MODULE_15__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_nzmg__WEBPACK_IMPORTED_MODULE_16__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_mill__WEBPACK_IMPORTED_MODULE_17__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_sinu__WEBPACK_IMPORTED_MODULE_18__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_moll__WEBPACK_IMPORTED_MODULE_19__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_eqdc__WEBPACK_IMPORTED_MODULE_20__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_vandg__WEBPACK_IMPORTED_MODULE_21__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_aeqd__WEBPACK_IMPORTED_MODULE_22__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_ortho__WEBPACK_IMPORTED_MODULE_23__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_qsc__WEBPACK_IMPORTED_MODULE_24__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_robin__WEBPACK_IMPORTED_MODULE_25__[\"default\"]);\n  proj4.Proj.projections.add(_lib_projections_geocent__WEBPACK_IMPORTED_MODULE_26__[\"default\"]);\n});\n\n//# sourceURL=webpack:///./node_modules/proj4/projs.js?");

/***/ }),

/***/ "./node_modules/shpjs/lib/binaryajax-browser.js":
/*!******************************************************!*\
  !*** ./node_modules/shpjs/lib/binaryajax-browser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nvar Promise = __webpack_require__(/*! lie */ \"./node_modules/lie/lib/browser.js\");\nmodule.exports = binaryAjax;\nfunction binaryAjax(url){\n\treturn new Promise(function(resolve,reject){\n\t\tvar type = url.slice(-3);\n\t\tvar ajax = new XMLHttpRequest();\n\t\tajax.open('GET',url,true);\n\t\tif(type !== 'prj' && type !== 'cpg'){\n\t\t\tajax.responseType='arraybuffer';\n\t\t}\n\t\tajax.addEventListener('load', function (){\n\t\t\tif(ajax.status>399){\n\t\t\t\tif(type==='prj' || type === 'cpg'){\n\t\t\t\t\treturn resolve(false);\n\t\t\t\t}else{\n\t\t\t\t\treturn reject(new Error(ajax.status));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(type !== 'prj' && type !== 'cpg'){\n\t\t\t\treturn resolve(new Buffer(ajax.response));\n\t\t\t} else {\n\t\t\t\treturn resolve(ajax.response);\n\t\t\t}\n\t\t}, false);\n\t\tajax.send();\n\t});\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/shpjs/lib/binaryajax-browser.js?");

/***/ }),

/***/ "./node_modules/shpjs/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/shpjs/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer, global) {\nvar proj4 = __webpack_require__(/*! proj4 */ \"./node_modules/proj4/lib/index.js\");\nif (proj4.default) {\n  proj4 = proj4.default;\n}\nvar unzip = __webpack_require__(/*! ./unzip */ \"./node_modules/shpjs/lib/unzip.js\");\nvar binaryAjax = __webpack_require__(/*! ./binaryajax */ \"./node_modules/shpjs/lib/binaryajax-browser.js\");\nvar parseShp = __webpack_require__(/*! ./parseShp */ \"./node_modules/shpjs/lib/parseShp.js\");\nvar parseDbf = __webpack_require__(/*! parsedbf */ \"./node_modules/parsedbf/index.js\");\nvar Promise = __webpack_require__(/*! lie */ \"./node_modules/lie/lib/browser.js\");\nvar Cache = __webpack_require__(/*! lru-cache */ \"./node_modules/lru-cache/lib/lru-cache.js\");\nvar cache = new Cache({\n  max: 20\n});\n\nfunction toBuffer(b) {\n  if (!b) {\n    throw new Error('forgot to pass buffer');\n  }\n  if (Buffer.isBuffer(b)) {\n    return b;\n  }\n  if (b instanceof global.ArrayBuffer) {\n    return new Buffer(b);\n  }\n  if (b.buffer instanceof global.ArrayBuffer) {\n    if (b.BYTES_PER_ELEMENT === 1) {\n      return new Buffer(b);\n    }\n    return new Buffer(b.buffer);\n  }\n}\n\nfunction shp(base, whiteList) {\n  if (typeof base === 'string' && cache.has(base)) {\n    return Promise.resolve(cache.get(base));\n  }\n  return shp.getShapefile(base, whiteList).then(function(resp) {\n    if (typeof base === 'string') {\n      cache.set(base, resp);\n    }\n    return resp;\n  });\n}\nshp.combine = function(arr) {\n  var out = {};\n  out.type = 'FeatureCollection';\n  out.features = [];\n  var i = 0;\n  var len = arr[0].length;\n  while (i < len) {\n    out.features.push({\n      'type': 'Feature',\n      'geometry': arr[0][i],\n      'properties': arr[1][i]\n    });\n    i++;\n  }\n  return out;\n};\nshp.parseZip = function(buffer, whiteList) {\n  var key;\n  buffer = toBuffer(buffer);\n  var zip = unzip(buffer);\n  var names = [];\n  whiteList = whiteList || [];\n  for (key in zip) {\n    if (key.indexOf('__MACOSX') !== -1) {\n      continue;\n    }\n    if (key.slice(-3).toLowerCase() === 'shp') {\n      names.push(key.slice(0, -4));\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    } else if (key.slice(-3).toLowerCase() === 'prj') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);\n    } else if (key.slice(-4).toLowerCase() === 'json' || whiteList.indexOf(key.split('.').pop()) > -1) {\n      names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());\n    } else if (key.slice(-3).toLowerCase() === 'dbf' || key.slice(-3).toLowerCase() === 'cpg') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    }\n  }\n  if (!names.length) {\n    throw new Error('no layers founds');\n  }\n  var geojson = names.map(function(name) {\n    var parsed, dbf;\n    var lastDotIdx = name.lastIndexOf('.');\n    if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf('json') > -1) {\n      parsed = JSON.parse(zip[name]);\n      parsed.fileName = name.slice(0, lastDotIdx);\n    } else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {\n      parsed = zip[name];\n      parsed.fileName = name;\n    } else {\n      if (zip[name + '.dbf']) {\n        dbf = parseDbf(zip[name + '.dbf'], zip[name + '.cpg']);\n      }\n      parsed = shp.combine([parseShp(zip[name + '.shp'], zip[name + '.prj']), dbf]);\n      parsed.fileName = name;\n    }\n    return parsed;\n  });\n  if (geojson.length === 1) {\n    return geojson[0];\n  } else {\n    return geojson;\n  }\n};\n\nfunction getZip(base, whiteList) {\n  return binaryAjax(base).then(function(a) {\n    return shp.parseZip(a, whiteList);\n  });\n}\nshp.getShapefile = function(base, whiteList) {\n  if (typeof base === 'string') {\n    if (base.slice(-4).toLowerCase() === '.zip') {\n      return getZip(base, whiteList);\n    } else {\n      return Promise.all([\n        Promise.all([\n          binaryAjax(base + '.shp'),\n          binaryAjax(base + '.prj')\n        ]).then(function(args) {\n          return parseShp(args[0], args[1] ? proj4(args[1]) : false);\n        }),\n        Promise.all([\n          binaryAjax(base + '.dbf'),\n          binaryAjax(base + '.cpg')\n        ]).then(function(args) {\n          return parseDbf(args[0], args[1]);\n        })\n      ]).then(shp.combine);\n    }\n  } else {\n    return new Promise(function(resolve) {\n      resolve(shp.parseZip(base));\n    });\n  }\n};\nshp.parseShp = function(shp, prj) {\n  shp = toBuffer(shp);\n  if (Buffer.isBuffer(prj)) {\n    prj = prj.toString();\n  }\n  if (typeof prj === 'string') {\n    prj = proj4(prj);\n    return parseShp(shp, prj);\n  } else {\n    return parseShp(shp);\n  }\n};\nshp.parseDbf = function(dbf, cpg) {\n  dbf = toBuffer(dbf);\n  return parseDbf(dbf, cpg);\n};\nmodule.exports = shp;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/shpjs/lib/index.js?");

/***/ }),

/***/ "./node_modules/shpjs/lib/parseShp.js":
/*!********************************************!*\
  !*** ./node_modules/shpjs/lib/parseShp.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction isClockWise(array) {\n  var sum = 0;\n  var i = 1;\n  var len = array.length;\n  var prev, cur;\n  while (i < len) {\n    prev = cur || array[0];\n    cur = array[i];\n    sum += ((cur[0] - prev[0]) * (cur[1] + prev[1]));\n    i++;\n  }\n  return sum > 0;\n}\n\nfunction polyReduce(a, b) {\n  if (isClockWise(b) || !a.length) {\n    a.push([b]);\n  } else {\n    a[a.length - 1].push(b);\n  }\n  return a;\n}\nParseShp.prototype.parsePoint = function(data) {\n  return {\n    'type': 'Point',\n    'coordinates': this.parseCoord(data, 0)\n  };\n};\nParseShp.prototype.parseZPoint = function(data) {\n  var pointXY = this.parsePoint(data);\n  pointXY.coordinates.push(data.readDoubleLE(16));\n  return pointXY;\n};\nParseShp.prototype.parsePointArray = function(data, offset, num) {\n  var out = [];\n  var done = 0;\n  while (done < num) {\n    out.push(this.parseCoord(data, offset));\n    offset += 16;\n    done++;\n  }\n  return out;\n};\nParseShp.prototype.parseZPointArray = function(data, zOffset, num, coordinates) {\n  var i = 0;\n  while (i < num) {\n    coordinates[i].push(data.readDoubleLE(zOffset));\n    i++;\n    zOffset += 8;\n  }\n  return coordinates;\n};\nParseShp.prototype.parseArrayGroup = function(data, offset, partOffset, num, tot) {\n  var out = [];\n  var done = 0;\n  var curNum, nextNum = 0,\n    pointNumber;\n  while (done < num) {\n    done++;\n    partOffset += 4;\n    curNum = nextNum;\n    if (done === num) {\n      nextNum = tot;\n    } else {\n      nextNum = data.readInt32LE(partOffset);\n    }\n    pointNumber = nextNum - curNum;\n    if (!pointNumber) {\n      continue;\n    }\n    out.push(this.parsePointArray(data, offset, pointNumber));\n    offset += (pointNumber << 4);\n  }\n  return out;\n};\nParseShp.prototype.parseZArrayGroup = function(data, zOffset, num, coordinates) {\n  var i = 0;\n  while (i < num) {\n    coordinates[i] = this.parseZPointArray(data, zOffset, coordinates[i].length, coordinates[i]);\n    zOffset += (coordinates[i].length << 3);\n    i++;\n  }\n  return coordinates;\n};\nParseShp.prototype.parseMultiPoint = function(data) {\n  var out = {};\n  var mins = this.parseCoord(data, 0);\n  var maxs = this.parseCoord(data, 16);\n  out.bbox = [\n    mins[0],\n    mins[1],\n    maxs[0],\n    maxs[1]\n  ];\n  var num = data.readInt32LE(32, true);\n  var offset = 36;\n  if (num === 1) {\n    out.type = 'Point';\n    out.coordinates = this.parseCoord(data, offset);\n  } else {\n    out.type = 'MultiPoint';\n    out.coordinates = this.parsePointArray(data, offset, num);\n  }\n  return out;\n};\nParseShp.prototype.parseZMultiPoint = function(data) {\n  var geoJson = this.parseMultiPoint(data);\n  var num;\n  if (geoJson.type === 'Point') {\n    geoJson.coordinates.push(data.readDoubleLE(72));\n    return geoJson;\n  } else {\n    num = geoJson.coordinates.length;\n  }\n  var zOffset = 52 + (num << 4);\n  geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n  return geoJson;\n};\nParseShp.prototype.parsePolyline = function(data) {\n  var out = {};\n  var mins = this.parseCoord(data, 0);\n  var maxs = this.parseCoord(data, 16);\n  out.bbox = [\n    mins[0],\n    mins[1],\n    maxs[0],\n    maxs[1]\n  ];\n  var numParts = data.readInt32LE(32);\n  var num = data.readInt32LE(36);\n  var offset, partOffset;\n  if (numParts === 1) {\n    out.type = 'LineString';\n    offset = 44;\n    out.coordinates = this.parsePointArray(data, offset, num);\n  } else {\n    out.type = 'MultiLineString';\n    offset = 40 + (numParts << 2);\n    partOffset = 40;\n    out.coordinates = this.parseArrayGroup(data, offset, partOffset, numParts, num);\n  }\n  return out;\n};\nParseShp.prototype.parseZPolyline = function(data) {\n  var geoJson = this.parsePolyline(data);\n  var num = geoJson.coordinates.length;\n  var zOffset;\n  if (geoJson.type === 'LineString') {\n    zOffset = 60 + (num << 4);\n    geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  } else {\n    var totalPoints = geoJson.coordinates.reduce(function(a, v) {\n      return a + v.length;\n    }, 0);\n    zOffset = 56 + (totalPoints << 4) + (num << 2);\n    geoJson.coordinates = this.parseZArrayGroup(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  }\n};\nParseShp.prototype.polyFuncs = function(out) {\n  if (out.type === 'LineString') {\n    out.type = 'Polygon';\n    out.coordinates = [out.coordinates];\n    return out;\n  } else {\n    out.coordinates = out.coordinates.reduce(polyReduce, []);\n    if (out.coordinates.length === 1) {\n      out.type = 'Polygon';\n      out.coordinates = out.coordinates[0];\n      return out;\n    } else {\n      out.type = 'MultiPolygon';\n      return out;\n    }\n  }\n};\nParseShp.prototype.parsePolygon = function(data) {\n  return this.polyFuncs(this.parsePolyline(data));\n};\nParseShp.prototype.parseZPolygon = function(data) {\n  return this.polyFuncs(this.parseZPolyline(data));\n};\nvar shpFuncObj = {\n  1: 'parsePoint',\n  3: 'parsePolyline',\n  5: 'parsePolygon',\n  8: 'parseMultiPoint',\n  11: 'parseZPoint',\n  13: 'parseZPolyline',\n  15: 'parseZPolygon',\n  18: 'parseZMultiPoint'\n};\n\n\n\nfunction makeParseCoord(trans) {\n  if (trans) {\n    return function(data, offset) {\n      return trans.inverse([data.readDoubleLE(offset), data.readDoubleLE(offset + 8)]);\n    };\n  } else {\n    return function(data, offset) {\n      return [data.readDoubleLE(offset), data.readDoubleLE(offset + 8)];\n    };\n  }\n}\n\nfunction ParseShp(buffer, trans) {\n  if (!(this instanceof ParseShp)) {\n    return new ParseShp(buffer, trans);\n  }\n  this.buffer = buffer;\n  this.shpFuncs(trans);\n  this.rows = this.getRows();\n}\nParseShp.prototype.shpFuncs = function(tran) {\n  var num = this.getShpCode();\n  if (num > 20) {\n    num -= 20;\n  }\n  if (!(num in shpFuncObj)) {\n    throw new Error('I don\\'t know that shp type');\n  }\n  this.parseFunc = this[shpFuncObj[num]];\n  this.parseCoord = makeParseCoord(tran);\n};\nParseShp.prototype.getShpCode = function() {\n  return this.parseHeader().shpCode;\n};\nParseShp.prototype.parseHeader = function() {\n  var view = this.buffer.slice(0, 100);\n  return {\n    length: view.readInt32BE(6 << 2),\n    version: view.readInt32LE(7 << 2),\n    shpCode: view.readInt32LE(8 << 2),\n    bbox: [\n      view.readDoubleLE(9 << 2),\n      view.readDoubleLE(11 << 2),\n      view.readDoubleLE(13 << 2),\n      view.readDoubleLE(13 << 2)\n    ]\n  };\n};\nParseShp.prototype.getRows = function() {\n  var offset = 100;\n  var len = this.buffer.byteLength;\n  var out = [];\n  var current;\n  while (offset < len) {\n    current = this.getRow(offset);\n    offset += 8;\n    offset += current.len;\n    if (current.type) {\n      out.push(this.parseFunc(current.data));\n    }\n  }\n  return out;\n};\nParseShp.prototype.getRow = function(offset) {\n  var view = this.buffer.slice(offset, offset + 12);\n  var len = view.readInt32BE(4) << 1;\n  var data = this.buffer.slice(offset + 12, offset + len + 8);\n\n  return {\n    id: view.readInt32BE(0),\n    len: len,\n    data: data,\n    type: view.readInt32LE(8)\n  };\n};\nmodule.exports = function(buffer, trans) {\n  return new ParseShp(buffer, trans).rows;\n};\n\n\n//# sourceURL=webpack:///./node_modules/shpjs/lib/parseShp.js?");

/***/ }),

/***/ "./node_modules/shpjs/lib/unzip.js":
/*!*****************************************!*\
  !*** ./node_modules/shpjs/lib/unzip.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar JSZip = __webpack_require__(/*! jszip */ \"./node_modules/jszip/lib/index.js\");\nmodule.exports = function(buffer) {\n\tvar zip = new JSZip(buffer);\n\tvar files = zip.file(/.+/);\n\tvar out = {};\n\tfiles.forEach(function(a) {\n\t\tif (a.name.slice(-3).toLowerCase() === 'shp' || a.name.slice(-3).toLowerCase() === 'dbf') {\n\t\t\tout[a.name] = a.asNodeBuffer();\n\t\t}\n\t\telse {\n\t\t\tout[a.name] = a.asText();\n\t\t}\n\t});\n\treturn out;\n};\n\n\n//# sourceURL=webpack:///./node_modules/shpjs/lib/unzip.js?");

/***/ }),

/***/ "./node_modules/text-encoding-polyfill/index.js":
/*!******************************************************!*\
  !*** ./node_modules/text-encoding-polyfill/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\nmodule.exports = __webpack_require__(/*! ./lib/encoding.js */ \"./node_modules/text-encoding-polyfill/lib/encoding.js\");\n\n\n//# sourceURL=webpack:///./node_modules/text-encoding-polyfill/index.js?");

/***/ }),

/***/ "./node_modules/text-encoding-polyfill/lib/encoding.js":
/*!*************************************************************!*\
  !*** ./node_modules/text-encoding-polyfill/lib/encoding.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n/**\n * @fileoverview Global |this| required for resolving indexes in node.\n * @suppress {globalThis}\n */\n(function(global) {\n  'use strict';\n\n  // If we're in node require encoding-indexes and attach it to the global.\n  if ( true && module.exports &&\n    !global[\"encoding-indexes\"]) {\n      __webpack_require__(/*! ./encoding-indexes.js */ 1);\n  }\n\n  //\n  // Utilities\n  //\n\n  /**\n   * @param {number} a The number to test.\n   * @param {number} min The minimum value in the range, inclusive.\n   * @param {number} max The maximum value in the range, inclusive.\n   * @return {boolean} True if a >= min and a <= max.\n   */\n  function inRange(a, min, max) {\n    return min <= a && a <= max;\n  }\n\n  /**\n   * @param {!Array.<*>} array The array to check.\n   * @param {*} item The item to look for in the array.\n   * @return {boolean} True if the item appears in the array.\n   */\n  function includes(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n\n  var floor = Math.floor;\n\n  /**\n   * @param {*} o\n   * @return {Object}\n   */\n  function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError('Could not convert argument to dictionary');\n  }\n\n  /**\n   * @param {string} string Input string of UTF-16 code units.\n   * @return {!Array.<number>} Code points.\n   */\n  function stringToCodePoints(string) {\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n    // 1. Let S be the DOMString value.\n    var s = String(string);\n\n    // 2. Let n be the length of S.\n    var n = s.length;\n\n    // 3. Initialize i to 0.\n    var i = 0;\n\n    // 4. Initialize U to be an empty sequence of Unicode characters.\n    var u = [];\n\n    // 5. While i < n:\n    while (i < n) {\n\n      // 1. Let c be the code unit in S at index i.\n      var c = s.charCodeAt(i);\n\n      // 2. Depending on the value of c:\n\n      // c < 0xD800 or c > 0xDFFF\n      if (c < 0xD800 || c > 0xDFFF) {\n        // Append to U the Unicode character with code point c.\n        u.push(c);\n      }\n\n      // 0xDC00 ≤ c ≤ 0xDFFF\n      else if (0xDC00 <= c && c <= 0xDFFF) {\n        // Append to U a U+FFFD REPLACEMENT CHARACTER.\n        u.push(0xFFFD);\n      }\n\n      // 0xD800 ≤ c ≤ 0xDBFF\n      else if (0xD800 <= c && c <= 0xDBFF) {\n        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n        // CHARACTER.\n        if (i === n - 1) {\n          u.push(0xFFFD);\n        }\n        // 2. Otherwise, i < n−1:\n        else {\n          // 1. Let d be the code unit in S at index i+1.\n          var d = s.charCodeAt(i + 1);\n\n          // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n          if (0xDC00 <= d && d <= 0xDFFF) {\n            // 1. Let a be c & 0x3FF.\n            var a = c & 0x3FF;\n\n            // 2. Let b be d & 0x3FF.\n            var b = d & 0x3FF;\n\n            // 3. Append to U the Unicode character with code point\n            // 2^16+2^10*a+b.\n            u.push(0x10000 + (a << 10) + b);\n\n            // 4. Set i to i+1.\n            i += 1;\n          }\n\n          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n          // U+FFFD REPLACEMENT CHARACTER.\n          else  {\n            u.push(0xFFFD);\n          }\n        }\n      }\n\n      // 3. Set i to i+1.\n      i += 1;\n    }\n\n    // 6. Return U.\n    return u;\n  }\n\n  /**\n   * @param {!Array.<number>} code_points Array of code points.\n   * @return {string} string String of UTF-16 code units.\n   */\n  function codePointsToString(code_points) {\n    var s = '';\n    for (var i = 0; i < code_points.length; ++i) {\n      var cp = code_points[i];\n      if (cp <= 0xFFFF) {\n        s += String.fromCharCode(cp);\n      } else {\n        cp -= 0x10000;\n        s += String.fromCharCode((cp >> 10) + 0xD800,\n                                 (cp & 0x3FF) + 0xDC00);\n      }\n    }\n    return s;\n  }\n\n\n  //\n  // Implementation of Encoding specification\n  // https://encoding.spec.whatwg.org/\n  //\n\n  //\n  // 4. Terminology\n  //\n\n  /**\n   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n   * @param {number} a The number to test.\n   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n   */\n  function isASCIIByte(a) {\n    return 0x00 <= a && a <= 0x7F;\n  }\n\n  /**\n   * An ASCII code point is a code point in the range U+0000 to\n   * U+007F, inclusive.\n   */\n  var isASCIICodePoint = isASCIIByte;\n\n\n  /**\n   * End-of-stream is a special token that signifies no more tokens\n   * are in the stream.\n   * @const\n   */ var end_of_stream = -1;\n\n  /**\n   * A stream represents an ordered sequence of tokens.\n   *\n   * @constructor\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n  function Stream(tokens) {\n    /** @type {!Array.<number>} */\n    this.tokens = [].slice.call(tokens);\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse();\n  }\n\n  Stream.prototype = {\n    /**\n     * @return {boolean} True if end-of-stream has been hit.\n     */\n    endOfStream: function() {\n      return !this.tokens.length;\n    },\n\n    /**\n     * When a token is read from a stream, the first token in the\n     * stream must be returned and subsequently removed, and\n     * end-of-stream must be returned otherwise.\n     *\n     * @return {number} Get the next token from the stream, or\n     * end_of_stream.\n     */\n     read: function() {\n      if (!this.tokens.length)\n        return end_of_stream;\n       return this.tokens.pop();\n     },\n\n    /**\n     * When one or more tokens are prepended to a stream, those tokens\n     * must be inserted, in given order, before the first token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n     * stream.\n     */\n    prepend: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.push(tokens.pop());\n      } else {\n        this.tokens.push(token);\n      }\n    },\n\n    /**\n     * When one or more tokens are pushed to a stream, those tokens\n     * must be inserted, in given order, after the last token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n     * stream.\n     */\n    push: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.unshift(tokens.shift());\n      } else {\n        this.tokens.unshift(token);\n      }\n    }\n  };\n\n  //\n  // 5. Encodings\n  //\n\n  // 5.1 Encoders and decoders\n\n  /** @const */\n  var finished = -1;\n\n  /**\n   * @param {boolean} fatal If true, decoding errors raise an exception.\n   * @param {number=} opt_code_point Override the standard fallback code point.\n   * @return {number} The code point to insert on a decoding error.\n   */\n  function decoderError(fatal, opt_code_point) {\n    if (fatal)\n      throw TypeError('Decoder error');\n    return opt_code_point || 0xFFFD;\n  }\n\n  /**\n   * @param {number} code_point The code point that could not be encoded.\n   * @return {number} Always throws, no value is actually returned.\n   */\n  function encoderError(code_point) {\n    throw TypeError('The code point ' + code_point + ' could not be encoded.');\n  }\n\n  /** @interface */\n  function Decoder() {}\n  Decoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point, or |finished|.\n     */\n    handler: function(stream, bite) {}\n  };\n\n  /** @interface */\n  function Encoder() {}\n  Encoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of code points being encoded.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n     */\n    handler: function(stream, code_point) {}\n  };\n\n  // 5.2 Names and labels\n\n  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n  // https://github.com/google/closure-compiler/issues/247\n\n  /**\n   * @param {string} label The encoding label.\n   * @return {?{name:string,labels:Array.<string>}}\n   */\n  function getEncoding(label) {\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    label = String(label).trim().toLowerCase();\n\n    // 2. If label is an ASCII case-insensitive match for any of the\n    // labels listed in the table below, return the corresponding\n    // encoding, and failure otherwise.\n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n      return label_to_encoding[label];\n    }\n    return null;\n  }\n\n  /**\n   * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n   * @const\n   * @type {!Array.<{\n   *          heading: string,\n   *          encodings: Array.<{name:string,labels:Array.<string>}>\n   *        }>}\n   */\n  var encodings = [\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"unicode-1-1-utf-8\",\n            \"utf-8\",\n            \"utf8\"\n          ],\n          \"name\": \"UTF-8\"\n        }\n      ],\n      \"heading\": \"The Encoding\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"866\",\n            \"cp866\",\n            \"csibm866\",\n            \"ibm866\"\n          ],\n          \"name\": \"IBM866\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin2\",\n            \"iso-8859-2\",\n            \"iso-ir-101\",\n            \"iso8859-2\",\n            \"iso88592\",\n            \"iso_8859-2\",\n            \"iso_8859-2:1987\",\n            \"l2\",\n            \"latin2\"\n          ],\n          \"name\": \"ISO-8859-2\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin3\",\n            \"iso-8859-3\",\n            \"iso-ir-109\",\n            \"iso8859-3\",\n            \"iso88593\",\n            \"iso_8859-3\",\n            \"iso_8859-3:1988\",\n            \"l3\",\n            \"latin3\"\n          ],\n          \"name\": \"ISO-8859-3\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin4\",\n            \"iso-8859-4\",\n            \"iso-ir-110\",\n            \"iso8859-4\",\n            \"iso88594\",\n            \"iso_8859-4\",\n            \"iso_8859-4:1988\",\n            \"l4\",\n            \"latin4\"\n          ],\n          \"name\": \"ISO-8859-4\"\n        },\n        {\n          \"labels\": [\n            \"csisolatincyrillic\",\n            \"cyrillic\",\n            \"iso-8859-5\",\n            \"iso-ir-144\",\n            \"iso8859-5\",\n            \"iso88595\",\n            \"iso_8859-5\",\n            \"iso_8859-5:1988\"\n          ],\n          \"name\": \"ISO-8859-5\"\n        },\n        {\n          \"labels\": [\n            \"arabic\",\n            \"asmo-708\",\n            \"csiso88596e\",\n            \"csiso88596i\",\n            \"csisolatinarabic\",\n            \"ecma-114\",\n            \"iso-8859-6\",\n            \"iso-8859-6-e\",\n            \"iso-8859-6-i\",\n            \"iso-ir-127\",\n            \"iso8859-6\",\n            \"iso88596\",\n            \"iso_8859-6\",\n            \"iso_8859-6:1987\"\n          ],\n          \"name\": \"ISO-8859-6\"\n        },\n        {\n          \"labels\": [\n            \"csisolatingreek\",\n            \"ecma-118\",\n            \"elot_928\",\n            \"greek\",\n            \"greek8\",\n            \"iso-8859-7\",\n            \"iso-ir-126\",\n            \"iso8859-7\",\n            \"iso88597\",\n            \"iso_8859-7\",\n            \"iso_8859-7:1987\",\n            \"sun_eu_greek\"\n          ],\n          \"name\": \"ISO-8859-7\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598e\",\n            \"csisolatinhebrew\",\n            \"hebrew\",\n            \"iso-8859-8\",\n            \"iso-8859-8-e\",\n            \"iso-ir-138\",\n            \"iso8859-8\",\n            \"iso88598\",\n            \"iso_8859-8\",\n            \"iso_8859-8:1988\",\n            \"visual\"\n          ],\n          \"name\": \"ISO-8859-8\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598i\",\n            \"iso-8859-8-i\",\n            \"logical\"\n          ],\n          \"name\": \"ISO-8859-8-I\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin6\",\n            \"iso-8859-10\",\n            \"iso-ir-157\",\n            \"iso8859-10\",\n            \"iso885910\",\n            \"l6\",\n            \"latin6\"\n          ],\n          \"name\": \"ISO-8859-10\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-13\",\n            \"iso8859-13\",\n            \"iso885913\"\n          ],\n          \"name\": \"ISO-8859-13\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-14\",\n            \"iso8859-14\",\n            \"iso885914\"\n          ],\n          \"name\": \"ISO-8859-14\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin9\",\n            \"iso-8859-15\",\n            \"iso8859-15\",\n            \"iso885915\",\n            \"iso_8859-15\",\n            \"l9\"\n          ],\n          \"name\": \"ISO-8859-15\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-16\"\n          ],\n          \"name\": \"ISO-8859-16\"\n        },\n        {\n          \"labels\": [\n            \"cskoi8r\",\n            \"koi\",\n            \"koi8\",\n            \"koi8-r\",\n            \"koi8_r\"\n          ],\n          \"name\": \"KOI8-R\"\n        },\n        {\n          \"labels\": [\n            \"koi8-ru\",\n            \"koi8-u\"\n          ],\n          \"name\": \"KOI8-U\"\n        },\n        {\n          \"labels\": [\n            \"csmacintosh\",\n            \"mac\",\n            \"macintosh\",\n            \"x-mac-roman\"\n          ],\n          \"name\": \"macintosh\"\n        },\n        {\n          \"labels\": [\n            \"dos-874\",\n            \"iso-8859-11\",\n            \"iso8859-11\",\n            \"iso885911\",\n            \"tis-620\",\n            \"windows-874\"\n          ],\n          \"name\": \"windows-874\"\n        },\n        {\n          \"labels\": [\n            \"cp1250\",\n            \"windows-1250\",\n            \"x-cp1250\"\n          ],\n          \"name\": \"windows-1250\"\n        },\n        {\n          \"labels\": [\n            \"cp1251\",\n            \"windows-1251\",\n            \"x-cp1251\"\n          ],\n          \"name\": \"windows-1251\"\n        },\n        {\n          \"labels\": [\n            \"ansi_x3.4-1968\",\n            \"ascii\",\n            \"cp1252\",\n            \"cp819\",\n            \"csisolatin1\",\n            \"ibm819\",\n            \"iso-8859-1\",\n            \"iso-ir-100\",\n            \"iso8859-1\",\n            \"iso88591\",\n            \"iso_8859-1\",\n            \"iso_8859-1:1987\",\n            \"l1\",\n            \"latin1\",\n            \"us-ascii\",\n            \"windows-1252\",\n            \"x-cp1252\"\n          ],\n          \"name\": \"windows-1252\"\n        },\n        {\n          \"labels\": [\n            \"cp1253\",\n            \"windows-1253\",\n            \"x-cp1253\"\n          ],\n          \"name\": \"windows-1253\"\n        },\n        {\n          \"labels\": [\n            \"cp1254\",\n            \"csisolatin5\",\n            \"iso-8859-9\",\n            \"iso-ir-148\",\n            \"iso8859-9\",\n            \"iso88599\",\n            \"iso_8859-9\",\n            \"iso_8859-9:1989\",\n            \"l5\",\n            \"latin5\",\n            \"windows-1254\",\n            \"x-cp1254\"\n          ],\n          \"name\": \"windows-1254\"\n        },\n        {\n          \"labels\": [\n            \"cp1255\",\n            \"windows-1255\",\n            \"x-cp1255\"\n          ],\n          \"name\": \"windows-1255\"\n        },\n        {\n          \"labels\": [\n            \"cp1256\",\n            \"windows-1256\",\n            \"x-cp1256\"\n          ],\n          \"name\": \"windows-1256\"\n        },\n        {\n          \"labels\": [\n            \"cp1257\",\n            \"windows-1257\",\n            \"x-cp1257\"\n          ],\n          \"name\": \"windows-1257\"\n        },\n        {\n          \"labels\": [\n            \"cp1258\",\n            \"windows-1258\",\n            \"x-cp1258\"\n          ],\n          \"name\": \"windows-1258\"\n        },\n        {\n          \"labels\": [\n            \"x-mac-cyrillic\",\n            \"x-mac-ukrainian\"\n          ],\n          \"name\": \"x-mac-cyrillic\"\n        }\n      ],\n      \"heading\": \"Legacy single-byte encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"chinese\",\n            \"csgb2312\",\n            \"csiso58gb231280\",\n            \"gb2312\",\n            \"gb_2312\",\n            \"gb_2312-80\",\n            \"gbk\",\n            \"iso-ir-58\",\n            \"x-gbk\"\n          ],\n          \"name\": \"GBK\"\n        },\n        {\n          \"labels\": [\n            \"gb18030\"\n          ],\n          \"name\": \"gb18030\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"big5\",\n            \"big5-hkscs\",\n            \"cn-big5\",\n            \"csbig5\",\n            \"x-x-big5\"\n          ],\n          \"name\": \"Big5\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseucpkdfmtjapanese\",\n            \"euc-jp\",\n            \"x-euc-jp\"\n          ],\n          \"name\": \"EUC-JP\"\n        },\n        {\n          \"labels\": [\n            \"csiso2022jp\",\n            \"iso-2022-jp\"\n          ],\n          \"name\": \"ISO-2022-JP\"\n        },\n        {\n          \"labels\": [\n            \"csshiftjis\",\n            \"ms932\",\n            \"ms_kanji\",\n            \"shift-jis\",\n            \"shift_jis\",\n            \"sjis\",\n            \"windows-31j\",\n            \"x-sjis\"\n          ],\n          \"name\": \"Shift_JIS\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Japanese encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseuckr\",\n            \"csksc56011987\",\n            \"euc-kr\",\n            \"iso-ir-149\",\n            \"korean\",\n            \"ks_c_5601-1987\",\n            \"ks_c_5601-1989\",\n            \"ksc5601\",\n            \"ksc_5601\",\n            \"windows-949\"\n          ],\n          \"name\": \"EUC-KR\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Korean encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"csiso2022kr\",\n            \"hz-gb-2312\",\n            \"iso-2022-cn\",\n            \"iso-2022-cn-ext\",\n            \"iso-2022-kr\"\n          ],\n          \"name\": \"replacement\"\n        },\n        {\n          \"labels\": [\n            \"utf-16be\"\n          ],\n          \"name\": \"UTF-16BE\"\n        },\n        {\n          \"labels\": [\n            \"utf-16\",\n            \"utf-16le\"\n          ],\n          \"name\": \"UTF-16LE\"\n        },\n        {\n          \"labels\": [\n            \"x-user-defined\"\n          ],\n          \"name\": \"x-user-defined\"\n        }\n      ],\n      \"heading\": \"Legacy miscellaneous encodings\"\n    }\n  ];\n\n  // Label to encoding registry.\n  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */\n  var label_to_encoding = {};\n  encodings.forEach(function(category) {\n    category.encodings.forEach(function(encoding) {\n      encoding.labels.forEach(function(label) {\n        label_to_encoding[label] = encoding;\n      });\n    });\n  });\n\n  // Registry of of encoder/decoder factories, by encoding name.\n  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */\n  var encoders = {};\n  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */\n  var decoders = {};\n\n  //\n  // 6. Indexes\n  //\n\n  /**\n   * @param {number} pointer The |pointer| to search for.\n   * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in |index|.\n   */\n  function indexCodePointFor(pointer, index) {\n    if (!index) return null;\n    return index[pointer] || null;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to search for.\n   * @param {!Array.<?number>} index The |index| to search within.\n   * @return {?number} The first pointer corresponding to |code point| in\n   *     |index|, or null if |code point| is not in |index|.\n   */\n  function indexPointerFor(code_point, index) {\n    var pointer = index.indexOf(code_point);\n    return pointer === -1 ? null : pointer;\n  }\n\n  /**\n   * @param {string} name Name of the index.\n   * @return {(!Array.<number>|!Array.<Array.<number>>)}\n   *  */\n  function index(name) {\n    if (!('encoding-indexes' in global)) {\n      throw Error(\"Indexes missing.\" +\n                  \" Did you forget to include encoding-indexes.js first?\");\n    }\n    return global['encoding-indexes'][name];\n  }\n\n  /**\n   * @param {number} pointer The |pointer| to search for in the gb18030 index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the gb18030 index.\n   */\n  function indexGB18030RangesCodePointFor(pointer) {\n    // 1. If pointer is greater than 39419 and less than 189000, or\n    // pointer is greater than 1237575, return null.\n    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))\n      return null;\n\n    // 2. If pointer is 7457, return code point U+E7C7.\n    if (pointer === 7457) return 0xE7C7;\n\n    // 3. Let offset be the last pointer in index gb18030 ranges that\n    // is equal to or less than pointer and let code point offset be\n    // its corresponding code point.\n    var offset = 0;\n    var code_point_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[0] <= pointer) {\n        offset = entry[0];\n        code_point_offset = entry[1];\n      } else {\n        break;\n      }\n    }\n\n    // 4. Return a code point whose value is code point offset +\n    // pointer − offset.\n    return code_point_offset + pointer - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to locate in the gb18030 index.\n   * @return {number} The first pointer corresponding to |code point| in the\n   *     gb18030 index.\n   */\n  function indexGB18030RangesPointerFor(code_point) {\n    // 1. If code point is U+E7C7, return pointer 7457.\n    if (code_point === 0xE7C7) return 7457;\n\n    // 2. Let offset be the last code point in index gb18030 ranges\n    // that is equal to or less than code point and let pointer offset\n    // be its corresponding pointer.\n    var offset = 0;\n    var pointer_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[1] <= code_point) {\n        offset = entry[1];\n        pointer_offset = entry[0];\n      } else {\n        break;\n      }\n    }\n\n    // 3. Return a pointer whose value is pointer offset + code point\n    // − offset.\n    return pointer_offset + code_point - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the Shift_JIS\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the Shift_JIS index.\n   */\n  function indexShiftJISPointerFor(code_point) {\n    // 1. Let index be index jis0208 excluding all entries whose\n    // pointer is in the range 8272 to 8835, inclusive.\n    shift_jis_index = shift_jis_index ||\n      index('jis0208').map(function(code_point, pointer) {\n        return inRange(pointer, 8272, 8835) ? null : code_point;\n      });\n    var index_ = shift_jis_index;\n\n    // 2. Return the index pointer for code point in index.\n    return index_.indexOf(code_point);\n  }\n  var shift_jis_index;\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the big5\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the big5 index.\n   */\n  function indexBig5PointerFor(code_point) {\n    // 1. Let index be index Big5 excluding all entries whose pointer\n    big5_index_no_hkscs = big5_index_no_hkscs ||\n      index('big5').map(function(code_point, pointer) {\n        return (pointer < (0xA1 - 0x81) * 157) ? null : code_point;\n      });\n    var index_ = big5_index_no_hkscs;\n\n    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n    // U+5345, return the last pointer corresponding to code point in\n    // index.\n    if (code_point === 0x2550 || code_point === 0x255E ||\n        code_point === 0x2561 || code_point === 0x256A ||\n        code_point === 0x5341 || code_point === 0x5345) {\n      return index_.lastIndexOf(code_point);\n    }\n\n    // 3. Return the index pointer for code point in index.\n    return indexPointerFor(code_point, index_);\n  }\n  var big5_index_no_hkscs;\n\n  //\n  // 8. API\n  //\n\n  /** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n  // 8.1 Interface TextDecoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding;\n   *     defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n  function TextDecoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextDecoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    options = ToDictionary(options);\n\n    // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Decoder} */\n    this._decoder = null;\n    /** @private @type {boolean} */\n    this._ignoreBOM = false;\n    /** @private @type {boolean} */\n    this._BOMseen = false;\n    /** @private @type {string} */\n    this._error_mode = 'replacement';\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n\n\n    // 1. Let encoding be the result of getting an encoding from\n    // label.\n    var encoding = getEncoding(label);\n\n    // 2. If encoding is failure or replacement, throw a RangeError.\n    if (encoding === null || encoding.name === 'replacement')\n      throw RangeError('Unknown encoding: ' + label);\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' +\n                  ' Did you forget to include encoding-indexes.js first?');\n    }\n\n    // 3. Let dec be a new TextDecoder object.\n    var dec = this;\n\n    // 4. Set dec's encoding to encoding.\n    dec._encoding = encoding;\n\n    // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n    if (Boolean(options['fatal']))\n      dec._error_mode = 'fatal';\n\n    // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n    if (Boolean(options['ignoreBOM']))\n      dec._ignoreBOM = true;\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty) {\n      this.encoding = dec._encoding.name.toLowerCase();\n      this.fatal = dec._error_mode === 'fatal';\n      this.ignoreBOM = dec._ignoreBOM;\n    }\n\n    // 7. Return dec.\n    return dec;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextDecoder.prototype, 'encoding', {\n      /** @this {TextDecoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n\n    // The fatal attribute's getter must return true if error mode\n    // is fatal, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'fatal', {\n      /** @this {TextDecoder} */\n      get: function() { return this._error_mode === 'fatal'; }\n    });\n\n    // The ignoreBOM attribute's getter must return true if ignore\n    // BOM flag is set, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n      /** @this {TextDecoder} */\n      get: function() { return this._ignoreBOM; }\n    });\n  }\n\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  TextDecoder.prototype.decode = function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal'});\n      this._BOMseen = false;\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    var input_stream = new Stream(bytes);\n\n    // 4. Let output be a new stream.\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    // 5. While true:\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      var token = input_stream.read();\n\n      // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n      if (token === end_of_stream)\n        break;\n\n      // 3. Otherwise, run these subsubsteps:\n\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n      result = this._decoder.handler(input_stream, token);\n\n      // 2. If result is finished, return output, serialized.\n      if (result === finished)\n        break;\n\n      if (result !== null) {\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n\n      // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n\n      // 4. Otherwise, do nothing.\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    // A TextDecoder object also has an associated serialize stream\n    // algorithm...\n    /**\n     * @param {!Array.<number>} stream\n     * @return {string}\n     * @this {TextDecoder}\n     */\n    function serializeStream(stream) {\n      // 1. Let token be the result of reading from stream.\n      // (Done in-place on array, rather than as a stream)\n\n      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n      // BOM flag and BOM seen flag are unset, run these subsubsteps:\n      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&\n          !this._ignoreBOM && !this._BOMseen) {\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\n          // 1. If token is U+FEFF, set BOM seen flag.\n          this._BOMseen = true;\n          stream.shift();\n        } else if (stream.length > 0) {\n          // 2. Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to stream.\n          this._BOMseen = true;\n        } else {\n          // 3. Otherwise, if token is not end-of-stream, append token\n          // to output.\n          // (no-op)\n        }\n      }\n      // 4. Otherwise, return output.\n      return codePointsToString(stream);\n    }\n\n    return serializeStream.call(this, output);\n  };\n\n  // 8.2 Interface TextEncoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding. NONSTANDARD.\n   * @param {Object=} options NONSTANDARD.\n   */\n  function TextEncoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextEncoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    options = ToDictionary(options);\n\n    // A TextEncoder object has an associated encoding and encoder.\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Encoder} */\n    this._encoder = null;\n\n    // Non-standard\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n    /** @private @type {string} */\n    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n\n    // 1. Let enc be a new TextEncoder object.\n    var enc = this;\n\n    // 2. Set enc's encoding to UTF-8's encoder.\n    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n      // NONSTANDARD behavior.\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n      var encoding = getEncoding(label);\n      if (encoding === null || encoding.name === 'replacement')\n        throw RangeError('Unknown encoding: ' + label);\n      if (!encoders[encoding.name]) {\n        throw Error('Encoder not present.' +\n                    ' Did you forget to include encoding-indexes.js first?');\n      }\n      enc._encoding = encoding;\n    } else {\n      // Standard behavior.\n      enc._encoding = getEncoding('utf-8');\n\n      if (label !== undefined && 'console' in global) {\n        console.warn('TextEncoder constructor called with encoding label, '\n                     + 'which is ignored.');\n      }\n    }\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty)\n      this.encoding = enc._encoding.name.toLowerCase();\n\n    // 3. Return enc.\n    return enc;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextEncoder.prototype, 'encoding', {\n      /** @this {TextEncoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n  }\n\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  TextEncoder.prototype.encode = function encode(opt_string, options) {\n    opt_string = opt_string === undefined ? '' : String(opt_string);\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n    // the input is a USVString so streaming is not necessary.\n    if (!this._do_not_flush)\n      this._encoder = encoders[this._encoding.name]({\n        fatal: this._fatal === 'fatal'});\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 1. Convert input to a stream.\n    var input = new Stream(stringToCodePoints(opt_string));\n\n    // 2. Let output be a new stream\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    // 3. While true, run these substeps:\n    while (true) {\n      // 1. Let token be the result of reading from input.\n      var token = input.read();\n      if (token === end_of_stream)\n        break;\n      // 2. Let result be the result of processing token for encoder,\n      // input, output.\n      result = this._encoder.handler(input, token);\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        output.push.apply(output, /**@type {!Array.<number>}*/(result));\n      else\n        output.push(result);\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n      this._encoder = null;\n    }\n    // 3. If result is finished, convert output into a byte sequence,\n    // and then return a Uint8Array object wrapping an ArrayBuffer\n    // containing output.\n    return new Uint8Array(output);\n  };\n\n\n  //\n  // 9. The encoding\n  //\n\n  // 9.1 utf-8\n\n  // 9.1.1 utf-8 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Decoder(options) {\n    var fatal = options.fatal;\n\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    var /** @type {number} */ utf8_code_point = 0,\n        /** @type {number} */ utf8_bytes_seen = 0,\n        /** @type {number} */ utf8_bytes_needed = 0,\n        /** @type {number} */ utf8_lower_boundary = 0x80,\n        /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 3. If utf-8 bytes needed is 0, based on byte:\n      if (utf8_bytes_needed === 0) {\n\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite;\n        }\n\n        // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n          // 1. Set utf-8 bytes needed to 1.\n          utf8_bytes_needed = 1;\n\n          // 2. Set UTF-8 code point to byte & 0x1F.\n          utf8_code_point = bite & 0x1F;\n        }\n\n        // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0)\n            utf8_lower_boundary = 0xA0;\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n          if (bite === 0xED)\n            utf8_upper_boundary = 0x9F;\n          // 3. Set utf-8 bytes needed to 2.\n          utf8_bytes_needed = 2;\n          // 4. Set UTF-8 code point to byte & 0xF.\n          utf8_code_point = bite & 0xF;\n        }\n\n        // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0)\n            utf8_lower_boundary = 0x90;\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n          if (bite === 0xF4)\n            utf8_upper_boundary = 0x8F;\n          // 3. Set utf-8 bytes needed to 3.\n          utf8_bytes_needed = 3;\n          // 4. Set UTF-8 code point to byte & 0x7.\n          utf8_code_point = bite & 0x7;\n        }\n\n        // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal);\n        }\n\n        // Return continue.\n        return null;\n      }\n\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF;\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Return error.\n        return decoderError(fatal);\n      }\n\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F);\n\n      // 7. Increase utf-8 bytes seen by one.\n      utf8_bytes_seen += 1;\n\n      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n      if (utf8_bytes_seen !== utf8_bytes_needed)\n        return null;\n\n      // 9. Let code point be utf-8 code point.\n      var code_point = utf8_code_point;\n\n      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n      // 11. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 9.1.2 utf-8 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Set count and offset based on the range code point is in:\n      var count, offset;\n      // U+0080 to U+07FF, inclusive:\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1;\n        offset = 0xC0;\n      }\n      // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2;\n        offset = 0xE0;\n      }\n      // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3;\n        offset = 0xF0;\n      }\n\n      // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n      var bytes = [(code_point >> (6 * count)) + offset];\n\n      // 5. Run these substeps while count is greater than 0:\n      while (count > 0) {\n\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> (6 * (count - 1));\n\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\n        bytes.push(0x80 | (temp & 0x3F));\n\n        // 3. Decrease count by one.\n        count -= 1;\n      }\n\n      // 6. Return bytes bytes, in order.\n      return bytes;\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-8'] = function(options) {\n    return new UTF8Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-8'] = function(options) {\n    return new UTF8Decoder(options);\n  };\n\n  //\n  // 10. Legacy single-byte encodings\n  //\n\n  // 10.1 single-byte decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteDecoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Let code point be the index code point for byte − 0x80 in\n      // index single-byte.\n      var code_point = index[bite - 0x80];\n\n      // 4. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 10.2 single-byte encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {!Array.<?number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteEncoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // single-byte.\n      var pointer = indexPointerFor(code_point, index);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        encoderError(code_point);\n\n      // 5. Return a byte whose value is pointer + 0x80.\n      return pointer + 0x80;\n    };\n  }\n\n  (function() {\n    if (!('encoding-indexes' in global))\n      return;\n    encodings.forEach(function(category) {\n      if (category.heading !== 'Legacy single-byte encodings')\n        return;\n      category.encodings.forEach(function(encoding) {\n        var name = encoding.name;\n        var idx = index(name.toLowerCase());\n        /** @param {{fatal: boolean}} options */\n        decoders[name] = function(options) {\n          return new SingleByteDecoder(idx, options);\n        };\n        /** @param {{fatal: boolean}} options */\n        encoders[name] = function(options) {\n          return new SingleByteEncoder(idx, options);\n        };\n      });\n    });\n  }());\n\n  //\n  // 11. Legacy multi-byte Chinese (simplified) encodings\n  //\n\n  // 11.1 gbk\n\n  // 11.1.1 gbk decoder\n  // gbk's decoder is gb18030's decoder.\n  /** @param {{fatal: boolean}} options */\n  decoders['GBK'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n  // 11.1.2 gbk encoder\n  // gbk's encoder is gb18030's encoder with its gbk flag set.\n  /** @param {{fatal: boolean}} options */\n  encoders['GBK'] = function(options) {\n    return new GB18030Encoder(options, true);\n  };\n\n  // 11.2 gb18030\n\n  // 11.2.1 gb18030 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function GB18030Decoder(options) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n    var /** @type {number} */ gb18030_first = 0x00,\n        /** @type {number} */ gb18030_second = 0x00,\n        /** @type {number} */ gb18030_third = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and gb18030 first, gb18030\n      // second, and gb18030 third are 0x00, return finished.\n      if (bite === end_of_stream && gb18030_first === 0x00 &&\n          gb18030_second === 0x00 && gb18030_third === 0x00) {\n        return finished;\n      }\n      // 2. If byte is end-of-stream, and gb18030 first, gb18030\n      // second, or gb18030 third is not 0x00, set gb18030 first,\n      // gb18030 second, and gb18030 third to 0x00, and return error.\n      if (bite === end_of_stream &&\n          (gb18030_first !== 0x00 || gb18030_second !== 0x00 ||\n           gb18030_third !== 0x00)) {\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        decoderError(fatal);\n      }\n      var code_point;\n      // 3. If gb18030 third is not 0x00, run these substeps:\n      if (gb18030_third !== 0x00) {\n        // 1. Let code point be null.\n        code_point = null;\n        // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n        // code point to the index gb18030 ranges code point for\n        // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n        // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n        if (inRange(bite, 0x30, 0x39)) {\n          code_point = indexGB18030RangesCodePointFor(\n              (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 +\n               gb18030_third - 0x81) * 10 + bite - 0x30);\n        }\n\n        // 3. Let buffer be a byte sequence consisting of gb18030\n        // second, gb18030 third, and byte, in order.\n        var buffer = [gb18030_second, gb18030_third, bite];\n\n        // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n        // 0x00.\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n\n        // 5. If code point is null, prepend buffer to stream and\n        // return error.\n        if (code_point === null) {\n          stream.prepend(buffer);\n          return decoderError(fatal);\n        }\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If gb18030 second is not 0x00, run these substeps:\n      if (gb18030_second !== 0x00) {\n\n        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n        // gb18030 third to byte and return continue.\n        if (inRange(bite, 0x81, 0xFE)) {\n          gb18030_third = bite;\n          return null;\n        }\n\n        // 2. Prepend gb18030 second followed by byte to stream, set\n        // gb18030 first and gb18030 second to 0x00, and return error.\n        stream.prepend([gb18030_second, bite]);\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 5. If gb18030 first is not 0x00, run these substeps:\n      if (gb18030_first !== 0x00) {\n\n        // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n        // gb18030 second to byte and return continue.\n        if (inRange(bite, 0x30, 0x39)) {\n          gb18030_second = bite;\n          return null;\n        }\n\n        // 2. Let lead be gb18030 first, let pointer be null, and set\n        // gb18030 first to 0x00.\n        var lead = gb18030_first;\n        var pointer = null;\n        gb18030_first = 0x00;\n\n        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x41;\n\n        // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - offset);\n\n        // 5. Let code point be null if pointer is null and the index\n        // code point for pointer in index gb18030 otherwise.\n        code_point = pointer === null ? null :\n            indexCodePointFor(pointer, index('gb18030'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x80, return code point U+20AC.\n      if (bite === 0x80)\n        return 0x20AC;\n\n      // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 first to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        gb18030_first = bite;\n        return null;\n      }\n\n      // 9. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 11.2.2 gb18030 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   * @param {boolean=} gbk_flag\n   */\n  function GB18030Encoder(options, gbk_flag) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gbk flag (initially unset).\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+E5E5, return error with code point.\n      if (code_point === 0xE5E5)\n        return encoderError(code_point);\n\n      // 4. If the gbk flag is set and code point is U+20AC, return\n      // byte 0x80.\n      if (gbk_flag && code_point === 0x20AC)\n        return 0x80;\n\n      // 5. Let pointer be the index pointer for code point in index\n      // gb18030.\n      var pointer = indexPointerFor(code_point, index('gb18030'));\n\n      // 6. If pointer is not null, run these substeps:\n      if (pointer !== null) {\n\n        // 1. Let lead be floor(pointer / 190) + 0x81.\n        var lead = floor(pointer / 190) + 0x81;\n\n        // 2. Let trail be pointer % 190.\n        var trail = pointer % 190;\n\n        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n        var offset = trail < 0x3F ? 0x40 : 0x41;\n\n        // 4. Return two bytes whose values are lead and trail + offset.\n        return [lead, trail + offset];\n      }\n\n      // 7. If gbk flag is set, return error with code point.\n      if (gbk_flag)\n        return encoderError(code_point);\n\n      // 8. Set pointer to the index gb18030 ranges pointer for code\n      // point.\n      pointer = indexGB18030RangesPointerFor(code_point);\n\n      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n      var byte1 = floor(pointer / 10 / 126 / 10);\n\n      // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n      pointer = pointer - byte1 * 10 * 126 * 10;\n\n      // 11. Let byte2 be floor(pointer / 10 / 126).\n      var byte2 = floor(pointer / 10 / 126);\n\n      // 12. Set pointer to pointer − byte2 × 10 × 126.\n      pointer = pointer - byte2 * 10 * 126;\n\n      // 13. Let byte3 be floor(pointer / 10).\n      var byte3 = floor(pointer / 10);\n\n      // 14. Let byte4 be pointer − byte3 × 10.\n      var byte4 = pointer - byte3 * 10;\n\n      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n      // 0x30, byte3 + 0x81, byte4 + 0x30.\n      return [byte1 + 0x81,\n              byte2 + 0x30,\n              byte3 + 0x81,\n              byte4 + 0x30];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['gb18030'] = function(options) {\n    return new GB18030Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['gb18030'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n\n  //\n  // 12. Legacy multi-byte Chinese (traditional) encodings\n  //\n\n  // 12.1 Big5\n\n  // 12.1.1 Big5 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Decoder(options) {\n    var fatal = options.fatal;\n    // Big5's decoder has an associated Big5 lead (initially 0x00).\n    var /** @type {number} */ Big5_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n      // Big5 lead to 0x00 and return error.\n      if (bite === end_of_stream && Big5_lead !== 0x00) {\n        Big5_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && Big5_lead === 0x00)\n        return finished;\n\n      // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n      // pointer be null, set Big5 lead to 0x00, and then run these\n      // substeps:\n      if (Big5_lead !== 0x00) {\n        var lead = Big5_lead;\n        var pointer = null;\n        Big5_lead = 0x00;\n\n        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x62;\n\n        // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))\n          pointer = (lead - 0x81) * 157 + (bite - offset);\n\n        // 3. If there is a row in the table below whose first column\n        // is pointer, return the two code points listed in its second\n        // column\n        // Pointer | Code points\n        // --------+--------------\n        // 1133    | U+00CA U+0304\n        // 1135    | U+00CA U+030C\n        // 1164    | U+00EA U+0304\n        // 1166    | U+00EA U+030C\n        switch (pointer) {\n          case 1133: return [0x00CA, 0x0304];\n          case 1135: return [0x00CA, 0x030C];\n          case 1164: return [0x00EA, 0x0304];\n          case 1166: return [0x00EA, 0x030C];\n        }\n\n        // 4. Let code point be null if pointer is null and the index\n        // code point for pointer in index Big5 otherwise.\n        var code_point = (pointer === null) ? null :\n            indexCodePointFor(pointer, index('big5'));\n\n        // 5. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 6. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 7. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n      // lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        Big5_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 12.1.2 Big5 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index Big5 pointer for code point.\n      var pointer = indexBig5PointerFor(code_point);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 157) + 0x81.\n      var lead = floor(pointer / 157) + 0x81;\n\n      // 6. If lead is less than 0xA1, return error with code point.\n      if (lead < 0xA1)\n        return encoderError(code_point);\n\n      // 7. Let trail be pointer % 157.\n      var trail = pointer % 157;\n\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x62;\n\n      // Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Big5'] = function(options) {\n    return new Big5Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Big5'] = function(options) {\n    return new Big5Decoder(options);\n  };\n\n\n  //\n  // 13. Legacy multi-byte Japanese encodings\n  //\n\n  // 13.1 euc-jp\n\n  // 13.1.1 euc-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n    var /** @type {boolean} */ eucjp_jis0212_flag = false,\n        /** @type {number} */ eucjp_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n      // euc-jp lead to 0x00, and return error.\n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\n        eucjp_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && eucjp_lead === 0x00)\n        return finished;\n\n      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n      // point whose value is 0xFF61 − 0xA1 + byte.\n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n        eucjp_lead = 0x00;\n        return 0xFF61 - 0xA1 + bite;\n      }\n\n      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n      // to byte, and return continue.\n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n        eucjp_jis0212_flag = true;\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n      // euc-jp lead to 0x00, and run these substeps:\n      if (eucjp_lead !== 0x00) {\n        var lead = eucjp_lead;\n        eucjp_lead = 0x00;\n\n        // 1. Let code point be null.\n        var code_point = null;\n\n        // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n        // inclusive, set code point to the index code point for (lead\n        // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n        // jis0212 flag is unset and in index jis0212 otherwise.\n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n          code_point = indexCodePointFor(\n            (lead - 0xA1) * 94 + (bite - 0xA1),\n            index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n        }\n\n        // 3. Unset the euc-jp jis0212 flag.\n        eucjp_jis0212_flag = false;\n\n        // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n        // prepend byte to stream.\n        if (!inRange(bite, 0xA1, 0xFE))\n          stream.prepend(bite);\n\n        // 5. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n      // inclusive, set euc-jp lead to byte and return continue.\n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 8. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.1.2 euc-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return two bytes whose values are 0x8E and code point −\n      // 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return [0x8E, code_point - 0xFF61 + 0xA1];\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 94) + 0xA1.\n      var lead = floor(pointer / 94) + 0xA1;\n\n      // 10. Let trail be pointer % 94 + 0xA1.\n      var trail = pointer % 94 + 0xA1;\n\n      // 11. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-JP'] = function(options) {\n    return new EUCJPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-JP'] = function(options) {\n    return new EUCJPDecoder(options);\n  };\n\n  // 13.2 iso-2022-jp\n\n  // 13.2.1 iso-2022-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPDecoder(options) {\n    var fatal = options.fatal;\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    };\n    // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n    var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,\n        /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,\n        /** @type {number} */ iso2022jp_lead = 0x00,\n        /** @type {boolean} */ iso2022jp_output_flag = false;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // switching on iso-2022-jp decoder state:\n      switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E\n            && bite !== 0x0F && bite !== 0x1B) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5C) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          iso2022jp_output_flag = false;\n          return 0x00A5;\n        }\n\n        // 0x7E\n        if (bite === 0x7E) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          iso2022jp_output_flag = false;\n          return 0x203E;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F\n            && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5F)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61 − 0x21 + byte.\n          iso2022jp_output_flag = false;\n          return 0xFF61 - 0x21 + bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          iso2022jp_decoder_state = states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          var code_point = indexCodePointFor(pointer, index('jis0208'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null)\n            return decoderError(fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n\n      case states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n\n      case states.Escape:\n        // Escape\n\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n        // 0x00.\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        // 2. Let state be null.\n        var state = null;\n\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n        if (lead === 0x28 && bite === 0x42)\n          state = states.ASCII;\n\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n        if (lead === 0x28 && bite === 0x4A)\n          state = states.Roman;\n\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n        if (lead === 0x28 && bite === 0x49)\n          state = states.Katakana;\n\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n        // state to lead byte.\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42))\n          state = states.LeadByte;\n\n        // 7. If state is non-null, run these substeps:\n        if (state !== null) {\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n          // output state to states.\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n          // 2. Let output flag be the iso-2022-jp output flag.\n          var output_flag = iso2022jp_output_flag;\n\n          // 3. Set the iso-2022-jp output flag.\n          iso2022jp_output_flag = true;\n\n          // 4. Return continue, if output flag is unset, and error\n          // otherwise.\n          return !output_flag ? null : decoderError(fatal);\n        }\n\n        // 8. Prepend lead and byte to stream.\n        stream.prepend([lead, bite]);\n\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n      }\n    };\n  }\n\n  // 13.2.2 iso-2022-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPEncoder(options) {\n    var fatal = options.fatal;\n    // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    var /** @type {number} */ iso2022jp_state = states.ASCII;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream and iso-2022-jp encoder\n      // state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (code_point === end_of_stream &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 2. If code point is end-of-stream and iso-2022-jp encoder\n      // state is ASCII, return finished.\n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)\n        return finished;\n\n      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n      if ((iso2022jp_state === states.ASCII ||\n           iso2022jp_state === states.Roman) &&\n          (code_point === 0x000E || code_point === 0x000F ||\n           code_point === 0x001B)) {\n        return encoderError(0xFFFD);\n      }\n\n      // 4. If iso-2022-jp encoder state is ASCII and code point is an\n      // ASCII code point, return a byte whose value is code point.\n      if (iso2022jp_state === states.ASCII &&\n          isASCIICodePoint(code_point))\n        return code_point;\n\n      // 5. If iso-2022-jp encoder state is Roman and code point is an\n      // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n      // or U+203E, run these substeps:\n      if (iso2022jp_state === states.Roman &&\n          ((isASCIICodePoint(code_point) &&\n           code_point !== 0x005C && code_point !== 0x007E) ||\n          (code_point == 0x00A5 || code_point == 0x203E))) {\n\n        // 1. If code point is an ASCII code point, return a byte\n        // whose value is code point.\n        if (isASCIICodePoint(code_point))\n          return code_point;\n\n        // 2. If code point is U+00A5, return byte 0x5C.\n        if (code_point === 0x00A5)\n          return 0x5C;\n\n        // 3. If code point is U+203E, return byte 0x7E.\n        if (code_point === 0x203E)\n          return 0x7E;\n      }\n\n      // 6. If code point is an ASCII code point, and iso-2022-jp\n      // encoder state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (isASCIICodePoint(code_point) &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n      // encoder state is not Roman, prepend code point to stream, set\n      // iso-2022-jp encoder state to Roman, and return three bytes\n      // 0x1B 0x28 0x4A.\n      if ((code_point === 0x00A5 || code_point === 0x203E) &&\n          iso2022jp_state !== states.Roman) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.Roman;\n        return [0x1B, 0x28, 0x4A];\n      }\n\n      // 8. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 9. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 10. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n      // point to stream, set iso-2022-jp encoder state to jis0208,\n      // and return three bytes 0x1B 0x24 0x42.\n      if (iso2022jp_state !== states.jis0208) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.jis0208;\n        return [0x1B, 0x24, 0x42];\n      }\n\n      // 12. Let lead be floor(pointer / 94) + 0x21.\n      var lead = floor(pointer / 94) + 0x21;\n\n      // 13. Let trail be pointer % 94 + 0x21.\n      var trail = pointer % 94 + 0x21;\n\n      // 14. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPDecoder(options);\n  };\n\n  // 13.3 Shift_JIS\n\n  // 13.3.1 Shift_JIS decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISDecoder(options) {\n    var fatal = options.fatal;\n    // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n    var /** @type {number} */ Shift_JIS_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n      // set Shift_JIS lead to 0x00 and return error.\n      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n        Shift_JIS_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n      // return finished.\n      if (bite === end_of_stream && Shift_JIS_lead === 0x00)\n        return finished;\n\n      // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n      // let pointer be null, set Shift_JIS lead to 0x00, and then run\n      // these substeps:\n      if (Shift_JIS_lead !== 0x00) {\n        var lead = Shift_JIS_lead;\n        var pointer = null;\n        Shift_JIS_lead = 0x00;\n\n        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n        // otherwise.\n        var offset = (bite < 0x7F) ? 0x40 : 0x41;\n\n        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n        // 0xC1 otherwise.\n        var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;\n\n        // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n        // 188 + byte − offset.\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))\n          pointer = (lead - lead_offset) * 188 + bite - offset;\n\n        // 4. If pointer is in the range 8836 to 10715, inclusive,\n        // return a code point whose value is 0xE000 − 8836 + pointer.\n        if (inRange(pointer, 8836, 10715))\n          return 0xE000 - 8836 + pointer;\n\n        // 5. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index jis0208 otherwise.\n        var code_point = (pointer === null) ? null :\n              indexCodePointFor(pointer, index('jis0208'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte or 0x80, return a code point\n      // whose value is byte.\n      if (isASCIIByte(bite) || bite === 0x80)\n        return bite;\n\n      // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n      // code point whose value is 0xFF61 − 0xA1 + byte.\n      if (inRange(bite, 0xA1, 0xDF))\n        return 0xFF61 - 0xA1 + bite;\n\n      // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n      // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n      // continue.\n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n        Shift_JIS_lead = bite;\n        return null;\n      }\n\n      // 7. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.3.2 Shift_JIS encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point or U+0080, return a\n      // byte whose value is code point.\n      if (isASCIICodePoint(code_point) || code_point === 0x0080)\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return a byte whose value is code point − 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return code_point - 0xFF61 + 0xA1;\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index Shift_JIS pointer for code point.\n      var pointer = indexShiftJISPointerFor(code_point);\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 188).\n      var lead = floor(pointer / 188);\n\n      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n      // 0xC1 otherwise.\n      var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;\n\n      // 11. Let trail be pointer % 188.\n      var trail = pointer % 188;\n\n      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n      // otherwise.\n      var offset = (trail < 0x3F) ? 0x40 : 0x41;\n\n      // 13. Return two bytes whose values are lead + lead offset and\n      // trail + offset.\n      return [lead + lead_offset, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Shift_JIS'] = function(options) {\n    return new ShiftJISEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Shift_JIS'] = function(options) {\n    return new ShiftJISDecoder(options);\n  };\n\n  //\n  // 14. Legacy multi-byte Korean encodings\n  //\n\n  // 14.1 euc-kr\n\n  // 14.1.1 euc-kr decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKRDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n    var /** @type {number} */ euckr_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n      // euc-kr lead to 0x00 and return error.\n      if (bite === end_of_stream && euckr_lead !== 0) {\n        euckr_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && euckr_lead === 0)\n        return finished;\n\n      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n      // pointer be null, set euc-kr lead to 0x00, and then run these\n      // substeps:\n      if (euckr_lead !== 0x00) {\n        var lead = euckr_lead;\n        var pointer = null;\n        euckr_lead = 0x00;\n\n        // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n        // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n        if (inRange(bite, 0x41, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n        // 2. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index euc-kr otherwise.\n        var code_point = (pointer === null)\n              ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n        // 3. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (pointer === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 4. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 5. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // euc-kr lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        euckr_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 14.1.2 euc-kr encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKREncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // euc-kr.\n      var pointer = indexPointerFor(code_point, index('euc-kr'));\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 6. Let trail be pointer % 190 + 0x41.\n      var trail = (pointer % 190) + 0x41;\n\n      // 7. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-KR'] = function(options) {\n    return new EUCKREncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-KR'] = function(options) {\n    return new EUCKRDecoder(options);\n  };\n\n\n  //\n  // 15. Legacy miscellaneous encodings\n  //\n\n  // 15.1 replacement\n\n  // Not needed - API throws RangeError\n\n  // 15.2 Common infrastructure for utf-16be and utf-16le\n\n  /**\n   * @param {number} code_unit\n   * @param {boolean} utf16be\n   * @return {!Array.<number>} bytes\n   */\n  function convertCodeUnitToBytes(code_unit, utf16be) {\n    // 1. Let byte1 be code unit >> 8.\n    var byte1 = code_unit >> 8;\n\n    // 2. Let byte2 be code unit & 0x00FF.\n    var byte2 = code_unit & 0x00FF;\n\n    // 3. Then return the bytes in order:\n        // utf-16be flag is set: byte1, then byte2.\n    if (utf16be)\n      return [byte1, byte2];\n    // utf-16be flag is unset: byte2, then byte1.\n    return [byte2, byte1];\n  }\n\n  // 15.2.1 shared utf-16 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Decoder(utf16_be, options) {\n    var fatal = options.fatal;\n    var /** @type {?number} */ utf16_lead_byte = null,\n        /** @type {?number} */ utf16_lead_surrogate = null;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and either utf-16 lead byte or\n      // utf-16 lead surrogate is not null, set utf-16 lead byte and\n      // utf-16 lead surrogate to null, and return error.\n      if (bite === end_of_stream && (utf16_lead_byte !== null ||\n                                utf16_lead_surrogate !== null)) {\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n      // lead surrogate are null, return finished.\n      if (bite === end_of_stream && utf16_lead_byte === null &&\n          utf16_lead_surrogate === null) {\n        return finished;\n      }\n\n      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n      // and return continue.\n      if (utf16_lead_byte === null) {\n        utf16_lead_byte = bite;\n        return null;\n      }\n\n      // 4. Let code unit be the result of:\n      var code_unit;\n      if (utf16_be) {\n        // utf-16be decoder flag is set\n        //   (utf-16 lead byte << 8) + byte.\n        code_unit = (utf16_lead_byte << 8) + bite;\n      } else {\n        // utf-16be decoder flag is unset\n        //   (byte << 8) + utf-16 lead byte.\n        code_unit = (bite << 8) + utf16_lead_byte;\n      }\n      // Then set utf-16 lead byte to null.\n      utf16_lead_byte = null;\n\n      // 5. If utf-16 lead surrogate is not null, let lead surrogate\n      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n      // and then run these substeps:\n      if (utf16_lead_surrogate !== null) {\n        var lead_surrogate = utf16_lead_surrogate;\n        utf16_lead_surrogate = null;\n\n        // 1. If code unit is in the range U+DC00 to U+DFFF,\n        // inclusive, return a code point whose value is 0x10000 +\n        // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +\n              (code_unit - 0xDC00);\n        }\n\n        // 2. Prepend the sequence resulting of converting code unit\n        // to bytes using utf-16be decoder flag to stream and return\n        // error.\n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n        return decoderError(fatal);\n      }\n\n      // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n      // set utf-16 lead surrogate to code unit and return continue.\n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\n        utf16_lead_surrogate = code_unit;\n        return null;\n      }\n\n      // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n      // return error.\n      if (inRange(code_unit, 0xDC00, 0xDFFF))\n        return decoderError(fatal);\n\n      // 8. Return code point code unit.\n      return code_unit;\n    };\n  }\n\n  // 15.2.2 shared utf-16 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Encoder(utf16_be, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n      // return the sequence resulting of converting code point to\n      // bytes using utf-16be encoder flag.\n      if (inRange(code_point, 0x0000, 0xFFFF))\n        return convertCodeUnitToBytes(code_point, utf16_be);\n\n      // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n      // converted to bytes using utf-16be encoder flag.\n      var lead = convertCodeUnitToBytes(\n        ((code_point - 0x10000) >> 10) + 0xD800, utf16_be);\n\n      // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n      // converted to bytes using utf-16be encoder flag.\n      var trail = convertCodeUnitToBytes(\n        ((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);\n\n      // 5. Return a byte sequence of lead followed by trail.\n      return lead.concat(trail);\n    };\n  }\n\n  // 15.3 utf-16be\n  // 15.3.1 utf-16be decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16BE'] = function(options) {\n    return new UTF16Encoder(true, options);\n  };\n  // 15.3.2 utf-16be encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16BE'] = function(options) {\n    return new UTF16Decoder(true, options);\n  };\n\n  // 15.4 utf-16le\n  // 15.4.1 utf-16le decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16LE'] = function(options) {\n    return new UTF16Encoder(false, options);\n  };\n  // 15.4.2 utf-16le encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16LE'] = function(options) {\n    return new UTF16Decoder(false, options);\n  };\n\n  // 15.5 x-user-defined\n\n  // 15.5.1 x-user-defined decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedDecoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n      return 0xF780 + bite - 0x80;\n    };\n  }\n\n  // 15.5.2 x-user-defined encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1.If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n      // return a byte whose value is code point − 0xF780 + 0x80.\n      if (inRange(code_point, 0xF780, 0xF7FF))\n        return code_point - 0xF780 + 0x80;\n\n      // 4. Return error with code point.\n      return encoderError(code_point);\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['x-user-defined'] = function(options) {\n    return new XUserDefinedEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['x-user-defined'] = function(options) {\n    return new XUserDefinedDecoder(options);\n  };\n\n  if (!global['TextEncoder'])\n    global['TextEncoder'] = TextEncoder;\n  if (!global['TextDecoder'])\n    global['TextDecoder'] = TextDecoder;\n\n  if ( true && module.exports) {\n    module.exports = {\n      TextEncoder: global['TextEncoder'],\n      TextDecoder: global['TextDecoder'],\n      EncodingIndexes: global[\"encoding-indexes\"]\n    };\n  }\n\n// For strict environments where `this` inside the global scope\n// is `undefined`, take a pure object instead\n}(this || {}));\n\n\n//# sourceURL=webpack:///./node_modules/text-encoding-polyfill/lib/encoding.js?");

/***/ }),

/***/ "./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs ***!
  \***************************************************************/
/*! exports provided: TextEncoder, TextDecoder */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextEncoder\", function() { return TextEncoder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextDecoder\", function() { return TextDecoder; });\n\n\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = string.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n                               (cp & 0x3FF) + 0xDC00);\n    }\n  }\n  return s;\n}\n\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 3. Terminology\n//\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the\n * stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n   read: function() {\n    if (!this.tokens.length)\n      return end_of_stream;\n     return this.tokens.shift();\n   },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.unshift(tokens.pop());\n    } else {\n      this.tokens.unshift(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.push(tokens.shift());\n    } else {\n      this.tokens.push(token);\n    }\n  }\n};\n\n//\n// 4. Encodings\n//\n\n// 4.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error');\n  return opt_code_point || 0xFFFD;\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function(stream, code_point) {}\n};\n\n//\n// 7. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 7.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(encoding, options) {\n  if (!(this instanceof TextDecoder)) {\n    return new TextDecoder(encoding, options);\n  }\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._fatal = Boolean(options['fatal']);\n  /** @private @type {boolean} */\n  this._ignoreBOM = Boolean(options['ignoreBOM']);\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n  Object.defineProperty(this, 'fatal', {value: this._fatal});\n  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});\n}\n\nTextDecoder.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    if (!this._streaming) {\n      this._decoder = new UTF8Decoder({fatal: this._fatal});\n      this._BOMseen = false;\n    }\n    this._streaming = Boolean(options['stream']);\n\n    var input_stream = new Stream(bytes);\n\n    var code_points = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    while (!input_stream.endOfStream()) {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (result === null)\n        continue;\n      if (Array.isArray(result))\n        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n      else\n        code_points.push(result);\n    }\n    if (!this._streaming) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n        else\n          code_points.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    if (code_points.length) {\n      // If encoding is one of utf-8, utf-16be, and utf-16le, and\n      // ignore BOM flag and BOM seen flag are unset, run these\n      // subsubsteps:\n      if (['utf-8'].indexOf(this.encoding) !== -1 &&\n          !this._ignoreBOM && !this._BOMseen) {\n        // If token is U+FEFF, set BOM seen flag.\n        if (code_points[0] === 0xFEFF) {\n          this._BOMseen = true;\n          code_points.shift();\n        } else {\n          // Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to output.\n          this._BOMseen = true;\n        }\n      }\n    }\n\n    return codePointsToString(code_points);\n  }\n};\n\n// 7.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextEncoder(encoding, options) {\n  if (!(this instanceof TextEncoder))\n    return new TextEncoder(encoding, options);\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n  /** @private @type {{fatal: boolean}} */\n  this._options = {fatal: Boolean(options['fatal'])};\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n}\n\nTextEncoder.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : '';\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,\n    // so streaming is not necessary.\n    if (!this._streaming)\n      this._encoder = new UTF8Encoder(this._options);\n    this._streaming = Boolean(options['stream']);\n\n    var bytes = [];\n    var input_stream = new Stream(stringToCodePoints(opt_string));\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    while (!input_stream.endOfStream()) {\n      result = this._encoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n      else\n        bytes.push(result);\n    }\n    if (!this._streaming) {\n      while (true) {\n        result = this._encoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n        else\n          bytes.push(result);\n      }\n      this._encoder = null;\n    }\n    return new Uint8Array(bytes);\n  }\n};\n\n//\n// 8. The encoding\n//\n\n// 8.1 utf-8\n\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7F)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      if (inRange(bite, 0xC2, 0xDF)) {\n        // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n        // − 0xC0.\n        utf8_bytes_needed = 1;\n        utf8_code_point = bite - 0xC0;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xE0, 0xEF)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xE0)\n          utf8_lower_boundary = 0xA0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xED)\n          utf8_upper_boundary = 0x9F;\n        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n        // byte − 0xE0.\n        utf8_bytes_needed = 2;\n        utf8_code_point = bite - 0xE0;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xF0, 0xF4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xF0)\n          utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xF4)\n          utf8_upper_boundary = 0x8F;\n        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n        // byte − 0xF0.\n        utf8_bytes_needed = 3;\n        utf8_code_point = bite - 0xF0;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code\n      // point to utf-8 code point << (6 × utf-8 bytes needed) and\n      // return continue.\n      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xBF;\n\n    // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n    // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes\n    // needed − utf-8 bytes seen)).\n    utf8_bytes_seen += 1;\n    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));\n\n    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed)\n      return null;\n\n    // 8. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 10. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished;\n\n    // 2. If code point is in the range U+0000 to U+007F, return a\n    // byte whose value is code point.\n    if (inRange(code_point, 0x0000, 0x007f))\n      return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF:    1 and 0xC0\n    if (inRange(code_point, 0x0080, 0x07FF)) {\n      count = 1;\n      offset = 0xC0;\n    }\n    // U+0800 to U+FFFF:    2 and 0xE0\n    else if (inRange(code_point, 0x0800, 0xFFFF)) {\n      count = 2;\n      offset = 0xE0;\n    }\n    // U+10000 to U+10FFFF: 3 and 0xF0\n    else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n      count = 3;\n      offset = 0xF0;\n    }\n\n    // 4.Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3F));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/wkt-parser/index.js":
/*!******************************************!*\
  !*** ./node_modules/wkt-parser/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser */ \"./node_modules/wkt-parser/parser.js\");\n/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./process */ \"./node_modules/wkt-parser/process.js\");\nvar D2R = 0.01745329251994329577;\n\n\n\n\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === 'GEOGCS') {\n    wkt.projName = 'longlat';\n  } else if (wkt.type === 'LOCAL_CS') {\n    wkt.projName = 'identity';\n    wkt.local = true;\n  } else {\n    if (typeof wkt.PROJECTION === 'object') {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    } else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === 'metre') {\n      wkt.units = 'meter';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === 'GEOGCS') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = wkt.UNIT.convert;\n      }\n    }\n  }\n  var geogcs = wkt.GEOGCS;\n  if (wkt.type === 'GEOGCS') {\n    geogcs = wkt;\n  }\n  if (geogcs) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (geogcs.DATUM) {\n      wkt.datumCode = geogcs.DATUM.name.toLowerCase();\n    } else {\n      wkt.datumCode = geogcs.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === 'd_') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n      wkt.datumCode = 'nzgd49';\n    }\n    if (wkt.datumCode === 'wgs_1984') {\n      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = 'wgs84';\n    }\n    if (wkt.datumCode.slice(-6) === '_ferro') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === '_jakarta') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf('belge')) {\n      wkt.datumCode = 'rnb72';\n    }\n    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\n      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {\n        wkt.ellps = 'intl';\n      }\n\n      wkt.a = geogcs.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\n    }\n\n    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {\n      wkt.datum_params = geogcs.DATUM.TOWGS84;\n    }\n    if (~wkt.datumCode.indexOf('osgb_1936')) {\n      wkt.datumCode = 'osgb36';\n    }\n    if (~wkt.datumCode.indexOf('osni_1952')) {\n      wkt.datumCode = 'osni52';\n    }\n    if (~wkt.datumCode.indexOf('tm65')\n      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {\n      wkt.datumCode = 'ire65';\n    }\n    if (wkt.datumCode === 'ch1903+') {\n      wkt.datumCode = 'ch1903';\n    }\n    if (~wkt.datumCode.indexOf('israel')) {\n      wkt.datumCode = 'isr93';\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return input * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    ['standard_parallel_1', 'Standard_Parallel_1'],\n    ['standard_parallel_2', 'Standard_Parallel_2'],\n    ['false_easting', 'False_Easting'],\n    ['false_northing', 'False_Northing'],\n    ['central_meridian', 'Central_Meridian'],\n    ['latitude_of_origin', 'Latitude_Of_Origin'],\n    ['latitude_of_origin', 'Central_Parallel'],\n    ['scale_factor', 'Scale_Factor'],\n    ['k0', 'scale_factor'],\n    ['latitude_of_center', 'Latitude_Of_Center'],\n    ['latitude_of_center', 'Latitude_of_center'],\n    ['lat0', 'latitude_of_center', d2r],\n    ['longitude_of_center', 'Longitude_Of_Center'],\n    ['longitude_of_center', 'Longitude_of_center'],\n    ['longc', 'longitude_of_center', d2r],\n    ['x0', 'false_easting', toMeter],\n    ['y0', 'false_northing', toMeter],\n    ['long0', 'central_meridian', d2r],\n    ['lat0', 'latitude_of_origin', d2r],\n    ['lat0', 'standard_parallel_1', d2r],\n    ['lat1', 'standard_parallel_1', d2r],\n    ['lat2', 'standard_parallel_2', d2r],\n    ['azimuth', 'Azimuth'],\n    ['alpha', 'azimuth', d2r],\n    ['srsCode', 'name']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(wkt) {\n  var lisp = Object(_parser__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(wkt);\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift(['name', name]);\n  lisp.unshift(['type', type]);\n  var obj = {};\n  Object(_process__WEBPACK_IMPORTED_MODULE_1__[\"sExpr\"])(lisp, obj);\n  cleanWKT(obj);\n  return obj;\n});\n\n\n//# sourceURL=webpack:///./node_modules/wkt-parser/index.js?");

/***/ }),

/***/ "./node_modules/wkt-parser/parser.js":
/*!*******************************************!*\
  !*** ./node_modules/wkt-parser/parser.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (parseString);\n\nvar NEUTRAL = 1;\nvar KEYWORD = 2;\nvar NUMBER = 3;\nvar QUOTED = 4;\nvar AFTERQUOTE = 5;\nvar ENDED = -1;\nvar whitespace = /\\s/;\nvar latin = /[A-Za-z]/;\nvar keyword = /[A-Za-z84]/;\nvar endThings = /[,\\]]/;\nvar digets = /[\\d\\.E\\-\\+]/;\n// const ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction Parser(text) {\n  if (typeof text !== 'string') {\n    throw new Error('not a string');\n  }\n  this.text = text.trim();\n  this.level = 0;\n  this.place = 0;\n  this.root = null;\n  this.stack = [];\n  this.currentObject = null;\n  this.state = NEUTRAL;\n}\nParser.prototype.readCharicter = function() {\n  var char = this.text[this.place++];\n  if (this.state !== QUOTED) {\n    while (whitespace.test(char)) {\n      if (this.place >= this.text.length) {\n        return;\n      }\n      char = this.text[this.place++];\n    }\n  }\n  switch (this.state) {\n    case NEUTRAL:\n      return this.neutral(char);\n    case KEYWORD:\n      return this.keyword(char)\n    case QUOTED:\n      return this.quoted(char);\n    case AFTERQUOTE:\n      return this.afterquote(char);\n    case NUMBER:\n      return this.number(char);\n    case ENDED:\n      return;\n  }\n};\nParser.prototype.afterquote = function(char) {\n  if (char === '\"') {\n    this.word += '\"';\n    this.state = QUOTED;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = this.word.trim();\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in afterquote yet, index ' + this.place);\n};\nParser.prototype.afterItem = function(char) {\n  if (char === ',') {\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n    }\n    this.word = null;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (char === ']') {\n    this.level--;\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n      this.word = null;\n    }\n    this.state = NEUTRAL;\n    this.currentObject = this.stack.pop();\n    if (!this.currentObject) {\n      this.state = ENDED;\n    }\n\n    return;\n  }\n};\nParser.prototype.number = function(char) {\n  if (digets.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = parseFloat(this.word);\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in number yet, index ' + this.place);\n};\nParser.prototype.quoted = function(char) {\n  if (char === '\"') {\n    this.state = AFTERQUOTE;\n    return;\n  }\n  this.word += char;\n  return;\n};\nParser.prototype.keyword = function(char) {\n  if (keyword.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (char === '[') {\n    var newObjects = [];\n    newObjects.push(this.word);\n    this.level++;\n    if (this.root === null) {\n      this.root = newObjects;\n    } else {\n      this.currentObject.push(newObjects);\n    }\n    this.stack.push(this.currentObject);\n    this.currentObject = newObjects;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in keyword yet, index ' + this.place);\n};\nParser.prototype.neutral = function(char) {\n  if (latin.test(char)) {\n    this.word = char;\n    this.state = KEYWORD;\n    return;\n  }\n  if (char === '\"') {\n    this.word = '';\n    this.state = QUOTED;\n    return;\n  }\n  if (digets.test(char)) {\n    this.word = char;\n    this.state = NUMBER;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in neutral yet, index ' + this.place);\n};\nParser.prototype.output = function() {\n  while (this.place < this.text.length) {\n    this.readCharicter();\n  }\n  if (this.state === ENDED) {\n    return this.root;\n  }\n  throw new Error('unable to parse string \"' +this.text + '\". State is ' + this.state);\n};\n\nfunction parseString(txt) {\n  var parser = new Parser(txt);\n  return parser.output();\n}\n\n\n//# sourceURL=webpack:///./node_modules/wkt-parser/parser.js?");

/***/ }),

/***/ "./node_modules/wkt-parser/process.js":
/*!********************************************!*\
  !*** ./node_modules/wkt-parser/process.js ***!
  \********************************************/
/*! exports provided: sExpr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sExpr\", function() { return sExpr; });\n\n\nfunction mapit(obj, key, value) {\n  if (Array.isArray(key)) {\n    value.unshift(key);\n    key = null;\n  }\n  var thing = key ? {} : obj;\n\n  var out = value.reduce(function(newObj, item) {\n    sExpr(item, newObj);\n    return newObj\n  }, thing);\n  if (key) {\n    obj[key] = out;\n  }\n}\n\nfunction sExpr(v, obj) {\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  var key = v.shift();\n  if (key === 'PARAMETER') {\n    key = v.shift();\n  }\n  if (v.length === 1) {\n    if (Array.isArray(v[0])) {\n      obj[key] = {};\n      sExpr(v[0], obj[key]);\n      return;\n    }\n    obj[key] = v[0];\n    return;\n  }\n  if (!v.length) {\n    obj[key] = true;\n    return;\n  }\n  if (key === 'TOWGS84') {\n    obj[key] = v;\n    return;\n  }\n  if (!Array.isArray(key)) {\n    obj[key] = {};\n  }\n\n  var i;\n  switch (key) {\n    case 'UNIT':\n    case 'PRIMEM':\n    case 'VERT_DATUM':\n      obj[key] = {\n        name: v[0].toLowerCase(),\n        convert: v[1]\n      };\n      if (v.length === 3) {\n        sExpr(v[2], obj[key]);\n      }\n      return;\n    case 'SPHEROID':\n    case 'ELLIPSOID':\n      obj[key] = {\n        name: v[0],\n        a: v[1],\n        rf: v[2]\n      };\n      if (v.length === 4) {\n        sExpr(v[3], obj[key]);\n      }\n      return;\n    case 'PROJECTEDCRS':\n    case 'PROJCRS':\n    case 'GEOGCS':\n    case 'GEOCCS':\n    case 'PROJCS':\n    case 'LOCAL_CS':\n    case 'GEODCRS':\n    case 'GEODETICCRS':\n    case 'GEODETICDATUM':\n    case 'EDATUM':\n    case 'ENGINEERINGDATUM':\n    case 'VERT_CS':\n    case 'VERTCRS':\n    case 'VERTICALCRS':\n    case 'COMPD_CS':\n    case 'COMPOUNDCRS':\n    case 'ENGINEERINGCRS':\n    case 'ENGCRS':\n    case 'FITTED_CS':\n    case 'LOCAL_DATUM':\n    case 'DATUM':\n      v[0] = ['name', v[0]];\n      mapit(obj, key, v);\n      return;\n    default:\n      i = -1;\n      while (++i < v.length) {\n        if (!Array.isArray(v[i])) {\n          return sExpr(v, obj[key]);\n        }\n      }\n      return mapit(obj, key, v);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/wkt-parser/process.js?");

/***/ }),

/***/ "./public/javascripts/map.js":
/*!***********************************!*\
  !*** ./public/javascripts/map.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//import { itowns } from \"itowns\";\r\n__webpack_require__(/*! itowns */ \"./node_modules/itowns/lib/Main.js\");\r\n\r\nvar searchParams = new URL(window.location.href).searchParams;\r\n\r\nfunction showPointcloud(serverUrl, fileName, lopocsTable) {\r\n    var pointcloud;\r\n    var oldPostUpdate;\r\n    var viewerDiv;\r\n    var debugGui;\r\n    var view;\r\n    var controls;\r\n\r\n    viewerDiv = document.getElementById('viewerDiv');\r\n    viewerDiv.style.display = 'block';\r\n\r\n    itowns.THREE.Object3D.DefaultUp.set(0, 0, 1);\r\n\r\n    debugGui = new dat.GUI({ width: 400 });\r\n\r\n    // TODO: do we really need to disable logarithmicDepthBuffer ?\r\n    view = new itowns.View('EPSG:3946', viewerDiv);\r\n    setupLoadingScreen(viewerDiv, view);\r\n    view.mainLoop.gfxEngine.renderer.setClearColor(0xcccccc);\r\n\r\n    // Configure Point Cloud layer\r\n    pointcloud = new itowns.GeometryLayer('eglise_saint_blaise_arles', new itowns.THREE.Group());\r\n    pointcloud.file = fileName || 'infos/sources';\r\n    pointcloud.protocol = 'potreeconverter';\r\n    pointcloud.url = serverUrl;\r\n    pointcloud.table = lopocsTable;\r\n    if (searchParams.get('material') === 'three') {\r\n        pointcloud.material = new itowns.THREE.PointsMaterial({\r\n            color: 0xff8888,\r\n            sizeAttenuation: false,\r\n            size: 1,\r\n            vertexColors: itowns.THREE.VertexColors\r\n        });\r\n    }\r\n\r\n    // point selection on double-click\r\n    function dblClickHandler(event) {\r\n        var pick = view.pickObjectsAt(event, 5, pointcloud);\r\n\r\n        for (const p of pick) {\r\n            console.info('Selected point #' + p.index + ' in position (' +\r\n                p.object.position.x + ', ' +\r\n                p.object.position.y + ', ' +\r\n                p.object.position.z +\r\n             ') in Points ' + p.object.layer.id);\r\n        }\r\n    }\r\n    view.mainLoop.gfxEngine.renderer.domElement.addEventListener('dblclick', dblClickHandler);\r\n\r\n\r\n    function placeCamera(position, lookAt) {\r\n        view.camera.camera3D.position.set(position.x, position.y, position.z);\r\n        view.camera.camera3D.lookAt(lookAt);\r\n        // create controls\r\n        controls = new itowns.FirstPersonControls(view, { focusOnClick: true });\r\n        debugGui.add(controls.options, 'moveSpeed', 1, 100).name('Movement speed');\r\n\r\n        view.notifyChange(view.camera.camera3D);\r\n    }\r\n\r\n    // add pointcloud to scene\r\n    function onLayerReady() {\r\n        var ratio;\r\n        var position;\r\n        var lookAt = new itowns.THREE.Vector3();\r\n        var size = new itowns.THREE.Vector3();\r\n\r\n        pointcloud.root.bbox.getSize(size);\r\n        pointcloud.root.bbox.getCenter(lookAt);\r\n\r\n        debug.PointCloudDebug.initTools(view, pointcloud, debugGui);\r\n\r\n        view.camera.camera3D.far = 2.0 * size.length();\r\n\r\n        ratio = size.x / size.z;\r\n        position = pointcloud.root.bbox.min.clone().add(\r\n            size.multiply({ x: 0, y: 0, z: ratio * 0.5 }));\r\n        lookAt.z = pointcloud.root.bbox.min.z;\r\n        placeCamera(position, lookAt);\r\n        controls.moveSpeed = size.length() / 3;\r\n\r\n        // update stats window\r\n        oldPostUpdate = pointcloud.postUpdate;\r\n        pointcloud.postUpdate = function postUpdate() {\r\n            var info = document.getElementById('info');\r\n            oldPostUpdate.apply(pointcloud, arguments);\r\n            info.textContent = 'Nb points: ' +\r\n                pointcloud.displayedCount.toLocaleString();\r\n        };\r\n    }\r\n    window.view = view;\r\n\r\n    view.addLayer(pointcloud).then(onLayerReady);\r\n}\r\n\r\nif (searchParams.get('selector')) {\r\n    document.getElementsByClassName('centered')[0].style.display = 'block';\r\n    document.getElementById('submit').addEventListener('click', onConnectClicked);\r\n} else {\r\n    onConnectClicked();\r\n}\n\n//# sourceURL=webpack:///./public/javascripts/map.js?");

/***/ }),

/***/ 0:
/*!************************!*\
  !*** xmldom (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///xmldom_(ignored)?");

/***/ }),

/***/ 1:
/*!***************************************!*\
  !*** ./encoding-indexes.js (ignored) ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///./encoding-indexes.js_(ignored)?");

/***/ })

/******/ });